[
  	{
	"name": "Thread32First",
	"return_type": "BOOL",
	"dll":"Kernel32.dll",
	"arguments":[{"type":"HANDLE"},{"type":"LPTHREADENTRY32"}]
	},
	{
	"name": "CreateToolhelp32Snapshot",
	"return_type": "HANDLE",
	"dll":"Kernel32.dll",
	"arguments":[{"type":"DWORD"},{"type":"DWORD"}]
	},
	{
	"name": "Thread32Next",
	"return_type": "HANDLE",
	"dll":"Kernel32.dll",
	"arguments":[{"type":"HANDLE"},{"type":"LPTHREADENTRY32"}]
  },
  {
    "n_arguments": 11,
    "description": "Creates a new process and its primary thread. Then the new process runs the specified executable file in the security context of the specified credentials (user, domain, and password). It can optionally load the user profile for a specified user.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call GetExitCodeProcess. ",
    "remarks": "By default,  CreateProcessWithLogonW does not load the specified user profile into the HKEY_USERS registry key. This means that access to information in the HKEY_CURRENT_USER registry key may not produce results that are consistent with a normal interactive logon. It is your responsibility to load the user registry hive into HKEY_USERS before calling  CreateProcessWithLogonW, by using LOGON_WITH_PROFILE, or by calling the  LoadUserProfile function. If the lpEnvironment parameter is NULL, the new process uses an environment block created from the profile of the user specified by lpUserName. If the HOMEDRIVE and HOMEPATH variables are not set, CreateProcessWithLogonW modifies the environment block to use the drive and path of the user's working directory. When created, the new process and thread handles receive full access rights (PROCESS_ALL_ACCESS and THREAD_ALL_ACCESS). For either handle, if a security descriptor is not provided, the handle can be used in any function that requires an object handle of that type. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If access is denied, the requesting process cannot use the handle to gain access to the process or thread. To retrieve a security token, pass the process handle in the  PROCESS_INFORMATION structure to the  OpenProcessToken function. The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or it can be specified in the  OpenProcess function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the  OpenThread function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in  PROCESS_INFORMATION. The calling thread can use the  WaitForInputIdle function to wait until the new process has completed its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because  CreateProcessWithLogonW returns without waiting for the new process to finish its initialization. For example, the creating process would use  WaitForInputIdle before trying to find a window that is associated with the new process. The preferred way to shut down a process is by using the  ExitProcess function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls  ExitProcess, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see  Terminating a Process. CreateProcessWithLogonW accesses the specified directory and executable image in the security context of the target user. If the executable image is on a network and a network drive letter is specified in the path, the network drive letter is not available to the target user, as network drive letters can be assigned for each logon. If a network drive letter is specified, this function fails. If the executable image is on a network, use the UNC path. There is a limit to the number of child processes that can be created by this function and run simultaneously. For example, on Windows XP, this limit is MAXIMUM_WAIT_OBJECTS*4. However, you may not be able to create this many processes due to system-wide quota limits. Windows XP with SP2,Windows Server 2003, or later:  You cannot call CreateProcessWithLogonW from a process that is running under the \"LocalSystem\" account,  because the function uses the logon SID in the caller token, and the token for the \"LocalSystem\" account does not contain this SID. As an alternative, use the CreateProcessAsUser and LogonUser functions. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. The lpApplicationName parameter can be NULL, and  the executable name must be the first white space\u00e2\u0080\u0093delimited string in lpCommandLine. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. Avoid the following example, because the function attempts to run \"Program.exe\", if it exists, instead of \"MyApp.exe\". If a malicious user creates an application called \"Program.exe\" on a system, any program that incorrectly calls  CreateProcessWithLogonW using the Program Files directory runs the malicious user application instead of the intended application. To avoid this issue, do not pass NULL for lpApplicationName. If you pass NULL for lpApplicationName, use quotation marks around the executable path in lpCommandLine, as shown in the following example: The following example demonstrates how to call this function. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "CreateProcessWithLogonW",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpUsername",
        "description": "The name of the user. This is the name of the user account to log on to. If you use the UPN format, user@DNS_domain_name, the lpDomain parameter must be NULL.     The user account must have the Log On Locally permission on the local computer. This permission is granted to all users on workstations and servers, but only to administrators on domain controllers."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpDomain",
        "description": "The name of the domain or server whose account database contains the lpUsername account. If this parameter is NULL, the user name must be specified in UPN format."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpPassword",
        "description": "The clear-text password for the lpUsername account."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonFlags",
        "description": "The logon option. This parameter can be 0 (zero) or one of the following values.  ValueMeaning  LOGON_WITH_PROFILE 0x00000001   Log on, then load the user profile in the HKEY_USERS registry key. The function returns after the profile is loaded. Loading the profile can be time-consuming, so it is best to use this value only if you must access the information in the HKEY_CURRENT_USER registry key.     Windows Server 2003:  The profile is unloaded after the new process is terminated, whether or not it has created child processes. Windows XP:  The profile is unloaded after the new process and all child processes it has created are terminated.   LOGON_NETCREDENTIALS_ONLY 0x00000002   Log on, but use the specified credentials on the network only. The new process uses the same token as the caller, but the system creates a new logon session within LSA, and the process uses the specified credentials as the default credentials.     This value can be used to create a process that uses a different set of credentials locally than it does remotely. This is useful in inter-domain scenarios where there is no trust relationship. The system does not validate the specified credentials. Therefore, the process can start, but it may not have access to network resources."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpApplicationName",
        "description": "The name of the module to be executed. ..."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPWSTR",
        "name": "lpCommandLine",
        "description": "The command line to be executed. ..."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationFlags",
        "description": "The flags that control how the process is created. ..."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpEnvironment",
        "description": "A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an environment created from the profile of the user specified by lpUsername.     An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form: name=value Because the equal sign (=) is used as a separator, it must not be used in the name of an environment variable. An environment block can contain Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.  If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. An ANSI environment block is terminated by two 0 (zero) bytes: one for the last string and one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the block. To retrieve a copy of the environment block for a specific user, use the  CreateEnvironmentBlock function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpCurrentDirectory",
        "description": "The full path to the current directory for the process. The string can also specify a UNC path.  If this parameter is NULL, the new process has the same current drive and directory as the calling process. This feature is provided primarily for shells that need to start an application, and specify its initial drive and working directory."
      },
      {
        "in_out": "_In_",
        "type": "LPSTARTUPINFOW",
        "name": "lpStartupInfo",
        "description": "A pointer to a  STARTUPINFO or STARTUPINFOEX structure.    The application must add permission for the specified user account to the specified window station and desktop, even for WinSta0\\Default. If the lpDesktop member is NULL or an empty string, the new process inherits the desktop and window station of its parent process.  The application must add permission for the specified user account to the inherited window station and desktop. Windows XP:  CreateProcessWithLogonW adds permission for the specified user account to the inherited window station and desktop.  Handles in  STARTUPINFO or STARTUPINFOEX must be closed with  CloseHandle when they are no longer needed. Important  If the dwFlags member of the  STARTUPINFO structure specifies STARTF_USESTDHANDLES, the standard handle fields are copied unchanged to the child process without validation. The caller is responsible for ensuring that these fields contain valid handle values.  Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles."
      },
      {
        "in_out": "_Out_",
        "type": "LPPROCESS_INFORMATION",
        "name": "lpProcessInfo",
        "description": "A pointer to a  PROCESS_INFORMATION structure that receives identification information for the new process, including a handle to the process.     Handles in  PROCESS_INFORMATION must be closed with the  CloseHandle function when they are not needed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "Creates a new process and its primary thread. The new process runs in the security context of the specified token. It can optionally load the user profile for the specified user.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call GetExitCodeProcess. ",
    "remarks": "By default,  CreateProcessWithTokenW does not load the specified user's profile into the HKEY_USERS registry key. This means that access to information in the  HKEY_CURRENT_USER registry key may not produce results consistent with a normal interactive logon. It is your responsibility to load the user's registry hive into HKEY_USERS  by either using LOGON_WITH_PROFILE, or by calling the  LoadUserProfile function before calling this function. If the lpEnvironment parameter is NULL, the new process uses an environment block created from the profile of the user specified by lpUserName. If the HOMEDRIVE and HOMEPATH variables are not set, CreateProcessWithTokenW modifies the environment block to use the drive and path of the user's working directory. When created, the new process and thread handles receive full access rights (PROCESS_ALL_ACCESS and THREAD_ALL_ACCESS). For either handle, if a security descriptor is not provided, the handle can be used in any function that requires an object handle of that type. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If access is denied, the requesting process cannot use the handle to gain access to the process or thread. To retrieve a security token, pass the process handle in the  PROCESS_INFORMATION structure to the  OpenProcessToken function. The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the  OpenProcess function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the  OpenThread function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in  PROCESS_INFORMATION. The calling thread can use the  WaitForInputIdle function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because  CreateProcessWithTokenW returns without waiting for the new process to finish its initialization. For example, the creating process would use  WaitForInputIdle before trying to find a window associated with the new process. The preferred way to shut down a process is by using the  ExitProcess function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls  ExitProcess, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see  Terminating a Process. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. The lpApplicationName parameter can be NULL, in which case the executable name must be the first white space\u00e2\u0080\u0093delimited string in lpCommandLine. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run \"Program.exe\", if it exists, instead of \"MyApp.exe\". If a malicious user were to create an application called \"Program.exe\" on a system, any program that incorrectly calls  CreateProcessWithTokenW using the Program Files directory will run this application instead of the intended application. To avoid this problem, do not pass NULL for lpApplicationName. If you do pass NULL for lpApplicationName, use quotation marks around the executable path in lpCommandLine, as shown in the example below. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "CreateProcessWithTokenW",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see  Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the lpApplicationName or the lpCommandLine parameter.     To get a primary token that represents the specified user, call the  LogonUser function. Alternatively, you can call the  DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client. Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the  SetTokenInformation function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonFlags",
        "description": "The logon option. This parameter can be zero or one of the following values.  ValueMeaning  LOGON_WITH_PROFILE 0x00000001   Log on, then load the user's profile in the HKEY_USERS registry key. The function returns after the profile has been loaded. Loading the profile can be time-consuming, so it is best to use this value only if you must access the information in the HKEY_CURRENT_USER registry key.     Windows Server 2003:  The profile is unloaded after the new process has been terminated, regardless of whether it has created child processes.   LOGON_NETCREDENTIALS_ONLY 0x00000002   Log on, but use the specified credentials on the network only. The new process uses the same token as the caller, but the system creates a new logon session within LSA, and the process uses the specified credentials as the default credentials.     This value can be used to create a process that uses a different set of credentials locally than it does remotely. This is useful in inter-domain scenarios where there is no trust relationship. The system does not validate the specified credentials. Therefore, the process can start, but it may not have access to network resources."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpApplicationName",
        "description": "The name of the module to be executed. ..."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPWSTR",
        "name": "lpCommandLine",
        "description": "The command line to be executed. ..."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationFlags",
        "description": "The flags that control how the process is created. The CREATE_DEFAULT_ERROR_MODE, CREATE_NEW_CONSOLE, and CREATE_NEW_PROCESS_GROUP flags are enabled by default. You can specify additional flags as noted.                                                                     ValueMeaning  CREATE_DEFAULT_ERROR_MODE 0x04000000   The new process does not inherit the error mode of the calling process. Instead, the new process gets the current default error mode. An application sets the current default error mode by calling  SetErrorMode.     This flag is enabled by default.   CREATE_NEW_CONSOLE 0x00000010   The new process has a new console, instead of inheriting the parent's console. This flag cannot be used with the DETACHED_PROCESS flag.     This flag is enabled by default.   CREATE_NEW_PROCESS_GROUP 0x00000200   The new process is the root process of a new process group. The process group includes all processes that are descendants of this root process. The process identifier of the new process group is the same as the process identifier, which is returned in the lpProcessInfo parameter. Process groups are used by the  GenerateConsoleCtrlEvent function to enable sending a CTRL+C or CTRL+BREAK signal to a group of console processes.     This flag is enabled by default.   CREATE_SEPARATE_WOW_VDM 0x00000800   This flag is only valid starting a 16-bit Windows-based application. If set, the new process runs in a private Virtual DOS Machine (VDM). By default, all 16-bit Windows-based applications run in a single, shared VDM. The advantage of running separately is that a crash only terminates the single VDM; any other programs running in distinct VDMs continue to function normally. Also, 16-bit Windows-based applications that run in separate VDMs have separate input queues. That means that if one application stops responding momentarily, applications in separate VDMs continue to receive input.   CREATE_SUSPENDED 0x00000004   The primary thread of the new process is created in a suspended state, and does not run until the  ResumeThread function is called.   CREATE_UNICODE_ENVIRONMENT 0x00000400   Indicates the format of the lpEnvironment parameter. If this flag is set, the environment block pointed to by lpEnvironment uses Unicode characters. Otherwise, the environment block uses ANSI characters.   EXTENDED_STARTUPINFO_PRESENT 0x00080000   The process is created with extended startup information; the lpStartupInfo parameter specifies a STARTUPINFOEX structure. Windows Server 2003:  This value is not supported.     This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see  GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpEnvironment",
        "description": "A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an environment created from the profile of the user specified by lpUsername.     An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form: name=value Because the equal sign (=) is used as a separator, it must not be used in the name of an environment variable. An environment block can contain Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.  If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. An ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the block. To retrieve a copy of the environment block for a specific user, use the  CreateEnvironmentBlock function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpCurrentDirectory",
        "description": "The full path to the current directory for the process. The string can also specify a UNC path.  If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)"
      },
      {
        "in_out": "_In_",
        "type": "LPSTARTUPINFOW",
        "name": "lpStartupInfo",
        "description": "A pointer to a  STARTUPINFO or STARTUPINFOEX structure.     If the lpDesktop member is NULL or an empty string, the new process inherits the desktop and window station of its parent process. The function adds permission for the specified user account to the inherited window station and desktop. Otherwise, if this member specifies a desktop, it is the responsibility of the application to add permission for the specified user account to the specified window station and desktop, even for WinSta0\\Default. Handles in  STARTUPINFO or STARTUPINFOEX must be closed with  CloseHandle when they are no longer needed. Important  If the dwFlags member of the  STARTUPINFO structure specifies STARTF_USESTDHANDLES, the standard handle fields are copied unchanged to the child process without validation. The caller is responsible for ensuring that these fields contain valid handle values.  Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles."
      },
      {
        "in_out": "_Out_",
        "type": "LPPROCESS_INFORMATION",
        "name": "lpProcessInfo",
        "description": "A pointer to a  PROCESS_INFORMATION structure that receives identification information for the new process, including a handle to the process.     Handles in  PROCESS_INFORMATION must be closed with the  CloseHandle function when they are no longer needed."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Ends the calling process and all its threads.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "Use the  GetExitCodeProcess function to retrieve the process's exit value. Use the  GetExitCodeThread function to retrieve a thread's exit value. Exiting a process causes the following: If one of the terminated threads in the process holds a lock and the DLL detach code in one of the loaded DLLs attempts to acquire the same lock, then calling ExitProcess results in a deadlock. In contrast, if a process terminates by calling  TerminateProcess, the DLLs that the process is attached to are not notified of the process termination. Therefore, if you do not know the state of all threads in your process, it is better to call TerminateProcess than  ExitProcess. Note that returning from the main function of an application results in a call to ExitProcess. Calling  ExitProcess in a DLL can lead to unexpected application or system errors. Be sure to call  ExitProcess from a DLL only if you know which applications or system components will load the DLL and that it is safe to call  ExitProcess in this context. Exiting a process does not cause child processes to be terminated. Exiting a process does not necessarily remove the process object from the operating system. A process object is deleted when the last handle to the process is closed. For an example, see  Creating a Child Process with Redirected Input and Output. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "ExitProcess",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uExitCode",
        "description": "The exit code for the process and all threads."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Flushes the write queue of each processor that is running a thread of the current process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The function generates an interprocessor interrupt (IPI) to all processors that are part of the current process affinity. It guarantees the visibility of write operations performed on one processor to the other processors. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "FlushProcessWriteBuffers",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Frees a block of environment strings.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processenv.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero To get extended error information, call  GetLastError. ",
    "remarks": "If you used the ANSI version of GetEnvironmentStrings, be sure to use the ANSI version of FreeEnvironmentStrings. Similarly, if you used the Unicode version of GetEnvironmentStrings, be sure to use the Unicode version of FreeEnvironmentStrings. For an example, see  Changing Environment Variables. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "FreeEnvironmentStrings",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTCH",
        "name": "lpszEnvironmentBlock",
        "description": "A pointer to a block of environment strings. The pointer to the block must be obtained by calling the  GetEnvironmentStrings function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the command-line string for the current process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processenv.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value is a pointer to the command-line string for the current process. ",
    "remarks": "ANSI console processes written in C can use the argc and argv arguments of the main function to access the command-line arguments. ANSI GUI applications can use the lpCmdLine parameter of the WinMain function to access the command-line string, excluding the program name. The main and WinMain functions cannot return Unicode strings. Unicode console process written in C can use the wmain or _tmain function to access the command-line arguments. Unicode GUI applications must use the  GetCommandLineW function to access Unicode strings. To convert the command line to an argv style array of strings, call the  CommandLineToArgvW function. ",
    "return_type": "LPTSTR",
    "category": "Processes",
    "name": "GetCommandLine",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves a pseudo handle for the current process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value is a pseudo handle to the current process. ",
    "remarks": "A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle. For compatibility with future operating systems, it is best to call  GetCurrentProcess instead of hard-coding this constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is required. Pseudo handles are not inherited by child processes. This handle has the PROCESS_ALL_ACCESS access right to the process object. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of the process to the primary token of the process. A process can create a \"real\" handle to itself that is valid in the context of other processes, or that can be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the DuplicateHandle function. A process can also use the  OpenProcess function to open a real handle to itself. The pseudo handle need not be closed when it is no longer needed. Calling the  CloseHandle function with a pseudo handle has no effect. If the pseudo handle is duplicated by  DuplicateHandle, the duplicate handle must be closed. For an example, see  Creating a Child Process with Redirected Input and Output. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "GetCurrentProcess",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the process identifier of the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value is the process identifier of the calling process. ",
    "remarks": "Until the process terminates, the process identifier uniquely identifies the process throughout the system. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetCurrentProcessId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the number of the processor the current thread was running on during the call to this function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The function returns the current processor number. ",
    "remarks": "This function is used to provide information for estimating process performance. On systems with more than 64 logical processors, the GetCurrentProcessorNumber function returns the processor number within the processor group to which the logical processor is assigned. Use the GetCurrentProcessorNumberEx function to retrieve the processor group and number of the current processor. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetCurrentProcessorNumber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the environment variables for the current process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processenv.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a pointer to the environment block of the current process. If the function fails, the return value is NULL. ",
    "remarks": "The  GetEnvironmentStrings function returns a pointer to a block of memory that contains the environment variables of the calling process (both the system and the user environment variables). Each environment block contains the environment variables in the following format: Treat this memory as read-only; do not modify it directly. To add or change an environment variable, use the  GetEnvironmentVariable and  SetEnvironmentVariable functions. When the block returned by  GetEnvironmentStrings is no longer needed, it should be freed by calling the  FreeEnvironmentStrings function. Note that the ANSI version of this function, GetEnvironmentStringsA, returns OEM characters. For an example, see  Changing Environment Variables. ",
    "return_type": "LPTCH",
    "category": "Processes",
    "name": "GetEnvironmentStrings",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the contents of the specified variable from the environment block of the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processenv.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is the number of characters stored in the buffer pointed to by lpBuffer, not including the terminating null character. If lpBuffer is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of lpBuffer are undefined. If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,  GetLastError returns ERROR_ENVVAR_NOT_FOUND. ",
    "remarks": "This function can retrieve either a system environment variable or a user environment variable. For an example, see  Changing Environment Variables. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetEnvironmentVariable",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the environment variable."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer pointed to by the lpBuffer parameter, including the null-terminating character, in characters."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the termination status of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function returns immediately. If the process has not terminated and the function succeeds, the status returned is STILL_ACTIVE. If the process has terminated and the function succeeds, the status returned is one of the following values: ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetExitCodeProcess",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpExitCode",
        "description": "A pointer to a variable to receive the process termination status. For more information, see Remarks."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no GUI objects are in use, the return value is zero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "A process without a graphical user interface does not use GUI resources, therefore,  GetGuiResources will return zero. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetGuiResources",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "uiFlags",
        "description": "The GUI object type. This parameter can be one of the following values.  ValueMeaning  GR_GDIOBJECTS 0   Return the count of GDI objects.   GR_GDIOBJECTS_PEAK 2   Return the peak count of GDI objects. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported until Windows 7 and Windows Server 2008 R2.   GR_USEROBJECTS 1   Return the count of USER objects.   GR_USEROBJECTS_PEAK 4   Return the peak count of USER objects. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported until Windows 7 and Windows Server 2008 R2."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Sysinfoapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is TRUE and at least one SYSTEM_LOGICAL_PROCESSOR_INFORMATION structure is written to the output buffer. If the function fails, the return value is FALSE. To get extended error information, call  GetLastError. ",
    "remarks": "GetLogicalProcessorInformation can be used to get information about the relationship between logical processors in the system, including: Your application can use this information when affinitizing your threads and processes to take best advantage of the hardware properties of the platform, or to determine the number of logical and physical processors for licensing purposes. Each of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION structures returned in the buffer contains the following: Note that the order in which the structures are returned in the buffer  may change between calls to this function. The size of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION structure varies between processor architectures and versions of Windows. For this reason, applications should first call this function to obtain the required buffer size, then dynamically allocate memory for the buffer. On systems with more than 64 logical processors, the GetLogicalProcessorInformation function retrieves logical processor information about processors in the processor group to which the calling thread is currently assigned. Use the GetLogicalProcessorInformationEx function to retrieve information about processors in all processor groups on the system. The following C++ example uses the GetLogicalProcessorInformation function to display information about processors on the current system.  Because GetLogicalProcessorInformation is not present on all systems, this example uses the GetProcAddress function instead of calling GetLogicalProcessorInformation directly. This example reports the number of active processor cores. This example also reports the number of NUMA nodes, physical packages, and caches on systems that support this information.   For more information, see the description of the Relationship member of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION structure. Windows Server 2003, Windows XP Professional x64 Edition and Windows XP with SP3:  This example reports the number of physical processors rather than the number of active processor cores. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetLogicalProcessorInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSYSTEM_LOGICAL_PROCESSOR_INFORMATION",
        "name": "Buffer",
        "description": "A pointer to a buffer that receives  an array of SYSTEM_LOGICAL_PROCESSOR_INFORMATION structures. If the function fails, the contents of this buffer are undefined."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "ReturnLength",
        "description": "On input, specifies the length of the buffer pointed to by  Buffer, in bytes. If the buffer is large enough to contain all of the data, this function succeeds and ReturnLength is set to the number of bytes returned. If the buffer is not large enough to contain all of the data, the function fails, GetLastError returns ERROR_INSUFFICIENT_BUFFER, and ReturnLength is set to the buffer length required to contain all of the data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of ReturnLength is undefined."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition, Windows XP with SP3 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the priority class for the specified process. This value, together with the priority value of each thread of the process, determines each thread's base priority level.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is the priority class of the specified process. If the function fails, the return value is zero. To get extended error information, call  GetLastError. The process's priority class is one of the following values.  ",
    "remarks": "Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The operating system uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a round-robin fashion at each priority level, and only when there are no executable threads at a higher level will scheduling of threads at a lower level take place. For a table that shows the base priority levels for each combination of priority class and thread priority value, see Scheduling Priorities. Priority class is maintained by the executive, so all processes have a priority class that can be queried. For an example, see  Taking a Snapshot and Viewing Processes. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetPriorityClass",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process.     The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the process affinity mask for the specified process and the system affinity mask for the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero and the function sets the variables pointed to by lpProcessAffinityMask and lpSystemAffinityMask to the appropriate affinity masks. On a system with more than 64 processors, if the threads of the calling process are in a single processor group, the function sets the variables pointed to by lpProcessAffinityMask and lpSystemAffinityMask to the process affinity mask and the processor mask of active logical processors for that group. If the calling process contains threads in multiple groups, the function returns zero for both affinity masks. If the function fails, the return value is zero, and the values of the variables pointed to by lpProcessAffinityMask and lpSystemAffinityMask are undefined. To get extended error information, call  GetLastError. ",
    "remarks": "A process affinity mask is a bit vector in which each bit represents the processors that a process is allowed to run on. A system affinity mask is a bit vector in which each bit represents the processors that are configured into a system. A process affinity mask is a subset of the system affinity mask. A process is only allowed to run on the processors configured into a system. Therefore, the process affinity mask cannot specify a 1 bit for a processor when the system affinity mask specifies a 0 bit for that processor. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessAffinityMask",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose affinity mask is desired. This handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD_PTR",
        "name": "lpProcessAffinityMask",
        "description": "A pointer to a variable that receives the affinity mask for the specified process."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD_PTR",
        "name": "lpSystemAffinityMask",
        "description": "A pointer to a variable that receives the affinity mask for the system."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the processor group affinity of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processtopologyapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use GetLastError. If the error value is ERROR_INSUFFICIENT_BUFFER, the GroupCount parameter contains the required buffer size in number of elements. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessGroupAffinity",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_Inout_",
        "type": "PUSHORT",
        "name": "GroupCount",
        "description": "On input, specifies the number of elements in GroupArray array. On output, specifies the number of processor groups written to the array. If the array is too small, the function fails with ERROR_INSUFFICIENT_BUFFER and sets the GroupCount parameter to the number of elements required."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "GroupArray",
        "description": "An array of processor group numbers. A group number is included in the array if a thread in the process is assigned to a processor in the group."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the number of open handles  that belong to the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error  information, call GetLastError. ",
    "remarks": "This function retrieves information about the executive objects for the process. For more information, see Kernel Objects. To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessHandleCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose handle count is being requested.  The         handle must have the PROCESS_QUERY_INFORMATION         or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwHandleCount",
        "description": "A pointer to a variable that receives the number of open handles that belong to the specified process."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the process identifier of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "",
    "remarks": "Until a process terminates, its process identifier uniquely identifies it on the system. For more information about access rights, see  Process Security and Access Rights. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetProcessId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Process",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the process identifier of the process associated with the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is the process identifier of the process associated with the specified thread. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Until a process terminates, its process identifier uniquely identifies it on the system. For more information about access rights, see  Thread Security and Access Rights. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetProcessIdOfThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Thread",
        "description": "A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003:  The handle must have the THREAD_QUERY_INFORMATION access right."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves accounting information for all I/O operations performed by the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessIoCounters",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_COUNTERS",
        "name": "lpIoCounters",
        "description": "A pointer to an  IO_COUNTERS structure that receives the I/O accounting information for the process."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves mitigation policy settings for the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Processthreadsapi.h",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve error values defined for this function, call GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0602. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessMitigationPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "PROCESS_MITIGATION_POLICY",
        "name": "MitigationPolicy",
        "description": "The mitigation policy to retrieve. This parameter can be one of the following values.  ValueMeaning  ProcessDEPPolicy   The data execution prevention (DEP) policy of the process. The lpBuffer parameter points to a PROCESS_MITIGATION_DEP_POLICY structure that specifies the DEP policy flags.   ProcessASLRPolicy   The Address Space Layout Randomization (ASLR) policy of the process. The lpBuffer parameter points to a PROCESS_MITIGATION_ASLR_POLICY structure that specifies the ASLR policy flags.   ProcessDynamicCodePolicy   The dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing executable code. The lpBuffer parameter points to a PROCESS_MITIGATION_DYNAMIC_CODE_POLICY structure that specifies the dynamic code policy flags.   ProcessStrictHandleCheckPolicy   The process will receive a fatal error if it manipulates a handle that is not valid. The lpBuffer parameter points to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the handle check policy flags.   ProcessSystemCallDisablePolicy   Disables the ability to use NTUser/GDI functions at the lowest layer. The lpBuffer parameter points to a PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags.   ProcessMitigationOptionsMask   Returns the mask of valid bits for all the mitigation options on the system.  An application can set many mitigation options without querying the operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at once. The lpBuffer parameter points to a ULONG64 bit vector for the mask, or a two-element array of ULONG64 bit vectors.   ProcessExtensionPointDisablePolicy    Prevents certain built-in third party extension points from being enabled, preventing legacy extension point DLLs from being loaded into the process. The lpBuffer parameter points to a PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure that specifies the extension point disable policy flags.   ProcessControlFlowGuardPolicy   The Control Flow Guard (CFG) policy of the process. The lpBuffer parameter points to a PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags.   ProcessSignaturePolicy   The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL). he lpBuffer parameter points to a PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that specifies the signature policy flags.   ProcessFontDisablePolicy   The policy regarding font loading for the process. When turned on, the process cannot load non-system fonts. The lpBuffer parameter points to a PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that specifies the policy flags for font loading.   ProcessImageLoadPolicy   The policy regarding image loading for the process, which determines the types of executable images that are allowed to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices or files that have the low mandatory label. The lpBuffer parameter points to a PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that specifies the policy flags for image loading."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "lpBuffer",
        "description": "If the MitigationPolicy parameter is ProcessDEPPolicy, this parameter points to a PROCESS_MITIGATION_DEP_POLICY structure that receives the DEP policy flags. If the MitigationPolicy parameter is ProcessASLRPolicy, this parameter points to a PROCESS_MITIGATION_ASLR_POLICY structure that receives the ASLR policy flags. If the MitigationPolicy parameter is ProcessDynamicCodePolicy, this parameter points to a PROCESS_MITIGATION_DYNAMIC_CODE_POLICY structure that receives the dynamic code policy flags. If the MitigationPolicy parameter is ProcessStrictHandleCheckPolicy, this parameter points to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the handle check policy flags. If the MitigationPolicy parameter is ProcessSystemCallDisablePolicy, this parameter points to a PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags. If the MitigationPolicy parameter is ProcessMitigationOptionsMask, this parameter points to a ULONG64 bit vector for the mask or a two-element array of ULONG64 bit vectors. If the MitigationPolicy parameter is ProcessExtensionPointDisablePolicy, this parameter points to a PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure that specifies the extension point disable policy flags. If the MitigationPolicy parameter is ProcessControlFlowGuardPolicy, this parameter points to a PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. If the MitigationPolicy parameter is ProcessSignaturePolicy, this parameter points to a PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that receives the signature policy flags. If the MitigationPolicy parameter is ProcessFontDisablePolicy, this parameter points to a PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that receives the policy flags for font loading. If the MitigationPolicy parameter is ProcessImageLoadPolicy, this parameter points to a PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that receives the policy flags for image loading."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwLength",
        "description": "The size of lpBuffer, in bytes."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the priority boost control state of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the pDisablePriorityBoost parameter receives the priority boost control state. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessPriorityBoost",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "pDisablePriorityBoost",
        "description": "A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the shutdown parameters for the currently calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessShutdownParameters",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwLevel",
        "description": "A pointer to a variable that receives the shutdown priority level. Higher levels shut down first. System level shutdown orders are reserved for system components. Higher numbers shut down first. Following are the level conventions.  ValueMeaning   000-0FF   System reserved last shutdown range.    100-1FF   Application reserved last shutdown range.    200-2FF   Application reserved \"in between\" shutdown range.    300-3FF   Application reserved first shutdown range.    400-4FF   System reserved first shutdown range.     All processes start at shutdown level 0x280."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwFlags",
        "description": "A pointer to a variable that receives the shutdown flags. This parameter can be the following value.  ValueMeaning  SHUTDOWN_NORETRY 0x00000001   If this process takes longer than the specified timeout to shut down, do not display a retry dialog box for the user. Instead, just cause the process to directly exit."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves timing information for the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "All times are expressed using FILETIME data structures. Such a structure contains two 32-bit values that combine to form a 64-bit count of 100-nanosecond time units. Process creation and exit times are points in time expressed as the amount of time that has elapsed since midnight on January 1, 1601 at Greenwich, England. There are several functions that an application can use to convert such values to more generally useful forms. Process kernel mode and user mode times are amounts of time. For example, if a process has spent one second in kernel mode, this function will fill the  FILETIME structure specified by lpKernelTime with a 64-bit value of ten million. That is the number of 100-nanosecond units in one second. To retrieve the number of CPU clock cycles used by the threads of the process, use the QueryProcessCycleTime function. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessTimes",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose timing information is sought. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpCreationTime",
        "description": "A pointer to a  FILETIME structure that receives the creation time of the process."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpExitTime",
        "description": "A pointer to a FILETIME structure that receives the exit time of the process. If the process has not exited, the content of this structure is undefined."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpKernelTime",
        "description": "A pointer to a  FILETIME structure that receives the amount of time that the process has executed in kernel mode. The time that each of the threads of the process has executed in kernel mode is determined, and then all of those times are summed together to obtain this value."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpUserTime",
        "description": "A pointer to a FILETIME structure that receives the amount of time that the process has executed in user mode. The time that each of the threads of the process has executed in user mode is determined, and then all of those times are summed together to obtain this value. Note that this value can exceed the amount of real time elapsed (between lpCreationTime and lpExitTime) if the process executes across multiple CPU cores."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the major and minor version numbers of the system on which the specified process expects to run.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is the version of the system on which the process expects to run. The high word of the return value contains the major version number. The low word of the return value contains the minor version number. If the function fails, the return value is zero. To get extended error information, call  GetLastError. The function fails if ProcessId is an invalid value. ",
    "remarks": "The  GetProcessVersion function performs less quickly when ProcessId is nonzero, specifying a process other than the calling process. The version number returned by this function is the version number stamped in the image header of the .exe file the process is running. Linker programs set this value. If this function is called from a 32-bit application running on WOW64, the specified process must be a 32-bit process or the function fails. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetProcessVersion",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ProcessId",
        "description": "The process identifier of the process of interest. A value of zero specifies the calling process."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the minimum and maximum working set sizes of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The \"working set\" of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessWorkingSetSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose working set sizes will be obtained. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpMinimumWorkingSetSize",
        "description": "A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active."
      },
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpMaximumWorkingSetSize",
        "description": "A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the minimum and maximum working set sizes of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  MemoryAPI.h on Windows 8 and Windows Server 2012",
    "return_value": "",
    "remarks": "The \"working set\" of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessWorkingSetSizeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose working set sizes will be obtained. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights. Windows Server 2003:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpMinimumWorkingSetSize",
        "description": "A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active."
      },
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpMaximumWorkingSetSize",
        "description": "A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "Flags",
        "description": "The flags that control the enforcement of the minimum and maximum working set sizes.  ValueMeaning  QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002   The working set may fall below the minimum working set limit if memory demands are high.   QUOTA_LIMITS_HARDWS_MIN_ENABLE 0x00000001   The working set will not fall below the minimum working set limit.   QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008   The working set may exceed the maximum working set limit if there is abundant memory.   QUOTA_LIMITS_HARDWS_MAX_ENABLE 0x00000004   The working set will not exceed the maximum working set limit."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the cycle time each processor in the specified processor group spent executing deferred procedure calls (DPCs) and interrupt service routines (ISRs) since the processor became active.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero. To get extended error information, use GetLastError. If the error value is ERROR_INSUFFICIENT_BUFFER, the ReturnedLength parameter contains the required buffer size. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0601 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetProcessorSystemCycleTime",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Group",
        "description": "The number of the processor group for which to retrieve the cycle time."
      },
      {
        "in_out": "_Out_",
        "type": "PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION",
        "name": "Buffer",
        "description": "A pointer to a buffer to receive a SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION structure for each processor in the group. On output, the DWORD64 CycleTime member of this structure is set to the cycle time for one processor."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "ReturnedLength",
        "description": "The size of the buffer, in bytes. When the function returns, this parameter contains the number of bytes written to Buffer. If the buffer is too small for the data, the function fails with ERROR_INSUFFICIENT_BUFFER and sets the ReturnedLength parameter to the required buffer size."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the contents of the  STARTUPINFO structure that was specified when the calling process was created.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. If an error occurs, the ANSI version of this function (GetStartupInfoA) can raise an exception. The Unicode version (GetStartupInfoW) does not fail. ",
    "remarks": "The  STARTUPINFO structure was specified by the process that created the calling process. It can be used to specify properties associated with the main window of the calling process. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "GetStartupInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPSTARTUPINFO",
        "name": "lpStartupInfo",
        "description": "A pointer to a  STARTUPINFO structure that receives the startup information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether the process belongs to a Windows Store app.",
    "library": "User32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winuser.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "IsImmersiveProcess",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "Target process handle."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether the current directory should be included in the search path for the specified executable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processenv.h on Windows 8 and Windows Server 2012",
    "return_value": "If the current directory should be part of the search path, the return value is TRUE. Otherwise, the return value is FALSE. ",
    "remarks": "This function should only be called in instances where the caller must explicitly resolve a relative executable name to an absolute name.  If CreateProcess is called with a relative executable name, it will automatically search for the executable, calling  this function to determine the search path. Most system functions perform their own path resolution, therefore, this function should only be called if you are attempting to resolve a search path for the specified executable based on the current directory. The value of the NoDefaultCurrentDirectoryInExePath environment variable determines the value this function returns. However, you should call this function rather than checking the environment variable directly, as the registry location of this environment variable can change. If the value of the ExeName parameter contains a backslash (\\), this function will always return TRUE. If it does not contain a backslash, the existence of the NoDefaultCurrentDirectoryInExePath environment variable is checked, and not its value. An example of an instance when this function should be called instead of relying on the default search path resolution algorithm in CreateProcess is the \"cmd.exe\" executable. It calls this function to determine the command search path because it does its own path resolution before calling CreateProcess.  If this function returns TRUE, cmd.exe uses the path \".;%PATH%\" for the executable search. If it returns FALSE, cmd.exe uses the path \"%PATH%\" for the search. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "NeedCurrentDirectoryForExePath",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "ExeName",
        "description": "The name of the executable file."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing local process object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "To open a handle to another local process and obtain full access rights, you must enable the SeDebugPrivilege privilege. For more information, see Changing Privileges in a Token. The handle returned by the  OpenProcess function can be used in any function that requires a handle to a process, such as the  wait functions, provided the appropriate access rights were requested. When you are finished with the handle, be sure to close it using the CloseHandle function. For an example, see  Taking a Snapshot and Viewing Processes. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "OpenProcess",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the process object. This access right is checked against the  security descriptor for the process. This parameter can be one or more of the  process access rights.  If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwProcessId",
        "description": "The identifier of the local process to be opened.  If the specified process is the System Process (0x00000000), the function fails and the last error code is ERROR_INVALID_PARAMETER. If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access restrictions prevent user-level code from opening them. If you are using GetCurrentProcessId as an argument to this function, consider using GetCurrentProcess instead of OpenProcess, for improved performance."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the full name of the executable image for the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryFullProcessImageName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one of the following values.  ValueMeaning   0   The name should use the Win32 path format.   PROCESS_NAME_NATIVE 0x00000001   The name should use the native system path format."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpExeName",
        "description": "The path to the executable image. If the function succeeds, this string is null-terminated."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "lpdwSize",
        "description": "On input, specifies the size of the lpExeName buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the affinity update mode of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that calls this function, define _WIN32_WINNT as 0x0600 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryProcessAffinityUpdateMode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD",
        "name": "lpdwFlags",
        "description": "The affinity update mode. This parameter can be one of the following values.  ValueMeaning   0   Dynamic update of the process affinity by the system is disabled.   PROCESS_AFFINITY_ENABLE_AUTO_UPDATE 0x00000001UL   Dynamic update of the process affinity by the system is enabled."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the sum of the cycle time of all threads of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Realtimeapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To enumerate the processes in the system, use the  EnumProcesses function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryProcessCycleTime",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "CycleTime",
        "description": "The number of CPU clock cycles used by the threads of the process. This value includes cycles spent in both user mode and kernel mode."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the contents of the specified environment variable for the current process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processenv.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function has no effect on the system environment variables or the environment variables of other processes. For an example, see  Changing Environment Variables. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetEnvironmentVariable",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the environment variable. The operating system creates the environment variable if it does not exist and lpValue is not NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValue",
        "description": "The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see  Environment Variables. Windows Server 2003 and Windows XP:  The total size of the environment block for a process may not exceed 32,767 characters. If this parameter is NULL, the variable is deleted from the current process's environment."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the priority class for the specified process. This value together with the priority value of each thread of the process determines each thread's base priority level.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The system uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. The  SetThreadPriority function enables setting the base priority level of a thread relative to the priority class of its process. For more information, see  Scheduling Priorities. The *_PRIORITY_CLASS values affect the CPU scheduling priority of the process. For processes that perform background work such as file I/O, network I/O, or data processing, it is not sufficient to adjust the CPU scheduling priority; even an idle CPU priority process can easily interfere with system responsiveness when it uses the disk and memory. Processes that perform background work should use the PROCESS_MODE_BACKGROUND_BEGIN and PROCESS_MODE_BACKGROUND_END values to adjust their resource scheduling priorities; processes that interact with the user should not use PROCESS_MODE_BACKGROUND_BEGIN. If a process is in background processing mode, the new threads it creates will also be in background processing mode. When a thread is in background processing mode, it should minimize sharing resources such as critical sections, heaps, and handles with other threads in the process, otherwise priority inversions can occur. If there are threads executing at high priority, a thread in background processing mode may not be scheduled promptly, but it will never be starved. Each  thread can enter background processing mode independently using SetThreadPriority. Do not call SetPriorityClass to enter background processing mode after a thread in the process has called SetThreadPriority to enter background processing mode. After a process ends background processing mode, it resets all threads in the process; however, it is not possible for the process to know which threads were already in background processing mode. The following example demonstrates the use of process background mode. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetPriorityClass",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process.     The handle must have the PROCESS_SET_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwPriorityClass",
        "description": "The priority class for the process. This parameter can be one of the following values.  PriorityMeaning  ABOVE_NORMAL_PRIORITY_CLASS 0x00008000    Process that has priority above NORMAL_PRIORITY_CLASS but below HIGH_PRIORITY_CLASS.   BELOW_NORMAL_PRIORITY_CLASS 0x00004000    Process that has priority above IDLE_PRIORITY_CLASS but below NORMAL_PRIORITY_CLASS.   HIGH_PRIORITY_CLASS 0x00000080   Process that performs time-critical tasks that must be executed immediately. The threads of the process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class application can use nearly all available CPU time.   IDLE_PRIORITY_CLASS 0x00000040   Process whose threads run only when the system is idle. The threads of the process are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle-priority class is inherited by child processes.   NORMAL_PRIORITY_CLASS 0x00000020   Process with no special scheduling needs.   PROCESS_MODE_BACKGROUND_BEGIN 0x00100000   Begin background processing mode. The system lowers the resource scheduling priorities of the process (and its threads) so that it can perform background work without significantly affecting activity in the foreground. This value can be specified only if hProcess is a handle to the current process. The function fails if the process is already in background processing mode. Windows Server 2003 and Windows XP:  This value is not supported.   PROCESS_MODE_BACKGROUND_END 0x00200000   End background processing mode. The system restores the resource scheduling priorities of the process (and its threads) as they were before the process entered background processing mode. This value can be specified only if hProcess is a handle to the current process. The function fails if the process is not in background processing mode. Windows Server 2003 and Windows XP:  This value is not supported.   REALTIME_PRIORITY_CLASS 0x00000100   Process that has the highest possible priority. The threads of the process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a processor affinity mask for the threads of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the process affinity mask requests a processor that is not configured in the system, the last error code is ERROR_INVALID_PARAMETER. On a system with more than 64 processors, if the calling process contains threads in more than one processor group, the last error code is ERROR_INVALID_PARAMETER. ",
    "remarks": "A process affinity mask is a bit vector in which each bit represents a logical processor on which the threads of the process are allowed to run. The value of the process affinity mask must be a subset of the system affinity mask values obtained by the  GetProcessAffinityMask function. A process is only allowed to run on the processors configured into a system. Therefore, the process affinity mask cannot specify a 1 bit for a processor when the system affinity mask specifies a 0 bit for that processor. Process affinity is inherited by any child process or newly instantiated local process. Do not call SetProcessAffinityMask in a DLL that may be called by processes other than your own. On a system with more than 64 processors, the SetProcessAffinityMask function can be used to set the process affinity mask only for processes with threads in a single processor group. Use the SetThreadAffinityMask function to set the affinity mask for individual threads in multiple groups. This effectively changes the group assignment of the process. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessAffinityMask",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose affinity mask is to be set. This handle must have the PROCESS_SET_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD_PTR",
        "name": "dwProcessAffinityMask",
        "description": "The affinity mask for the threads of the process. On a system with more than 64 processors, the affinity mask must specify processors in a single processor group."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the affinity update mode of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The system can adjust process affinity under various conditions, such as when a processor is added dynamically. By default, dynamic updates to the process affinity are disabled for each process. Processes should use this function to indicate whether they can handle dynamic adjustment of process affinity by the system. After a process enables affinity update mode, it can call this function to disable it. However, a process cannot enable affinity update mode after it has used this function to disable it. Child processes do not inherit the affinity update mode of the parent process. The affinity update mode must be explicitly set for each child process. To compile an application that calls this function, define _WIN32_WINNT as 0x0600 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessAffinityUpdateMode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process. This handle must be returned by the GetCurrentProcess function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The affinity update mode. This parameter can be one of the following values.  ValueMeaning   0   Disables dynamic update of the process affinity by the system.   PROCESS_AFFINITY_ENABLE_AUTO_UPDATE 0x00000001UL   Enables dynamic update of the process affinity by the system."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets information for the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "To help improve system performance, applications should use the      SetProcessInformation function with      ProcessMemoryPriority to lower the default memory priority of threads that perform      background operations or access files and data that are not expected to be accessed again soon. For example, a      file indexing application might set a lower default priority for the process that performs the indexing task. Memory priority helps to determine how long pages remain in the      working set of a process before they are trimmed. A process's      memory priority determines the default priority of the physical pages that are added to the process working set by      the threads of that process. When the memory manager trims the working set, it trims lower priority pages before      higher priority pages. This improves overall system performance because higher priority pages are less likely to      be trimmed from the working set and then trigger a page fault when they are accessed again. The following example shows how to call       SetProcessInformation with       ProcessMemoryPriority to set low memory priority as the default for the calling       process. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. This handle must have the PROCESS_SET_INFORMATION access        right. For more information, see        Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "PROCESS_INFORMATION_CLASS",
        "name": "ProcessInformationClass",
        "description": "The class of information to set.  The only supported value is ProcessMemoryPriority."
      },
      {
        "in_out": "",
        "type": "_In_reads_bytes_(ProcessInformationSize)",
        "name": "ProcessInformation",
        "description": "Pointer to an object that contains the type of information specified by the         ProcessInformationClass parameter. If the ProcessInformationClass parameter is         ProcessMemoryPriority, this parameter must point to a         MEMORY_PRIORITY_INFORMATION structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ProcessInformationSize",
        "description": "The size in bytes of the structure specified by the ProcessInformation parameter. If the ProcessInformationClass parameter is         ProcessMemoryPriority, this parameter must be         sizeof(MEMORY_PRIORITY_INFORMATION)."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Sets a mitigation policy for the calling process. Mitigation policies enable a process to harden itself against various types of attacks.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Processthreadsapi.h",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve error values defined for this function, call GetLastError. ",
    "remarks": "Setting mitigation policy for a process helps prevent an attacker from exploiting security vulnerabilities. Use the SetProcessMitigationPolicy function to enable or disable security mitigation programmatically. For maximum effectiveness, mitigation policies should be applied before or during process initialization. For example, setting the ASLR policy that enables forced relocation of images is effective only if it is applied before all of the images in a process have been loaded. ASLR mitigation policies cannot be made less restrictive after they have been applied. To compile an application that uses this function, set _WIN32_WINNT >= 0x0602. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessMitigationPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PROCESS_MITIGATION_POLICY",
        "name": "MitigationPolicy",
        "description": "The mitigation policy to apply. This parameter can be one of the following values.  ValueMeaning  ProcessDEPPolicy   The data execution prevention (DEP) policy of the process. The lpBuffer parameter points to a PROCESS_MITIGATION_DEP_POLICY structure that specifies the DEP policy flags.   ProcessASLRPolicy   The Address Space Layout Randomization (ASLR) policy of the process. The lpBuffer parameter points to a PROCESS_MITIGATION_ASLR_POLICY structure that specifies the ASLR policy flags.   ProcessDynamicCodePolicy   The dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing executable code. The lpBuffer parameter points to a PROCESS_MITIGATION_DYNAMIC_CODE_POLICY structure that specifies the dynamic code policy flags.   ProcessStrictHandleCheckPolicy   The process will receive a fatal error if it manipulates a handle that is not valid. The lpBuffer parameter points to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the handle check policy flags.   ProcessSystemCallDisablePolicy   Disables the ability to use NTUser/GDI functions at the lowest layer. The lpBuffer parameter points to a PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags.   ProcessMitigationOptionsMask   Returns the mask of valid bits for all the mitigation options on the system.  An application can set many mitigation options without querying the operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at once. The lpBuffer parameter points to a ULONG64 bit vector for the mask, or to accommodate more than 64 bits, a two-element array of ULONG64 bit vectors.   ProcessExtensionPointDisablePolicy   The lpBuffer parameter points to a PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure that specifies the extension point disable policy flags.   ProcessControlFlowGuardPolicy   The Control Flow Guard (CFG) policy of the process. The lpBuffer parameter points to a PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. Note  This value is not currently supported.     ProcessSignaturePolicy   The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL). he lpBuffer parameter points to a PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that specifies the signature policy flags.   ProcessFontDisablePolicy   The policy regarding font loading for the process. When turned on, the process cannot load non-system fonts. The lpBuffer parameter points to a PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that specifies the policy flags for font loading.   ProcessImageLoadPolicy   The policy regarding image loading for the process, which determines the types of executable images that are allowed to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices or files that have the low mandatory label. The lpBuffer parameter points to a PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that specifies the policy flags for image loading."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpBuffer",
        "description": "If the MitigationPolicy parameter is ProcessDEPPolicy, this parameter points to a PROCESS_MITIGATION_DEP_POLICY structure that specifies the DEP policy flags. If the MitigationPolicy parameter is ProcessASLRPolicy, this parameter points to a PROCESS_MITIGATION_ASLR_POLICY structure that specifies the ASLR policy flags. If the MitigationPolicy parameter is ProcessImageLoadPolicy, this parameter points to a PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that receives the policy flags for image loading. If the MitigationPolicy parameter is ProcessStrictHandleCheckPolicy, this parameter points to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the handle check policy flags. If the MitigationPolicy parameter is ProcessSystemCallDisablePolicy, this parameter points to a PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags. If the MitigationPolicy parameter is ProcessMitigationOptionsMask, this parameter points to a ULONG64 bit vector for the mask, or to accommodate more than 64 bits, a two-element array of ULONG64 bit vectors. If the MitigationPolicy parameter is ProcessExtensionPointDisablePolicy, this parameter points to a PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure that specifies the extension point disable policy flags. If the MitigationPolicy parameter is ProcessControlFlowGuardPolicy, this parameter points to a PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. If the MitigationPolicy parameter is ProcessSignaturePolicy, this parameter points to a PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that specifies the signature policy flags. If the MitigationPolicy parameter is ProcessFontDisablePolicy, this parameter points to a PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that specifies the policy flags for font loading. If the MitigationPolicy parameter is ProcessImageLoadPolicy, this parameter points to a PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that specifies the policy flags for image loading."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwLength",
        "description": "The size of lpBuffer, in bytes."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Disables or enables the ability of the system to temporarily boost the priority of the threads of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "When a thread is running in one of the dynamic priority classes, the system temporarily boosts the thread's priority when it is taken out of a wait state. If  SetProcessPriorityBoost is called with the DisablePriorityBoost parameter set to TRUE, its threads' priorities are not boosted. This setting affects all existing threads and any threads subsequently created by the process. To restore normal behavior, call  SetProcessPriorityBoost with DisablePriorityBoost set to FALSE. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessPriorityBoost",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. This handle must have the PROCESS_SET_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "DisablePriorityBoost",
        "description": "If this parameter is TRUE, dynamic boosting is disabled. If the parameter is FALSE, dynamic boosting is enabled."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Exempts the calling process from restrictions preventing desktop processes from interacting with the Windows Store app environment. This function is used by development and debugging tools.",
    "library": "User32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winuser.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Any process can call this function, including desktop and Windows Store app processes and processes that use IL code. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessRestrictionExemption",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "BOOL",
        "name": "fEnableExemption",
        "description": "When set to TRUE, indicates a request to disable exemption for the calling process."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets shutdown parameters for the currently calling process. This function sets a shutdown order for a process relative to the other processes in the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function is succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Applications running in the system security context do not get shut down by the operating system. They get notified of shutdown or logoff through the callback function installable via  SetConsoleCtrlHandler. They also get notified in the order specified by the dwLevel parameter. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessShutdownParameters",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLevel",
        "description": "The shutdown priority for a process relative to other processes in the system. The system shuts down processes from high dwLevel values to low. The highest and lowest shutdown priorities are reserved for system components. This parameter must be in the following range of values.     ValueMeaning   000-0FF   System reserved last shutdown range.    100-1FF   Application reserved last shutdown range.    200-2FF   Application reserved \"in between\" shutdown range.    300-3FF   Application reserved first shutdown range.    400-4FF   System reserved first shutdown range.     All processes start at shutdown level 0x280."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be the following value.  ValueMeaning  SHUTDOWN_NORETRY 0x00000001   The system terminates the process without displaying a retry dialog box for the user."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Sets the minimum and maximum working set sizes for the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Call GetLastError to obtain extended error information. ",
    "remarks": "The working set of a process is the set of memory pages in the virtual address space of the process that are currently resident in physical memory. These pages are available for an application to use without triggering a page fault. For more information about page faults, see Working Set. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process. The working set of the specified process can be emptied by specifying the value (SIZE_T)\u00e2\u0080\u00931 for both the minimum and maximum working set sizes. This removes as many pages as possible from the working set. The EmptyWorkingSet function can also be used for this purpose. If the values of either dwMinimumWorkingSetSize or dwMaximumWorkingSetSize are greater than the process' current working set sizes, the specified process must have the SE_INC_WORKING_SET_NAME privilege. All users generally have this privilege. For more information about security privileges, see  Privileges. Windows Server 2003 and Windows XP:  The specified process must have the SE_INC_BASE_PRIORITY_NAME privilege. Users in the Administrators and Power Users groups generally have this privilege. The operating system allocates working set sizes on a first-come, first-served basis. For example, if an application successfully sets 40 megabytes as its minimum working set size on a 64-megabyte system, and a second application requests a 40-megabyte working set size, the operating system denies the second application's request. Using the  SetProcessWorkingSetSize function to set an application's minimum and maximum working set sizes does not guarantee that the requested memory will be reserved, or that it will remain resident at all times. When the application is idle, or a low-memory situation causes a demand for memory, the operating system can reduce the application's working set. An application can use the VirtualLock \t\tfunction to lock ranges of the application's virtual address space in memory; however, that can potentially degrade the performance of the system. When you increase the working set size of an application, you are taking away physical memory from the rest of the system. This can degrade the performance of other applications and the system as a whole. It can also lead to failures of operations that require physical memory to be present (for example, creating processes, threads, and kernel pool). Thus, you must use the  SetProcessWorkingSetSize function carefully. You must always consider the performance of the whole system when you are designing an application. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessWorkingSetSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose working set sizes is to be set.     The handle must have the PROCESS_SET_QUOTA access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwMinimumWorkingSetSize",
        "description": "The minimum working set size for the process, in bytes. ..."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwMaximumWorkingSetSize",
        "description": "The maximum working set size for the process, in bytes. ..."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets the minimum and maximum working set sizes for the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Memoryapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function is succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The working set of a process is the set of memory pages in the virtual address space of the process that are currently resident in physical memory. These pages are available for an application to use without triggering a page fault. For more information about page faults, see Working Set. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process. The working set of the specified process can be emptied by specifying the value (SIZE_T)\u00e2\u0080\u00931 for both the minimum and maximum working set sizes. This removes as many pages as possible from the working set. The EmptyWorkingSet function can also be used for this purpose. If the values of either dwMinimumWorkingSetSize or dwMaximumWorkingSetSize are greater than the process' current working set sizes, the specified process must have the SE_INC_WORKING_SET_NAME privilege. All users generally have this privilege. For more information about security privileges, see  Privileges. Windows Server 2003:  The specified process must have the SE_INC_BASE_PRIORITY_NAME privilege. Users in the Administrators and Power Users groups generally have this privilege. The operating system allocates working set sizes on a first-come, first-served basis. For example, if an application successfully sets 40 megabytes as its minimum working set size on a 64-megabyte system, and a second application requests a 40-megabyte working set size, the operating system denies the second application's request. By default, using the  SetProcessWorkingSetSize function to set an application's minimum and maximum working set sizes does not guarantee that the requested memory will be reserved, or that it will remain resident at all times. When an application is idle, or a low-memory situation causes a demand for memory, the operating system can reduce the application's working set below its minimum working set limit. If memory is abundant, the system might allow an application to exceed its maximum working set limit. The QUOTA_LIMITS_HARDWS_MIN_ENABLE and QUOTA_LIMITS_HARDWS_MAX_ENABLE flags enable you to ensure that limits are enforced. When you increase the working set size of an application, you are taking away physical memory from the rest of the system. This can degrade the performance of other applications and the system as a whole. It can also lead to failures of operations that require physical memory to be present (for example, creating processes, threads, and kernel pool). Thus, you must use the  SetProcessWorkingSetSize function carefully. You must always consider the performance of the whole system when you are designing an application. An application can use the  VirtualLock function to lock ranges of the application's virtual address space in memory; however, that can potentially degrade the performance of the system. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProcessWorkingSetSizeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose working set sizes is to be set. The handle must have PROCESS_SET_QUOTA access rights. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwMinimumWorkingSetSize",
        "description": "The minimum working set size for the process, in bytes. ..."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwMaximumWorkingSetSize",
        "description": "The maximum working set size for the process, in bytes. ..."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "The flags that control the enforcement of the minimum and maximum working set sizes.  ValueMeaning  QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002   The working set may fall below the minimum working set limit if memory demands are high. This flag cannot be used with QUOTA_LIMITS_HARDWS_MIN_ENABLE.   QUOTA_LIMITS_HARDWS_MIN_ENABLE 0x00000001   The working set will not fall below the minimum working set limit. This flag cannot be used with QUOTA_LIMITS_HARDWS_MIN_DISABLE.   QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008   The working set may exceed the maximum working set limit if there is abundant memory. This flag cannot be used with QUOTA_LIMITS_HARDWS_MAX_ENABLE.   QUOTA_LIMITS_HARDWS_MAX_ENABLE 0x00000004   The working set will not exceed the maximum working set limit. This flag cannot be used with QUOTA_LIMITS_HARDWS_MAX_DISABLE."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Terminates the specified process and all of its threads.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  TerminateProcess function is used to unconditionally cause a process to exit. The state of global data maintained by dynamic-link libraries (DLLs) may be compromised if  TerminateProcess is used rather than  ExitProcess. This function stops execution of all threads within the process and requests cancellation of all pending I/O. The terminated process cannot exit until all pending I/O has been completed or canceled. When a process terminates, its kernel object is not destroyed until all processes that have open handles to the process have released those handles. TerminateProcess is asynchronous; it initiates termination and returns immediately. If you need to be sure the process has terminated, call the WaitForSingleObject function with a handle to the process. A process cannot prevent itself from being terminated. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "TerminateProcess",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process to be terminated. The handle must have the PROCESS_TERMINATE access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uExitCode",
        "description": "The exit code to be used by the process and threads terminated as a result of this call. Use the  GetExitCodeProcess function to retrieve a process's exit value. Use the  GetExitCodeThread function to retrieve a thread's exit value."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves information about the first process encountered in a system snapshot.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "TlHelp32.h",
    "return_value": "Returns TRUE if the first entry of the process list has been copied to the buffer or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the  GetLastError function if no processes exist or the snapshot does not contain process information. ",
    "remarks": "The calling application must set the dwSize member of  PROCESSENTRY32 to the size, in bytes, of the structure. To retrieve information about other processes recorded in the same snapshot, use the  Process32Next function. For an example, see  Taking a Snapshot and Viewing Processes. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "Process32First",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hSnapshot",
        "description": "A handle to the snapshot returned from a previous call to the  CreateToolhelp32Snapshot function."
      },
      {
        "in_out": "_Inout_",
        "type": "LPPROCESSENTRY32",
        "name": "lppe",
        "description": "A pointer to a  PROCESSENTRY32 structure. It contains process information such as the name of the executable file, the process identifier, and the process identifier of the parent process."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves information about the next process recorded in a system snapshot.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "TlHelp32.h",
    "return_value": "Returns TRUE if the next entry of the process list has been copied to the buffer or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the  GetLastError function if no processes exist or the snapshot does not contain process information. ",
    "remarks": "To retrieve information about the first process recorded in a snapshot, use the  Process32First function. For an example, see  Taking a Snapshot and Viewing Processes. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "Process32Next",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hSnapshot",
        "description": "A handle to the snapshot returned from a previous call to the  CreateToolhelp32Snapshot function."
      },
      {
        "in_out": "_Out_",
        "type": "LPPROCESSENTRY32",
        "name": "lppe",
        "description": "A pointer to a  PROCESSENTRY32 structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information about the active      processes on a specified Remote Desktop Session Host (RD Session Host) server.",
    "library": "Wtsapi32.lib",
    "min_server": "Windows Server 2008",
    "header": "Wtsapi32.h",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The caller must be a member of the Administrators group to enumerate processes that are running under a      different user's context. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "WTSEnumerateProcesses",
    "is_callback": 0,
    "dll": "Wtsapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hServer",
        "description": "Handle to an RD Session Host server. Specify a handle opened by the        WTSOpenServer function, or specify        WTS_CURRENT_SERVER_HANDLE to indicate the RD Session Host server on which your application is        running."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "Reserved; must be zero."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Version",
        "description": "Specifies the version of the enumeration request. Must be 1."
      },
      {
        "in_out": "_Out_",
        "type": "PWTS_PROCESS_INFO*",
        "name": "ppProcessInfo",
        "description": "Pointer to a variable that receives a pointer to an array of        WTS_PROCESS_INFO structures. Each structure        in the array contains information about an active process on the specified RD Session Host server. To free the returned        buffer, call the WTSFreeMemory function."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD*",
        "name": "pCount",
        "description": "Pointer to a variable that receives the number of WTS_PROCESS_INFO        structures returned in the ppProcessInfo buffer."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "Queries the value associated with a protected policy.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "True if the function succeeds; otherwise, false. ",
    "remarks": "Protected policies are process-wide configuration settings that are stored in read-only memory. This is intended to help protect the policy from being corrupted or altered in an unintended way while an application is executing. To compile an application that calls this function, define _WIN32_WINNT as 0x0603 or later. For more information, see Using the Windows Headers. This function became available in Windows 8.1 and  Windows Server 2012 R2 update 3 (the November 2014 update). ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryProtectedPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "PolicyGuid",
        "description": "The globally-unique identifier of the policy to query."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "PolicyValue",
        "description": "Receives the value that the supplied policy is set to."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Sets a protected policy.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "True if the function succeeds; otherwise, false. To retrieve error values for this function, call GetLastError. ",
    "remarks": "Protected policies are process-wide configuration settings that are stored in read-only memory. This is intended to help protect the policy from being corrupted or altered in an unintended way while an application is executing. To compile an application that calls this function, define _WIN32_WINNT as 0x0603 or later. For more information, see Using the Windows Headers. This function became available in update 3 (the November 2014 update) for Windows 8.1 and  Windows Server 2012 R2. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetProtectedPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "PolicyGuid",
        "description": "The globally-unique identifier of the policy to set."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "PolicyValue",
        "description": "The value to set the policy to."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "OldPolicyValue",
        "description": "Optionally receives the original value that was associated with the supplied policy."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Attaches or detaches the input processing mechanism of one thread to that of another thread.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. Windows Server 2003 and Windows XP:  There is no extended error information; do not call GetLastError. This behavior changed as of Windows Vista. ",
    "remarks": "Windows created in different threads typically process input independently of each other. That is, they have their own input states (focus, active, capture windows, key state, queue status, and so on), and their input processing is not synchronized with the input processing of other threads. By using the  AttachThreadInput function, a thread can attach its input processing mechanism to another thread. Keyboard and mouse events received by both threads are processed by the  thread specified by the idAttachTo parameter until the threads are detached by calling AttachThreadInput a second time and specifying FALSE for the fAttach parameter. This also allows threads to share their input states, so they can call the SetFocus function to set the keyboard focus to a window of a different thread. This also allows threads to get key-state information. The  AttachThreadInput function fails if either of the specified threads does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the USER or GDI functions. The  AttachThreadInput function also fails if a journal record hook is installed. Journal record hooks attach all input queues together. Note that key state, which can be ascertained by calls to the  GetKeyState or  GetKeyboardState function, is reset after a call to  AttachThreadInput. You cannot attach a thread to a thread in another desktop. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AttachThreadInput",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "idAttach",
        "description": "The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system thread."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "idAttachTo",
        "description": "The identifier of the thread to which idAttach will be attached. This thread cannot be a system thread.     A thread cannot attach to itself. Therefore, idAttachTo cannot equal idAttach."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fAttach",
        "description": "If this parameter is TRUE, the two threads are attached. If the parameter is FALSE, the threads are detached."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Creates a thread that runs in the virtual address space of another process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. Note that  CreateRemoteThread may succeed even if lpStartAddress points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature of  CreateProcess, where the process is created even if it refers to invalid or missing dynamic-link libraries (DLL). ",
    "remarks": "The  CreateRemoteThread function causes a new thread of execution to begin in the address space of the specified process. The thread has access to all objects that the process opens. Terminal Services isolates each terminal session by design. Therefore,  CreateRemoteThread fails if the target process is in a different session than the calling process. The new thread handle is created with full access to the new thread. If a security descriptor is not provided, the handle may be used in any function that requires a thread object handle. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If the access check denies access, the requesting process cannot use the handle to gain access to the thread. If the thread is created in a runnable state (that is, if the CREATE_SUSPENDED flag is not used), the thread can start running before CreateThread returns and, in particular, before  the caller receives the handle and identifier of the created thread. The thread is created with a thread priority of THREAD_PRIORITY_NORMAL. Use the  GetThreadPriority and  SetThreadPriority functions to get and set the priority value of a thread. When a thread terminates, the thread object attains a signaled state, which satisfies the threads that are waiting for the object. The thread object remains in the system until the thread has terminated and all handles to it are closed through a call to  CloseHandle. The  ExitProcess,  ExitThread,  CreateThread,  CreateRemoteThread functions, and a process that is starting (as the result of a  CreateProcess call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold: A common use of this function is to inject a thread into a process that is being debugged to issue a break. However, this use is not recommended, because the extra thread is confusing to the person debugging the application and there are several side effects to using this technique: Another common use of this function is to inject a thread into a process to query heap or other process information. This can cause the same side effects mentioned in the previous paragraph. Also, the application can deadlock if the thread attempts to obtain ownership of locks that another thread is using. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "CreateRemoteThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpThreadAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator. Windows XP:  The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwStackSize",
        "description": "The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see  Thread Stack Size."
      },
      {
        "in_out": "_In_",
        "type": "LPTHREAD_START_ROUTINE",
        "name": "lpStartAddress",
        "description": "A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see  ThreadProc."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A pointer to a variable to be passed to the thread function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationFlags",
        "description": "The flags that control the creation of the thread.  ValueMeaning   0   The thread runs immediately after creation.   CREATE_SUSPENDED 0x00000004   The thread is created in a suspended state, and does not run until the  ResumeThread function is called.   STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000   The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit size."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpThreadId",
        "description": "A pointer to a variable that receives the thread identifier.     If this parameter is NULL, the thread identifier is not returned."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The  CreateRemoteThreadEx function causes a new thread of execution to begin in the address space of the specified process. The thread has access to all objects that the process opens. The lpAttribute parameter can be used to specify extended attributes such as processor group affinity for the new thread. If lpAttribute is NULL, the function's behavior is the same as  CreateRemoteThread. Prior to Windows 8, Terminal Services isolates each terminal session by design. Therefore,  CreateRemoteThread fails if the target process is in a different session than the calling process. The new thread handle is created with full access to the new thread. If a security descriptor is not provided, the handle may be used in any function that requires a thread object handle. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If the access check denies access, the requesting process cannot use the handle to gain access to the thread. If the thread is created in a runnable state (that is, if the CREATE_SUSPENDED flag is not used), the thread can start running before CreateThread returns and, in particular, before  the caller receives the handle and identifier of the created thread. The thread is created with a thread priority of THREAD_PRIORITY_NORMAL. To get and set the priority value of a thread, use the  GetThreadPriority and  SetThreadPriority functions. When a thread terminates, the thread object attains a signaled state, which satisfies the threads that are waiting for the object. The thread object remains in the system until the thread has terminated and all handles to it are closed through a call to  CloseHandle. The  ExitProcess,  ExitThread,  CreateThread,  CreateRemoteThread functions, and a process that is starting (as the result of a  CreateProcess call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold: A common use of this function is to inject a thread into a process that is being debugged to issue a break. However, this use is not recommended, because the extra thread is confusing to the person debugging the application and there are several side effects to using this technique: Another common use of this function is to inject a thread into a process to query heap or other process information. This can cause the same side effects mentioned in the previous paragraph. Also, the application can deadlock if the thread attempts to obtain ownership of locks that another thread is using. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "CreateRemoteThreadEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. In Windows 10, version 1607, your code must obtain these access rights for the new handle. However, starting in Windows 10, version 1703, if the new handle is entitled to these access rights, the system obtains them for you. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpThreadAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwStackSize",
        "description": "The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see  Thread Stack Size."
      },
      {
        "in_out": "_In_",
        "type": "LPTHREAD_START_ROUTINE",
        "name": "lpStartAddress",
        "description": "A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see  ThreadProc."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationFlags",
        "description": "The flags that control the creation of the thread.  ValueMeaning   0   The thread runs immediately after creation.   CREATE_SUSPENDED 0x00000004   The thread is created in a suspended state and does not run until the  ResumeThread function is called.   STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000   The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit size."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPPROC_THREAD_ATTRIBUTE_LIST",
        "name": "lpAttributeList",
        "description": "An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpThreadId",
        "description": "A pointer to a variable that receives the thread identifier.     If this parameter is NULL, the thread identifier is not returned."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Creates a thread to execute within the virtual address space of the calling process.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. Note that CreateThread may succeed even if         lpStartAddress points to data, code, or is not accessible. If the start address is         invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a         invalid start address is handled as an error exit for the thread's process. This behavior is similar to the         asynchronous nature of CreateProcess, where the         process is created even if it refers to invalid or missing dynamic-link libraries (DLLs). ",
    "remarks": "The number of threads a process can create is limited by the available virtual memory. By default, every thread has one megabyte of stack space. Therefore, you can create at most 2,048 threads. If you reduce the default stack size, you can create more threads. However, your application will have better performance if you create one thread per processor and build queues of requests for which the application maintains the context information. A thread would process all requests in a queue before processing requests in the next queue. The new thread handle is created with the THREAD_ALL_ACCESS access right. If a security descriptor is not provided when the thread is created, a default security descriptor is constructed for the new thread using the primary token of the   process that is creating the thread. When a caller attempts to access the thread  with the OpenThread function, the effective token of the caller is evaluated against this  security descriptor to grant or deny access. The newly created thread  has full access rights to itself when calling the GetCurrentThread  function. Windows Server 2003:  The thread's access rights to itself are computed by evaluating the primary token of the process in which the thread was created  against the default security descriptor constructed for the thread. If the thread is created in a remote process, the primary token of the remote process is used. As a result, the newly created thread may have reduced access rights to itself when calling GetCurrentThread. Some access rights including THREAD_SET_THREAD_TOKEN and THREAD_GET_CONTEXT may not be present, leading to unexpected failures. For this reason, creating a thread while impersonating another user is not recommended. If the thread is created in a runnable state (that is, if the CREATE_SUSPENDED flag is not used), the thread can start running before CreateThread returns and, in particular, before  the caller receives the handle and identifier of the created thread. The thread execution begins at the function specified by the lpStartAddress parameter. If this function returns, the DWORD return value is used to terminate the thread in an implicit call to the  ExitThread function. Use the  GetExitCodeThread function to get the thread's return value. The thread is created with a thread priority of THREAD_PRIORITY_NORMAL. Use the  GetThreadPriority and  SetThreadPriority functions to get and set the priority value of a thread. When a thread terminates, the thread object attains a signaled state, satisfying any threads that were waiting on the object. The thread object remains in the system until the thread has terminated and all handles to it have been closed through a call to  CloseHandle. The  ExitProcess,  ExitThread,  CreateThread,  CreateRemoteThread functions, and a process that is starting (as the result of a call by  CreateProcess) are serialized between each other within a process. Only one of these events can happen in an address space at a time. This means that the following restrictions hold: A thread in an executable that calls the C run-time library (CRT) should use the _beginthreadex and _endthreadex functions for thread management rather than  CreateThread and  ExitThread; this requires the use of the multithreaded version of the CRT. If a thread created using CreateThread calls the CRT, the CRT may terminate the process in low-memory conditions. Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. For an example, see  Creating Threads. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "CreateThread",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpThreadAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES         structure that determines whether the returned handle can be inherited by child processes. If         lpThreadAttributes is NULL, the handle cannot be inherited. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new thread. If lpThreadAttributes is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the primary token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwStackSize",
        "description": "The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is zero, the new thread uses the default size for the executable. For more information, see  Thread Stack Size."
      },
      {
        "in_out": "_In_",
        "type": "LPTHREAD_START_ROUTINE",
        "name": "lpStartAddress",
        "description": "A pointer to the application-defined function to be executed by the thread. This pointer represents the starting address of the thread. For more information on the thread function, see  ThreadProc."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A pointer to a variable to be passed to the thread."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationFlags",
        "description": "The flags that control the creation of the thread.  ValueMeaning   0   The thread runs immediately after creation.   CREATE_SUSPENDED 0x00000004   The thread is created in a suspended state, and does not run until the  ResumeThread function is called.   STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000   The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit size."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpThreadId",
        "description": "A pointer to a variable that receives the  thread identifier. If this parameter is        NULL, the thread identifier is not returned."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves a pseudo handle for the calling thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value is a pseudo handle for the current thread. ",
    "remarks": "A pseudo handle is a special constant that is interpreted as the current thread handle. The calling thread can use this handle to specify itself whenever a thread handle is required. Pseudo handles are not inherited by child processes. This handle has the THREAD_ALL_ACCESS access right to the thread object. For more information, see  Thread Security and Access Rights. Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of the thread to the primary token of the process. The function cannot be used by one thread to create a handle that can be used by other threads to refer to the first thread. The handle is always interpreted as referring to the thread that is using it. A thread can create a \"real\" handle to itself that can be used by other threads, or inherited by other processes, by specifying the pseudo handle as the source handle in a call to the DuplicateHandle function. The pseudo handle need not be closed when it is no longer needed. Calling the  CloseHandle function with this handle has no effect. If the pseudo handle is duplicated by  DuplicateHandle, the duplicate handle must be closed. Do not create a thread while impersonating a security context. The call will succeed, however the newly created thread will have reduced access rights to itself when calling GetCurrentThread. The access rights granted this thread will  be derived from the access rights the impersonated user has to the process.  Some access rights including THREAD_SET_THREAD_TOKEN and THREAD_GET_CONTEXT may not be present, leading to unexpected failures. For an example, see  Checking Client Access. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "GetCurrentThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the thread identifier of the calling thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value is the thread identifier of the calling thread. ",
    "remarks": "Until the thread terminates, the thread identifier uniquely identifies the thread throughout the system. For an example, see  Using Thread Local Storage. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetCurrentThreadId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the termination status of the specified thread.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function returns immediately. If the specified thread has not terminated and the function succeeds, the status returned is STILL_ACTIVE. If the thread has terminated and the function succeeds, the status returned is one of the following values: Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetExitCodeThread",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the THREAD_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpExitCode",
        "description": "A pointer to a variable to receive the thread termination status. For more information, see Remarks."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the description that was assigned to a thread by calling SetThreadDescription.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "ProcessThreadsApi.h",
    "return_value": "If the function succeeds, the return value is the HRESULT that denotes a successful operation. If the function fails, the return value is an HRESULT that denotes the error. ",
    "remarks": "The description for a thread can change at any time. For example, a different thread can change the description of a thread of interest while you try to retrieve that description. Thread descriptions do not need to be unique. To free the memory for the thread description, call the LocalFree method. The following example gets the description for a thread,  prints the description, and then frees the memory for the description. ",
    "return_type": "HRESULT",
    "category": "Processes",
    "name": "GetThreadDescription",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread for which to retrieve the description. The handle must have THREAD_QUERY_LIMITED_INFORMATION access."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR*",
        "name": "threadDescription",
        "description": "A Unicode string that contains the description of the thread."
      }
    ],
    "min_client": "Windows 10, version 1607 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Assigns a description to a thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "ProcessThreadsApi.h",
    "return_value": "If the function succeeds, the return value is the HRESULT that denotes a successful operation. If the function fails, the return value is an HRESULT that denotes the error. ",
    "remarks": "The description of a thread can be set more than once; the most recently set value is used. You can retrieve the description of a thread by calling GetThreadDescription. The following example sets the description for the current thread to \"simulation_thread\". ",
    "return_type": "HRESULT",
    "category": "Processes",
    "name": "SetThreadDescription",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle for the thread for which you want to set the description. The handle must have THREAD_SET_LIMITED_INFORMATION access."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "lpThreadDescription",
        "description": "A Unicode string that specifies the description of the thread."
      }
    ],
    "min_client": "Windows 10, version 1607 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the processor group affinity of the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Processtopologyapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetThreadGroupAffinity",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread for which the processor group affinity is desired.  The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PGROUP_AFFINITY",
        "name": "GroupAffinity",
        "description": "A pointer to a GROUP_AFFINITY structure to receive the group affinity of the thread."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the thread identifier of the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Until a thread terminates, its thread identifier uniquely identifies it on the system. To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetThreadId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Thread",
        "description": "A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information about access rights, see  Thread Security and Access Rights. Windows Server 2003:  The handle must have the THREAD_QUERY_INFORMATION access right."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the processor number of the ideal processor for the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, it returns zero. To get extended error information, use GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetThreadIdealProcessorEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread for which to retrieve the ideal processor. This handle must have been created with the THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see Thread Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PPROCESSOR_NUMBER",
        "name": "lpIdealProcessor",
        "description": "Points to PROCESSOR_NUMBER structure to receive the number of the ideal processor."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves information about the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call        GetLastError. ",
    "remarks": "",
    "return_type": " BOOL",
    "category": "Processes",
    "name": "GetThreadInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread. The handle must have THREAD_QUERY_INFORMATION access rights. For more information, see  Thread Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "THREAD_INFORMATION_CLASS",
        "name": "ThreadInformationClass",
        "description": "The class of information to retrieve. The only supported value is ThreadMemoryPriority."
      },
      {
        "in_out": "",
        "type": "_Out_writes_bytes_",
        "name": "ThreadInformation",
        "description": "Pointer to a structure to receive the type of information specified by the ThreadInformationClass parameter. If the ThreadInformationClass parameter is ThreadMemoryPriority, this parameter must point to a MEMORY_PRIORITY_INFORMATION structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ThreadInformationSize",
        "description": "The size in bytes of the structure specified by the ThreadInformation parameter. If the ThreadInformationClass parameter is ThreadMemoryPriority, this parameter must be sizeof(MEMORY_PRIORITY_INFORMATION)."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether a specified thread has any I/O requests pending.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the  function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "Keep in mind that the I/O status of the specified thread can change  rapidly, and may already have changed by the time the function returns. For example, a pending I/O operation could complete between the time the function sets  lpIOIsPending and the time it returns. To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetThreadIOPendingFlag",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread in question. This handle must have been created with the THREAD_QUERY_INFORMATION access right. For more information, see Thread Security and Access Rights."
      },
      {
        "in_out": "_Inout_",
        "type": "PBOOL",
        "name": "lpIOIsPending",
        "description": "A pointer to a  variable which the function sets to TRUE if the specified thread has one or more I/O requests pending, or to FALSE otherwise."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base-priority level.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is the thread's priority level. If the function fails, the return value is THREAD_PRIORITY_ERROR_RETURN. To get extended error information, call  GetLastError. Windows Phone 8.1:  This function will always return THREAD_PRIORITY_NORMAL. The thread's priority level is one of the following values.  If the thread has the REALTIME_PRIORITY_CLASS base class, this function can also return one of the following values: -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see  Scheduling Priorities. ",
    "remarks": "Every thread has a base-priority level determined by the thread's priority value and the priority class of its process. The operating system uses the base-priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a round-robin fashion at each priority level, and only when there are no executable threads at a higher level will scheduling of threads at a lower level take place. For a table that shows the base-priority levels for each combination of priority class and thread priority value, refer to the  SetPriorityClass function. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps. Windows Phone 8.1:Windows Phone Store apps may call this function but it has no effect. ",
    "return_type": "int",
    "category": "Processes",
    "name": "GetThreadPriority",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003:  The handle must have the THREAD_QUERY_INFORMATION access right."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the priority boost control state of the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the pDisablePriorityBoost parameter receives the priority boost control state. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetThreadPriorityBoost",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the THREAD_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "pDisablePriorityBoost",
        "description": "A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves timing information for the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "All times are expressed using  FILETIME data structures. Such a structure contains two 32-bit values that combine to form a 64-bit count of 100-nanosecond time units. Thread creation and exit times are points in time expressed as the amount of time that has elapsed since midnight on January 1, 1601 at Greenwich, England. There are several functions that an application can use to convert such values to more generally useful forms; see  Time Functions. Thread kernel mode and user mode times are amounts of time. For example, if a thread has spent one second in kernel mode, this function will fill the FILETIME structure specified by lpKernelTime with a 64-bit value of ten million. That is the number of 100-nanosecond units in one second. To retrieve the number of CPU clock cycles used by the threads, use the QueryThreadCycleTime function. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetThreadTimes",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread whose timing information is sought. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the THREAD_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpCreationTime",
        "description": "A pointer to a  FILETIME structure that receives the creation time of the thread."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpExitTime",
        "description": "A pointer to a FILETIME structure that receives the exit time of the thread. If the thread has not exited, the content of this structure is undefined."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpKernelTime",
        "description": "A pointer to a  FILETIME structure that receives the amount of time that the thread has executed in kernel mode."
      },
      {
        "in_out": "_Out_",
        "type": "LPFILETIME",
        "name": "lpUserTime",
        "description": "A pointer to a FILETIME structure that receives the amount of time that the thread has executed in user mode."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing thread object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is an open handle to the specified thread. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The handle returned by  OpenThread can be used in any function that requires a handle to a thread, such as the  wait functions, provided you requested the appropriate access rights. The handle is granted access to the thread object only to the extent it was specified in the dwDesiredAccess parameter. When you are finished with the handle, be sure to close it by using the  CloseHandle function. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "OpenThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the thread object. This access right is checked against the security descriptor for the thread. This parameter can be one or more of the  thread access rights. If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwThreadId",
        "description": "The identifier of the thread to be opened."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the cycle time for the idle thread of each processor in the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Realtimeapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryIdleProcessorCycleTime",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "BufferLength",
        "description": "On input, specifies the size of the ProcessorIdleCycleTime buffer, in bytes. This buffer is expected to be 8 times the number of processors in the group. On output, specifies the number of elements written to the buffer. If the buffer size is not sufficient, the function fails and this parameter receives the required length of the buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "ProcessorIdleCycleTime",
        "description": "The number of CPU clock cycles used by each idle thread. This buffer must be 8  times the number of processors in the system in size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the cycle time for the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Realtimeapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To enumerate the threads of the process, use the Thread32First and Thread32Next functions. To get the thread handle for a thread identifier, use the  OpenThread function. Do not attempt to convert the CPU clock cycles returned by QueryThreadCycleTime to elapsed time. This function uses timer services provided by the CPU, which can vary in implementation. For example, some CPUs will vary the frequency of the timer when changing the frequency at which the CPU runs and others will leave it at a fixed rate. The behavior of each CPU is described in the documentation provided by the CPU vendor. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryThreadCycleTime",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ThreadHandle",
        "description": "A handle to the thread. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "CycleTime",
        "description": "The number of CPU clock cycles used by the thread. This value includes cycles spent in both user mode and kernel mode."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is the thread's previous suspend count. If the function fails, the return value is (DWORD) -1. To get extended error information, call GetLastError. ",
    "remarks": "The  ResumeThread function checks the suspend count of the subject thread. If the suspend count is zero, the thread is not currently suspended. Otherwise, the subject thread's suspend count is decremented. If the resulting value is zero, then the execution of the subject thread is resumed. If the return value is zero, the specified thread was not suspended. If the return value is 1, the specified thread was suspended but was restarted. If the return value is greater than 1, the specified thread is still suspended. Note that while reporting debug events, all threads within the reporting process are frozen. Debuggers are expected to use the  SuspendThread and  ResumeThread functions to limit the set of threads that can execute within a process. By suspending all threads in a process except for the one reporting a debug event, it is possible to \"single step\" a single thread. The other threads are not released by a continue operation if they are suspended. Windows Phone 8.1:  This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "ResumeThread",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread to be restarted.     This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see  Thread Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a processor affinity mask for the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the thread's previous affinity mask. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the thread affinity mask requests a processor that is not selected for the process affinity mask, the last error code is ERROR_INVALID_PARAMETER. ",
    "remarks": "A thread affinity mask is a bit vector in which each bit represents a logical processor that a thread is allowed to run on. A thread affinity mask must be a subset of the process affinity mask for the containing process of a thread. A thread can only run on the processors its process can run on. Therefore, the thread affinity mask cannot specify a 1 bit for a processor when the process affinity mask specifies a 0 bit for that processor. Setting an affinity mask for a process or thread can result in threads receiving less processor time, as the system is restricted from running the threads on certain processors. In most cases, it is better to let the system select an available processor. If the new thread affinity mask does not specify the processor that is currently running the thread, the thread is rescheduled on one of the allowable processors. ",
    "return_type": "DWORD_PTR",
    "category": "Processes",
    "name": "SetThreadAffinityMask",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread whose affinity mask is to be set. This handle must have the THREAD_SET_INFORMATION or THREAD_SET_LIMITED_INFORMATION access right and the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the THREAD_SET_INFORMATION and THREAD_QUERY_INFORMATION access rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD_PTR",
        "name": "dwThreadAffinityMask",
        "description": "The affinity mask for the thread. On a system with more than 64 processors, the affinity mask must specify processors in the thread's current processor group."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Sets the processor group affinity for the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Processtopologyapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadGroupAffinity",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread.  The handle must have the THREAD_SET_INFORMATION access right. For more information, see  Thread Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "const GROUP_AFFINITY*",
        "name": "GroupAffinity",
        "description": "A GROUP_AFFINITY structure that specifies the processor group affinity to be used for the specified thread."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PGROUP_AFFINITY",
        "name": "PreviousGroupAffinity",
        "description": "A pointer to a GROUP_AFFINITY structure to receive the thread's previous group affinity. This parameter can be NULL."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a preferred processor for a thread. The system schedules threads on their preferred processors whenever possible.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the previous preferred processor. If the function fails, the return value is (DWORD) \u00e2\u0080\u0093 1. To get extended error information, call  GetLastError. ",
    "remarks": "You can use the GetSystemInfo function to determine the number of processors on the computer. You can also use the  GetProcessAffinityMask function to check the processors on which the thread is allowed to run. Note that  GetProcessAffinityMask returns a bitmask whereas  SetThreadIdealProcessor uses an integer value to represent the processor. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "SetThreadIdealProcessor",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread whose preferred processor is to be set. The handle must have the THREAD_SET_INFORMATION access right. For more information, see  Thread Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIdealProcessor",
        "description": "The number of the preferred processor for the thread. This value is zero-based. If this parameter is MAXIMUM_PROCESSORS, the function returns the current ideal processor without changing it."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Sets the ideal processor for the specified thread and optionally retrieves the previous ideal processor.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, it returns zero. To get extended error information, use GetLastError. ",
    "remarks": "Specifying a thread ideal processor provides a hint to the scheduler about the preferred processor for a thread. The scheduler runs the thread on the thread's ideal processor when possible. To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadIdealProcessorEx",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread for which to set the ideal processor. This handle must have been created with the THREAD_SET_INFORMATION access right. For more information, see Thread Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "PPROCESSOR_NUMBER",
        "name": "lpIdealProcessor",
        "description": "A pointer to a PROCESSOR_NUMBER structure that specifies the processor number of the desired ideal processor."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PPROCESSOR_NUMBER",
        "name": "lpPreviousIdealProcessor",
        "description": "A pointer to a PROCESSOR_NUMBER structure to receive the previous ideal processor. This parameter can point to the same memory location as the lpIdealProcessor parameter. This parameter can be NULL if the previous ideal processor is not required."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Sets information for the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call        GetLastError. ",
    "remarks": "To help improve system performance, applications should use the SetThreadInformation function with ThreadMemoryPriority to lower the memory priority of threads that perform background operations or access files and data that are not expected to be accessed again soon. For example, an anti-malware application might lower the priority of threads involved in scanning files. Memory priority helps to determine how long pages remain in the working set of a process before they are trimmed. A thread's memory priority determines the minimum priority of the physical pages that are added to the process working set by that thread. When the memory manager trims the working set, it trims lower priority pages before higher priority pages. This improves overall system performance because higher priority pages are less likely to be trimmed from the working set and then trigger a page fault when they are accessed again. The following example shows how to call SetThreadInformation with ThreadMemoryPriority to set low memory priority on the current thread. ",
    "return_type": " BOOL",
    "category": "Processes",
    "name": "SetThreadInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread. The handle must have THREAD_QUERY_INFORMATION access right. For more information, see  Thread Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "THREAD_INFORMATION_CLASS",
        "name": "ThreadInformationClass",
        "description": "The class of information to set. The only supported value is ThreadMemoryPriority."
      },
      {
        "in_out": "",
        "type": "_In_reads_bytes_",
        "name": "ThreadInformation",
        "description": "Pointer to a structure that contains the type of information specified by the ThreadInformationClass parameter. If the ThreadInformationClass parameter is ThreadMemoryPriority, this parameter must point to a MEMORY_PRIORITY_INFORMATION structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ThreadInformationSize",
        "description": "The size in bytes of the structure specified by the ThreadInformation parameter. If the ThreadInformationClass parameter is ThreadMemoryPriority, this parameter must be sizeof(MEMORY_PRIORITY_INFORMATION)."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base priority level.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. Windows Phone 8.1:  Windows Phone Store apps may call this function but it has no effect. The function will return a nonzero value indicating success. ",
    "remarks": "Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The system uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a round-robin fashion at each priority level, and only when there are no executable threads at a higher level does scheduling of threads at a lower level take place. The  SetThreadPriority function enables setting the base priority level of a thread relative to the priority class of its process. For example, specifying THREAD_PRIORITY_HIGHEST in a call to  SetThreadPriority for a thread of an IDLE_PRIORITY_CLASS process sets the thread's base priority level to 6. For a table that shows the base priority levels for each combination of priority class and thread priority value, see  Scheduling Priorities. For IDLE_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, ABOVE_NORMAL_PRIORITY_CLASS, and HIGH_PRIORITY_CLASS processes, the system dynamically boosts a thread's base priority level when events occur that are important to the thread. REALTIME_PRIORITY_CLASS processes do not receive dynamic boosts. All threads initially start at THREAD_PRIORITY_NORMAL. Use the  GetPriorityClass and  SetPriorityClass functions to get and set the priority class of a process. Use the  GetThreadPriority function to get the priority value of a thread. Use the priority class of a process to differentiate between applications that are time critical and those that have normal or below normal scheduling requirements. Use thread priority values to differentiate the relative priorities of the tasks of a process. For example, a thread that handles input for a window could have a higher priority level than a thread that performs intensive calculations for the CPU. When manipulating priorities, be very careful to ensure that a high-priority thread does not consume all of the available CPU time. A thread with a base priority level above 11 interferes with the normal operation of the operating system. Using REALTIME_PRIORITY_CLASS may cause disk caches to not flush, cause the mouse to stop responding, and so on. The THREAD_PRIORITY_* values affect the CPU scheduling priority of the thread. For threads that perform background work such as file I/O, network I/O, or data processing, it is not sufficient to adjust the CPU scheduling priority; even an idle CPU priority thread can easily interfere with system responsiveness when it uses the disk and memory. Threads that perform background work should use the THREAD_MODE_BACKGROUND_BEGIN and THREAD_MODE_BACKGROUND_END values to adjust their resource scheduling priorities; threads that interact with the user should not use THREAD_MODE_BACKGROUND_BEGIN. When a thread is in background processing mode, it should minimize sharing resources such as critical sections, heaps, and handles with other threads in the process, otherwise priority inversions can occur. If there are threads executing at high priority, a thread in background processing mode may not be scheduled promptly, but it will never be starved. Windows Server 2008 and Windows Vista:  While the system is starting, the SetThreadPriority function returns a success return value but does not change thread priority  for applications that are started from the system Startup folder or listed in the HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run registry key. These applications run at reduced priority for a short time (approximately 60 seconds) to make the system more responsive to user actions during startup. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps. Windows Phone 8.1:Windows Phone Store apps may call this function but it has no effect. The following example demonstrates the use of thread background mode. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadPriority",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread whose priority value is to be set. The handle must have the THREAD_SET_INFORMATION or THREAD_SET_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights.Windows Server 2003:  The handle must have the THREAD_SET_INFORMATION access right."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nPriority",
        "description": "The priority value for the thread. This parameter can be one of the following values.  PriorityMeaning  THREAD_MODE_BACKGROUND_BEGIN 0x00010000   Begin background processing mode. The system lowers the resource scheduling priorities of the thread so that it can perform background work without significantly affecting activity in the foreground. This value can be specified only if hThread is a handle to the current thread.  The function fails if the thread is already in background processing mode. Windows Server 2003:  This value is not supported.   THREAD_MODE_BACKGROUND_END 0x00020000   End background processing mode. The system restores the resource scheduling priorities of the thread as they were before the thread entered background processing mode. This value can be specified only if hThread is a handle to the current thread. The function fails if the thread is not in background processing mode. Windows Server 2003:  This value is not supported.   THREAD_PRIORITY_ABOVE_NORMAL 1   Priority 1 point above the priority class.   THREAD_PRIORITY_BELOW_NORMAL -1   Priority 1 point below the priority class.   THREAD_PRIORITY_HIGHEST 2   Priority 2 points above the priority class.   THREAD_PRIORITY_IDLE -15   Base priority of 1 for IDLE_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, ABOVE_NORMAL_PRIORITY_CLASS, or HIGH_PRIORITY_CLASS processes, and a base priority of 16 for REALTIME_PRIORITY_CLASS processes.   THREAD_PRIORITY_LOWEST -2   Priority 2 points below the priority class.   THREAD_PRIORITY_NORMAL 0   Normal priority for the priority class.   THREAD_PRIORITY_TIME_CRITICAL 15   Base priority of 15 for IDLE_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, ABOVE_NORMAL_PRIORITY_CLASS, or HIGH_PRIORITY_CLASS processes, and a base priority of 31 for REALTIME_PRIORITY_CLASS processes.            If the thread has the REALTIME_PRIORITY_CLASS base class, this parameter can also be -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see  Scheduling Priorities."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Disables or enables the ability of the system to temporarily boost the priority of a thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "When a thread is running in one of the dynamic priority classes, the system temporarily boosts the thread's priority when it is taken out of a wait state. If  SetThreadPriorityBoost is called with the DisablePriorityBoost parameter set to TRUE, the thread's priority is not boosted. To restore normal behavior, call  SetThreadPriorityBoost with DisablePriorityBoost set to FALSE. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadPriorityBoost",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread whose priority is to be boosted. The handle must have the THREAD_SET_INFORMATION or THREAD_SET_LIMITED_INFORMATION access right. For more information, see  Thread Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the THREAD_SET_INFORMATION access right."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "DisablePriorityBoost",
        "description": "If this parameter is TRUE, dynamic boosting is disabled. If the parameter is FALSE, dynamic boosting is enabled."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the minimum size of the stack associated with the calling thread or fiber that will be available during any stack overflow exceptions. This is useful for handling stack overflow exceptions; the application can safely use the specified number of bytes during exception handling.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. ",
    "remarks": "If the function is successful, the application can handle possible EXCEPTION_STACK_OVERFLOW exceptions using structured exception handling. To resume execution after handling a stack overflow, you must perform certain recovery steps. If you are using the Microsoft C/C++ compiler, call the _resetstkoflw function. If you are using another compiler, see the documentation for the compiler for information on recovering from stack overflows. To set the stack guarantee for a fiber, you must first call the SwitchToFiber function to execute the fiber. After you set the guarantee for this fiber, it is used by the fiber no matter which thread executes the fiber. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadStackGuarantee",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "StackSizeInBytes",
        "description": "The size of the stack, in bytes. On return, this value is set to the size of the previous stack, in bytes. If this parameter is 0 (zero), the function succeeds and the parameter contains the size of the current stack. If the specified size is less than the current size, the function succeeds but ignores this request. Therefore, you cannot use this function to reduce the size of the stack. This value cannot be larger than the reserved stack size."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Suspends the execution of the current thread until the time-out interval elapses.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "This function does not return a value. ",
    "remarks": "This function causes a thread to relinquish the remainder of its time slice and become unrunnable for an interval based on the value of dwMilliseconds. The system clock \"ticks\" at a constant rate. If dwMilliseconds is less than the resolution of the system clock, the thread may sleep for less than the specified length of time. If dwMilliseconds is greater than one tick but less than two, the wait can be anywhere between one and two ticks, and so on. To increase the accuracy of the sleep interval, call the timeGetDevCaps function to determine the supported minimum timer resolution and the timeBeginPeriod function to set the timer resolution to its minimum. Use caution when calling timeBeginPeriod, as frequent calls can significantly affect the system clock, system power usage, and the scheduler. If you call timeBeginPeriod, call it one time early in the application and be sure to call the timeEndPeriod function at the very end of the application. After the sleep interval has passed, the thread is ready to run. If you specify 0 milliseconds, the thread will relinquish the remainder of its time slice but remain ready. Note that a ready thread is not guaranteed to run immediately. Consequently, the thread may not run until some time after the sleep interval elapses. For more information, see  Scheduling Priorities. Be careful when using Sleep in the following scenarios: For these scenarios, use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, rather than  Sleep. Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. For an example, see  Using Thread Local Storage. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "Sleep",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time interval for which execution is to be suspended, in milliseconds. A value of zero causes the thread to relinquish the remainder of its time slice to any other thread  that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution.Windows XP:  A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003. A value of INFINITE indicates that the suspension should not time out."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Suspends the current thread until the specified condition is met. Execution resumes when one of the following occurs:",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "The return value is zero if the specified time interval expired. The return value is WAIT_IO_COMPLETION if the function returned due to one or more I/O completion callback functions. This can happen only if bAlertable is TRUE, and if the thread that called the  SleepEx function is the same thread that called the extended I/O function. ",
    "remarks": "This function causes a thread to relinquish the remainder of its time slice and become unrunnable for an interval based on the value of dwMilliseconds. The system clock \"ticks\" at a constant rate. If dwMilliseconds is less than the resolution of the system clock, the thread may sleep for less than the specified length of time. If dwMilliseconds is greater than one tick but less than two, the wait can be anywhere between one and two ticks, and so on. To increase the accuracy of the sleep interval, call the timeGetDevCaps function to determine the supported minimum timer resolution and the timeBeginPeriod function to set the timer resolution to its minimum. Use caution when calling timeBeginPeriod, as frequent calls can significantly affect the system clock, system power usage, and the scheduler. If you call timeBeginPeriod, call it one time early in the application and be sure to call the timeEndPeriod function at the very end of the application. After the sleep interval has passed, the thread is ready to run. If you specify 0 milliseconds, the thread will relinquish the remainder of its time slice but remain ready. Note that a ready thread is not guaranteed to run immediately. Consequently, the thread may not run until some time after the sleep interval elapses. For more information, see  Scheduling Priorities. This function can be used with the ReadFileEx or WriteFileEx functions to suspend a thread until an I/O operation has been completed. These functions specify a completion routine that is to be executed when the I/O operation has been completed. For the completion routine to be executed, the thread that called the I/O function must be in an alertable wait state when the completion callback function occurs. A thread goes into an alertable wait state by calling either  SleepEx,  MsgWaitForMultipleObjectsEx,  WaitForSingleObjectEx, or  WaitForMultipleObjectsEx, with the function's bAlertable parameter set to TRUE. Be careful when using SleepEx in the following scenarios: For these scenarios, use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, rather than  SleepEx. Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "SleepEx",
    "is_callback": 0,
    "dll": "KernelBase.dll on Windows Phone 8.1;  Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time interval for which execution is to be suspended, in milliseconds. A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. A value of INFINITE indicates that the suspension should not time out."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bAlertable",
        "description": "If this parameter is FALSE, the function does not return until the time-out period has elapsed. If an I/O completion callback occurs, the function does not return and the I/O completion function is not executed. If an APC is queued to the thread, the function does not return and the APC function is not executed. If the parameter is TRUE and the thread that called this function is the same thread that called the extended I/O function (ReadFileEx or  WriteFileEx), the function returns when either the time-out period has elapsed or when an I/O completion callback function occurs. If an I/O completion callback occurs, the I/O completion function is called. If an APC is queued to the thread (QueueUserAPC), the function returns when either the timer-out period has elapsed or when the APC function is called."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Suspends the specified thread.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the  GetLastError function. ",
    "remarks": "If the function succeeds, execution of the specified thread is suspended and the thread's suspend count is incremented. Suspending a thread causes the thread to stop executing user-mode (application) code. This function is primarily designed for use by debuggers. It is not intended to be used for thread synchronization. Calling  SuspendThread on a thread that owns a synchronization object, such as a mutex or critical section, can lead to a deadlock if the calling thread tries to obtain a synchronization object owned by a suspended thread. To avoid this situation, a thread within an application that is not a debugger should signal the other thread to suspend itself. The target thread must be designed to watch for this signal and respond appropriately. Each thread has a suspend count (with a maximum value of MAXIMUM_SUSPEND_COUNT). If the suspend count is greater than zero, the thread is suspended; otherwise, the thread is not suspended and is eligible for execution. Calling  SuspendThread causes the target thread's suspend count to be incremented. Attempting to increment past the maximum suspend count causes an error without incrementing the count. The  ResumeThread function decrements the suspend count of a suspended thread. Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "SuspendThread",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread that is to be suspended. The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see  Thread Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the next thread to be executed.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If calling the  SwitchToThread function causes the operating system to switch execution to another thread, the return value is nonzero. If there are no other threads ready to execute, the operating system does not switch execution to another thread, and the return value is zero. ",
    "remarks": "The yield of execution is in effect for up to one thread-scheduling time slice on the processor of the calling thread. The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority. After the yielding thread's time slice elapses, the operating system reschedules execution for the yielding thread. The rescheduling is determined by the priority of the yielding thread and the status of other threads that are available to run. Note that the operating system will not switch to a thread that is being prevented from running only by concurrency control. For example, an I/O completion port or thread pool limits the number of associated threads that can run. If the maximum number of threads is already running, no additional associated thread can run until a running thread finishes.   If a thread uses SwitchToThread to wait for one of the additional associated threads to accomplish some work, the process might deadlock. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SwitchToThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Terminates a thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "TerminateThread is used to cause a thread to exit. When this occurs, the target thread has no chance to execute any user-mode code. DLLs attached to the thread are not notified that the thread is terminating. The system frees the thread's initial stack. Windows Server 2003 and Windows XP:  The target thread's initial stack is not freed, causing a resource leak. TerminateThread is a dangerous function that should only be used in the most extreme cases. You should call  TerminateThread only if you know exactly what the target thread is doing, and you control all of the code that the target thread could possibly be running at the time of the termination. For example,  TerminateThread can result in the following problems: A thread cannot protect itself against  TerminateThread, other than by controlling access to its handles. The thread handle returned by the  CreateThread and  CreateProcess functions has THREAD_TERMINATE access, so any caller holding one of these handles can terminate your thread. If the target thread is the last thread of a process when this function is called, the thread's process is also terminated. The state of the thread object becomes signaled, releasing any other threads that had been waiting for the thread to terminate. The thread's termination status changes from STILL_ACTIVE to the value of the dwExitCode parameter. Terminating a thread does not necessarily remove the thread object from the system. A thread object is deleted when the last thread handle is closed. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "TerminateThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread to be terminated. The handle must have the THREAD_TERMINATE access right. For more information, see  Thread Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwExitCode",
        "description": "The exit code for the thread. Use the  GetExitCodeThread function to retrieve a thread's exit value."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined function that serves as the starting address for a thread. Specify this address when calling the  CreateThread,   CreateRemoteThread, or CreateRemoteThreadEx function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value indicates the success or failure of this function. The return value should never be set to STILL_ACTIVE (259), as noted in GetExitCodeThread. Do not declare this callback function with a void return type and cast the function pointer to LPTHREAD_START_ROUTINE when creating the thread. Code that does this is common, but it can crash on 64-bit Windows. ",
    "remarks": "A process can determine when a thread it created has completed by using one of the wait functions. It can also obtain the return value of its  ThreadProc by calling the  GetExitCodeThread function. Each thread receives a unique copy of the local variables of this function. Any static or global variables are shared by all threads in the process. To provide unique data to each thread using a global index, use thread local storage. For an example, see  Creating Threads. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "ThreadProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "The thread data passed to the function using the lpParameter parameter of the  CreateThread,   CreateRemoteThread, or CreateRemoteThreadEx function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Allocates a thread local storage (TLS) index. Any thread of the process can subsequently use this index to store and retrieve values that are local to the thread, because each thread receives its own slot for the index.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is a TLS index. The slots for the index are initialized to zero. If the function fails, the return value is TLS_OUT_OF_INDEXES. To get extended error information, call  GetLastError. ",
    "remarks": "Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to FlsAlloc. Refer to FlsAlloc for function documentation. Windows 8.1,  Windows Server 2012 R2, and Windows 10, version 1507: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to FlsAlloc. Refer to FlsAlloc for function documentation. Windows 10, version 1511 and Windows 10, version 1607: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to FlsAlloc. The threads of the process can use the TLS index in subsequent calls to the  TlsFree,  TlsSetValue, or  TlsGetValue functions. The value of the TLS index should be treated as an opaque value; do not assume that it is an index into a zero-based array. TLS indexes are typically allocated during process or dynamic-link library (DLL) initialization. When a TLS index is allocated, its storage slots are initialized to NULL. After a TLS index has been allocated, each thread of the process can use it to access its own TLS storage slot. To store a value in its TLS slot, a thread specifies the index in a call to  TlsSetValue. The thread specifies the same index in a subsequent call to  TlsGetValue, to retrieve the stored value. TLS indexes are not valid across process boundaries. A DLL cannot assume that an index assigned in one process is valid in another process. For an example, see  Using Thread Local Storage or  Using Thread Local Storage in a Dynamic-Link Library. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "TlsAlloc",
    "is_callback": 0,
    "dll": "KernelBase.dll on Windows Phone 8.1;  Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases a thread local storage (TLS) index, making it available for reuse.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to FlsFree. Refer to FlsFree for function documentation. Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to FlsFree. Refer to FlsFree for function documentation. Windows 10, version 1511 and Windows 10, version 1607: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to FlsFree. If the threads of the process have allocated memory and stored a pointer to the memory in a TLS slot, they should free the memory before calling  TlsFree. The  TlsFree function does not free memory blocks whose addresses have been stored in the TLS slots associated with the TLS index. It is expected that DLLs call this function (if at all) only during DLL_PROCESS_DETACH. For more information, see  Thread Local Storage. For an example, see  Using Thread Local Storage or  Using Thread Local Storage in a Dynamic-Link Library. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "TlsFree",
    "is_callback": 0,
    "dll": "KernelBase.dll on Windows Phone 8.1;  Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTlsIndex",
        "description": "The TLS index that was allocated by the  TlsAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is the value stored in the calling thread's TLS slot associated with the specified index. If dwTlsIndex is a valid index allocated by a successful call to TlsAlloc, this function always succeeds. If the function fails, the return value is zero. To get extended error information, call  GetLastError. The data stored in a TLS slot can have a value of 0 because it still has its initial value or because the thread called the TlsSetValue function with 0. Therefore, if the return value is 0, you must check whether GetLastError returns ERROR_SUCCESS before determining that the function has failed. If GetLastError returns ERROR_SUCCESS, then the function has succeeded and the data stored in the TLS slot is 0. Otherwise, the function has failed. Functions that return indications of failure call SetLastError     when they fail. They generally do not call SetLastError     when they succeed. The  TlsGetValue function is an exception to this general rule. The  TlsGetValue function calls SetLastError    to clear a thread's last error when it succeeds. That allows checking for the error-free retrieval of zero values. ",
    "remarks": "Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to FlsGetValue. Refer to FlsGetValue for function documentation. Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to FlsGetValue. Refer to FlsGetValue for function documentation. Windows 10, version 1511 and Windows 10, version 1607: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to FlsGetValue. TLS indexes are typically allocated by the  TlsAlloc function during process or DLL initialization. After a TLS index is allocated, each thread of the process can use it to access its own TLS slot for that index. A thread specifies a TLS index in a call to  TlsSetValue to store a value in its slot. The thread specifies the same index in a subsequent call to  TlsGetValue to retrieve the stored value. TlsGetValue was implemented with speed as the primary goal. The function performs minimal parameter validation and error checking. In particular, it succeeds if dwTlsIndex is in the range 0 through (TLS_MINIMUM_AVAILABLE\u00e2\u0080\u0093 1). It is up to the programmer to ensure that the index is valid and that the thread calls TlsSetValue before calling TlsGetValue. For an example, see  Using Thread Local Storage or  Using Thread Local Storage in a Dynamic-Link Library. ",
    "return_type": "LPVOID",
    "category": "Processes",
    "name": "TlsGetValue",
    "is_callback": 0,
    "dll": "KernelBase.dll on Windows Phone 8.1;  Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTlsIndex",
        "description": "The TLS index that was allocated by the  TlsAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Stores a value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to FlsSetValue. Refer to FlsSetValue for function documentation. Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to FlsSetValue. Refer to FlsSetValue for function documentation. Windows 10, version 1511 and Windows 10, version 1607: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to FlsSetValue. TLS indexes are typically allocated by the  TlsAlloc function during process or DLL initialization. When a TLS index is allocated, its storage slots are initialized to NULL. After a TLS index is allocated, each thread of the process can use it to access its own TLS slot for that index. A thread specifies a TLS index in a call to  TlsSetValue, to store a value in its slot. The thread specifies the same index in a subsequent call to  TlsGetValue, to retrieve the stored value. TlsSetValue was implemented with speed as the primary goal. The function performs minimal parameter validation and error checking. In particular, it succeeds if dwTlsIndex is in the range 0 through (TLS_MINIMUM_AVAILABLE \u00e2\u0080\u0093 1). It is up to the programmer to ensure that the index is valid before calling TlsGetValue. For an example, see  Using Thread Local Storage or  Using Thread Local Storage in a Dynamic-Link Library. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "TlsSetValue",
    "is_callback": 0,
    "dll": "KernelBase.dll on Windows Phone 8.1;  Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTlsIndex",
        "description": "The TLS index that was allocated by the TlsAlloc        function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpTlsValue",
        "description": "The value to be stored in the calling thread's TLS slot for the index."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Waits until the specified process has finished processing its initial input and is waiting for user input with no input pending, or until the time-out interval has elapsed.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "The following table shows the possible return values for this function.  ",
    "remarks": "The  WaitForInputIdle function enables a thread to suspend its execution until the specified process has finished its initialization and is waiting for user input with no input pending. If the process has multiple threads, the WaitForInputIdle function returns as soon as any thread becomes idle. WaitForInputIdle  can be used at any time, not just during application startup. However, WaitForInputIdle waits only once for a process to become idle; subsequent WaitForInputIdle calls return immediately, whether the process is idle or busy. WaitForInputIdle can be useful for synchronizing a parent process and a newly created child process. When a parent process creates a child process, the  CreateProcess function returns without waiting for the child process to finish its initialization. Before trying to communicate with the child process, the parent process can use  the WaitForInputIdle function to determine when the child's initialization has been completed. For example, the parent process should use  the WaitForInputIdle function before trying to find a window associated with the child process. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "WaitForInputIdle",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. If this process is a console application or does not have a message queue,  WaitForInputIdle returns immediately."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If dwMilliseconds is INFINITE, the function does not return until the process is idle."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes the specified list of attributes for process and thread creation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Processes",
    "name": "DeleteProcThreadAttributeList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPPROC_THREAD_ATTRIBUTE_LIST",
        "name": "lpAttributeList",
        "description": "The attribute list. This list is created by the InitializeProcThreadAttributeList function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Initializes the specified list of attributes for process and thread creation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "First, call this function with the dwAttributeCount parameter set to the maximum number of attributes you will be using and the lpAttributeList to NULL. The function returns the required buffer size in bytes in the lpSize parameter. Allocate enough space for the data in the lpAttributeList buffer and call the function again to initialize the buffer. To add attributes to the list, call the UpdateProcThreadAttribute function. To specify these attributes when creating a process, specify EXTENDED_STARTUPINFO_PRESENT in the dwCreationFlag parameter and a STARTUPINFOEX structure in the lpStartupInfo parameter. Note that you can specify the same STARTUPINFOEX structure to multiple child processes. When you have finished using the list, call the DeleteProcThreadAttributeList function. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "InitializeProcThreadAttributeList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_opt_",
        "type": "LPPROC_THREAD_ATTRIBUTE_LIST",
        "name": "lpAttributeList",
        "description": "The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAttributeCount",
        "description": "The count of attributes to be added to the list."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_Inout_",
        "type": "PSIZE_T",
        "name": "lpSize",
        "description": "If lpAttributeList is not NULL, this parameter specifies the size in bytes of the lpAttributeList buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.  If lpAttributeList is NULL, this parameter receives the required buffer size in bytes."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Updates the specified attribute in a list of attributes for process and thread creation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "An attribute list is an opaque structure that consists of a series of key/value pairs, one for each attribute. A process can update only the attribute keys described in this topic. The  DWORD or DWORD64 pointed to by lpValue can be one or more of the following values when you specify PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY for the Attribute parameter: The  DWORD or DWORD64 pointed to by lpValue can be one or more of the following values when you specify PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY for the Attribute parameter: The  DWORD pointed to by lpValue can be one or more of the following values when you specify PROC_THREAD_ATTRIBUTE_DESKTOP_APP_POLICY for the Attribute parameter: In order to launch the child process with the same protection level as the parent, the parent process must specify the PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL attribute for the child process. This can be used for both protected and unprotected processes. For example, when this flag is used by an unprotected process, the system will launch a child process at unprotected level. The CREATE_PROTECTED_PROCESS flag must be specified in both cases. The following example launches a child process with the same protection level as the parent process: ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "UpdateProcThreadAttribute",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPPROC_THREAD_ATTRIBUTE_LIST",
        "name": "lpAttributeList",
        "description": "A pointer to an attribute list created by the InitializeProcThreadAttributeList function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "DWORD_PTR",
        "name": "Attribute",
        "description": "The attribute key to update in the attribute list. This parameter can be one of the following values.  ValueMeaning  PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY   The lpValue parameter is a pointer to a GROUP_AFFINITY structure that specifies the processor group affinity for the new thread. Windows Server 2008 and Windows Vista:  This value is not supported until Windows 7 and Windows Server 2008 R2.   PROC_THREAD_ATTRIBUTE_HANDLE_LIST   The lpValue parameter is a pointer to a list of handles to be inherited by the child process. These handles must be created as inheritable handles and must not include pseudo handles such as those returned by the GetCurrentProcess or GetCurrentThread function. Note  if you use this attribute, pass in a value of TRUE for the bInheritHandles parameter of the CreateProcess function.     PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR   The lpValue parameter is a pointer to a  PROCESSOR_NUMBER structure that specifies the ideal processor for the new thread. Windows Server 2008 and Windows Vista:  This value is not supported until Windows 7 and Windows Server 2008 R2.   PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY   The lpValue parameter is a pointer to a DWORD or DWORD64 that specifies the exploit mitigation policy for the child process.  The specified policy overrides the policies set for the application and the system and cannot be changed after the child process starts running.   Windows Server 2008 and Windows Vista:  This value is not supported until Windows 7 and Windows Server 2008 R2. The  DWORD or DWORD64 pointed to by lpValue can be one or more of the values listed in the remarks.   PROC_THREAD_ATTRIBUTE_PARENT_PROCESS   The lpValue parameter is a pointer to a handle to a process to use instead of the calling process as the parent for the process being created. The process to use must have the PROCESS_CREATE_PROCESS access right. Attributes inherited from the specified process include handles, the device map, processor affinity, priority, quotas, the process token, and job object. (Note that some attributes such as the debug port will come from the creating process, not the process specified by this handle.)   PROC_THREAD_ATTRIBUTE_PREFERRED_NODE   The lpValue parameter is a pointer to the node number of the preferred NUMA node for the new process. Windows Server 2008 and Windows Vista:  This value is not supported until Windows 7 and Windows Server 2008 R2.   PROC_THREAD_ATTRIBUTE_UMS_THREAD   The lpValue parameter is a pointer to a UMS_CREATE_THREAD_ATTRIBUTES structure that specifies a user-mode scheduling (UMS) thread context and a UMS completion list to associate with the thread.  After the UMS thread is created, the system queues it to the specified completion list. The UMS thread runs only when an application's UMS scheduler retrieves the UMS thread from the completion list and selects it to run.  For more information, see User-Mode Scheduling. Windows Server 2008 and Windows Vista:  This value is not supported until Windows 7 and Windows Server 2008 R2.   PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES   The lpValue parameter is a pointer to a SECURITY_CAPABILITIES structure that defines the security capabilities of an app container. If this attribute is set the new process will be created as an AppContainer process. Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista:  This value is not supported until  Windows 8 and Windows Server 2012.   PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL   The lpValue parameter is a pointer to a DWORD value of PROTECTION_LEVEL_SAME. This specifies the protection level of the child process to be the same as the protection level of its parent process.   PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY   The lpValue parameter is a pointer to a DWORD or DWORD64 value that specifies the child process policy. THe policy specifies whether to allow a child process to be created. For information on the possible values for the  DWORD or DWORD64 to which lpValue points, see Remarks.   PROC_THREAD_ATTRIBUTE_DESKTOP_APP_POLICY   This attribute is relevant only to win32 applications that have been converted to UWP packages by using the Desktop Bridge.  The lpValue parameter is a pointer to a DWORD value that specifies the desktop app policy. The policy specifies whether descendant processes should continue to run in the desktop environment. For information about the possible values for the DWORD to which lpValue points, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpValue",
        "description": "A pointer to the attribute value. This value should persist until the attribute is destroyed using the DeleteProcThreadAttributeList function."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "cbSize",
        "description": "The size of the attribute value specified by the lpValue parameter."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "lpPreviousValue",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSIZE_T",
        "name": "lpReturnSize",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Determines whether the last message read from the current thread's queue originated from a WOW64 process.",
    "library": "User32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "The function returns TRUE if the last message read from the current thread's queue originated from a WOW64 process, and FALSE otherwise. ",
    "remarks": "This function  is useful to helping you develop 64-bit native applications that can receive private messages sent from  32-bit client applications, if the messages are associated with data structures that contain pointer-dependent data. In these situations, you can call this function in your 64-bit native application to determine if the message originated from a WOW64 process and then thunk the message appropriately. For compatibility with operating systems that do not support this function, call  GetProcAddress to detect whether  IsWow64Message is implemented in User32.dll. If GetProcAddress succeeds, it is safe to call this function. Otherwise, WOW64 is not present. Note that this technique is not a reliable way to detect whether the operating system is a 64-bit version of Windows because the User32.dll in current versions of 32-bit Windows also contains this function. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "IsWow64Message",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether the specified process is running under  WOW64.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Wow64apiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see  Using the Windows Headers. For compatibility with operating systems that do not support this function, call  GetProcAddress to detect whether  IsWow64Process is implemented in Kernel32.dll. If GetProcAddress succeeds, it is safe to call this function. Otherwise, WOW64 is not present. Note that this technique is not a reliable way to detect whether the operating system is a 64-bit version of Windows because the Kernel32.dll in current versions of 32-bit Windows also contains this function. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "IsWow64Process",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "Wow64Process",
        "description": "A pointer to a value that is set to TRUE if the process is running under WOW64. If the process is running under 32-bit Windows, the value is set to FALSE. If the process is a 64-bit application running under 64-bit Windows, the value is also set to FALSE."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Suspends the specified WOW64 thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the  GetLastError function. ",
    "remarks": "If the function succeeds, execution of the specified thread is suspended and the thread's suspend count is incremented. Suspending a thread causes the thread to stop executing user-mode (application) code. This function is primarily designed for use by debuggers. It is not intended to be used for thread synchronization. Calling  Wow64SuspendThread on a thread that owns a synchronization object, such as a mutex or critical section, can lead to a deadlock if the calling thread tries to obtain a synchronization object owned by a suspended thread. To avoid this situation, a thread within an application that is not a debugger should signal the other thread to suspend itself. The target thread must be designed to watch for this signal and respond appropriately. Each thread has a suspend count (with a maximum value of MAXIMUM_SUSPEND_COUNT). If the suspend count is greater than zero, the thread is suspended; otherwise, the thread is not suspended and is eligible for execution. Calling  Wow64SuspendThread causes the target thread's suspend count to be incremented. Attempting to increment past the maximum suspend count causes an error without incrementing the count. The  ResumeThread function decrements the suspend count of a suspended thread. This function is intended for 64-bit applications. It is not supported on 32-bit Windows; such calls fail and set the last error code to ERROR_INVALID_FUNCTION. A 32-bit application can call this function on a WOW64 thread; the result is the same as calling the SuspendThread function. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "Wow64SuspendThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread that is to be suspended.     The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see  Thread Security and Access Rights."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Assigns a process to an existing job object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "After you associate a process with a job object using  AssignProcessToJobObject, the process is subject to the limits set for the job. To set limits for a job, use the  SetInformationJobObject function. If the job has a user-mode time limit, and the time limit has been exhausted,  AssignProcessToJobObject fails and the specified process is terminated. If the time limit would be exceeded by associating the process,  AssignProcessToJobObject still succeeds. However, the time limit violation will be reported. If the job has an active process limit, and the limit would be exceeded by associating this process,  AssignProcessToJobObject fails, and the specified process is terminated. Memory operations performed by a process associated with a job that has a memory limit are subject to the memory limit. Memory operations performed by the process before it was associated with the job are not examined by  AssignProcessToJobObject. If the process is already running and the job has security limitations,  AssignProcessToJobObject may fail. For example, if the primary token of the process contains the local administrators group, but the job object has the security limitation JOB_OBJECT_SECURITY_NO_ADMIN, the function fails. If the job has the security limitation JOB_OBJECT_SECURITY_ONLY_TOKEN, the process must be created suspended. To create a suspended process, call the  CreateProcess function with the CREATE_SUSPENDED flag. A process can be associated with more than one job in a hierarchy of nested jobs. For priority class, affinity, commit charge, per-process execution time limit, scheduling class limit, and working set minimum and maximum, the process inherits an effective limit which is the most restrictive limit of all the jobs in its parent job chain. For other resource limits, the process inherits limits from its immediate job in the hierarchy. Accounting information is added to the  immediate job and aggregated in each parent job in the job chain. By default, all child processes are associated with the immediate job and every job in the parent job chain. To create a child process that is not part of the same job chain, call the CreateProcess function with the CREATE_BREAKAWAY_FROM_JOB flag. The child process breaks away from every job in the job chain unless a job in the chain does not allow breakaway. In this case, the child process does not break away from that job or any job above it in the job chain. For more information, see Nested Jobs. Windows 7, Windows Server 2008 R2, Windows XP with SP3, Windows Server 2008, Windows Vista and Windows Server 2003:  A process can be associated only with a single job. A process inherits limits from the job it is associated with and adds its accounting information to the job. If a process is associated with a job, all child processes it creates are associated with that job by default. To create a child process that is not part of the same job, call the  CreateProcess function with the CREATE_BREAKAWAY_FROM_JOB flag. A process can be associated with more than one job starting in Windows 8 and Windows Server 2012. Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista:  If the process is being monitored by the Program Compatibility Assistant (PCA), it is placed into a compatibility job. Therefore, the process must be created using CREATE_BREAKAWAY_FROM_JOB before it can be placed in another job. Alternatively, you can embed an application manifest that specifies a User Account Control (UAC) level in your application and PCA will not add the process to the compatibility job. For more information, see Application Development Requirements for User Account Control Compatibility. If the job or any of its parent jobs in the job chain is terminating when AssignProcessToJob is called, the function fails. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AssignProcessToJobObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hJob",
        "description": "A handle to the job object to which the process will be associated. The  CreateJobObject or  OpenJobObject function returns this handle. The handle must have the JOB_OBJECT_ASSIGN_PROCESS access right. For more information, see  Job Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process to associate with the job object. The handle must have the PROCESS_SET_QUOTA and PROCESS_TERMINATE access rights. For more information, see  Process Security and Access Rights. If the process is already associated with a job, the job specified by hJob must be empty or it must be in the hierarchy of nested jobs to which the process already belongs, and it cannot have UI limits set (SetInformationJobObject with JobObjectBasicUIRestrictions). For more information, see Remarks.  Windows 7, Windows Server 2008 R2, Windows XP with SP3, Windows Server 2008, Windows Vista and Windows Server 2003:  The process must not already be assigned to a job; if it is, the function fails with ERROR_ACCESS_DENIED. This behavior changed starting in Windows 8 and Windows Server 2012. Terminal Services:  All processes within a job must run within the same session as the job."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Creates or opens a job object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the job object. The handle has the JOB_OBJECT_ALL_ACCESS access right. If the object existed before the function call, the function returns a handle to the existing job object and  GetLastError returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "When a job is created, its accounting information is initialized to zero, all limits are inactive, and there are no associated processes. To assign a process to  a job object, use the  AssignProcessToJobObject function. To set limits for a job, use the  SetInformationJobObject function. To query accounting information, use the  QueryInformationJobObject function. All processes associated with a job must run in the same session. A job is associated with the session of the first process to be assigned to the job. Windows Server 2003 and Windows XP:  A job is associated with the session of the  process that created it. To close a job object handle, use the  CloseHandle function. The job is destroyed when its last handle has been closed and all associated processes have exited. However, if the job has the JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE flag specified, closing the last job object handle terminates all associated processes and then destroys the job object itself. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "CreateJobObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpJobAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If lpJobAttributes is NULL, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the job. The name is limited to MAX_PATH characters. Name comparison is case-sensitive.     If lpName is NULL, the job is created without a name. If lpName matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the  GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The object can be created in a private namespace. For more information, see Object Namespaces. Terminal Services:  The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Determines whether the process is running in the specified job.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Jobapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "An application cannot obtain a handle to the job object in which it is running unless it has the name of the job object. However, an application can call the QueryInformationJobObject function with NULL to obtain information about the job object. To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "IsProcessInJob",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process to be tested. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights. Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "JobHandle",
        "description": "A handle to the job. If this parameter is NULL, the function tests if the process is running under any job. If this parameter is not NULL, the handle must have the JOB_OBJECT_QUERY access right. For more information, see Job Object Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "Result",
        "description": "A pointer to a value that receives TRUE if the process is running in the job, and FALSE otherwise."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing job object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "To associate a process with a job, use the  AssignProcessToJobObject function. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "OpenJobObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the job object. This parameter can be one or more of the  job object access rights. This access right is checked against any security descriptor for the object."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandles",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the job to be opened. Name comparisons are case sensitive. This function can open objects in a private namespace. For more information, see Object Namespaces. Terminal Services:  The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves limit and job state information from the job object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Use  QueryInformationJobObject to obtain the current limits and modify them. Use the  SetInformationJobObject function to set new limits. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryInformationJobObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "hJob",
        "description": "A handle to the job whose information is being queried. The  CreateJobObject or  OpenJobObject function returns this handle. The handle must have the JOB_OBJECT_QUERY access right. For more information, see  Job Object Security and Access Rights.     If this value is NULL and the calling process is associated with a job, the job associated with the calling process is used. If the job is nested, the immediate job of the calling process is used."
      },
      {
        "in_out": "_In_",
        "type": "JOBOBJECTINFOCLASS",
        "name": "JobObjectInfoClass",
        "description": "The information class for the limits to be queried. This parameter can be one of the following values.  ValueMeaning  JobObjectBasicAccountingInformation 1   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_BASIC_ACCOUNTING_INFORMATION structure.   JobObjectBasicAndIoAccountingInformation 8   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION structure.   JobObjectBasicLimitInformation 2   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_BASIC_LIMIT_INFORMATION structure.   JobObjectBasicProcessIdList 3   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_BASIC_PROCESS_ID_LIST structure.   JobObjectBasicUIRestrictions 4   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_BASIC_UI_RESTRICTIONS structure.   JobObjectCpuRateControlInformation 15   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_CPU_RATE_CONTROL_INFORMATION structure.  Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectEndOfJobTimeInformation 6   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure.   JobObjectExtendedLimitInformation 9   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure.   JobObjectGroupInformation 11   The lpJobObjectInfo parameter is a pointer to a buffer that receives the list of  processor groups to which the job is currently assigned. The variable pointed to by the lpReturnLength parameter is set to the size of the group data. Divide this value by sizeof(USHORT) to determine the number of groups. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectGroupInformationEx 14   The lpJobObjectInfo parameter is a pointer to a buffer that receives an array of GROUP_AFFINITY structures that indicate the affinity of the job in the processor groups to which the job is currently assigned. The variable pointed to by the lpReturnLength parameter is set to the size of the group affinity data. Divide this value by sizeof(GROUP_AFFINITY) to determine the number of groups. Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectLimitViolationInformation 13   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_LIMIT_VIOLATION_INFORMATION structure.  Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectLimitViolationInformation2 35   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2          structure.          Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectNetRateControlInformation 32   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_NET_RATE_CONTROL_INFORMATION          structure.          Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectNotificationLimitInformation 12   The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION structure.  Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectNotificationLimitInformation2 34   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2          structure.          Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectSecurityLimitInformation 5   This flag is not supported. Applications must set security limits individually for each process. Windows Server 2003 and Windows XP:  The lpJobObjectInfo parameter is a pointer to a  JOBOBJECT_SECURITY_LIMIT_INFORMATION structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpJobObjectInfo",
        "description": "The limit or job state information. The format of this data depends on the value of the JobObjectInfoClass parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbJobObjectInfoLength",
        "description": "The count of the job information being queried, in bytes. This value depends on the value of the JobObjectInfoClass parameter."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpReturnLength",
        "description": "A pointer to a variable that receives the length of data written to the structure pointed to by the lpJobObjectInfo parameter. Specify NULL  to not receive this information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets limits for a job object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Use the SetInformationJobObject      function to set several limits in a single call. To establish the limits one at a time or change a      subset of the limits, call the      QueryInformationJobObject function to obtain      the current limits, modify these limits, and then call      SetInformationJobObject. You must set security limits individually for each process associated with a job object, rather than setting      them for the job object itself. For information, see      Process Security and Access Rights. Windows Server 2003 and Windows XP:  Use the SetInformationJobObject        function to set security limits for the job object. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more      information, see      Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetInformationJobObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hJob",
        "description": "A handle to the job whose limits are being set. The        CreateJobObject or        OpenJobObject function returns this handle. The handle        must have the JOB_OBJECT_SET_ATTRIBUTES access right. For more information, see        Job Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "JOBOBJECTINFOCLASS",
        "name": "JobObjectInfoClass",
        "description": "The information class for the limits to be set. This parameter can be one of the following values.  ValueMeaning  JobObjectAssociateCompletionPortInformation 7   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_ASSOCIATE_COMPLETION_PORT          structure.   JobObjectBasicLimitInformation 2   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_BASIC_LIMIT_INFORMATION          structure.   JobObjectBasicUIRestrictions 4   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_BASIC_UI_RESTRICTIONS          structure.   JobObjectCpuRateControlInformation 15   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_CPU_RATE_CONTROL_INFORMATION          structure.          Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectEndOfJobTimeInformation 6   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_END_OF_JOB_TIME_INFORMATION          structure.   JobObjectExtendedLimitInformation 9   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_EXTENDED_LIMIT_INFORMATION          structure.   JobObjectGroupInformation 11   The lpJobObjectInfo parameter is a pointer to a          USHORT value that specifies the list of          processor groups to assign the job to. The          cbJobObjectInfoLength parameter is set to the size of the group data. Divide this          value by sizeof(USHORT) to determine the number of groups.          Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectGroupInformationEx 14   The lpJobObjectInfo parameter is a pointer to a buffer that contains an array          of GROUP_AFFINITY structures that specify the          affinity of the job for the processor groups to which          the job is currently assigned. The cbJobObjectInfoLength parameter is set to the          size of the group affinity data. Divide this value by          sizeof(GROUP_AFFINITY) to determine the number of groups.          Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectLimitViolationInformation2 35   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2          structure.          Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectNetRateControlInformation 32   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_NET_RATE_CONTROL_INFORMATION          structure.          Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectNotificationLimitInformation 12   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION          structure.          Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectNotificationLimitInformation2 34   The lpJobObjectInfo parameter is a pointer to a          JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2          structure.          Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This flag is not supported.   JobObjectSecurityLimitInformation 5   This flag is not supported. Applications must set security limitations individually for each process.          Windows Server 2003 and Windows XP:  The lpJobObjectInfo parameter is a pointer to a            JOBOBJECT_SECURITY_LIMIT_INFORMATION            structure. The            hJob handle must have the            JOB_OBJECT_SET_SECURITY_ATTRIBUTES access right associated with it."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpJobObjectInfo",
        "description": "The limits or job state to be set for the job. The format of this data depends on the value of JobObjectInfoClass."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbJobObjectInfoLength",
        "description": "The size of the job information being set, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Terminates all processes currently associated with the job.  If the job is nested, this function terminates all processes currently associated with the job and all of its child jobs in the hierarchy.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "It is not possible for any of the processes associated with the job to postpone or handle the termination. It is as if  TerminateProcess were called for each process associated with the job. Terminating a nested job additionally terminates all child job objects. Resources used by the terminated jobs are charged up the parent job chain in the hierarchy. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "TerminateJobObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hJob",
        "description": "A handle to the job whose processes will be terminated. The  CreateJobObject or  OpenJobObject function returns this handle. This handle must have the JOB_OBJECT_TERMINATE access right. For more information, see  Job Object Security and Access Rights. The handle for each process in the job object must have the PROCESS_TERMINATE access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uExitCode",
        "description": "The exit code to be used by all processes and threads in the job object. Use the  GetExitCodeProcess function to retrieve each process's exit value. Use the  GetExitCodeThread function to retrieve each thread's exit value."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Grants or denies access to a handle to a User object to a job that has a user-interface restriction. When access is granted, all processes associated with the job can subsequently recognize and use the handle. When access is denied, the processes can no longer use the handle. For more information see  User Objects.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  UserHandleGrantAccess function can be called only from a process not associated with the job specified by the hJob parameter. The User handle must not be owned by a process or thread associated with the job. To create user-interface restrictions, call the  SetInformationJobObject function with the JobObjectBasicUIRestrictions job information class. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "UserHandleGrantAccess",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hUserHandle",
        "description": "A handle to the User object."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hJob",
        "description": "A handle to the job to be granted access to the User handle. The  CreateJobObject or  OpenJobObject function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bGrant",
        "description": "If this parameter is TRUE, all processes associated with the job can recognize and use the handle. If the parameter is FALSE, the processes cannot use the handle."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates that the callback may not return quickly.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "The function returns TRUE if another thread in the thread pool is available for processing callbacks or the thread pool was able to spin up a new thread.  In this case, the current callback function may use the current thread indefinitely. The function returns FALSE if another thread in the thread pool is not available to process callbacks and the thread pool was not able to spin up a new thread.  The thread pool will attempt to spin up a new thread after a delay, but if the current callback function runs long, the thread pool may lose efficiency. ",
    "remarks": "The thread pool may use this information to better determine when a new thread should be created. The CallbackMayRunLong function should be called only by the thread that is processing the callback. Calling this function from another thread may cause a race condition. The CallbackMayRunLong function always marks the callback as long-running, whether or not a thread is available for processing callbacks or the threadpool is able to allocate a new thread. Therefore, this function should be called only once, even if it returns FALSE. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "CallbackMayRunLong",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Cancels the notification from the StartThreadpoolIo function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To prevent memory leaks, you must call the CancelThreadpoolIo function for either of the following scenarios: To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CancelThreadpoolIo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_IO",
        "name": "pio",
        "description": "A TP_IO structure that defines the I/O completion object. The CreateThreadpoolIo function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Notifies the thread pool that I/O operations may possibly begin for the specified I/O completion object. A worker thread calls the I/O completion object's callback function after the operation completes on the file handle bound to this object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "You must call this function before initiating each asynchronous I/O operation on the file handle bound to the I/O completion object. Failure to do so will cause the thread pool to ignore an I/O operation when it completes and will cause memory corruption. If the I/O operation fails, call the CancelThreadpoolIo function to cancel this notification. If the file handle bound to the I/O completion object has the notification mode FILE_SKIP_COMPLETION_PORT_ON_SUCCESS and an asynchronous I/O operation returns immediately with success, the object's I/O completion callback function is not called and threadpool I/O notifications must be canceled. For more information, see  CancelThreadpoolIo. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "StartThreadpoolIo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_IO",
        "name": "pio",
        "description": "A TP_IO structure that defines the I/O completion object. The CreateThreadpoolIo function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Closes the specified thread pool.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h);  WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The thread pool is closed immediately if there are no outstanding work, I/O, timer, or wait objects that are bound to the pool; otherwise, the thread pool is released asynchronously after the outstanding objects are freed. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpool",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_POOL",
        "name": "ptpp",
        "description": "A TP_POOL structure that defines the thread pool. The CreateThreadpool function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Closes the specified cleanup group.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The cleanup group must have no members when you call this function. For information on removing members of the group, see CloseThreadpoolCleanupGroupMembers. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpoolCleanupGroup",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CLEANUP_GROUP",
        "name": "ptpcg",
        "description": "A TP_CLEANUP_GROUP structure that defines the cleanup group. The CreateThreadpoolCleanupGroup returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Releases the members of the specified cleanup group, waits for all callback functions to complete, and optionally cancels any outstanding callback functions.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h);  WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The CloseThreadpoolCleanupGroupMembers function simplifies cleanup of thread pool callback objects by releasing, in a single operation, all work objects, wait objects, and timer objects that are members of the cleanup group. An object becomes a member of a cleanup group when the object is created with the threadpool callback environment that was specified when the cleanup group was created. For more information, see CreateThreadpoolCleanupGroup. The CloseThreadpoolCleanupGroupMembers function blocks until all currently executing callback functions finish. If fCancelPendingCallbacks is TRUE, outstanding callbacks are canceled; otherwise, the function blocks until all outstanding callbacks also finish.  After the CloseThreadpoolCleanupGroupMembers function returns, an application should not use any object that was a member of the cleanup group at the time CloseThreadpoolCleanupGroupMembers was called.  Also, an application should not release any of the objects individually by calling a function such as CloseThreadpoolWork, because the objects have already been released. The CloseThreadpoolCleanupGroupMembers function does not close the cleanup group itself. Instead, the cleanup group persists until the CloseThreadpoolCleanupGroup function is called. Also, closing a cleanup group does not affect the associated threadpool callback environment. The callback environment persists until it is destroyed by calling DestroyThreadpoolEnvironment. As long as a cleanup group persists, new objects created with the cleanup group's associated threadpool callback environment are added to the cleanup group. This allows an application to reuse the cleanup group. However, it can lead to errors if the application does not synchronize code that calls CloseThreadpoolCleanupGroupMembers with code that creates new objects. For example, suppose a thread creates two threadpool work objects, Work1 and Work2. Another thread calls CloseThreadpoolCleanupGroupMembers. Depending on when the threads run, any of the following might occur: To simply wait for or cancel pending work items without releasing them, use one of the threadpool callback functions: WaitForThreadpoolIoCallbacks, WaitForThreadpoolTimerCallbacks, WaitForThreadpoolWaitCallbacks, or WaitForThreadpoolWorkCallbacks. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpoolCleanupGroupMembers",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CLEANUP_GROUP",
        "name": "ptpcg",
        "description": "A TP_CLEANUP_GROUP structure that defines the cleanup group. The CreateThreadpoolCleanupGroup function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fCancelPendingCallbacks",
        "description": "If this parameter is TRUE, the function cancels outstanding callbacks that have not yet started. If this parameter is FALSE, the function waits for outstanding callback functions to complete."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "pvCleanupContext",
        "description": "The application-defined data to pass to the application's cleanup group callback function. You can specify the callback function when you call SetThreadpoolCallbackCleanupGroup."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases the specified I/O completion object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The I/O completion object is freed immediately if there are no outstanding callbacks; otherwise, the I/O completion object is freed asynchronously after the outstanding callbacks complete. You should close the associated file handle and wait for all outstanding overlapped I/O operations to complete before calling this function\u00e2\u0080\u0094you must not cause any more overlapped I/O operations to occur after calling this function. It may be necessary to cancel threadpool I/O notifications to prevent memory leaks. For more information, see CancelThreadpoolIo. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpoolIo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_IO",
        "name": "pio",
        "description": "A TP_IO structure that defines the I/O completion object. The CreateThreadpoolIo function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases the specified timer object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The timer object is freed immediately if there are no outstanding callbacks; otherwise, the timer object is freed asynchronously after the outstanding callback functions complete. In some cases, callback functions might run after CloseThreadpoolTimer has been called. To prevent this behavior: If there is a cleanup group associated with the timer object, it is not necessary to call this function; calling the CloseThreadpoolCleanupGroupMembers function releases the  work, wait, and timer objects associated with the cleanup group. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpoolTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_TIMER",
        "name": "pti",
        "description": "A TP_TIMER structure that defines the timer object. The CreateThreadpoolTimer function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases the specified wait object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The wait object is freed immediately if there are no outstanding callbacks; otherwise, the timer object is freed asynchronously after the outstanding callbacks complete. If there is a cleanup group associated with the wait object, it is not necessary to call this function; calling the CloseThreadpoolCleanupGroupMembers function releases the  work, wait, and timer objects associated with the cleanup group. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpoolWait",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WAIT",
        "name": "pwa",
        "description": "A TP_WAIT structure that defines the wait object. The CreateThreadpoolWait function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases the specified work object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The work object is freed immediately if there are no outstanding callbacks; otherwise, the work object is freed asynchronously after the outstanding callbacks complete. If there is a cleanup group associated with the work object, it is not necessary to call this function; calling the CloseThreadpoolCleanupGroupMembers function releases the  work, wait, and timer objects associated with the cleanup group. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "CloseThreadpoolWork",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WORK",
        "name": "pwk",
        "description": "A TP_WORK structure that defines the work object. The CreateThreadpoolWork function returns this  structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Allocates a new pool of threads to execute callbacks.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns a TP_POOL structure representing the newly allocated thread pool. Applications do not modify the members of this structure. If function fails, it returns NULL. To retrieve extended error information, call GetLastError. ",
    "remarks": "After creating the new thread pool, you should call SetThreadpoolThreadMaximum to specify the maximum number of threads that the pool can allocate and SetThreadpoolThreadMinimum to specify the minimum number of threads available in the pool. To use the pool, you must associate the pool with a callback environment. To create the callback environment, call InitializeThreadpoolEnvironment. Then, call SetThreadpoolCallbackPool to associate the pool with the callback environment. To release the thread pool, call CloseThreadpool. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "PTP_POOL",
    "category": "Processes",
    "name": "CreateThreadpool",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Reserved_",
        "type": "PVOID",
        "name": "reserved",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Creates a cleanup group that applications can use to track one or more thread pool callbacks.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns a TP_CLEANUP_GROUP structure of the newly allocated cleanup group. Applications do not modify the members of this structure. If function fails, it returns NULL. To retrieve extended error information, call GetLastError. ",
    "remarks": "After creating the cleanup group, call SetThreadpoolCallbackCleanupGroup to associate the cleanup group with a callback environment. A member is added to the group each time you call one of the following functions: You use one of the following corresponding close functions to remove a member from the group. To close all the callbacks, call CloseThreadpoolCleanupGroupMembers. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "PTP_CLEANUP_GROUP",
    "category": "Processes",
    "name": "CreateThreadpoolCleanupGroup",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Creates a new I/O completion object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns a TP_IO structure that defines the I/O object. Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve extended error information, call GetLastError. ",
    "remarks": "To begin receiving overlapped I/O completion callbacks, call the StartThreadpoolIo function. If the file handle bound to the I/O completion object has the notification mode FILE_SKIP_COMPLETION_PORT_ON_SUCCESS and an asychronous I/O operation returns immediately with success, the I/O completion callback function is not called and threadpool I/O notifications must be canceled. For more information, see CancelThreadpoolIo. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "PTP_IO",
    "category": "Processes",
    "name": "CreateThreadpoolIo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "fl",
        "description": "The file handle to bind to this I/O completion object."
      },
      {
        "in_out": "_In_",
        "type": "PTP_WIN32_IO_CALLBACK",
        "name": "pfnio",
        "description": "The callback function to be called each time  an overlapped I/O operation completes on the file. For details, see IoCompletionCallback."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "pv",
        "description": "Optional application-defined data to pass to the callback function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the environment in which to execute the callback. The InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes in the default callback environment. For more information, see InitializeThreadpoolEnvironment."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a new timer object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns a TP_TIMER structure that defines the timer object. Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve extended error information, call GetLastError. ",
    "remarks": "To set the timer object, call the SetThreadpoolTimer function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "PTP_TIMER",
    "category": "Processes",
    "name": "CreateThreadpoolTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTP_TIMER_CALLBACK",
        "name": "pfnti",
        "description": "The callback function to call each time the timer object expires. For details, see TimerCallback."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "pv",
        "description": "Optional application-defined data to pass to the callback function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the environment in which to execute the callback. The InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes in the default callback environment. For more information, see InitializeThreadpoolEnvironment."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a new wait object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns a TP_WAIT structure that defines the wait object. Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve extended error information, call GetLastError. ",
    "remarks": "To set the wait object, call the SetThreadpoolWait function. The work item and all functions it calls must be thread-pool safe. Therefore, you cannot call an asynchronous call that requires a persistent thread, such as the  RegNotifyChangeKeyValue function, from the default callback environment. Instead, set the thread pool maximum equal to the thread pool minimum using the SetThreadpoolThreadMaximum and SetThreadpoolThreadMinimum functions, or create your own thread using the CreateThread function. Windows 8:  RegNotifyChangeKeyValue can be called from a work item by setting the REG_NOTIFY_THREAD_AGNOSTIC flag. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "PTP_WAIT",
    "category": "Processes",
    "name": "CreateThreadpoolWait",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTP_WAIT_CALLBACK",
        "name": "pfnwa",
        "description": "The callback function to call when the wait completes or times out. For details, see WaitCallback."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "pv",
        "description": "Optional application-defined data to pass to the callback function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the environment in which to execute the callback. The InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes in the default callback environment. For more information, see InitializeThreadpoolEnvironment."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a new work object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a TP_WORK structure that defines the work object. Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve extended error information, call GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "PTP_WORK",
    "category": "Processes",
    "name": "CreateThreadpoolWork",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTP_WORK_CALLBACK",
        "name": "pfnwk",
        "description": "The callback function. A worker thread calls this callback each time you call SubmitThreadpoolWork to post the work object. For details, see WorkCallback."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "pv",
        "description": "Optional application-defined data to pass to the callback function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the  environment in which to execute the callback. The InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes in the default callback environment. For more information, see InitializeThreadpoolEnvironment."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes the specified callback environment. Call this function when the callback environment is no longer needed for creating new thread pool objects.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "DestroyThreadpoolEnvironment",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Removes the association between the currently executing callback function and the object that initiated the callback.  The current thread will no longer count as executing a callback on behalf of the object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "If this is the last thread executing a callback on behalf of the object, any threads waiting for the object's callbacks to complete will be released. The thread remains associated with the object's cleanup group until the thread returns to the thread pool. This lets DLL shutdown routines safely synchronize with outstanding callbacks and proceed with unloading the DLL's code when all callbacks have completed. The callback-generating object remains valid for the duration of the callback. The callback object may be reused or released (although synchronization with cleanup group release is still required). To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "DisassociateCurrentThreadFromCallback",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Specifies the DLL  that the thread pool will unload when the current callback completes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "FreeLibraryWhenCallbackReturns",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "HMODULE",
        "name": "mod",
        "description": "A handle to the DLL."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes a callback environment.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "By default, a callback executes in the default thread pool for the process. No cleanup group is associated with the callback environment, the caller is responsible for keeping the callback's DLL loaded while there are outstanding callbacks, and the callback is expected to run in a reasonable amount of time for the application. Create a callback environment if you plan to call one of the following functions to modify the environment: To use the default callback environment, set the optional callback environment parameter to NULL when calling one of the following functions: The InitializeThreadpoolEnvironment function is implemented as an inline function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "InitializeThreadpoolEnvironment",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines a callback environment."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether the specified timer object is currently set.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "The return value is TRUE if the timer is set; otherwise, the return value is FALSE. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "IsThreadpoolTimerSet",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_TIMER",
        "name": "pti",
        "description": "A TP_TIMER structure that defines the timer object. The CreateThreadpoolTimer function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Specifies the critical section that the thread pool will release when the current callback completes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "LeaveCriticalSectionWhenCallbackReturns",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      },
      {
        "in_out": "_Inout_",
        "type": "PCRITICAL_SECTION",
        "name": "pcs",
        "description": "The critical section."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the stack reserve and commit sizes for threads in the specified thread pool.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT to _WIN32_WINNT_WIN7. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryThreadpoolStackInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTP_POOL",
        "name": "ptpp",
        "description": "A TP_POOL structure that specifies the thread pool. The CreateThreadpool function returns this structure."
      },
      {
        "in_out": "_Out_",
        "type": "PTP_POOL_STACK_INFORMATION",
        "name": "ptpsi",
        "description": "A TP_POOL_STACK_INFORMATION structure that receives the stack reserve and commit size."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Specifies the mutex that the thread pool will release when the current callback completes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "ReleaseMutexWhenCallbackReturns",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "mut",
        "description": "A handle to the mutex."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Specifies the semaphore that the thread pool will release when the current callback completes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "ReleaseSemaphoreWhenCallbackReturns",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "sem",
        "description": "A handle to the semaphore."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "crel",
        "description": "The amount by which to increment the semaphore object's count."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Specifies the event that the thread pool will set when the current callback completes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetEventWhenCallbackReturns",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_INSTANCE",
        "name": "pci",
        "description": "A TP_CALLBACK_INSTANCE structure that defines the callback instance. The structure is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "evt",
        "description": "A handle to the event to be set."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Associates the specified cleanup group with the specified callback environment.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolCallbackCleanupGroup",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PTP_CLEANUP_GROUP",
        "name": "ptpcg",
        "description": "A TP_CLEANUP_GROUP structure that defines the cleanup group. The CreateThreadpoolCleanupGroup function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CLEANUP_GROUP_CANCEL_CALLBACK",
        "name": "pfng",
        "description": "The cleanup callback to be called if the cleanup group is canceled before the associated object is released. The function is called when you call CloseThreadpoolCleanupGroupMembers."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Ensures that the specified DLL remains loaded as long as there are outstanding callbacks.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "You should call this function if a callback might acquire the loader lock. This prevents a deadlock from occurring when one thread in DllMain is waiting for the callback to end, and another thread that is executing the callback attempts to acquire the loader lock. If the DLL containing the callback might be unloaded, the cleanup code in DllMain must cancel outstanding callbacks before releasing the object. Managing callbacks created with a TP_CALLBACK_ENVIRON that specifies a callback library is somewhat processing-intensive.  You should consider other options for ensuring that the library is not unloaded while callbacks are executing, or to guarantee that callbacks which may be executing do not acquire the loader lock. The thread pool assumes ownership of the library reference supplied to this function.  The caller should not call FreeLibrary on a module handle after passing it to this function. This function is implemented as an inline function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolCallbackLibrary",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "mod",
        "description": "A handle to the DLL."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Specifies that the callback should run on a persistent thread.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. To compile an application that uses this function, set _WIN32_WINNT to _WIN32_WINNT_WIN7. For more information, see Using the Windows Headers. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolCallbackPersistent",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the thread pool to be used when generating callbacks.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "If you do not specify a thread pool, the global thread pool is used. This function is implemented as an inline function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolCallbackPool",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PTP_POOL",
        "name": "ptpp",
        "description": "A TP_POOL structure that defines the thread pool. The CreateThreadpool function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Specifies the priority of a callback function relative to other work items in the same thread pool.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Higher priority callbacks are guaranteed to be run first by the first available worker thread, but they are not guaranteed to finish before lower priority callbacks. This function is implemented as an inline function. To compile an application that uses this function, set _WIN32_WINNT >= _WIN32_WINNT_WIN7. For more information, see Using the Windows Headers. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolCallbackPriority",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "TP_CALLBACK_PRIORITY",
        "name": "Priority",
        "description": "The priority for the callback relative to other callbacks in the same thread pool. This parameter can be one of the following TP_CALLBACK_PRIORITY enumeration values:  ValueMeaning  TP_CALLBACK_PRIORITY_HIGH   The callback should run at high priority.    TP_CALLBACK_PRIORITY_LOW   The callback should run at low priority.   TP_CALLBACK_PRIORITY_NORMAL   The callback should run at normal priority."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates that callbacks associated with this callback environment may not return quickly.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The thread pool may use this information to better determine when a new thread should be created. This function is implemented as an inline function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolCallbackRunsLong",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the stack reserve and commit sizes for new threads in the specified thread pool. Stack reserve and commit sizes for existing threads are not changed.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT to _WIN32_WINNT_WIN7. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadpoolStackInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_POOL",
        "name": "ptpp",
        "description": "A TP_POOL structure that specifies the thread pool. The CreateThreadpool function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PTP_POOL_STACK_INFORMATION",
        "name": "ptpsi",
        "description": "A TP_POOL_STACK_INFORMATION structure that specifies the stack reserve and commit size for threads in the pool."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the maximum number of threads that the specified thread pool can allocate to process callbacks.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "To specify the minimum number of threads available in the pool, call SetThreadpoolThreadMinimum. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolThreadMaximum",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_POOL",
        "name": "ptpp",
        "description": "A TP_POOL structure that defines the thread pool. The CreateThreadpool function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cthrdMost",
        "description": "The maximum number of threads."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the minimum number of threads that the specified thread pool must make available to process callbacks.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve extended error information, call GetLastError. ",
    "remarks": "To specify the maximum number of threads that  the pool may allocate, call SetThreadpoolThreadMaximum. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadpoolThreadMinimum",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_POOL",
        "name": "ptpp",
        "description": "A TP_POOL structure that defines the thread pool. The CreateThreadpool function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cthrdMic",
        "description": "The minimum number of threads."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Sets the timer object\u00e2\u0080\u0094, replacing the previous timer, if any. A worker thread calls the timer object's callback after the specified timeout expires.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Threadpoolapiset.h",
    "return_value": "If the timer was previously active and was canceled, a value of TRUE is     returned. Otherwise a value of FALSE is returned.      If FALSE is returned, a callback may be in progress or about to commence.     If this is the case, a subsequent SetThreadpoolTimerEx operation will be properly     synchronized with completion of the timer callback. ",
    "remarks": "Setting the timer cancels the previous timer, if any. In some cases, callback functions might run after an application closes the threadpool timer. To prevent this behavior, an application should call SetThreadpoolTimerEx with the pftDueTime parameter set to NULL and the msPeriod and msWindowLength parameters set to 0. For more information, see CloseThreadpoolTimer. If the due time specified by pftDueTime is relative, the time that the system spends in sleep or hibernation does not count toward the expiration of the timer. The timer is signaled when the cumulative amount of elapsed time the system spends in the waking state equals the timer's relative due time or period. If the  due time specified by pftDueTime is absolute, the time that the system spends in sleep or hibernation does count toward the expiration of the timer. If the timer expires while the system is sleeping, the timer is signaled immediately when the system wakes. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadpoolTimerEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_TIMER",
        "name": "pti",
        "description": "A pointer to a TP_TIMER structure that defines the timer object to set. The CreateThreadpoolTimer function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PFILETIME",
        "name": "pftDueTime",
        "description": "A pointer to a FILETIME structure that specifies the absolute or relative time at which the timer should expire.  If positive or zero, it indicates the absolute time since January 1, 1601 (UTC), measured in 100 nanosecond units. If negative, it indicates the amount of time to wait relative to the current time. For more information about time values, see File Times. If this parameter is NULL, the timer object will cease to queue new callbacks (but callbacks already queued will still occur). Note that if this parameter is zero, the timer will expire immediately."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "msPeriod",
        "description": "The timer period, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "msWindowLength",
        "description": "The maximum amount of time the system can delay before calling the timer callback. If this parameter is set, the system can batch calls to conserve power."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Sets the timer object\u00e2\u0080\u0094, replacing the previous timer, if any. A worker thread calls the timer object's callback after the specified timeout expires.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "Setting the timer cancels the previous timer, if any. In some cases, callback functions might run after an application closes the threadpool timer. To prevent this behavior, an application should call SetThreadpoolTimer with the pftDueTime parameter set to NULL and the msPeriod and msWindowLength parameters set to 0. For more information, see CloseThreadpoolTimer. If the due time specified by pftDueTime is relative, the time that the system spends in sleep or hibernation does not count toward the expiration of the timer. The timer is signaled when the cumulative amount of elapsed time the system spends in the waking state equals the timer's relative due time or period. If the  due time specified by pftDueTime is absolute, the time that the system spends in sleep or hibernation does count toward the expiration of the timer. If the timer expires while the system is sleeping, the timer is signaled immediately when the system wakes. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_TIMER",
        "name": "pti",
        "description": "A pointer to a TP_TIMER structure that defines the timer object to set. The CreateThreadpoolTimer function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PFILETIME",
        "name": "pftDueTime",
        "description": "A pointer to a FILETIME structure that specifies the absolute or relative time at which the timer should expire.  If positive or zero, it indicates the absolute time since January 1, 1601 (UTC), measured in 100 nanosecond units. If negative, it indicates the amount of time to wait relative to the current time. For more information about time values, see File Times. If this parameter is NULL, the timer object will cease to queue new callbacks (but callbacks already queued will still occur). Note that if this parameter is zero, the timer will expire immediately."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "msPeriod",
        "description": "The timer period, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "msWindowLength",
        "description": "The maximum amount of time the system can delay before calling the timer callback. If this parameter is set, the system can batch calls to conserve power."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Sets the wait object\u00e2\u0080\u0094replacing the previous wait object, if any. A worker thread calls the wait object's callback function after the  handle becomes signaled or after the specified timeout expires.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "A wait object can wait for only one handle. Setting the handle for a wait object replaces the previous handle, if any. You must re-register the event with the wait object  before signaling it each time to trigger the wait callback. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SetThreadpoolWait",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WAIT",
        "name": "pwa",
        "description": "A pointer to a TP_WAIT structure that defines the wait object. The CreateThreadpoolWait function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "h",
        "description": "A handle. If this parameter is NULL, the wait object will cease to queue new callbacks (but callbacks already queued will still occur). If this parameter is not NULL, it must refer to a valid waitable object. If this handle is closed while the wait is still pending, the function's behavior is undefined. If the wait is still pending and the handle must be closed, use CloseThreadpoolWait to cancel the wait and then close the handle."
      },
      {
        "in_out": "_In_opt_",
        "type": "PFILETIME",
        "name": "pftTimeout",
        "description": "A pointer to a FILETIME structure that specifies the absolute or relative time at which the wait operation should time out.  If this parameter points to a positive value, it indicates the absolute time since January 1, 1601 (UTC), in 100-nanosecond intervals. If this parameter points to a negative value, it indicates the amount of time to wait relative to the current time. For more information about time values, see File Times. If this parameter points to 0, the wait times out immediately. If this parameter is NULL, the wait will not time out."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Sets the wait object\u00e2\u0080\u0094replacing the previous wait object, if any. A worker thread calls the wait object's callback function after the handle becomes signaled or after the specified timeout expires.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Threadpoolapiset.h",
    "return_value": "TRUE, if the timer was previously active and was canceled; otherwise, FALSE. This return value can be used to maintain reference counts to synchronize between completion and cancellation of a non-periodic timer operation. If FALSE is returned, a callback may be in progress or about to commence. If FALSE is returned, a subsequent WaitForThreadpool or WaitForThreadpoolEx Callback operation will complete after that callback is completed. A subsequent SetThreadpool or SetThreadpoolEx operation that is not later canceled will result in an additional callback.\u00e2\u0080\u009d ",
    "remarks": "A wait object can wait for only one handle. Setting the handle for a wait object replaces the previous wait handle, if any. In some cases, callback functions might run after an application closes the threadpool timer. To prevent this behavior, an application should call SetThreadpoolTimer or SetThreadpoolTimerEx with the pftDueTime parameter set to NULL and the msPeriod and msWindowLength parameters set to 0. For more information, see CloseThreadpoolTimer. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetThreadpoolWaitEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WAIT",
        "name": "pwa",
        "description": "A pointer to a TP_WAIT structure that defines the wait object. The CreateThreadpoolWait function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "h",
        "description": "A handle.   If this parameter is NULL, the wait object will cease to queue new callbacks (but callbacks already queued will still occur).   If this parameter is not NULL, it must refer to a valid waitable object. If this handle is closed while the wait is still pending, the function's behavior is undefined. If the wait is still pending and the handle must be closed, use CloseThreadpoolWait to cancel the wait and then close the handle."
      },
      {
        "in_out": "_In_opt_",
        "type": "PFILETIME",
        "name": "pftTimeout",
        "description": "A pointer to a FILETIME structure that specifies the absolute or relative time at which the wait operation should time out.  If this parameter points to a positive value, it indicates the absolute time since January 1, 1601 (UTC), in 100-nanosecond intervals. If this parameter points to a negative value, it indicates the amount of time to wait relative to the current time. For more information about time values, see File Times."
      },
      {
        "in_out": "_Reserved_",
        "type": "PVOID",
        "name": "Reserved",
        "description": "Reserved."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Posts a work object to the thread pool. A worker thread calls the work object's callback function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "You can post a work object one or more times (up to MAXULONG) without waiting for prior callbacks to complete.  The callbacks will execute in parallel. To improve efficiency, the thread pool may throttle the threads. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SubmitThreadpoolWork",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WORK",
        "name": "pwk",
        "description": "A TP_WORK structure that defines the work object. The CreateThreadpoolWork function returns this structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes a callback environment for the thread pool.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The thread pool callback environment is subject to default behaviors that can be changed. For example, callbacks execute in the global pool by default, but a different thread pool can be specified using TpSetCallbackThreadpool. Thread pool callback environment behavior can be changed with the following functions: Call TpInitializeCallbackEnviron to create a callback environment that can be modified. Call TpDestroyCallbackEnviron to destroy the callback environment. This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpInitializeCallbackEnviron",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. Allocate space for this structure and initialize it using this function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Deletes the specified callback environment. Call this function when the callback environment is no longer needed for creating new thread pool objects.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpDestroyCallbackEnviron",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Assigns an activation context to the callback environment.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackActivationContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "struct _ACTIVATION_CONTEXT*",
        "name": "ActivationContext",
        "description": "Pointer to an _ACTIVATION_CONTEXT structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Associates the specified cleanup group with the specified callback environment.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackCleanupGroup",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PTP_CLEANUP_GROUP",
        "name": "CleanupGroup",
        "description": "A TP_CLEANUP_GROUP structure that defines the cleanup group. The CreateThreadpoolCleanupGroup function returns this structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CLEANUP_GROUP_CANCEL_CALLBACK",
        "name": "CleanupGroupCancelCallback",
        "description": "The cleanup callback to be called if the cleanup group is canceled before the associated object is released. The function is called when you call CloseThreadpoolCleanupGroupMembers."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Indicates a function to call when the callback environment is finalized.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackFinalizationCallback",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PTP_SIMPLE_CALLBACK",
        "name": "FinalizationCallback",
        "description": "Pointer to a TP_SIMPLE_CALLBACK structure indicating a function to call when the callback environment is finalized."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Indicates that callbacks associated with this callback environment may not return quickly.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The thread pool may use this information to better determine when a new thread should be created. This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackLongFunction",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Indicates that the callback environment has no activation context.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackNoActivationContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Specifies that the callback should run on a persistent thread.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackPersistent",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Specifies the priority of a callback function relative to other work items in the same thread pool.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "Higher priority callbacks are guaranteed to be run first by the first available worker thread, but they are not guaranteed to finish before lower priority callbacks. This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackPriority",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "TP_CALLBACK_PRIORITY",
        "name": "Priority",
        "description": "The priority for the callback relative to other callbacks in the same thread pool. This parameter can be one of the following TP_CALLBACK_PRIORITY enumeration values:  ValueMeaning  TP_CALLBACK_PRIORITY_HIGH   The callback should run at high priority.    TP_CALLBACK_PRIORITY_LOW   The callback should run at low priority.   TP_CALLBACK_PRIORITY_NORMAL   The callback should run at normal priority."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Ensures that the specified DLL remains loaded as long as there are outstanding callbacks.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "You should call this function if a callback might acquire the loader lock. This prevents a deadlock from occurring when one thread in DllMain is waiting for the callback to end, and another thread that is executing the callback attempts to acquire the loader lock. If the DLL containing the callback might be unloaded, the cleanup code in DllMain must cancel outstanding callbacks before releasing the object. Managing callbacks created with a TP_CALLBACK_ENVIRON that specifies a callback library is somewhat processing-intensive.  You should consider other options for ensuring that the library is not unloaded while callbacks are executing, or to guarantee that callbacks which may be executing do not acquire the loader lock. This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackRaceWithDll",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DllHandle",
        "description": "A handle to the DLL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Assigns a thread pool to a callback environment.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h",
    "return_value": "This function does not return a value. ",
    "remarks": "If you do not specify a thread pool, the global thread pool is used. This function is implemented as an inline function. ",
    "return_type": "VOID FORCEINLINE",
    "category": "Processes",
    "name": "TpSetCallbackThreadpool",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "CallbackEnviron",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The TpInitializeCallbackEnviron function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "PTP_POOL",
        "name": "Pool",
        "description": "A TP_POOL structure that defines a thread pool. The CreateThreadpool function returns this structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Requests that a thread pool worker thread call the specified callback function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve extended error information, call GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "TrySubmitThreadpoolCallback",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTP_SIMPLE_CALLBACK",
        "name": "pfns",
        "description": "The callback function. For details, see SimpleCallback."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "pv",
        "description": "Optional application-defined data to pass to the callback function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTP_CALLBACK_ENVIRON",
        "name": "pcbe",
        "description": "A TP_CALLBACK_ENVIRON structure that defines the environment in which to execute the callback function. The InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes in the default callback environment. For more information, see InitializeThreadpoolEnvironment."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Waits for outstanding I/O completion callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "When fCancelPendingCallbacks is set to TRUE, only queued callbacks are canceled. Pending I/O requests are not canceled. Therefore, the caller should call GetOverlappedResult for the OVERLAPPED structure to check whether the I/O operation has completed before freeing the structure. As an alternative, set fCancelPendingCallbacks to FALSE and have the associated I/O completion callback free the OVERLAPPED structure. Be careful not to free the OVERLAPPED structure while I/O requests are still pending; use GetOverlappedResult to determine the status of the I/O operation and wait for the operation to complete. The CancelIoEx function can optionally be used first to cancel outstanding I/O requests, potentially shortening the wait. For more information, see Canceling Pending I/O Operations. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "WaitForThreadpoolIoCallbacks",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_IO",
        "name": "pio",
        "description": "A TP_IO structure that defines the I/O completion object. The CreateThreadpoolIo function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fCancelPendingCallbacks",
        "description": "Indicates whether to cancel queued callbacks that have not yet started to execute."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Waits for outstanding timer callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "WaitForThreadpoolTimerCallbacks",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_TIMER",
        "name": "pti",
        "description": "A TP_TIMER structure that defines the timer object. The CreateThreadpoolTimer function returns the TP_TIMER structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fCancelPendingCallbacks",
        "description": "Indicates whether to cancel queued callbacks that have not yet started to execute."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Waits for outstanding wait callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. For an example, see Using the Thread Pool Functions. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "WaitForThreadpoolWaitCallbacks",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WAIT",
        "name": "pwa",
        "description": "A TP_WAIT structure that defines the wait object. The CreateThreadpoolWait function returns the TP_WAIT structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fCancelPendingCallbacks",
        "description": "Indicates whether to cancel queued callbacks that have not yet started to execute."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Waits for outstanding work callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "WaitForThreadpoolWorkCallbacks",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTP_WORK",
        "name": "pwk",
        "description": "A TP_WORK structure that defines the work object. The CreateThreadpoolWork function returns this structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fCancelPendingCallbacks",
        "description": "Indicates whether to cancel queued callbacks that have not yet started to execute."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Associates the I/O completion port owned by the thread pool with the specified file handle. On completion of an I/O request involving this file, a non-I/O worker thread will execute the specified callback function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. The value returned is an NTSTATUS error code. To retrieve the corresponding system error code, use the RtlNtStatusToDosError function. ",
    "remarks": "The callback function might not be executed if the process issues an asynchronous request on the file specified by the FileHandle parameter but the request returns immediately with an error code other than ERROR_IO_PENDING. Be sure that the thread that initiates the asynchronous I/O request does not terminate before the request is completed. Also, if a function in a DLL is queued to a worker thread, be sure that the function in the DLL has completed execution before the DLL is unloaded. The thread pool maintains an I/O completion port. When you call BindIoCompletionCallback, it associates the specified file with the thread pool's I/O completion port. Asynchronous requests on that file object will complete by posting to the completion port, where they will be picked up by thread pool worker threads. For callbacks that must issue an I/O request that completes as an asynchronous procedure call, the thread pool provides an I/O worker pool. The I/O worker threads do not wait on the completion port; they sleep in an alertable wait state so that I/O request packets that complete can wake them up. Both types of worker threads check whether there is I/O pending on them and if there is, they do not exit. For more information, see Asynchronous Procedure Calls. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "BindIoCompletionCallback",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle to the file opened for overlapped I/O completion. This handle is returned by the  CreateFile function, with the FILE_FLAG_OVERLAPPED flag."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED_COMPLETION_ROUTINE",
        "name": "Function",
        "description": "A pointer to the callback function to be executed in a non-I/O worker thread when the I/O operation is complete. This callback function must not call the  TerminateThread function. For more information about the completion routine, see  FileIOCompletionRoutine."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "This parameter must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Queues a work item to a worker thread in the  thread pool.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoollegacyapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If a function in a DLL is queued to a worker thread, be sure that the function has completed execution before the DLL is unloaded. By default, the thread pool has a maximum of 512 threads per process. To raise the queue limit, use the WT_SET_MAX_THREADPOOL_THREAD macro defined in WinNT.h. Use this macro in the call to QueueUserWorkItem to specify the Flags parameter. The macro parameters are the desired flags and the new limit, up to (2<<16)-1 threads. However, the size of the queue is limited by the size of the kernel nonpaged pool. Note that your application can improve its performance by keeping the number of worker threads low. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueueUserWorkItem",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTHREAD_START_ROUTINE",
        "name": "Function",
        "description": "A pointer to the application-defined callback function of type LPTHREAD_START_ROUTINE to be executed by the thread in the thread pool. This value represents the starting address of the thread. This callback function must not call the  TerminateThread function.     For more information, see  ThreadProc."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "A single parameter value to be passed to the thread function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "The flags that control execution. This parameter can be one or more of the following values.  ValueMeaning  WT_EXECUTEDEFAULT 0x00000000   By default, the callback function is queued to a non-I/O worker thread. The callback function is queued to a thread that uses I/O completion ports, which means they cannot perform an alertable wait. Therefore, if I/O completes and generates an APC, the APC might wait indefinitely because there is no guarantee that the thread will enter an alertable wait state after the callback completes.   WT_EXECUTEINIOTHREAD 0x00000001   This flag is not used. Windows Server 2003 and Windows XP:  The callback function is queued to an I/O worker thread. This flag should be used if the function should be executed in a thread that waits in an alertable state.    I/O worker threads were removed starting with Windows Vista and Windows Server 2008.   WT_EXECUTEINPERSISTENTTHREAD 0x00000080   The callback function is queued to a thread that never terminates. It does not guarantee that the same thread is used each time. This flag should be used only for short tasks or it could affect other timer operations.    This flag must be set if the thread calls functions that use APCs. For more information, see Asynchronous Procedure Calls. Note that currently no worker thread is truly persistent, although worker threads do not terminate if there are any pending I/O requests.   WT_EXECUTELONGFUNCTION 0x00000010   The callback function can perform a long wait. This flag helps the system to decide if it should create a new thread.   WT_TRANSFER_IMPERSONATION 0x00000100   Callback functions will use the current access token, whether it is a process or impersonation token. If this flag is not specified, callback functions execute only with the process token. Windows XP:  This flag is not supported until Windows XP SP2 and Windows Server 2003."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Directs a wait thread in the thread pool to wait on the object. The wait thread queues the specified callback function to the thread pool when one of the following occurs:",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call   GetLastError. ",
    "remarks": "New wait threads are created automatically when required. The wait operation is performed by a wait thread from the thread pool. The callback routine is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If dwFlags is not WT_EXECUTEONLYONCE, the timer is reset every time the event is signaled or the time-out interval elapses. When the wait is completed, you must call the  UnregisterWait or  UnregisterWaitEx function to cancel the wait operation. (Even wait operations that use WT_EXECUTEONLYONCE must be canceled.) Do not make a blocking call to either of these functions from within the callback function. Note that you should not pulse an event object passed to  RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset. You should not register an object that remains signaled (such as a manual reset event or terminated process) unless you set the WT_EXECUTEONLYONCE or WT_EXECUTEINWAITTHREAD flag. For other flags,  the callback function might be called too many times before the event is reset. The function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore object is decreased by one. The  RegisterWaitForSingleObject function can wait for the following objects: For more information, see  Synchronization Objects. By default, the thread pool has a maximum of 500 threads. To raise this limit, use the WT_SET_MAX_THREADPOOL_THREAD macro defined in WinNT.h. Use this macro when specifying the dwFlags parameter. The macro parameters are the desired flags and the new limit (up to (2<<16)-1 threads). However, note that your application can improve its performance by keeping the number of worker threads low. The work item and all functions it calls must be thread-pool safe. Therefore, you cannot call an asynchronous call that requires a persistent thread, such as the  RegNotifyChangeKeyValue function, from the default callback environment. Instead, set the thread pool maximum equal to the thread pool minimum using the SetThreadpoolThreadMaximum and SetThreadpoolThreadMinimum functions, or create your own thread using the CreateThread function. (For the original thread pool API, specify WT_EXECUTEINPERSISTENTTHREAD using the QueueUserWorkItem function.) To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "RegisterWaitForSingleObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "phNewWaitObject",
        "description": "A pointer to a variable that receives a wait handle on return. Note that a wait handle cannot be used in functions that require an object handle, such as  CloseHandle."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hObject",
        "description": "A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.     If this handle is closed while the wait is still pending, the function's behavior is undefined. The handles must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "WAITORTIMERCALLBACK",
        "name": "Callback",
        "description": "A pointer to the application-defined function of type WAITORTIMERCALLBACK to be executed when hObject is in the signaled state, or dwMilliseconds elapses. For more information, see  WaitOrTimerCallback."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "A single value that is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled. If dwMilliseconds is zero, the function tests the object's state and returns immediately. If dwMilliseconds is INFINITE, the function's time-out interval never elapses."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "dwFlags",
        "description": "This parameter can be one or more of the following values.   For information about using these values with objects that remain signaled, see the Remarks section.  ValueMeaning  WT_EXECUTEDEFAULT 0x00000000   By default, the callback function is queued to a non-I/O worker thread.   WT_EXECUTEINIOTHREAD 0x00000001   This flag is not used. Windows Server 2003 and Windows XP:  The callback function is queued to an I/O worker thread. This flag should be used if the function should be executed in a thread that waits in an alertable state.    I/O worker threads were removed starting with Windows Vista and Windows Server 2008.   WT_EXECUTEINPERSISTENTTHREAD 0x00000080   The callback function is queued to a thread that never terminates. It does not guarantee that the same thread is used each time. This flag should be used only for short tasks or it could affect other wait operations.    This flag must be set if the thread calls functions that use APCs. For more information, see Asynchronous Procedure Calls. Note that currently no worker thread is truly persistent, although no worker thread will terminate if there are any pending I/O requests.   WT_EXECUTEINWAITTHREAD 0x00000004   The callback function is invoked by the wait thread itself. This flag should be used only for short tasks or it could affect other wait operations.     Deadlocks can occur if some other thread acquires an exclusive lock and calls the  UnregisterWait or  UnregisterWaitEx function while the callback function is trying to acquire the same lock.   WT_EXECUTELONGFUNCTION 0x00000010   The callback function can perform a long wait. This flag helps the system to decide if it should create a new thread.   WT_EXECUTEONLYONCE 0x00000008   The thread will no longer wait on the handle after the callback function has been called once. Otherwise, the timer is reset every time the wait operation completes until the wait operation is canceled.   WT_TRANSFER_IMPERSONATION 0x00000100   Callback functions will use the current access token, whether it is a process or impersonation token. If this flag is not specified, callback functions execute only with the process token. Windows XP:  This flag is not supported until Windows XP with SP2 and Windows Server 2003."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Cancels a registered wait operation issued by the  RegisterWaitForSingleObject function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LibLoaderAPI.h on Windows 8 and Windows Server 2012 (include Windows.h);  WinBase.h on Windows 7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP and Windows Server 2003 (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "You cannot make a blocking call to  UnregisterWaitEx from within a callback function for the same wait operation. Otherwise, the callback will be waiting for itself to finish. In general, a blocking call to UnregisterWaitEx creates a dependency between the current thread and the callback, so to make a blocking unregister call on another wait operation, you must ensure that the callback functions do not depend on one another and that the second wait operation does not also perform a blocking unregister call on the first operation. Be careful when making a blocking UnregisterWaitEx call on a persistent thread. If the wait operation being unregistered was created with   WT_EXECUTEINPERSISTENTTHREAD, a deadlock may occur. After making non-blocking call to UnregisterWaitEx, no new callback functions associated with WaitHandle can be queued. However, there may be pending callback functions already queued to worker threads. Under some conditions, the function will fail with ERROR_IO_PENDING if CompletionEvent is NULL. This indicates that there are outstanding callback functions. Those callbacks either will execute or are in the middle of executing. If CompletionEvent is a handle to an event provided by the caller, it is possible for the function to succeed, fail with ERROR_IO_PENDING, or fail with a different error code. If the function succeeds, or if the function fails with ERROR_IO_PENDING, the caller should always wait until the event is signaled to close the event. If the function fails with a different error code, it is not necessary to wait until the event is signaled to close the event. Windows XP:  If CompletionEvent is a handle to an event provided by the caller and the function fails with  ERROR_IO_PENDING,  the caller should wait until the event is signaled to close the event. This behavior changed starting with Windows Vista. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "UnregisterWaitEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "WaitHandle",
        "description": "The wait handle. This handle is returned by the  RegisterWaitForSingleObject function."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "CompletionEvent",
        "description": "A handle to the event object to be signaled when the wait operation has been unregistered. This parameter can be NULL. If this parameter is INVALID_HANDLE_VALUE, the function waits for all callback functions to complete before returning. If this parameter is NULL, the function marks the timer for deletion and returns immediately. However, most callers should wait for the callback function to complete so they can perform any needed cleanup. If the caller provides this event and the function succeeds or the function fails with  ERROR_IO_PENDING,  do not close the event until it is signaled."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the system responsiveness setting used by the multimedia class scheduler service.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvQuerySystemResponsiveness",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "AvrtHandle",
        "description": "A handle to the task. This handle is returned by the AvSetMmThreadCharacteristics or AvSetMmMaxThreadCharacteristics function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "SystemResponsivenessValue",
        "description": "The system responsiveness value. This value can range from 10 to 100 percent."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Creates a thread ordering group.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If a thread ordering group with the specified identifier already exists, the function fails and sets the last error to ERROR_ALREADY_EXISTS. ",
    "remarks": "The calling thread is considered to be the parent thread. Each thread ordering group has one parent thread. Each parent thread can have zero or more predecessor threads and zero or more successor threads. A client thread can join a thread ordering group and specify whether it is a predecessor or successor using the AvRtJoinThreadOrderingGroup function. The parent thread encloses the code to be executed during each period within a loop that is controlled by the AvRtWaitOnThreadOrderingGroup function. To delete the thread ordering group, call the AvRtDeleteThreadOrderingGroup function. A thread can create more than one thread ordering group and join more than one thread ordering group. However, a thread cannot join the same thread ordering group more than one time. The following snippet creates a thread ordering group. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRtCreateThreadOrderingGroup",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Context",
        "description": "A pointer to a context handle."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Period",
        "description": "A pointer to a value, in 100-nanosecond increments, that specifies the period for the thread ordering group. Each thread in the thread ordering group runs one time during this period. If all threads complete their execution before a period ends, all threads wait until the remainder of the period elapses before any are executed again. The possible values for this parameter depend on the platform, but this parameter can be as low as 500 microseconds or as high as 0x1FFFFFFFFFFFFFFF. If this parameter is less than 500 microseconds, then it is set to 500 microseconds. If this parameter is greater than the maximum, then it is set to 0x1FFFFFFFFFFFFFFF."
      },
      {
        "in_out": "_Inout_",
        "type": "GUID*",
        "name": "ThreadOrderingGuid",
        "description": "A pointer to the unique identifier for the thread ordering group to be created. If this value is not unique to the thread ordering service, the function fails. If the identifier is GUID_NULL on input, the thread ordering service generates and returns a unique identifier."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "A pointer to a time-out value. All threads within the group should complete their execution within Period plus Timeout. If a thread fails to complete its processing within the period plus this time-out interval, it is removed from the thread ordering group. If the parent fails to complete its processing within the period plus the time-out interval, the thread ordering group is destroyed. The possible values for this parameter depend on the platform, but can be as low as 500 microseconds or as high as 0x1FFFFFFFFFFFFFFF. If this parameter is less than 500 microseconds, then it is set to 500 microseconds. If this parameter is greater than the maximum, then it is set to 0x1FFFFFFFFFFFFFFF. If this parameter is NULL or 0, the default is five times the value of Period. If this parameter is THREAD_ORDER_GROUP_INFINITE_TIMEOUT, the group is created with an infinite time-out interval. This can be useful for debugging purposes."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Creates a thread ordering group and associates the server thread with a task.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If a thread ordering group with the specified identifier already exists, the function fails and sets the last error to ERROR_ALREADY_EXISTS. ",
    "remarks": "The calling thread is considered to be the parent thread. Each thread ordering group has one parent thread. Each parent thread can have zero or more predecessor threads and zero or more successor threads. A client thread can join a thread ordering group and specify whether it is a predecessor or successor using the AvRtJoinThreadOrderingGroup function. The parent thread encloses the code to be executed during each period within a loop that is controlled by the AvRtWaitOnThreadOrderingGroup function. To delete the thread ordering group, call the AvRtDeleteThreadOrderingGroup function. A thread can create more than one thread ordering group and join more than one thread ordering group. However, a thread cannot join the same thread ordering group more than one time. The parent and client threads of a thread ordering group run at high priorities. However, the server thread that manages the thread ordering group runs at normal priority. Therefore, there can be a delay switching from one client thread to another if there are other high-priority threads running. The TaskName parameter of this function specifies the task to be associated with the server thread. The following snippet creates a thread ordering group. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRtCreateThreadOrderingGroupEx",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Context",
        "description": "A pointer to a context handle."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Period",
        "description": "A pointer to a value, in 100-nanosecond increments, that specifies the period for the thread ordering group. Each thread in the thread ordering group runs one time during this period. If all threads complete their execution before a period ends, all threads wait until the remainder of the period elapses before any are executed again. The possible values for this parameter depend on the platform, but this parameter can be as low as 500 microseconds or as high as 0x1FFFFFFFFFFFFFFF. If this parameter is less than 500 microseconds, then it is set to 500 microseconds. If this parameter is greater than the maximum, then it is set to 0x1FFFFFFFFFFFFFFF."
      },
      {
        "in_out": "_Inout_",
        "type": "GUID*",
        "name": "ThreadOrderingGuid",
        "description": "A pointer to the unique identifier for the thread ordering group to be created. If this value is not unique to the thread ordering service, the function fails. If the identifier is GUID_NULL on input, the thread ordering service generates and returns a unique identifier."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "A pointer to a time-out value. All threads within the group should complete their execution within Period plus Timeout. If a thread fails to complete its processing within the period plus this time-out interval, it is removed from the thread ordering group. If the parent fails to complete its processing within the period plus the time-out interval, the thread ordering group is destroyed. The possible values for this parameter depend on the platform, but can be as low as 500 microseconds or as high as 0x1FFFFFFFFFFFFFFF. If this parameter is less than 500 microseconds, then it is set to 500 microseconds. If this parameter is greater than the maximum, then it is set to 0x1FFFFFFFFFFFFFFF. If this parameter is NULL or 0, the default is five times the value of Period. If this parameter is THREAD_ORDER_GROUP_INFINITE_TIMEOUT, the group is created with an infinite time-out interval. This can be useful for debugging purposes."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "TaskName",
        "description": "The name of the task."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes the specified thread ordering group created by the caller. It cleans up  resources for the thread ordering group, including the context information, and returns.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function can only be called successfully by the parent thread for the thread ordering group. If a thread other than the parent thread calls this function, the function fails with a last error code of ERROR_INVALID_FUNCTION. If the parent thread times out and attempts to call this function, the function fails with a last error code of ERROR_INVALID_PARAMETER. The following code deletes a thread ordering group. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRtDeleteThreadOrderingGroup",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Context",
        "description": "A context handle. This handle is returned by the AvRtCreateThreadOrderingGroup function when creating the group."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Joins client threads to a thread ordering group.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The thread encloses the code to be executed during each period within a loop that is controlled by the AvRtWaitOnThreadOrderingGroup function. A thread can create more than one thread ordering group and join more than one thread ordering group. However, a thread cannot join the same thread ordering group more than one time. The number of threads that can join a group is limited only by available system resources. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRtJoinThreadOrderingGroup",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Context",
        "description": "A pointer to a context handle."
      },
      {
        "in_out": "_In_",
        "type": "GUID*",
        "name": "ThreadOrderingGuid",
        "description": "A pointer to the unique identifier for the thread ordering group."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "Before",
        "description": "The thread order. If this parameter is TRUE, the thread is a predecessor thread that is scheduled to run before the parent thread. If this parameter is FALSE, the thread is a successor thread that is scheduled to run after the parent thread."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Enables client threads to leave a thread ordering group.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The parent thread for a thread ordering group should not remove itself from the group. If a thread times out and attempts to call this function, the function fails with a last error code of ERROR_INVALID_PARAMETER. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRtLeaveThreadOrderingGroup",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Context",
        "description": "A context handle. This handle is returned by the AvRtJoinThreadOrderingGroup function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Enables client threads of a thread ordering group to wait until they should execute.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "When this function returns, the thread should complete its processing for the period and then call the function again. If the thread fails to complete its processing during the time-out interval specified by the parent thread when creating the group, it is deleted from the thread ordering group. Therefore, when the thread finishes its processing loop, the next call to AvRtWaitOnThreadOrderingGroup fails and the last error code is set to ERROR_ACCESS_DENIED. If the thread ordering group is deleted during the wait, this function eventually times out and return ERROR_ACCESS_DENIED. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRtWaitOnThreadOrderingGroup",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Context",
        "description": "A context handle. This handle is returned by the AvRtCreateThreadOrderingGroup or AvRtJoinThreadOrderingGroup function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates that a thread is no longer performing work associated with the specified task.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function must be called from the same thread that called the AvSetMmThreadCharacteristics or AvSetMmMaxThreadCharacteristics function to create the handle. Otherwise, the function will fail. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvRevertMmThreadCharacteristics",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "AvrtHandle",
        "description": "A handle to the task. This handle is returned by the AvSetMmThreadCharacteristics or AvSetMmMaxThreadCharacteristics function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Associates the calling thread with the specified tasks.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, it returns a handle to the task. If the function fails, it returns 0. To retrieve extended error information, call GetLastError.  The following are possible error codes.  ",
    "remarks": "The resulting characteristics of the thread performing the tasks reflect the task with the highest priority. When the task is completed, call the AvRevertMmThreadCharacteristics function. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "AvSetMmMaxThreadCharacteristics",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "FirstTask",
        "description": "The name of the first task to be performed. This name must match the name of one of the subkeys of the following key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Multimedia\\SystemProfile\\Tasks."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SecondTask",
        "description": "The name of the second task to be performed. This name must match the name of one of the subkeys of the following key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Multimedia\\SystemProfile\\Tasks."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "TaskIndex",
        "description": "The unique task identifier. The first time this function is called, this value must be 0 on input. The index value is returned on output and can be used as input in subsequent calls."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Associates the calling thread with the specified task.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, it returns a handle to the task. If the function fails, it returns 0. To retrieve extended error information, call GetLastError.  The following are possible error codes.  ",
    "remarks": "When the task is completed, call the AvRevertMmThreadCharacteristics function. ",
    "return_type": "HANDLE",
    "category": "Processes",
    "name": "AvSetMmThreadCharacteristics",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "TaskName",
        "description": "The name of the task to be performed. This name must match the name of one of the subkeys of the following key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Multimedia\\SystemProfile\\Tasks."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "TaskIndex",
        "description": "The unique task identifier. The first time this function is called, this value must be 0 on input. The index value is returned on output and can be used as input in subsequent calls."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Adjusts the thread priority of the calling thread relative to other threads performing the same task.",
    "library": "Avrt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Avrt.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AvSetMmThreadPriority",
    "is_callback": 0,
    "dll": "Avrt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "AvrtHandle",
        "description": "A handle to the task. This handle is returned by the AvSetMmThreadCharacteristics or AvSetMmMaxThreadCharacteristics function."
      },
      {
        "in_out": "_In_",
        "type": "AVRT_PRIORITY",
        "name": "Priority",
        "description": "The relative thread priority of this thread to other threads performing a similar task. This parameter can be one of the following values.  AVRT_PRIORITY_CRITICAL (2) AVRT_PRIORITY_HIGH (1) AVRT_PRIORITY_LOW (-1) AVRT_PRIORITY_NORMAL (0)"
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Converts the current fiber into a thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The function releases the resources allocated by the  ConvertThreadToFiber function. After calling this function, you cannot call any of the fiber functions from the thread. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "ConvertFiberToThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "Only fibers can execute other fibers. If a thread needs to execute a fiber, it must call  ConvertThreadToFiber or  ConvertThreadToFiberEx to create an area in which to save fiber state information. The thread is now the current fiber. The state information for this fiber includes the fiber data specified by lpParameter. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. For an example, see Using Fibers. ",
    "return_type": "LPVOID",
    "category": "Processes",
    "name": "ConvertThreadToFiber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the  GetFiberData macro."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "Only fibers can execute other fibers. If a thread needs to execute a fiber, it must call  ConvertTheadToFiber or  ConvertThreadToFiberEx to create an area in which to save fiber state information. The thread is now the current fiber. The state information for this fiber includes the fiber data specified by lpParameter. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LPVOID",
    "category": "Processes",
    "name": "ConvertThreadToFiberEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A  pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the  GetFiberData macro."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The number of fibers a process can create is limited by the available virtual memory. For example, if you create each fiber with 1 megabyte of reserved stack space, you can create at most 2028 fibers. If you reduce the default stack size by using the STACKSIZE statement in the module definition (.def) file or  by using CreateFiberEx, you can create more fibers. However, your application will have better performance if you use an alternate strategy for processing requests instead of creating such a large number of fibers. Before a thread can schedule a fiber using the  SwitchToFiber function, it must call the  ConvertThreadToFiber function so there is a fiber associated with the thread. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. For an example, see Using Fibers. ",
    "return_type": "LPVOID",
    "category": "Processes",
    "name": "CreateFiber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwStackSize",
        "description": "The initial size of the stack, in bytes. If this parameter is zero, the new fiber uses the default stack size for the executable. For more information, see Thread Stack Size."
      },
      {
        "in_out": "_In_",
        "type": "LPFIBER_START_ROUTINE",
        "name": "lpStartAddress",
        "description": "A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the  SwitchToFiber function with this address. For more information of the fiber callback function, see  FiberProc."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the  GetFiberData macro."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The number of fibers a process can create is limited by the available virtual memory. By default, every fiber has 1 megabyte of reserved stack space. Therefore, you can create at most 2028 fibers. If you reduce the default stack size, you can create more fibers. However, your application will have better performance if you use an alternate strategy for processing requests. Before a thread can schedule a fiber using the  SwitchToFiber function, it must call the  ConvertThreadToFiber function so there is a fiber associated with the thread. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LPVOID",
    "category": "Processes",
    "name": "CreateFiberEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwStackCommitSize",
        "description": "The initial commit size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see Thread Stack Size."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwStackReserveSize",
        "description": "The initial reserve size of the stack, in bytes. If this parameter is zero, the new fiber uses the default reserved stack size for the executable. For more information, see Thread Stack Size."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber. Windows XP:  The FIBER_FLAG_FLOAT_SWITCH flag is not supported."
      },
      {
        "in_out": "_In_",
        "type": "LPFIBER_START_ROUTINE",
        "name": "lpStartAddress",
        "description": "A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the  SwitchToFiber function with this address. For more information on the fiber callback function, see  FiberProc."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpParameter",
        "description": "A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the  GetFiberData macro."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes an existing fiber.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The  DeleteFiber function deletes all data associated with the fiber. This data includes the stack, a subset of the registers, and the fiber data. If the currently running fiber calls  DeleteFiber, its thread calls  ExitThread and terminates. However, if a currently running fiber is deleted by another fiber, the thread running the deleted fiber is likely to terminate abnormally because the fiber stack has been freed. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. For an example, see Using Fibers. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "DeleteFiber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpFiber",
        "description": "The address of the fiber to be deleted."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined function used with the  CreateFiber function. It serves as the starting address for a fiber. The LPFIBER_START_ROUTINE type defines a pointer to this callback function.  FiberProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. For an example, see Using Fibers. ",
    "remarks": "",
    "return_type": "VOID CALLBACK",
    "category": "Processes",
    "name": "FiberProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpParameter",
        "description": "The fiber data passed using the lpParameter parameter of the  CreateFiber function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Allocates a fiber local storage (FLS) index. Any fiber in the process can subsequently use this index to store and retrieve values that are local to the fiber.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Fibersapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is an FLS index initialized to zero. If the function fails, the return value is FLS_OUT_OF_INDEXES. To get extended error information, call  GetLastError. ",
    "remarks": "The fibers of the process can use the FLS index in subsequent calls to the  FlsFree,  FlsSetValue, or  FlsGetValue functions. FLS indexes are typically allocated during process or dynamic-link library (DLL) initialization. After an FLS index has been allocated, each fiber of the process can use it to access its own FLS storage slot. To store a value in its FLS slot, a fiber specifies the index in a call to  FlsSetValue. The fiber specifies the same index in a subsequent call to  FlsGetValue to retrieve the stored value. FLS indexes are not valid across process boundaries. A DLL cannot assume that an index assigned in one process is valid in another process. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "FlsAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PFLS_CALLBACK_FUNCTION",
        "name": "lpCallback",
        "description": "A pointer to the application-defined callback function of type PFLS_CALLBACK_FUNCTION. This parameter is optional. For more information, see  FlsCallback."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases a fiber local storage (FLS) index, making it available for reuse.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Fibersapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Freeing an FLS index frees the index for all instances of FLS in the current process. Freeing an FLS index also causes the associated callback routine to be called for each fiber, if the corresponding FLS slot contains a non-NULL value. If the fibers of the process have allocated memory and stored a pointer to the memory in an FLS slot, they should free the memory before calling  FlsFree. The  FlsFree function does not free memory blocks whose addresses have been stored in the FLS slots associated with the FLS index. It is expected that DLLs call this function (if at all) only during DLL_PROCESS_DETACH. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "FlsFree",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlsIndex",
        "description": "The FLS index that was allocated by the  FlsAlloc function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the value in the calling fiber's fiber local storage (FLS) slot for the specified FLS index. Each fiber has its own slot for each FLS index.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Fibersapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is the value stored in the calling fiber's FLS slot associated with the specified index. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "FLS indexes are typically allocated by the  FlsAlloc function during process or DLL initialization. After an FLS index is allocated, each fiber of the process can use it to access its own FLS slot for that index. A fiber specifies an FLS index in a call to  FlsSetValue to store a value in its slot. The thread specifies the same index in a subsequent call to  FlsSetValue to retrieve the stored value. ",
    "return_type": "PVOID",
    "category": "Processes",
    "name": "FlsGetValue",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlsIndex",
        "description": "The FLS index that was allocated by the  FlsAlloc function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Stores a value in the calling fiber's fiber local storage (FLS) slot for the specified FLS index. Each fiber has its own slot for each FLS index.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Fibersapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. The following errors can be returned.  ",
    "remarks": "FLS indexes are typically allocated by the  FlsAlloc function during process or DLL initialization. After an FLS index is allocated, each fiber of the process can use it to access its own FLS slot for that index. A thread specifies an FLS index in a call to  FlsSetValue to store a value in its slot. The thread specifies the same index in a subsequent call to  FlsGetValue to retrieve the stored value. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "FlsSetValue",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlsIndex",
        "description": "The FLS index that was allocated by the  FlsAlloc function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "lpFlsData",
        "description": "The value to be stored in the FLS slot for the calling fiber."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Determines whether the current thread is a fiber.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Fibersapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The function returns TRUE if the thread is a fiber and FALSE otherwise. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "IsThreadAFiber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Schedules a fiber. The function must be called on a fiber.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "You create fibers with the  CreateFiber function. Before you can schedule fibers associated with a thread, you must call  ConvertThreadToFiber to set up an area in which to save the fiber state information. The thread is now the currently executing fiber. The  SwitchToFiber function saves the state information of the current fiber and restores the state of the specified fiber. You can call  SwitchToFiber with the address of a fiber created by a different thread. To do this, you must have the address returned to the other thread when it called  CreateFiber and you must use proper synchronization. Avoid making the following call: This call can cause unpredictable problems. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "SwitchToFiber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpFiber",
        "description": "The address of the fiber to be scheduled."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Allocates physical memory pages to be mapped and unmapped within any      Address Windowing Extensions (AWE) region of a      specified process  and specifies the NUMA node for the physical memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. Fewer pages than requested can be allocated. The caller must check the value of the         NumberOfPages parameter on return to see how many pages are allocated. All allocated         page frame numbers are sequentially placed in the memory pointed to by the PageArray         parameter. If the function fails, the return value is FALSE and no frames are allocated. To get         extended error information, call the GetLastError         function. ",
    "remarks": "The AllocateUserPhysicalPagesNuma      function is used to allocate physical memory within a NUMA node that can later be mapped within the virtual      address space of the process. The SeLockMemoryPrivilege privilege must be enabled in the      caller's token or the function will fail with ERROR_PRIVILEGE_NOT_HELD. For more      information, see Privilege Constants. Memory allocated by this function must be physically present in the system. After the memory is allocated, it      is locked down and unavailable to the rest of the virtual memory management system. Physical pages cannot be simultaneously mapped at more than one virtual address. Physical pages can reside at any physical address. You should make no assumptions about the contiguity of the      physical pages. To compile an application that uses this function, define _WIN32_WINNT as 0x0600      or later. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "AllocateUserPhysicalPagesNuma",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to a process.  The function allocates memory that can later be mapped within the virtual address        space of this process. The handle must have the PROCESS_VM_OPERATION access right. For        more information, see        Process Security and Access Rights."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG_PTR",
        "name": "NumberOfPages",
        "description": "The size of the physical memory to allocate, in pages. To determine the page size of the computer, use the         GetSystemInfo function. On output, this parameter         receives the number of pages that are actually allocated, which might be less than the number requested."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "PageArray",
        "description": "A pointer to an array to store the page frame numbers of the allocated memory. The size of the array that is allocated should be at least the NumberOfPages times         the size of the ULONG_PTR data type. Caution  Do not attempt to modify this buffer. It contains operating system data, and corruption         could be catastrophic. The information in the buffer is not useful to an application."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nndPreferred",
        "description": "The NUMA node where the physical memory should reside."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the amount of memory available in the specified node.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The GetNumaAvailableMemoryNode function returns the amount of memory consumed by free and zeroed pages on the specified node. On systems with more than one node, this memory does not include standby pages. Therefore, the sum of the available memory values for all nodes in the system is equal to the value of the Free & Zero Page List Bytes memory performance counter. On systems with only one node, the value returned by GetNumaAvailableMemoryNode  includes standby pages and  is equal to the value of the Available Bytes memory performance counter. For more information about performance counters, see Memory Performance Information. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaAvailableMemoryNode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Node",
        "description": "The number of the node."
      },
      {
        "in_out": "_Out_",
        "type": "PULONGLONG",
        "name": "AvailableBytes",
        "description": "The amount of available memory for the node, in bytes."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the amount of memory that is available in a node specified as a USHORT value.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "The GetNumaAvailableMemoryNodeEx function returns the amount of memory consumed by free and zeroed pages on the specified node. On systems with more than one node, this memory does not include standby pages. Therefore, the sum of the available memory values for all nodes in the system is equal to the value of the Free & Zero Page List Bytes memory performance counter. On systems with only one node, the value returned by GetNumaAvailableMemoryNode  includes standby pages and  is equal to the value of the Available Bytes memory performance counter. For more information about performance counters, see Memory Performance Information. The only difference between the GetNumaAvailableMemoryNodeEx function and the GetNumaAvailableMemoryNode function is the data type of the Node parameter. To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaAvailableMemoryNodeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Node",
        "description": "The number of the node."
      },
      {
        "in_out": "_Out_",
        "type": "PULONGLONG",
        "name": "AvailableBytes",
        "description": "The amount of available memory for the node, in bytes."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the node that currently has the highest number.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Systemtopologyapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The number of the highest node is not guaranteed to be the total number of nodes. To retrieve a list of all processors in a node, use the  GetNumaNodeProcessorMask function. For an example, see Allocating Memory from a NUMA Node. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaHighestNodeNumber",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "HighestNodeNumber",
        "description": "The number of the highest node."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the NUMA node associated with the file or I/O device represented by the specified file handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use GetLastError. ",
    "remarks": "If the specified handle does not have a node associated with it, the function returns FALSE. The value of the NodeNumber parameter is undetermined and should not be used. To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaNodeNumberFromHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to a file or I/O device. Examples of I/O devices include files, file streams, volumes, physical disks, and sockets. For more information, see the CreateFile function."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "NodeNumber",
        "description": "A pointer to a variable to receive the number of the NUMA node associated with the specified file handle."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the processor mask for the specified node.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To retrieve the highest numbered node in the system, use the  GetNumaHighestNodeNumber function. Note that this number is not guaranteed to equal the total number of nodes in the system. To ensure that all threads for your process run on the same node, use the  SetProcessAffinityMask function with a process affinity mask that specifies processors in the same node. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaNodeProcessorMask",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Node",
        "description": "The number of the node."
      },
      {
        "in_out": "_Out_",
        "type": "PULONGLONG",
        "name": "ProcessorMask",
        "description": "The processor mask for the node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node. If the node has no processors configured, the processor mask is zero. On systems with more than 64 processors, this parameter is set to the processor mask for the node only if the node is in the same processor group as the calling thread. Otherwise, the parameter is set to zero."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the processor mask for a node regardless of the processor group the node belongs to.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Systemtopologyapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The GetNumaNodeProcessorMaskEx function differs from GetNumaNodeProcessorMask in that it can retrieve the processor mask for a node regardless of the group the node belongs to. That is, the node does not have to be in the same group as the calling thread. The GetNumaNodeProcessorMask function can retrieve the processor mask only for nodes that are in the same group as the calling thread. To retrieve the highest numbered node in the system, use the  GetNumaHighestNodeNumber function. Note that this number is not guaranteed to equal the total number of nodes in the system. To ensure that all threads for your process run on the same node, use the  SetProcessAffinityMask function with a process affinity mask that specifies processors in the same node. To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaNodeProcessorMaskEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Node",
        "description": "The node number."
      },
      {
        "in_out": "_Out_",
        "type": "PGROUP_AFFINITY",
        "name": "ProcessorMask",
        "description": "A pointer to a GROUP_AFFINITY structure that receives the processor mask for the specified node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node. If the specified node has no processors configured, the Mask member is zero and the Group member is undefined."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the node number for the specified processor.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To retrieve the list of processors on the system, use the  GetProcessAffinityMask function. For an example, see Allocating Memory from a NUMA Node. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaProcessorNode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Processor",
        "description": "The processor number. On a system with more than 64 logical processors, the processor number is relative to the processor group that contains the processor on which the calling thread is running."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "NodeNumber",
        "description": "The node number. If the processor does not exist, this parameter is 0xFF."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the node number as a USHORT value for the specified logical processor.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaProcessorNodeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PPROCESSOR_NUMBER",
        "name": "Processor",
        "description": "A pointer to a PROCESSOR_NUMBER structure that represents the logical processor and the processor group to which it is assigned."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "NodeNumber",
        "description": "A pointer  to a variable to receive the node number. If the specified processor does not exist, this parameter is set to MAXUSHORT."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the NUMA node number that corresponds to the specified proximity domain identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error  information, call GetLastError. ",
    "remarks": "A proximity domain identifier is an index to a NUMA node on a NUMA system. Proximity domain identifiers are found in the ACPI System Resource Affinity Table (SRAT), where they are used to associate processors and memory regions with a particular NUMA node. Proximity domain identifiers are also found in the ACPI namespace, where they are used to associate a device with a particular NUMA node. Proximity domain identifiers are typically used only by management applications provided by system manufacturers. Windows does not use proximity domain identifiers to identify NUMA nodes; instead, it assigns a unique number to each NUMA node in the system. The relative distance between nodes on a system is stored in the ACPI System Locality Distance Information Table (SLIT), which is not exposed by any Windows functions. For more information about ACPI tables, see the ACPI specifications. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaProximityNode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ProximityId",
        "description": "The proximity domain identifier of the node."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "NodeNumber",
        "description": "The node number. If the processor does not exist, this parameter is 0xFF."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the NUMA node number that corresponds to  the specified proximity identifier as a USHORT value.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "A proximity domain identifier is an index to a NUMA node on a NUMA system. Proximity domain identifiers are found in the ACPI System Resource Affinity Table (SRAT), where they are used to associate processors and memory regions with a particular NUMA node. Proximity domain identifiers are also found in the ACPI namespace, where they are used to associate a device with a particular NUMA node. Proximity domain identifiers are typically used only by management applications provided by system manufacturers. Windows does not use proximity domain identifiers to identify NUMA nodes; instead, it assigns a unique number to each NUMA node in the system. The relative distance between nodes on a system is stored in the ACPI System Locality Distance Information Table (SLIT), which is not exposed by any Windows functions. For more information about ACPI tables, see the ACPI specifications. The only difference between the GetNumaProximityNodeEx function and the GetNumaProximityNode function is the data type of the NodeNumber parameter. To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetNumaProximityNodeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ProximityId",
        "description": "The proximity identifier of the node."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "NodeNumber",
        "description": "Points to a variable to receive the node number for the specified proximity identifier."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Reserves, commits, or changes the state  of a region of memory within the virtual address space of the specified process, and      specifies the NUMA node for the physical memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "Each page has an associated page state. The       VirtualAllocExNuma function can perform the       following operations:  VirtualAllocExNuma cannot reserve a reserved       page. It can commit a page that is already committed. This means you can commit a range of pages, regardless of       whether they have already been committed, and the function will not fail. You can use VirtualAllocExNuma to reserve a       block of pages and then make additional calls to       VirtualAllocExNuma to commit individual pages from       the reserved block. This enables a process to reserve a range of its virtual address space without consuming       physical storage until it is needed. If the lpAddress parameter is not NULL, the function uses       the lpAddress and dwSize parameters to compute the region of       pages to be allocated. The current state of the entire range of pages must be compatible with the type of       allocation specified by the flAllocationType parameter. Otherwise, the function fails       and none of the pages is allocated. This compatibility requirement does not preclude committing an already       committed page; see the preceding list. Because VirtualAllocExNuma does not allocate any       physical pages, it will succeed whether or not the pages are available on that node or elsewhere in the system.       The physical pages are allocated on demand. If the preferred node runs out of pages, the memory manager will use       pages from other nodes. If the memory is paged out, the same process is used when it is brought back in. To execute dynamically generated code, use       VirtualAllocExNuma to allocate memory and the       VirtualProtectEx function to grant       PAGE_EXECUTE access. The VirtualAllocExNuma function can be used to       reserve an       Address Windowing Extensions       (AWE) region of memory within the virtual address space of a specified process. This region of memory can then be       used to map physical pages into and out of virtual memory as required by the application. The       MEM_PHYSICAL and MEM_RESERVE values must be set in the       AllocationType parameter. The MEM_COMMIT value must not be       set. The page protection must be set to PAGE_READWRITE. The VirtualFreeEx function can decommit a committed       page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also       release a reserved page, making it a free page. To compile an application that uses this function, define _WIN32_WINNT as 0x0600       or later. For an example, see       Allocating Memory from a NUMA Node. ",
    "return_type": "LPVOID",
    "category": "Processes",
    "name": "VirtualAllocExNuma",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right. For more information,         see         Process Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "The pointer that specifies a desired starting address for the region of pages that you want to allocate. If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation         granularity. If you are committing memory that is already reserved, the function rounds this address down to the nearest         page boundary. To determine the size of a page and the allocation granularity on the host computer, use the         GetSystemInfo function. If lpAddress is NULL, the function determines where to         allocate the region."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region of memory to be allocated, in bytes. If lpAddress is NULL, the function rounds         dwSize up to the next page boundary. If lpAddress is not NULL, the function allocates all         pages that contain one or more bytes in the range from lpAddress to         (lpAddress+dwSize). This means, for example, that a 2-byte         range that straddles a page boundary causes the function to allocate both pages."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flAllocationType",
        "description": "The type of memory allocation. This parameter must contain one of the following values.  ValueMeaning  MEM_COMMIT 0x00001000   Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified           reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,           the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are           actually accessed. To reserve and commit pages in one step, call the function with           MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without           MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been reserved. The resulting           error code is ERROR_INVALID_ADDRESS. An attempt to commit a page that is already committed does not cause the function to fail. This means that           you can commit pages without first determining the current commitment state of each page.   MEM_RESERVE 0x00002000   Reserves a range of the process's virtual address space without allocating any actual physical storage in           memory or in the paging file on disk. You commit reserved pages by calling the function again with MEM_COMMIT. To           reserve and commit pages in one step, call the function with           MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and           LocalAlloc, cannot use reserved memory until it has           been released.   MEM_RESET 0x00080000   Indicates that data in the memory range specified by lpAddress and           dwSize is no longer of interest. The pages should not be read from or written to           the paging file. However, the memory block will be used again later, so it should not be decommitted. This           value cannot be used with any other value. Using this value does not guarantee that the range operated on with MEM_RESET           will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it. When you use MEM_RESET, the function ignores the value of           fProtect. However, you must still set fProtect to a valid           protection value, such as PAGE_NOACCESS. The function returns an error if you use MEM_RESET and the range of memory is           mapped to a file. A shared view is only acceptable if it is mapped to a paging file.   MEM_RESET_UNDO 0x1000000   MEM_RESET_UNDO should only be called on an address range to which           MEM_RESET was successfully applied earlier. It indicates that the data in the           specified memory range specified by lpAddress and dwSize           is of interest to the caller and attempts to reverse the effects of MEM_RESET. If           the function succeeds, that means all data in the specified address range is intact. If the function fails,           at least some of the data in the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an           address range which was not MEM_RESET earlier, the behavior is undefined. When you           specify MEM_RESET, the           VirtualAllocExNuma function ignores the value of           flProtect. However, you must still set flProtect to a           valid protection value, such as PAGE_NOACCESS. Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  The MEM_RESET_UNDO flag is not supported until Windows 8 and            Windows Server 2012.     This parameter can also specify the following values as indicated.  ValueMeaning  MEM_LARGE_PAGES 0x20000000   Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the           GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.   MEM_PHYSICAL 0x00400000   Reserves an address range that can be used to map           Address Windowing Extensions (AWE)           pages. This value must be used with MEM_RESERVE and no other values.   MEM_TOP_DOWN 0x00100000   Allocates memory at the highest possible address."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flProtect",
        "description": "The memory protection for the region of pages to be allocated. If the pages are being committed, you can         specify any one of the         memory protection constants. Protection attributes specified when protecting a page cannot conflict with those specified when allocating         a page."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nndPreferred",
        "description": "The NUMA node where the physical memory should reside. Used only when allocating a new VA region (either committed or reserved). Otherwise this parameter is ignored         when the API is used to commit pages in a region that already exists"
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Returns the number of active processors in a processor group or in the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of active processors in the specified group. If the function fails, the return value is zero. To get extended error information, use GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetActiveProcessorCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "GroupNumber",
        "description": "The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the number of active processors in the system."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the number of active processor groups in the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of active processor groups in the system. If the function fails, the return value is zero. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "WORD",
    "category": "Processes",
    "name": "GetActiveProcessorGroupCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the processor group and number of the logical processor in which the calling thread is running.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the ProcNumber parameter contains the group and processor number of the processor on which the calling thread is running. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "GetCurrentProcessorNumberEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PPROCESSOR_NUMBER",
        "name": "ProcNumber",
        "description": "A pointer to a PROCESSOR_NUMBER structure that receives the processor group to which the logical processor is assigned and the number of the logical processor within its group."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves information about the relationships of logical processors and related hardware.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE and at least one SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is written to the output buffer. If the function fails, the return value is FALSE. To get extended error information, call  GetLastError. ",
    "remarks": "If a 32-bit process running under WOW64 calls this function on a system with more than 64 processors, some of the processor affinity masks returned by the function may be incorrect. This is  because the high-order DWORD of the 64-bit KAFFINITY structure that represents all 64 processors is \"folded\" into a 32-bit KAFFINITY structure in the caller's buffer. As a result, the affinity masks for processors 32 through 63 are incorrectly represented as duplicates of the masks for processors 0 through 31. In addition, the sum of all per-group ActiveProcessorCount and MaximumProcessorCount values reported in PROCESSOR_GROUP_INFO structures may exclude some active logical processors. When this function is called with a relationship type of RelationProcessorCore, it returns a PROCESSOR_RELATIONSHIP structure for every active processor core in every processor group in the system. This is by design, because an unaffinitized 32-bit thread can run on any logical processor in a given group, including processors 32 through 63. A 32-bit caller can use the total count of PROCESSOR_RELATIONSHIP structures to determine the actual number of active processor cores on the system. However, the affinity of a 32-bit thread cannot be explicitly set to logical processor 32 through 63 of any processor group. To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetLogicalProcessorInformationEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LOGICAL_PROCESSOR_RELATIONSHIP",
        "name": "RelationshipType",
        "description": "The type of relationship to retrieve. This parameter can be one of the following LOGICAL_PROCESSOR_RELATIONSHIP values.  ValueMeaning  RelationCache 2   Retrieves information about logical processors  that share a cache.    RelationNumaNode 1   Retrieves information about logical processors  that are part of the same NUMA node.    RelationProcessorCore 0   Retrieves information about logical processors that share a single processor core.    RelationProcessorPackage 3   Retrieves information about logical processors that share a physical package.    RelationGroup 4   Retrieves information about logical processors that share a processor group.    RelationAll 0xffff   Retrieves information about logical processors for all relationship types (cache, NUMA node, processor core, physical package, and processor group)."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX",
        "name": "Buffer",
        "description": "A pointer to a buffer that receives  an array of SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structures. If the function fails, the contents of this buffer are undefined."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "ReturnedLength",
        "description": "On input, specifies the length of the buffer pointed to by  Buffer, in bytes. If the buffer is large enough to contain all of the data, this function succeeds and ReturnedLength is set to the number of bytes returned. If the buffer is not large enough to contain all of the data, the function fails, GetLastError returns ERROR_INSUFFICIENT_BUFFER, and ReturnedLength is set to the buffer length required to contain all of the data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of ReturnedLength is undefined."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Returns the maximum number of logical processors that a processor group or the system can have.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the maximum number of processors that the specified group can have. If the function fails, the return value is zero. To get extended error information, use GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Processes",
    "name": "GetMaximumProcessorCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "GroupNumber",
        "description": "The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the maximum number of processors that the system can have."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the maximum number of processor groups that the system can have.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the maximum number of processor groups that the system can have. If the function fails, the return value is zero. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "WORD",
    "category": "Processes",
    "name": "GetMaximumProcessorGroupCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the accumulated cycle time for the idle thread on each logical processor in the specified processor group.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Realtimeapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use GetLastError. ",
    "remarks": "To compile an application that uses this function, set _WIN32_WINNT >= 0x0601. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryIdleProcessorCycleTimeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Group",
        "description": "The number of the processor group for which to retrieve the cycle time."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "BufferLength",
        "description": "On input, specifies the size of the ProcessorIdleCycleTime buffer, in bytes. This buffer is expected to be 8 times the number of processors in the group.  On output, specifies the number of elements written to the buffer. If the buffer size is not sufficient, the function fails and this parameter receives the required length of the buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "ProcessorIdleCycleTime",
        "description": "The number of CPU clock cycles used by each idle thread. If this parameter is NULL, the function updates the BufferLength parameter with the required length."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Creates a user-mode scheduling (UMS) completion list.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call         GetLastError. Possible error values include the         following.  ",
    "remarks": "A completion list is associated with a UMS scheduler thread when the      EnterUmsSchedulingMode function is called to       create the scheduler thread. The system queues newly created UMS worker threads to the completion list. It also       queues previously blocked UMS worker threads to the completion list when the threads are no longer blocked. When an application's UmsSchedulerProc entry       point function is called, the application's scheduler should retrieve items from the completion list by calling       DequeueUmsCompletionListItems. Each completion list has an associated completion list event which is signaled whenever the system queues       items to an empty list. Use the       GetUmsCompletionListEvent to obtain a       handle to the event for a specified completion list. When a completion list is no longer needed, use the       DeleteUmsCompletionList to release the list.       The list must be empty before it can be released. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "CreateUmsCompletionList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PUMS_COMPLETION_LIST*",
        "name": "UmsCompletionList",
        "description": "A PUMS_COMPLETION_LIST variable. On output, this parameter receives a pointer        to an empty UMS completion list."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Creates a user-mode scheduling (UMS) thread context to represent a UMS worker thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include the following.  ",
    "remarks": "A UMS thread context represents the state of a UMS worker thread. Thread contexts are used to specify UMS worker threads in function calls. A UMS worker thread is created by calling the CreateRemoteThreadEx function after using InitializeProcThreadAttributeList and UpdateProcThreadAttribute to prepare a list of UMS attributes for the thread. The underlying structures for a UMS thread context are managed by the system and should not be modified directly. To get and set information about a UMS worker thread, use the QueryUmsThreadInformation and SetUmsThreadInformation functions. After a UMS worker thread terminates, its thread context should be released by calling DeleteUmsThreadContext. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "CreateUmsThreadContext",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PUMS_CONTEXT*",
        "name": "lpUmsThread",
        "description": "A PUMS_CONTEXT variable. On output, this parameter receives a pointer to a UMS thread context."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes the specified user-mode scheduling (UMS) completion list. The list must be empty.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "If the completion list is shared, the caller is responsible for ensuring that no active UMS thread holds a reference to the list before deleting it. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "DeleteUmsCompletionList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_COMPLETION_LIST",
        "name": "UmsCompletionList",
        "description": "A pointer to the UMS completion list to be deleted. The CreateUmsCompletionList function provides this pointer."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes  the specified user-mode scheduling (UMS) thread context. The thread must be terminated.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "A UMS thread context cannot be deleted until the associated thread has terminated. When a UMS worker thread finishes running (for example, by returning from its thread entry point function),   the system terminates the thread,  sets the  termination status in the thread's UMS thread context, and queues the UMS thread context to the associated completion list.   Any attempt to execute the  UMS thread will fail because the thread is already terminated. To check the termination status of a thread, the application's scheduler should call QueryUmsThreadInformation with the UmsIsThreadTerminated information class. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "DeleteUmsThreadContext",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_CONTEXT",
        "name": "UmsThread",
        "description": "A pointer to the UMS thread context to be deleted. The CreateUmsThreadContext function provides this pointer."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves user-mode scheduling (UMS) worker threads from the specified UMS completion list.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include the following.  ",
    "remarks": "The system queues a UMS worker thread to a completion list when the worker thread is created or when a previously blocked worker thread becomes unblocked. The DequeueUmsCompletionListItems function retrieves a pointer to a list of all thread contexts in the specified completion list. The GetNextUmsListItem function can be used to pop UMS thread contexts off the list into the scheduler's own ready thread queue. The scheduler is responsible for selecting threads to run based on priorities chosen by the application. Do not run UMS threads directly from the list provided by DequeueUmsCompletionListItems, or run a thread transferred from the list to  the ready thread queue before the list is completely empty. This can cause unpredictable behavior in the application. If more than one caller attempts to retrieve threads from a shared completion list, only the first caller retrieves the threads. For subsequent callers,  the DequeueUmsCompletionListItems function returns success but the UmsThreadList parameter is set to NULL. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "DequeueUmsCompletionListItems",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_COMPLETION_LIST",
        "name": "UmsCompletionList",
        "description": "A pointer to the completion list from which to retrieve worker threads."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "WaitTimeOut",
        "description": "The time-out interval for the retrieval operation, in milliseconds. The function returns if the interval elapses, even if no worker threads are queued to the completion list. If the WaitTimeOut parameter is zero, the completion list is checked for available worker threads without waiting for worker threads to become available. If the WaitTimeOut parameter is INFINITE, the function's time-out interval never elapses. This is not recommended, however, because it causes the function to block until one or more worker threads become available."
      },
      {
        "in_out": "_Out_",
        "type": "PUMS_CONTEXT*",
        "name": "UmsThreadList",
        "description": "A pointer to a UMS_CONTEXT variable. On output, this parameter receives a pointer to the first UMS thread context in a list of UMS thread contexts.  If no worker threads are available before the time-out specified by the WaitTimeOut parameter, this parameter is set to NULL."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Converts the calling thread into a user-mode scheduling (UMS) scheduler thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "An application's UMS scheduler creates one UMS scheduler thread for each processor that will be used to run UMS threads. The scheduler typically sets the affinity of the scheduler thread for a single processor, effectively reserving the processor for the use of that scheduler thread. For more information about thread affinity, see Multiple Processors. When a UMS scheduler thread is created, the system calls the UmsSchedulerProc entry point function specified with the EnterUmsSchedulingMode function call.  The application's scheduler is responsible for finishing any application-specific initialization of the scheduler thread and selecting a UMS worker thread to run. The application's scheduler selects a UMS worker thread to run by calling ExecuteUmsThread with the worker thread's UMS thread context. The worker thread runs until it yields control by calling UmsThreadYield, blocks, or terminates. The scheduler thread is then available to run another worker thread. A scheduler thread should continue to run until all of its worker threads reach a natural stopping point: that is, all worker threads have yielded, blocked, or  terminated. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "EnterUmsSchedulingMode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_SCHEDULER_STARTUP_INFO",
        "name": "SchedulerStartupInfo",
        "description": "A pointer to a UMS_SCHEDULER_STARTUP_INFO structure that specifies UMS attributes for the thread, including a completion list and a UmsSchedulerProc     entry point function."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Runs the specified UMS worker thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it does not return a value. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error codes include the following.  ",
    "remarks": "The ExecuteUmsThread function loads the state of the specified UMS worker thread over the state of the calling UMS scheduler thread so that the worker thread can run. The worker thread runs until it yields by calling the UmsThreadYield function, blocks, or terminates. When a worker thread yields or blocks, the system calls the scheduler thread's UmsSchedulerProc entry point function. When a previously blocked worker thread becomes unblocked, the system queues the worker thread to the completion list specified with the UpdateProcThreadAttribute function when the worker thread was created. The ExecuteUmsThread function does not return unless an error occurs. If the function returns ERROR_RETRY, the error is transitory and the operation can be retried. If the function returns an error other than ERROR_RETRY, the application's scheduler should check whether the thread is suspended or terminated by calling QueryUmsThreadInformation with UmsThreadIsSuspended or UmsThreadIsTerminated, respectively. Other possible errors include calling the function on a thread that is not   a UMS scheduler thread, passing an invalid UMS worker thread context, or specifying a worker thread that is already executing on another scheduler thread. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "ExecuteUmsThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUMS_CONTEXT",
        "name": "UmsThread",
        "description": "A pointer to the UMS thread context of the worker thread to run."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the user-mode scheduling (UMS) thread context of the calling UMS thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns a pointer to the UMS thread context of the calling thread. If calling thread is not a UMS thread, the function returns NULL. To get extended error information, call GetLastError. ",
    "remarks": "The GetCurrentUmsThread function can be called for a UMS scheduler thread or UMS worker thread. ",
    "return_type": "PUMS_CONTEXT",
    "category": "Processes",
    "name": "GetCurrentUmsThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Returns the next user-mode scheduling (UMS) thread context in a list of thread contexts.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a pointer to the next thread context in the list. If there is no thread context after the context specified by the UmsContext parameter,  the function returns NULL. To get extended error information, call GetLastError. ",
    "remarks": "",
    "return_type": "PUMS_CONTEXT",
    "category": "Processes",
    "name": "GetNextUmsListItem",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUMS_CONTEXT",
        "name": "UmsContext",
        "description": "A pointer to a UMS context in a list of thread contexts. This list is retrieved by the DequeueUmsCompletionListItems function."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a handle to the event associated with the specified user-mode scheduling (UMS) completion list.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "The system signals a UMS completion list event when the system queues items to an empty completion list. A completion list event handle can be used with any wait function that takes a handle to an event. When the event is signaled, an application typically calls DequeueUmsCompletionListItems to retrieve the contents of the completion list. The event handle remains valid until its completion list is deleted. Do not use the event handle to wait on a completion list that has been deleted or is in the process of being deleted. When the handle is no longer needed, use the CloseHandle function to close the handle. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetUmsCompletionListEvent",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_COMPLETION_LIST",
        "name": "UmsCompletionList",
        "description": "A pointer to a UMS completion list. The CreateUmsCompletionList function provides this pointer."
      },
      {
        "in_out": "_Inout_",
        "type": "PHANDLE",
        "name": "UmsCompletionEvent",
        "description": "A pointer to a HANDLE variable. On output, the UmsCompletionEvent parameter is set to a handle to the event associated with the specified completion list."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Queries whether the specified thread is a UMS scheduler thread, a UMS worker thread, or a non-UMS thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 with SP1 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns TRUE if the specified thread matches the kind of thread specified by the SystemThreadInfo parameter. Otherwise, the function returns FALSE. ",
    "remarks": "The GetUmsSystemThreadInformation function is intended for use in debuggers, troubleshooting tools, and profiling applications. For example, thread-isolated tracing or single-stepping through instructions might involve suspending all other threads in the process. However, if the thread to be traced is a UMS worker thread, suspending UMS scheduler threads might cause a deadlock because a UMS worker thread requires the intervention of a UMS scheduler thread in order to run. A debugger can call GetUmsSystemThreadInformation for each thread that it might suspend to determine the kind of thread, and then suspend it or not as needed for the code being debugged. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "GetUmsSystemThreadInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ThreadHandle",
        "description": "A handle to a thread. The thread handle must have the THREAD_QUERY_INFORMATION access right. For more information, see Thread Security and Access Rights."
      },
      {
        "in_out": "_Inout_",
        "type": "PUMS_SYSTEM_THREAD_INFORMATION",
        "name": "SystemThreadInfo",
        "description": "A pointer to an initialized UMS_SYSTEM_THREAD_INFORMATION structure that specifies the kind of thread for the query."
      }
    ],
    "min_client": "Windows 7 with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information about the specified user-mode scheduling (UMS) worker thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include the following.  ",
    "remarks": "The QueryUmsThreadInformation function retrieves information about the specified UMS worker thread such as its application-defined context, its thread execution block (TEB), and whether the thread is suspended or terminated. The underlying structures for UMS worker threads are managed by the system. Information that is not exposed through QueryUmsThreadInformation should be considered reserved. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "QueryUmsThreadInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_CONTEXT",
        "name": "UmsThread",
        "description": "A pointer to a UMS thread context."
      },
      {
        "in_out": "_In_",
        "type": "UMS_THREAD_INFO_CLASS",
        "name": "UmsThreadInfoClass",
        "description": "A UMS_THREAD_INFO_CLASS value that specifies the kind of information to retrieve."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "UmsThreadInformation",
        "description": "A pointer to a buffer to receive the specified information. The required size of this buffer depends on the specified information class. If the information class is UmsThreadContext or UmsThreadTeb, the buffer must be sizeof(PVOID). If the information class is UmsThreadIsSuspended or UmsThreadIsTerminated, the buffer must be sizeof(BOOLEAN)."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UmsThreadInformationLength",
        "description": "The size of the UmsThreadInformation buffer, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a ULONG variable. On output, this parameter receives the number of bytes written to the UmsThreadInformation buffer."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets application-specific context information for the specified user-mode scheduling (UMS) worker thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include the following.  ",
    "remarks": "The SetUmsThreadInformation function can be used to set an application-defined context for the specified UMS worker thread. The context information can consist of anything the application might find useful to track, such as per-scheduler or per-worker thread state. The underlying structures for UMS worker threads are managed by the system and should not be modified directly. The QueryUmsThreadInformation function can be used to retrieve other exposed information about the specified thread, such as its thread execution block (TEB) and whether the thread is suspended or terminated. Information that is not exposed through QueryUmsThreadInformation should be considered reserved. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "SetUmsThreadInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUMS_CONTEXT",
        "name": "UmsThread",
        "description": "A pointer to a UMS thread context."
      },
      {
        "in_out": "_In_",
        "type": "UMS_THREAD_INFO_CLASS",
        "name": "UmsThreadInfoClass",
        "description": "A UMS_THREAD_INFO_CLASS value that specifies the kind of information to set. This parameter must be UmsThreadUserContext."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "UmsThreadInformation",
        "description": "A pointer to a buffer that contains the information to set."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UmsThreadInformationLength",
        "description": "The size of the UmsThreadInformation buffer, in bytes."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The application-defined user-mode scheduling (UMS) scheduler entry point function associated with a UMS completion list.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The UmsSchedulerProc function pointer type is defined as PUMS_SCHEDULER_ENTRY_POINT in WinBase.h. The underlying function type is defined as RTL_UMS_SCHEDULER_ENTRY_POINT in WinNT.h Each UMS scheduler thread has an associated UmsSchedulerProc entry point function that is specified when the thread calls the EnterUmsSchedulingMode function. The system calls the scheduler entry point function with a reason of UmsSchedulerStartup when the scheduler thread is converted for UMS. Subsequently, when a UMS worker thread that is running on the scheduler thread yields or blocks, the system calls the scheduler thread's entry point function with a pointer to the UMS thread context of the worker thread. The application's scheduler is responsible for selecting the next UMS worker thread to run. The scheduler implements all policies that influence execution of its UMS threads, including processor affinity and thread priority. For example, a scheduler might give priority to I/O-intensive threads, or it might run threads on a first-come, first-served basis. This logic can be implemented in the scheduler entry point function or elsewhere in the application. When a blocked UMS worker thread becomes unblocked, the system queues the unblocked thread to the associated completion list and signals the completion list event. To retrieve UMS worker threads from the completion list, use the DequeueUmsCompletionListItems function. ",
    "return_type": "VOID",
    "category": "Processes",
    "name": "UmsSchedulerProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UMS_SCHEDULER_REASON",
        "name": "Reason",
        "description": "The reason the scheduler entry point is being called. This parameter can be one of the following values.  ValueMeaning  UmsSchedulerStartup 0   A UMS scheduler thread was created. The entry point is called with this reason once each time  EnterUmsSchedulingMode is called.   UmsSchedulerThreadBlocked 1   A UMS worker thread blocked.   UmsSchedulerThreadYield 2   An executing UMS worker thread yielded control by calling the UmsThreadYield function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "ActivationPayload",
        "description": "If the Reason parameter is UmsSchedulerStartup, this parameter is NULL. If the Reason parameter is  UmsSchedulerThreadBlocked, bit 0 of this parameter indicates the type of activity that was being serviced when the UMS worker thread blocked.   ValueMeaning  0   The thread blocked on a trap (for example, a hard page fault) or an interrupt (for example, an asynchronous procedure call).   1   The thread blocked on a system call.     If the Reason parameter is UmsSchedulerThreadYield, this parameter is a pointer to the UMS thread context of the UMS worker thread that yielded."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SchedulerParam",
        "description": "If the Reason parameter is UmsSchedulerStartup, this parameter is the SchedulerParam member of the UMS_SCHEDULER_STARTUP_INFO structure passed to the EnterUmsSchedulingMode function that triggered the entry point call.  If the Reason parameter is UmsSchedulerThreadYield this parameter is the SchedulerParam parameter passed to the UmsThreadYield function that triggered the entry point call.  If the Reason parameter is UmsSchedulerThreadBlocked, this parameter is NULL."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Yields control to the user-mode scheduling (UMS) scheduler thread on which the calling UMS worker thread is running.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "A UMS worker thread calls the UmsThreadYield function to cooperatively yield control to the UMS scheduler thread on which the worker thread is running. If a UMS worker thread never calls UmsThreadYield, the worker thread runs until it either blocks or is terminated. When control switches to the UMS scheduler thread, the system calls the associated scheduler entry point function with the reason UmsSchedulerThreadYield and the ScheduleParam parameter specified by the worker thread in the UmsThreadYield call. The application's scheduler is responsible for rescheduling the worker thread. ",
    "return_type": "BOOL",
    "category": "Processes",
    "name": "UmsThreadYield",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SchedulerParam",
        "description": "A parameter to pass to the scheduler thread's UmsSchedulerProc function."
      }
    ],
    "min_client": "Windows 7 (64-bit only) [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "[NtGetCurrentProcessorNumber      may be altered or unavailable in future versions of Windows. Applications should use the      GetCurrentProcessorNumber function      instead.]",
    "library": "",
    "min_server": "",
    "header": "",
    "return_value": "The function returns the current processor number. ",
    "remarks": "This function is used to provide information for estimating process performance. This function has no associated import library. You must use the      LoadLibrary and      GetProcAddress functions to dynamically link to      Ntdll.dll. ",
    "return_type": "ULONG",
    "category": "Processes",
    "name": "NtGetCurrentProcessorNumber",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "[NtQueryInformationProcess may be altered or unavailable in future versions of Windows. Applications should use the alternate functions listed in this topic.]",
    "library": "",
    "min_server": "",
    "header": "Winternl.h",
    "return_value": "The function returns  an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation under Kernel-Mode Driver Architecture / Design Guide / Driver Programming Techniques / Logging Errors. ",
    "remarks": "The NtQueryInformationProcess function and the structures that it returns are internal to the operating system and  subject to change from one  release of Windows to another.  To maintain the    compatibility of your application, it is better to use public functions mentioned in the description of the ProcessInformationClass parameter instead. If you do use NtQueryInformationProcess, access the function through run-time dynamic linking.  This gives  your code an opportunity to respond gracefully if the function has been   changed or removed from the operating system. Signature changes, however, may not be detectable. This function has no associated import library. You must use the LoadLibrary and GetProcAddress functions to dynamically link to Ntdll.dll. ",
    "return_type": "NTSTATUS",
    "category": "Processes",
    "name": "NtQueryInformationProcess",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process for which information is to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "PROCESSINFOCLASS",
        "name": "ProcessInformationClass",
        "description": "The type of process information to be retrieved. This parameter can be one of the following values from the PROCESSINFOCLASS enumeration.  ValueMeaning  ProcessBasicInformation 0   Retrieves a pointer to a PEB structure that can be used to determine whether the specified process is being debugged, and a unique value used by the system to identify the specified process.  It is best to use the CheckRemoteDebuggerPresent and GetProcessId  functions to obtain this information.   ProcessDebugPort 7   Retrieves a DWORD_PTR value that is the port number of the debugger for the process. A nonzero value indicates that the process is being run under the control of a ring 3 debugger. It is best to use the CheckRemoteDebuggerPresent or IsDebuggerPresent function.   ProcessWow64Information 26   Determines whether the process is running in the WOW64 environment (WOW64 is the x86 emulator that allows Win32-based applications to run on 64-bit Windows). It is best to use the  IsWow64Process function to obtain this information.   ProcessImageFileName 27   Retrieves a UNICODE_STRING value containing the name of the image file for the process. It is best to use the QueryFullProcessImageName or GetProcessImageFileName function to obtain this information.   ProcessBreakOnTermination 29   Retrieves a ULONG value indicating whether the process is considered critical. Note  This value can be used starting in Windows XP with SP3. Starting in Windows 8.1, IsProcessCritical should be used instead.     ProcessSubsystemInformation 75   Retrieves a SUBSYSTEM_INFORMATION_TYPE value indicating the subsystem type of the process. The buffer pointed to by the ProcessInformation parameter should be large enough to hold a single SUBSYSTEM_INFORMATION_TYPE enumeration."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "ProcessInformation",
        "description": "A pointer to a buffer supplied by the calling application into which the function writes the requested information. The size of the information written varies depending on the data type of the ProcessInformationClass parameter:   PROCESS_BASIC_INFORMATION  When the ProcessInformationClass  parameter is ProcessBasicInformation,  the buffer pointed to by the ProcessInformation parameter should be large enough to hold a single PROCESS_BASIC_INFORMATION structure having the following layout:       Copy     typedef struct _PROCESS_BASIC_INFORMATION {     PVOID Reserved1;     PPEB PebBaseAddress;     PVOID Reserved2[2];     ULONG_PTR UniqueProcessId;     PVOID Reserved3; } PROCESS_BASIC_INFORMATION;     The UniqueProcessId member points to the system's unique identifier for this process. It is best to use the GetProcessId function to retrieve this information. The PebBaseAddress member points to a PEB structure. The  other members of this structure are reserved for internal use by the operating system.  ULONG_PTR  When the ProcessInformationClass  parameter is ProcessWow64Information,  the buffer pointed to by the ProcessInformation parameter should be large enough to hold a  ULONG_PTR. If this value is nonzero, the process is running in a WOW64 environment; otherwise, if the value is equal to zero, the process is not running in a WOW64 environment. It is best to use the IsWow64Process function to determine whether a process is running in the WOW64 environment.  UNICODE_STRING  When the ProcessInformationClass  parameter is ProcessImageFileName,  the buffer pointed to by the ProcessInformation parameter should be large enough to hold a  UNICODE_STRING structure as well as the string itself. The string stored in the Buffer member is the name of the image file. If the buffer is too small, the function fails with the STATUS_INFO_LENGTH_MISMATCH error code and the ReturnLength parameter is set to the required buffer size."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ProcessInformationLength",
        "description": "The size of the buffer pointed to by the ProcessInformation parameter, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a variable in which the function returns the size of the requested information. If the function was successful, this is the size of the information written to the buffer pointed to by the ProcessInformation parameter, but if the buffer was too small, this is the minimum size of buffer needed to receive the information successfully."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "[NtQueryInformationThread may be altered or unavailable in future versions of Windows. Applications should use the alternate functions listed in this topic.]",
    "library": "",
    "min_server": "",
    "header": "Winternl.h",
    "return_value": "Returns an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation under Kernel-Mode Driver Architecture / Design Guide / Driver Programming Techniques / Logging Errors. ",
    "remarks": "The NtQueryInformationThread function is internal to the operating system and  subject to change from one  release of Windows to another.  To maintain the    compatibility of your application, it is better to use the public  function previously mentioned instead. If you do use NtQueryInformationThread, access the function through run-time dynamic linking.  This gives  your code an opportunity to respond gracefully if the function has been   changed or removed from the operating system. Signature changes, however, may not be detectable. This function has no associated import library. You must use the LoadLibrary and GetProcAddress functions to dynamically link to Ntdll.dll. ",
    "return_type": "NTSTATUS",
    "category": "Processes",
    "name": "NtQueryInformationThread",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ThreadHandle",
        "description": "A handle to the thread about which information is being requested."
      },
      {
        "in_out": "_In_",
        "type": "THREADINFOCLASS",
        "name": "ThreadInformationClass",
        "description": "If this parameter is the ThreadIsIoPending value of the  THREADINFOCLASS enumeration, the function determines whether the thread has any I/O operations pending. Use the public  function GetThreadIOPendingFlag instead to obtain this information. If this parameter is the ThreadQuerySetWin32StartAddress value of the THREADINFOCLASS enumeration, the function returns the start address of the thread. Note that on versions of Windows prior to Windows Vista, the returned start address is only reliable before the thread starts running. If this parameter is the ThreadSubsystemInformation value of the  THREADINFOCLASS enumeration, the function retrieves a SUBSYSTEM_INFORMATION_TYPE value indicating the subsystem type of the thread. The buffer pointed to by the ThreadInformation parameter should be large enough to hold a single SUBSYSTEM_INFORMATION_TYPE enumeration."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "ThreadInformation",
        "description": "A pointer to a buffer in which the function writes the requested information. If ThreadIsIoPending is specified for the ThreadInformationClass parameter, this buffer must be large enough to hold a ULONG value, which indicates whether  the specified thread has I/O requests pending. If this value is equal to zero, then there are no I/O operations pending; otherwise, if the value is nonzero, then the thread does have I/O operations pending. Use the public  function GetThreadIOPendingFlag instead to obtain this information. If ThreadQuerySetWin32StartAddress is specified for the ThreadInformationClass parameter, this buffer must be large enough to hold a PVOID value, which is the start address of the thread."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ThreadInformationLength",
        "description": "The size of the buffer pointed to by the ThreadInformation parameter, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a variable in which the function returns the size of the requested information. If the function was successful, this is the size of the information written to the buffer pointed to by the ThreadInformation parameter, but if the buffer was too small, this is the minimum size of buffer required to receive the information successfully."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Runs the specified application.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is greater than 31. If the function fails, the return value is one of the following error values.  ",
    "remarks": "The  WinExec function returns when the started process calls the GetMessage function or a time-out limit is reached. To avoid waiting for the time out delay, call the GetMessage function as soon as possible in any process started by a call to  WinExec. The executable name is treated as the first white space-delimited string in lpCmdLine. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run \"Program.exe\", if it exists, instead of \"MyApp.exe\". If a malicious user were to create an application called \"Program.exe\" on a system, any program that incorrectly calls  WinExec using the Program Files directory will run this application instead of the intended application. To avoid this problem, use  CreateProcess rather than  WinExec. However, if you must use  WinExec for legacy reasons, make sure the application name is enclosed in quotation marks as shown in the example below. ",
    "return_type": "UINT",
    "category": "Processes",
    "name": "WinExec",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "lpCmdLine",
        "description": "The command line (file name plus optional parameters) for the application to be executed. If the name of the executable file in the lpCmdLine parameter does not contain a directory path, the system searches for the executable file in this sequence:      The directory from which the application loaded. The current directory. The Windows system directory. The  GetSystemDirectory function retrieves the path of this directory. The Windows directory. The  GetWindowsDirectory function retrieves the path of this directory. The directories listed in the PATH environment variable."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uCmdShow",
        "description": "The display options. For a list of the acceptable values, see the description of the nCmdShow parameter of the  ShowWindow function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[ZwQueryInformationProcess may be altered or unavailable in future versions of Windows. Applications should use the alternate functions listed in this topic.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "",
    "return_value": "Returns  an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation under Kernel-Mode Driver Architecture / Design Guide / Driver Programming Techniques / Logging Errors. ",
    "remarks": "The ZwQueryInformationProcess function and the structures that it returns are internal to the operating system and  subject to change from one  release of Windows to another.  To maintain the    compatibility of your application, it is better to use public functions mentioned in the description of the ProcessInformationClass parameter instead. If you do use ZwQueryInformationProcess, access the function through run-time dynamic linking.  This gives  your code an opportunity to respond gracefully if the function has been   changed or removed from the operating system. Signature changes, however, may not be detectable. This function has no associated import library. You must use the LoadLibrary and GetProcAddress functions to dynamically link to Ntdll.dll. ",
    "return_type": "NTSTATUS",
    "category": "Processes",
    "name": "ZwQueryInformationProcess",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process for which information is to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "PROCESSINFOCLASS",
        "name": "ProcessInformationClass",
        "description": "The type of process information to be retrieved. This parameter can be one of the following values from the PROCESSINFOCLASS enumeration.  ValueMeaning  ProcessBasicInformation 0   Retrieves a pointer to a PEB structure that can be used to determine whether the specified process is being debugged, and a unique value used by the system to identify the specified process.  It is best to use the CheckRemoteDebuggerPresent and GetProcessId  functions to obtain this information.   ProcessDebugPort 7   Retrieves a DWORD_PTR value that is the port number of the debugger for the process. A nonzero value indicates that the process is being run under the control of a ring 3 debugger. It is best to use the CheckRemoteDebuggerPresent or IsDebuggerPresent function.   ProcessWow64Information 26   Determines whether the process is running in the WOW64 environment (WOW64 is the x86 emulator that allows Win32-based applications to run on 64-bit Windows). It is best to use the  IsWow64Process function to obtain this information.   ProcessImageFileName 27   Retrieves a UNICODE_STRING value containing the name of the image file for the process.   ProcessBreakOnTermination 29   Retrieves a ULONG value indicating whether the process is considered critical. Note  This value can be used starting in Windows XP with SP3. Starting in Windows 8.1, IsProcessCritical should be used instead."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "ProcessInformation",
        "description": "A pointer to a buffer supplied by the calling application into which the function writes the requested information. The size of the information written varies depending on the value of the ProcessInformationClass parameter:   PROCESS_BASIC_INFORMATION  When the ProcessInformationClass  parameter is ProcessBasicInformation,  the buffer pointed to by the ProcessInformation parameter should be large enough to hold a single PROCESS_BASIC_INFORMATION structure having the following layout:       Copy     typedef struct _PROCESS_BASIC_INFORMATION {     PVOID Reserved1;     PPEB PebBaseAddress;     PVOID Reserved2[2];     ULONG_PTR UniqueProcessId;     PVOID Reserved3; } PROCESS_BASIC_INFORMATION;     The UniqueProcessId member points to the system's unique identifier for this process. It is best to use the GetProcessId function to retrieve this information. The PebBaseAddress member points to a PEB structure. The  other members of this structure are reserved for internal use by the operating system.  ULONG_PTR  When the ProcessInformationClass  parameter is ProcessWow64Information,  the buffer pointed to by the ProcessInformation parameter should be large enough to hold a  ULONG_PTR. If this value is nonzero, the process is running in a WOW64 environment; otherwise, if the value is equal to zero, the process is not running in a WOW64 environment. It is best to use the IsWow64Process function to determine whether a process is running in the WOW64 environment.  UNICODE_STRING  When the ProcessInformationClass  parameter is ProcessImageFileName,  the buffer pointed to by the ProcessInformation parameter should be large enough to hold a  UNICODE_STRING structure as well as the string itself. The string stored in the Buffer member is the name of the image file. If the buffer is too small, the function fails with the STATUS_INFO_LENGTH_MISMATCH error code and the ReturnLength parameter is set to the required buffer size."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ProcessInformationLength",
        "description": "The size of the buffer pointed to by the ProcessInformation parameter, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a variable in which the function returns the size of the requested information. If the function was successful, this is the size of the information written to the buffer pointed to by the ProcessInformation parameter, but if the buffer was too small, this is the minimum size of buffer needed to receive the information successfully."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]