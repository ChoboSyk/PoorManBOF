[
  {
    "n_arguments": 1,
    "description": "Registers a callback function to be called when a secured memory range is freed or its protections are      changed.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it registers the callback function and returns        TRUE. If the function fails, it returns FALSE. To get extended error information, call        the GetLastError function. ",
    "remarks": "An application that performs I/O directly to a high-performance device typically caches a virtual-to-physical      memory mapping for the buffer it uses for the I/O. The device's driver typically secures this memory address range      by calling the MmSecureVirtualMemory routine,      which prevents the memory range from being freed or its protections  changed until the driver unsecures the      memory. An application can use      AddSecureMemoryCacheCallback to register      a callback function that will be called when the memory is freed or its protections are changed, so the      application can invalidate its cached memory mapping. For more information, see      SecureMemoryCacheCallback. To compile an application that uses this function, define _WIN32_WINNT as 0x0600      or later. For more information, see      Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "AddSecureMemoryCacheCallback",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURE_MEMORY_CACHE_CALLBACK",
        "name": "pfnCallBack",
        "description": "A pointer to the application-defined        SecureMemoryCacheCallback function to        register."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Copies a block of memory from one location to another.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function has no return value. ",
    "remarks": "This function is defined as the RtlCopyMemory      function. Its implementation is provided inline. For more information, see WinBase.h and      WinNT.h. If the source and destination blocks overlap, the results are undefined. For overlapped blocks, use the      MoveMemory function. The first parameter, Destination, must be large enough to hold       Length bytes of Source; otherwise, a buffer overrun may       occur. This may lead to a denial of service attack against the application if an access violation occurs or, in       the worst case, allow an attacker to inject executable code into your process. This is especially true if       Destination is a stack-based buffer. Be aware that the last parameter,       Length, is the number of bytes to copy into Destination, not       the size of the Destination. The following code example shows a safer way to use       CopyMemory. Alternatively, you could use the       memcpy_s or wmemcpy_s function. ",
    "return_type": "void",
    "category": "Memory Management",
    "name": "CopyMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Destination",
        "description": "A pointer to the starting address of the copied block's destination."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "Source",
        "description": "A pointer to the starting address of the block of memory to copy."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The size of the block of memory to copy, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Creates a memory resource notification object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a memory resource notification object. If the function fails, the return value is NULL. To get extended  information, call         GetLastError. ",
    "remarks": "Applications can use memory resource notification events to scale the memory usage as appropriate. If      available memory is low, the application can reduce its working set. If available memory is high, the application      can allocate more memory. Any thread of the calling process can specify the memory resource notification handle in a call to the      QueryMemoryResourceNotification      function or one of the wait functions. The state of the      object is signaled when the specified memory condition exists. This is a system-wide event, so all applications      receive notification when the object is signaled. Note that there is a range of memory availability where neither      the LowMemoryResourceNotification or      HighMemoryResourceNotification object is signaled. In this case, applications should      attempt to keep the memory use constant. Use the CloseHandle function to close the handle. The      system closes the handle automatically when the process terminates. The memory resource notification object is      destroyed when its last handle has been closed. To compile an application that uses this function, define the _WIN32_WINNT macro      as 0x0501 or later. For more information, see      Using the Windows Headers. ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "CreateMemoryResourceNotification",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "MEMORY_RESOURCE_NOTIFICATION_TYPE",
        "name": "NotificationType",
        "description": "The memory condition under which the object is to be signaled. This parameter can be one of the following        values from the MEMORY_RESOURCE_NOTIFICATION_TYPE enumeration.  ValueMeaning  LowMemoryResourceNotification 0   Available physical memory is running low.   HighMemoryResourceNotification 1   Available physical memory is high."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the minimum size of a large page.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the processor supports large pages, the return value is the minimum size of a large page. If the processor does not support large pages, the return value is zero. ",
    "remarks": "The minimum large page size varies, but it is typically 2 MB or greater. ",
    "return_type": "SIZE_T",
    "category": "Memory Management",
    "name": "GetLargePageMinimum",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the amount of RAM that is physically installed on the computer.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns TRUE and sets the                     TotalMemoryInKilobytes parameter to a nonzero value. If the function fails, it returns FALSE and does not modify the                     TotalMemoryInKilobytes parameter. To get extended error information, use the GetLastError function. Common errors are listed in the following table.  ",
    "remarks": "The GetPhysicallyInstalledSystemMemory function retrieves the amount of physically installed RAM from the computer's SMBIOS  firmware tables. This can differ from the amount reported by the GlobalMemoryStatusEx function, which sets the ullTotalPhys member of the MEMORYSTATUSEX structure to the amount of physical memory that is available for the operating system to use. The amount of memory available to the operating system can be less than the amount of memory physically installed in the computer because the BIOS and some drivers may reserve memory as I/O regions for memory-mapped devices, making the memory unavailable to the operating system and applications. The amount of physical memory retrieved by the GetPhysicallyInstalledSystemMemory function must be equal to or greater than the amount reported by the GlobalMemoryStatusEx function; if it is less, the SMBIOS data is malformed and the function fails with ERROR_INVALID_DATA. Malformed SMBIOS data may indicate a problem with the user's computer. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "GetPhysicallyInstalledSystemMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PULONGLONG",
        "name": "TotalMemoryInKilobytes",
        "description": "A pointer to a  variable that receives the amount of physically installed RAM, in kilobytes."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the current size limits for the working set of the system cache.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see  Using the Windows Headers. The FILE_CACHE constants will be defined in the Windows header files starting with the Windows SDK for Windows Server 2008. If you are using header files from an earlier version of the SDK, add the definitions shown in SetSystemFileCacheSize to your code. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "GetSystemFileCacheSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpMinimumFileCacheSize",
        "description": "A pointer to a variable that receives the minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache, if there is a previous call to the SetSystemFileCacheSize function with the FILE_CACHE_MIN_HARD_ENABLE flag."
      },
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpMaximumFileCacheSize",
        "description": "A pointer to a variable that receives the maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if there is a previous call to SetSystemFileCacheSize with the FILE_CACHE_MAX_HARD_ENABLE flag."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "lpFlags",
        "description": "The flags that indicate which of the file cache limits are enabled.  ValueMeaning  FILE_CACHE_MAX_HARD_ENABLE 0x1   The maximum size limit is enabled. If this flag is not present, this limit is disabled.   FILE_CACHE_MIN_HARD_ENABLE 0x4   The minimum size limit is enabled. If this flag is not present, this limit is disabled."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves the addresses of      the pages that are written to in a region of virtual memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is 0 (zero). If the function fails, the return value is a nonzero value. ",
    "remarks": "When you call the VirtualAlloc function      to reserve or commit memory, you can specify MEM_WRITE_WATCH. This value causes the system to keep track of the      pages that are written to in the committed memory region. You can call the      GetWriteWatch function to retrieve the addresses of the      pages that have been written to since the region has been allocated or the write-tracking state has been reset. To reset the write-tracking state, set the WRITE_WATCH_FLAG_RESET value in the      dwFlags parameter. Alternatively, you can call the      ResetWriteWatch function to reset the write-tracking      state. However, if you use ResetWriteWatch,  you must      ensure that no threads write to the region during the interval between the      GetWriteWatch and      ResetWriteWatch calls. Otherwise, there may be written      pages that you do not detect. The GetWriteWatch function can be useful to      profilers, debugging tools, or garbage collectors. ",
    "return_type": "UINT",
    "category": "Memory Management",
    "name": "GetWriteWatch",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Indicates whether the function resets the write-tracking state.  To reset the write-tracking state, set this        parameter to WRITE_WATCH_FLAG_RESET. If this parameter is 0 (zero),        GetWriteWatch does not reset the write-tracking state.        For more information, see the Remarks section of this topic."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpBaseAddress",
        "description": "The base address of the memory region for which to retrieve write-tracking information.  This address must be in        a memory region that is allocated by the VirtualAlloc        function using MEM_WRITE_WATCH."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwRegionSize",
        "description": "The size of the memory region for which to retrieve write-tracking information, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "lpAddresses",
        "description": "A pointer to a buffer that receives an array of page addresses in the memory region.  The addresses indicate        the pages that have been written to since the region has been allocated or the write-tracking state has been reset."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG_PTR",
        "name": "lpdwCount",
        "description": "On input, this variable indicates the size of the lpAddresses array, in array       elements.  On output, the variable receives the number of page addresses that are returned in the array."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "lpdwGranularity",
        "description": "A pointer to a variable that receives the page size, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves information about the system's current usage of both physical and virtual memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "You can use the  GlobalMemoryStatusEx function to determine how much memory your application can allocate without severely impacting other applications. The information returned by the  GlobalMemoryStatusEx function is volatile. There is no guarantee that two sequential calls to this function will return the same information. The  ullAvailPhys member of the MEMORYSTATUSEX structure at lpBuffer includes memory for all NUMA nodes. The following code shows a simple use of the  GlobalMemoryStatusEx function. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "GlobalMemoryStatusEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPMEMORYSTATUSEX",
        "name": "lpBuffer",
        "description": "A pointer to a  MEMORYSTATUSEX structure that receives information about current memory availability."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Moves a block of memory from one location to another.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function has no return value. ",
    "remarks": "This function is defined as the RtlMoveMemory function. Its implementation is provided inline. For more information, see WinBase.h and Winnt.h. The source and destination blocks may overlap. The first parameter, Destination, must be large enough to hold Length bytes of Source; otherwise, a buffer overrun may occur. This may lead to a denial of service attack against the application if an access violation occurs or, in the worst case, allow an attacker to inject executable code into your process. This is especially true if Destination is a stack-based buffer. Be aware that the last parameter, Length, is the number of bytes to copy into Destination, not the size of the Destination. ",
    "return_type": "void",
    "category": "Memory Management",
    "name": "MoveMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Destination",
        "description": "A pointer to the starting address of the move destination."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "Source",
        "description": "A pointer to the starting address of the block of memory to be moved."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The size of the block of memory to move, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the state of the specified memory resource object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. For more error information, call  GetLastError. ",
    "remarks": "Unlike the  wait functions,  QueryMemoryResourceNotification does not block the calling thread. Therefore, it is an efficient way to check the state of physical memory before proceeding with an operation. To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0501 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "QueryMemoryResourceNotification",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ResourceNotificationHandle",
        "description": "A handle to a memory resource notification object. The  CreateMemoryResourceNotification function returns this handle."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "ResourceState",
        "description": "The memory pointed to by this parameter receives the state of the memory resource notification object. The value of this parameter is set to TRUE if the specified memory condition exists, and  FALSE if the specified memory condition does not exist."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Unregisters a callback function that was previously registered with the AddSecureMemoryCacheCallback function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "RemoveSecureMemoryCacheCallback",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURE_MEMORY_CACHE_CALLBACK",
        "name": "pfnCallBack",
        "description": "A pointer to the application-defined SecureMemoryCacheCallback function to remove."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Resets the      write-tracking state for a region of virtual memory. Subsequent calls to the      GetWriteWatch function only report pages that are written to since the reset operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is 0 (zero). If the function fails, the return value is a nonzero value. ",
    "remarks": "The ResetWriteWatch function can be useful to an      application such as a garbage collector. The application calls the      GetWriteWatch function to retrieve the list of written      pages, and then writes to those pages as part of its cleanup operation. Then the garbage collector calls      ResetWriteWatch to remove the write-tracking records      caused by the cleanup. You can also reset the write-tracking state of a memory region by specifying WRITE_WATCH_FLAG_RESET when you      call GetWriteWatch. If you use ResetWriteWatch, you must ensure that      no threads write to the region during the interval between the      GetWriteWatch and      ResetWriteWatch calls. Otherwise, there may be written      pages that you not detect. ",
    "return_type": "UINT",
    "category": "Memory Management",
    "name": "ResetWriteWatch",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpBaseAddress",
        "description": "A pointer to the base address of the memory region for which to reset the write-tracking state.  This address        must be in a memory region that is allocated by the        VirtualAlloc function with MEM_WRITE_WATCH."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwRegionSize",
        "description": "The size of the memory region for which to reset the write-tracking information, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "An application-defined function previously registered with the      AddSecureMemoryCacheCallback function      that is called when a secured memory range is freed or its protections are changed.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinNT.h (include Windows.h)",
    "return_value": "The return value indicates the success or failure of this function. If the caller has secured the specified memory range, this function should unsecure the memory and return         TRUE. If the caller has not secured the specified memory range, this function should return         FALSE. ",
    "remarks": "After the callback function is registered, it is called after any attempt to free the specified memory range      or change its protections. If the application has secured any part of the specified memory range, the callback      function must invalidate all of the application's cached memory mappings for the secured memory range, unsecure      the secured parts of the memory range, and return TRUE. Otherwise it must  return      FALSE. The application secures and unsecures a memory range by sending requests to a device driver, which uses the      MmSecureVirtualMemory and      MmUnsecureVirtualMemory      functions to actually secure and unsecure the range. Operations on other types of secured or locked memory do not      trigger this callback. Examples of function calls that trigger the callback function include calls to the      VirtualFree,      VirtualFreeEx,      VirtualProtect,      VirtualProtectEx, and      UnmapViewOfFile functions. The callback function can also be triggered by a heap operation. In this case, the function must not perform      any further operations on the heap that triggered the callback. This includes calling      heap functions on a private heap or the process's default      heap, or calling standard library functions such as malloc and      free, which implicitly use the process's default heap. To unregister the callback function, use the      RemoveSecureMemoryCacheCallback      function. ",
    "return_type": "BOOLEAN CALLBACK",
    "category": "Memory Management",
    "name": "SecureMemoryCacheCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Addr",
        "description": "The starting address of the memory range."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Range",
        "description": "The size of the memory range, in bytes."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Fills a block of memory with zeros. It is designed to be a more secure version of     ZeroMemory.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function returns a pointer to the block of memory. ",
    "remarks": "This function is defined as the      RtlSecureZeroMemory function (see      WinBase.h). The implementation of      RtlSecureZeroMemory is provided inline and can be      used on any version of Windows (see WinNT.h.) Use this function instead of ZeroMemory when you want to      ensure that your data will be overwritten promptly, as some C++  compilers can optimize a call to      ZeroMemory by removing it entirely. Many programming languages include syntax for initializing complex variables to zero. There can be differences      between the results of these operations and the      SecureZeroMemory function. Use      SecureZeroMemory to clear a block of memory in any      programming language. The following code fragment shows an instance where it is good to use        SecureZeroMemory instead of        ZeroMemory. If  ZeroMemory were called in this example instead of       SecureZeroMemory, the compiler could optimize the       call because the szPassword buffer is not read from before it goes out of scope. The       password would remain on the application stack where it could be captured in a crash dump or probed by a       malicious application. ",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "SecureZeroMemory",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ptr",
        "description": "A pointer to the starting address of the block of memory to fill with zeros."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "cnt",
        "description": "The size of the block of memory to fill with zeros, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Limits the size of the working set for the file system cache.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. ",
    "remarks": "The calling process must enable the SE_INCREASE_QUOTA_NAME privilege. Setting the MaximumFileCacheSize parameter to a very low value can adversely affect system performance. To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see  Using the Windows Headers. The FILE_CACHE_* constants will be defined in the Windows header files starting with the Windows SDK for Windows Server 2008. If you are using header files from an earlier version of the SDK, add the following definitions to your code. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "SetSystemFileCacheSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "MinimumFileCacheSize",
        "description": "The minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache. To flush the cache, specify (SIZE_T) -1."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "MaximumFileCacheSize",
        "description": "The maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if this call or a previous call to SetSystemFileCacheSize specifies FILE_CACHE_MAX_HARD_ENABLE. To flush the cache, specify (SIZE_T) -1."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "The flags that enable or disable the file cache limits. If this parameter is 0 (zero), the size limits retain the current setting, which is either disabled or enabled.  ValueMeaning  FILE_CACHE_MAX_HARD_DISABLE 0x2   Disable the maximum size limit. The FILE_CACHE_MAX_HARD_DISABLE and FILE_CACHE_MAX_HARD_ENABLE flags are mutually exclusive.   FILE_CACHE_MAX_HARD_ENABLE 0x1   Enable the maximum size limit. The FILE_CACHE_MAX_HARD_DISABLE and FILE_CACHE_MAX_HARD_ENABLE flags are mutually exclusive.   FILE_CACHE_MIN_HARD_DISABLE 0x8   Disable the minimum size limit. The FILE_CACHE_MIN_HARD_DISABLE and FILE_CACHE_MIN_HARD_ENABLE flags are mutually exclusive.   FILE_CACHE_MIN_HARD_ENABLE 0x4   Enable the minimum size limit. The FILE_CACHE_MIN_HARD_DISABLE and FILE_CACHE_MIN_HARD_ENABLE flags are mutually exclusive."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Gets the data execution prevention (DEP) and DEP-ATL thunk emulation settings for the specified 32-bit process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve error values defined for this function,  call GetLastError. ",
    "remarks": "GetProcessDEPPolicy is supported for 32-bit processes only. If this function is called on a 64-bit process, it fails with ERROR_NOT_SUPPORTED. To compile an application that calls this function, define _WIN32_WINNT as 0x0600 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "GetProcessDEPPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process. PROCESS_QUERY_INFORMATION privilege is required to get the DEP policy of a process.  Windows XP with SP3:  The hProcess parameter is ignored."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpFlags",
        "description": "A DWORD that receives one or more of the following flags.  ValueMeaning   0   DEP is disabled for the specified process.   PROCESS_DEP_ENABLE 0x00000001   DEP is enabled for the specified process.     PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION 0x00000002   DEP-ATL thunk emulation is disabled for the specified process. For information about DEP-ATL thunk emulation, see SetProcessDEPPolicy."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "lpPermanent",
        "description": "TRUE if DEP is enabled or disabled permanently for the specified process; otherwise FALSE. If lpPermanent is TRUE, the current DEP setting persists for the life of the process and cannot be changed by calling SetProcessDEPPolicy."
      }
    ],
    "min_client": "Windows Vista with SP1, Windows XP with SP3 [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Gets the data execution prevention (DEP) policy setting for the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function returns a value of type DEP_SYSTEM_POLICY_TYPE, which can be one of the following values.  ",
    "remarks": "The system-wide DEP policy is configured at boot time according to the policy setting in the boot configuration data.  To change the system-wide DEP policy setting, use the BCDEdit /set command to set the nx boot entry option. If the system DEP policy is OptIn or OptOut, DEP can be selectively enabled or disabled for the current process by calling the SetProcessDEPPolicy function. This function works only for 32-bit processes. A user with administrative privileges can disable DEP for selected applications by using the System Control Panel application. If the system DEP policy is OptOut, DEP is disabled for these applications. The Application Compatibility Toolkit can be used to create a list of individual applications that are exempt from DEP. If the system DEP policy is OptOut, DEP is automatically disabled for applications on the list. ",
    "return_type": "DEP_SYSTEM_POLICY_TYPE",
    "category": "Memory Management",
    "name": "GetSystemDEPPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows Vista with SP1, Windows XP with SP3 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Changes data execution prevention (DEP) and DEP-ATL thunk emulation settings for a 32-bit process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve error values defined for this function,  call GetLastError. ",
    "remarks": "The SetProcessDEPPolicy  function overrides the system DEP policy for the current process unless its DEP policy was specified at process creation. The system DEP policy setting must be OptIn or OptOut. If the system DEP policy is AlwaysOff or AlwaysOn, SetProcessDEPPolicy returns an error. After DEP is enabled for a process, subsequent calls to SetProcessDEPPolicy are ignored. DEP policy specified at process creation with the PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY attribute cannot be changed for the life of the process. In this case, calls to SetProcessDEPPolicy fail with ERROR_ACCESS_DENIED. SetProcessDEPPolicy is supported for 32-bit processes only. If this function is called on a 64-bit process, it fails with ERROR_NOT_SUPPORTED. Applications written to ATL 7.1 and earlier can attempt to execute code on pages marked as non-executable, which triggers an NX fault and terminates the application. DEP-ATL thunk emulation allows an application that would otherwise trigger an NX fault to run with DEP enabled. For information about ATL versions, see ATL and MFC Version Numbers. If DEP-ATL thunk emulation is enabled, the system intercepts NX faults, emulates the instructions, and handles the exceptions so the application can continue to run. If DEP-ATL thunk emulation is disabled by setting PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION for the process, NX faults are not intercepted, which is useful when testing applications for compatibility with DEP. The following table summarizes the interactions between system DEP policy, DEP-ATL thunk emulation, and  SetProcessDEPPolicy. To get the system DEP policy setting, use the GetSystemDEPPolicy function.  To compile an application that calls this function, define _WIN32_WINNT as 0x0600 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "SetProcessDEPPolicy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A DWORD that can be one or more of the following values.  ValueMeaning   0   If the DEP system policy is OptIn or OptOut and DEP is enabled for the process, setting dwFlags to 0 disables DEP for the process.   PROCESS_DEP_ENABLE 0x00000001   Enables DEP permanently on the current process. After DEP has been enabled for the process by setting PROCESS_DEP_ENABLE, it cannot be disabled for the life of the process.    PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION 0x00000002   Disables DEP-ATL thunk emulation for the current process, which prevents the system from intercepting NX faults that originate from the Active Template Library (ATL) thunk layer. For more information, see the Remarks section. This flag can be specified only with  PROCESS_DEP_ENABLE."
      }
    ],
    "min_client": "Windows Vista with SP1, Windows XP with SP3 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Creates or opens a named or unnamed file mapping object for a specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the newly created file mapping object. If the object exists before the function call, the function returns a handle to the existing object (with its         current size, not the specified size), and GetLastError        returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "After a file mapping object is created, the size of the file must not exceed the size of the file mapping      object; if it does, not all of the file contents are available for sharing. If an application specifies a size for the file mapping object that is larger than the size of the actual named      file on disk and if the page protection allows write access (that is, the flProtect      parameter specifies  PAGE_READWRITE or      PAGE_EXECUTE_READWRITE), then the file on disk is increased to match the specified size      of the file mapping object. If the file is extended, the contents of the file between the old end of the file and      the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file      on disk cannot be increased, CreateFileMapping fails      and GetLastError  returns      ERROR_DISK_FULL. The initial contents of the pages in a file mapping object backed by the operating system paging file are 0      (zero). The handle that CreateFileMapping returns has      full access to a new file mapping object, and can be used with any function that requires a handle to a file      mapping object. Multiple processes can share a view of the same file   by either using a single shared file mapping object or      creating separate file mapping objects backed by the same file. A single file mapping object can be shared by      multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file      mapping object by name. For more information, see the      CreateProcess,      DuplicateHandle and      OpenFileMapping functions. Creating a file mapping object does not actually map the view into a process address space. The      MapViewOfFile and      MapViewOfFileEx functions map a view of a file into a      process address space. With one important exception, file views derived from any file mapping object that is backed by the same file      are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views      that are mapped by different processes. The exception is related to remote files. Although      CreateFileMapping works with remote files, it does      not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,      each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged. A mapped file and a file that is accessed by using the input and output (I/O) functions      (ReadFile and      WriteFile) are not necessarily coherent. Mapped views of a file mapping object maintain internal references to the object, and a file mapping object      does not close until all references to it are released. Therefore, to fully close a file mapping object, an      application must unmap all mapped views of the file mapping object by calling      UnmapViewOfFile and  close the file mapping object      handle by calling CloseHandle. These functions can be      called in any order. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.      If required, the caller should use SetFileTime to set the      timestamp. Creating a file mapping object in the global namespace from a session other than session zero requires the       SeCreateGlobalPrivilege privilege.       Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening       existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any       process running in any session can access that file mapping object provided that the caller has the required       access rights. Windows XP:  The requirement described in the previous paragraph was introduced with Windows Server 2003        and Windows XP with SP2 Use structured exception handling to protect any code that writes to or reads from a file view. For more       information, see       Reading and Writing From a File View. To have a mapping with executable permissions, an application must call      CreateFileMapping with either       PAGE_EXECUTE_READWRITE or PAGE_EXECUTE_READ, and then       call MapViewOfFile with       FILE_MAP_EXECUTE | FILE_MAP_WRITE or       FILE_MAP_EXECUTE | FILE_MAP_READ. In Windows Server 2012, this function is supported by the following technologies.  For an example, see       Creating Named Shared Memory or       Creating a File Mapping Using Large Pages. ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "CreateFileMapping",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file from which to create a file mapping object. The file must be opened with access rights that are compatible with the protection flags that the         flProtect parameter specifies. It is not required, but it is recommended that files         you intend to map be opened for exclusive access. For more information, see         File Security and Access Rights. If hFile is INVALID_HANDLE_VALUE, the calling process         must also specify a size for the file mapping object in the dwMaximumSizeHigh and         dwMaximumSizeLow parameters. In this scenario,         CreateFileMapping creates a file mapping object         of a specified size  that is backed by the system paging file instead of by a file in the file system."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES         structure that determines whether a returned handle can be inherited by child processes. The        lpSecurityDescriptor member of the        SECURITY_ATTRIBUTES structure specifies a        security descriptor for a new file mapping object. If lpAttributes is NULL, the handle cannot be inherited        and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default        security descriptor for a file mapping object come from the primary or impersonation token of the creator. For        more information, see        File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flProtect",
        "description": "Specifies the page protection of the file mapping object. All mapped views of the object must be compatible         with this protection. This parameter can be one of the following values.  ValueMeaning  PAGE_EXECUTE_READ 0x20   Allows views to be mapped for read-only, copy-on-write, or execute access. The file handle specified by  the hFile parameter must be created with the           GENERIC_READ and GENERIC_EXECUTE access rights. Windows Server 2003 and Windows XP:  This value is not available until Windows XP with SP2 and            Windows Server 2003 with SP1.   PAGE_EXECUTE_READWRITE 0x40   Allows views to be mapped for read-only, copy-on-write, read/write, or execute access. The file   handle that the hFile parameter specifies must be created with the           GENERIC_READ, GENERIC_WRITE, and           GENERIC_EXECUTE access rights. Windows Server 2003 and Windows XP:  This value is not available until Windows XP with SP2 and            Windows Server 2003 with SP1.   PAGE_EXECUTE_WRITECOPY 0x80   Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to           PAGE_EXECUTE_READ. The file handle that the hFile parameter specifies must be created with the           GENERIC_READ and GENERIC_EXECUTE access rights. Windows Vista:  This value is not available until Windows Vista with SP1. Windows Server 2003 and Windows XP:  This value is not supported.   PAGE_READONLY 0x02   Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific          region results in an access violation. The file handle that  the hFile parameter          specifies must be created with the GENERIC_READ access right.   PAGE_READWRITE 0x04   Allows views to be mapped for read-only, copy-on-write, or read/write access. The file handle that the hFile parameter specifies must be created with the           GENERIC_READ and          GENERIC_WRITE access rights.   PAGE_WRITECOPY 0x08   Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to           PAGE_READONLY. The file handle that  the hFile parameter specifies must be created with the          GENERIC_READ access right.     An application can specify one or more of the following attributes for the file mapping object by combining         them with one of the preceding page protection values.  ValueMeaning  SEC_COMMIT 0x8000000   If the file mapping object is backed by the operating system paging file (the           hfile parameter is INVALID_HANDLE_VALUE), specifies that           when  a view of the file is mapped into a process address space, the entire range of pages is committed           rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,           CreateFileMapping fails. This attribute has no effect for file mapping objects that are backed by executable image files or data           files (the hfile parameter is a handle to a file). SEC_COMMIT cannot be combined with SEC_RESERVE. If no attribute is specified, SEC_COMMIT is assumed.   SEC_IMAGE 0x1000000   Specifies that the file that the  hFile parameter specifies is an executable           image file. The SEC_IMAGE attribute must be combined with a page protection value such as           PAGE_READONLY. However, this page protection value has no effect on views of the           executable image file. Page protection for views of an executable image file is determined by the executable           file itself. No other attributes are valid with SEC_IMAGE.   SEC_IMAGE_NO_EXECUTE 0x11000000   Specifies that the file that the  hFile parameter specifies is an executable           image file that will not be executed and the loaded image file will have no forced integrity checks run.           Additionally, mapping a view of a file mapping object created with the           SEC_IMAGE_NO_EXECUTE attribute will not invoke driver callbacks registered using           the PsSetLoadImageNotifyRoutine           kernel API. The SEC_IMAGE_NO_EXECUTE attribute must be combined with the           PAGE_READONLY page protection value. No other attributes are valid with           SEC_IMAGE_NO_EXECUTE. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported before Windows Server 2012 and Windows 8.   SEC_LARGE_PAGES 0x80000000   Enables large pages to be used for file mapping objects that are backed by the operating system paging file           (the hfile parameter is INVALID_HANDLE_VALUE). This           attribute is not supported for file mapping objects that are backed by executable image files or data files           (the hFile parameter is a handle to an executable image or data file). The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned           by the GetLargePageMinimum function. If it is           not, CreateFileMapping fails. When mapping a           view of a file mapping object created with SEC_LARGE_PAGES, the base address and           view size must also be multiples of the minimum large page size. SEC_LARGE_PAGES requires the           SeLockMemoryPrivilege           privilege to be enabled in the caller's token. If SEC_LARGE_PAGES is specified, SEC_COMMIT must also           be specified. Windows Server 2003:  This value is not supported until Windows Server 2003 with SP1. Windows XP:  This value is not supported.   SEC_NOCACHE 0x10000000   Sets all pages to be non-cachable. Applications should not use this attribute except when           explicitly required for a device. Using the interlocked functions with memory that is mapped with           SEC_NOCACHE can result in an           EXCEPTION_ILLEGAL_INSTRUCTION exception. SEC_NOCACHE requires either the SEC_RESERVE or           SEC_COMMIT attribute to be set.   SEC_RESERVE 0x4000000   If the file mapping object is backed by the operating system paging file (the           hfile parameter is INVALID_HANDLE_VALUE), specifies that           when a view of the file is mapped into a process address space, the entire range of pages is reserved for           later use by the process rather than committed. Reserved pages can be committed in subsequent calls to the           VirtualAlloc function. After the pages are           committed, they cannot be freed or decommitted with the           VirtualFree function. This attribute has no effect for file mapping objects that are backed by executable image files or data           files (the hfile parameter is a handle to a file). SEC_RESERVE cannot be combined with SEC_COMMIT.   SEC_WRITECOMBINE 0x40000000   Sets all pages to  be write-combined. Applications should not use this attribute except when           explicitly required for a device. Using the interlocked functions with memory that is mapped with           SEC_WRITECOMBINE can result in an           EXCEPTION_ILLEGAL_INSTRUCTION exception. SEC_WRITECOMBINE requires either the SEC_RESERVE or           SEC_COMMIT attribute to be set. Windows Server 2003 and Windows XP:  This flag is not supported until Windows Vista."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMaximumSizeHigh",
        "description": "The high-order DWORD of the maximum size of the file mapping object."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMaximumSizeLow",
        "description": "The low-order DWORD of the maximum size of the file mapping object. If this parameter and dwMaximumSizeHigh are 0 (zero), the maximum size of the file         mapping object is equal to the current size of the file that  hFile identifies. An attempt to map a file with a length of 0 (zero) fails with an error code of         ERROR_FILE_INVALID. Applications should test for files with a length of 0 (zero) and         reject those files."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the file mapping object. If this parameter matches the name of an existing mapping object, the function requests access to the         object with the protection that flProtect specifies. If this parameter is NULL, the file mapping object is created without a name. If lpName matches the name of an existing event, semaphore, mutex, waitable timer, or         job object, the function fails, and the GetLastError         function returns ERROR_INVALID_HANDLE. This occurs because these objects share the         same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the         object in the global or session namespace. The remainder of the name can contain any character except the         backslash character (\\). Creating a file mapping object in the global namespace from a session other than         session zero requires the         SeCreateGlobalPrivilege         privilege. For more information, see         Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session         0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the         guidelines that are outlined for Terminal Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Creates or opens a named or unnamed file mapping object for a specified file from a      Windows Store app.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "MemoryApi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the newly created file mapping object. If the object exists before the function call, the function returns a handle to the existing object (with its         current size, not the specified size), and GetLastError         returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "After a file mapping object is created, the size of the file must not exceed the size of the file mapping      object; if it does, not all of the file contents are available for sharing. If an application specifies a size for the file mapping object that is larger than the size of the actual      named file on disk and if the page protection allows write access (that is, the      flProtect parameter specifies  PAGE_READWRITE), then the file      on disk is increased to match the specified size of the file mapping object. If the file is extended, the contents      of the file between the old end of the file and the new end of the file are not guaranteed to be zero; the      behavior is defined by the file system. If the file on disk cannot be increased,      CreateFileMappingFromApp fails and      GetLastError  returns      ERROR_DISK_FULL. The initial contents of the pages in a file mapping object backed by the operating system paging file are 0      (zero). The handle that CreateFileMappingFromApp      returns has full access to a new file mapping object, and can be used with any function that requires a handle to      a file mapping object. Multiple processes can share a view of the same file   by either using a single shared file mapping object or      creating separate file mapping objects backed by the same file. A single file mapping object can be shared by      multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file      mapping object by name. For more information, see the      CreateProcess,      DuplicateHandle and      OpenFileMapping functions. Creating a file mapping object does not actually map the view into a process address space. The      MapViewOfFileEx function map a view of a file into a      process address space. With one important exception, file views derived from any file mapping object that is backed by the same file      are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views      that are mapped by different processes. The exception is related to remote files. Although      CreateFileMappingFromApp works with remote      files, it does not keep them coherent. For example, if two computers both map a file as writable, and both change      the same page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is      not merged. A mapped file and a file that is accessed by using the input and output (I/O) functions      (ReadFile and      WriteFile) are not necessarily coherent. Mapped views of a file mapping object maintain internal references to the object, and a file mapping object      does not close until all references to it are released. Therefore, to fully close a file mapping object, an      application must unmap all mapped views of the file mapping object by calling      UnmapViewOfFile and  close the file mapping object      handle by calling CloseHandle. These functions can be      called in any order. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.      If required, the caller should use SetFileTime to set the      timestamp. Use structured exception handling to protect any code that writes to or reads from a file view. For more      information, see      Reading and Writing From a File View. ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "CreateFileMappingFromApp",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file from which to create a file mapping object. The file must be opened with access rights that are compatible with the protection flags that the         flProtect parameter specifies. It is not required, but it is recommended that files         you intend to map be opened for exclusive access. For more information, see         File Security and Access Rights. If hFile is INVALID_HANDLE_VALUE, the calling process         must also specify a size for the file mapping object in the dwMaximumSizeHigh and         dwMaximumSizeLow parameters. In this scenario,         CreateFileMappingFromApp creates a file         mapping object of a specified size  that is backed by the system paging file instead of by a file in the file         system."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSECURITY_ATTRIBUTES",
        "name": "SecurityAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES         structure that determines whether a returned handle can be inherited by child processes. The         lpSecurityDescriptor member of the         SECURITY_ATTRIBUTES structure specifies a         security descriptor for a new file mapping object. If SecurityAttributes is NULL, the handle cannot be         inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the         default security descriptor for a file mapping object come from the primary or impersonation token of the         creator. For more information, see         File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PageProtection",
        "description": "Specifies the page protection of the file mapping object. All mapped views of the object must be compatible         with this protection. This parameter can be one of the following values.  ValueMeaning  PAGE_READONLY 0x02   Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific           region results in an access violation. The file handle that  the hFile parameter           specifies must be created with the GENERIC_READ access right.   PAGE_READWRITE 0x04   Allows views to be mapped for read-only, copy-on-write, or read/write access. The file handle that the hFile parameter specifies must be created with the           GENERIC_READ and GENERIC_WRITE access rights.   PAGE_WRITECOPY 0x08   Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to           PAGE_READONLY. The file handle that  the hFile parameter specifies must be created with the           GENERIC_READ access right.     An application can specify one or more of the following attributes for the file mapping object by combining         them with one of the preceding page protection values.  ValueMeaning  SEC_COMMIT 0x8000000   If the file mapping object is backed by the operating system paging file (the           hfile parameter is INVALID_HANDLE_VALUE), specifies that           when  a view of the file is mapped into a process address space, the entire range of pages is committed           rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,           CreateFileMappingFromApp fails. This attribute has no effect for file mapping objects that are backed by executable image files or data           files (the hfile parameter is a handle to a file). SEC_COMMIT cannot be combined with SEC_RESERVE. If no attribute is specified, SEC_COMMIT is assumed.   SEC_IMAGE_NO_EXECUTE 0x11000000   Specifies that the file that the  hFile parameter specifies is an executable           image file that will not be executed and the loaded image file will have no forced integrity checks run.           Additionally, mapping a view of a file mapping object created with the           SEC_IMAGE_NO_EXECUTE attribute will not invoke driver callbacks registered using           the PsSetLoadImageNotifyRoutine           kernel API. The SEC_IMAGE_NO_EXECUTE attribute must be combined with the           PAGE_READONLY page protection value. No other attributes are valid with           SEC_IMAGE_NO_EXECUTE.   SEC_LARGE_PAGES 0x80000000   Enables large pages to be used for file mapping objects that are backed by the operating system paging file           (the hfile parameter is INVALID_HANDLE_VALUE). This           attribute is not supported for file mapping objects that are backed by executable image files or data files           (the hFile parameter is a handle to an executable image or data file). The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned           by the GetLargePageMinimum function. If it is           not, CreateFileMappingFromApp fails.           When mapping a view of a file mapping object created with SEC_LARGE_PAGES, the base           address and view size must also be multiples of the minimum large page size. SEC_LARGE_PAGES requires the           SeLockMemoryPrivilege           privilege to be enabled in the caller's token. If SEC_LARGE_PAGES is specified, SEC_COMMIT must also           be specified.   SEC_NOCACHE 0x10000000   Sets all pages to be non-cachable. Applications should not use this attribute except when           explicitly required for a device. Using the interlocked functions with memory that is mapped with           SEC_NOCACHE can result in an           EXCEPTION_ILLEGAL_INSTRUCTION exception. SEC_NOCACHE requires either the SEC_RESERVE or           SEC_COMMIT attribute to be set.   SEC_RESERVE 0x4000000   If the file mapping object is backed by the operating system paging file (the           hfile parameter is INVALID_HANDLE_VALUE), specifies that           when a view of the file is mapped into a process address space, the entire range of pages is reserved for           later use by the process rather than committed. Reserved pages can be committed in subsequent calls to the           VirtualAlloc function. After the pages are           committed, they cannot be freed or decommitted with the           VirtualFree function. This attribute has no effect for file mapping objects that are backed by executable image files or data           files (the hfile parameter is a handle to a file). SEC_RESERVE cannot be combined with SEC_COMMIT.   SEC_WRITECOMBINE 0x40000000   Sets all pages to  be write-combined. Applications should not use this attribute except when           explicitly required for a device. Using the interlocked functions with memory that is mapped with           SEC_WRITECOMBINE can result in an           EXCEPTION_ILLEGAL_INSTRUCTION exception. SEC_WRITECOMBINE requires either the SEC_RESERVE or           SEC_COMMIT attribute to be set."
      },
      {
        "in_out": "_In_",
        "type": "ULONG64",
        "name": "MaximumSize",
        "description": "The maximum size of the file mapping object. An attempt to map a file with a length of 0 (zero) fails with an error code of         ERROR_FILE_INVALID. Applications should test for files with a length of 0 (zero) and         reject those files."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "Name",
        "description": "The name of the file mapping object. If this parameter matches the name of an existing mapping object, the function requests access to the         object with the protection that flProtect specifies. If this parameter is NULL, the file mapping object is created without a name. If lpName matches the name of an existing event, semaphore, mutex, waitable timer,         or job object, the function fails, and the         GetLastError function returns         ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session         namespace. The remainder of the name can contain any character except the backslash character (\\). Creating a         file mapping object in the global namespace from a session other than session zero requires the         SeCreateGlobalPrivilege         privilege. For more information, see         Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session         0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the         guidelines that are outlined for Terminal Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA      node for the physical memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the file mapping object. If the object exists         before the function call, the function returns a handle to the existing object (with its current size, not the         specified size) and the GetLastError        function returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information,         call the GetLastError function. ",
    "remarks": "After a file mapping object is created, the size of the file must not exceed the size of the file mapping      object; if it does, not all of the file contents are available for sharing. The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the      pages in a file mapping object backed by the page file are 0 (zero). If an application specifies a size for the file mapping object that is larger than the size of the actual       named file on disk and if the page protection allows write access (that is, the       flProtect parameter specifies  PAGE_READWRITE or       PAGE_EXECUTE_READWRITE), then the file on disk is increased to match the specified size       of the file mapping object. If the file is extended, the contents of the file between the old end of the file and       the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file cannot be increased, the result is a failure to create the file mapping object and the       GetLastError function returns       ERROR_DISK_FULL. The handle that the CreateFileMappingNuma      function returns has full access to a new file mapping object and can be used with any function that requires a      handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,      or by name. For more information, see the      DuplicateHandle and      OpenFileMapping functions. Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.      The MapViewOfFileExNuma function maps a view of a      file into a process address space. With one important exception, file views derived from a single file mapping object are coherent or identical      at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view      of the data when they map a view of the file. The exception is related to remote files. Although the      CreateFileMappingNuma function works with remote      files, it does not keep them coherent. For example, if two computers both map a file as writable and both change      the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the      page is not merged. A mapped file and a file that is accessed by using the input and output (I/O) functions      (ReadFile and      WriteFile) are not necessarily coherent. To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by       calling the UnmapViewOfFile function and then close       the file mapping object handle by calling the CloseHandle       function. These functions can be called in any order. The call to the       UnmapViewOfFile function is necessary, because mapped       views of a file mapping object maintain internal open handles to the object, and a file mapping object does not       close until all open handles to it are closed. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.       If required, the caller should use SetFileTime to set the       timestamp. Creating a file-mapping object from a session other than session zero requires the       SeCreateGlobalPrivilege privilege.       Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening       existing ones. For example, if a service or the system creates a file mapping object, any process running in any       session can access that file mapping object provided that the caller has the required access rights. Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For       more information, see       Reading and Writing From a File View. To have a mapping with executable permissions, an application must call the       CreateFileMappingNuma function with either       PAGE_EXECUTE_READWRITE or PAGE_EXECUTE_READ and then call the       MapViewOfFileExNuma function with       FILE_MAP_EXECUTE | FILE_MAP_WRITE or       FILE_MAP_EXECUTE | FILE_MAP_READ. In Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "CreateFileMappingNuma",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file from which to create a file mapping object.  The file must be opened with access         rights that are compatible with the protection flags that the flProtect parameter         specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive         access. For more information, see         File Security and Access Rights. If hFile is INVALID_HANDLE_VALUE, the calling process         must also specify a size for the file mapping object in the dwMaximumSizeHigh and         dwMaximumSizeLow parameters. In this scenario,         CreateFileMappingNuma creates a file mapping         object of a specified size  that is backed by the system paging file instead of by a file in the file         system."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpFileMappingAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES         structure that determines whether a returned handle can be inherited by child processes. The         lpSecurityDescriptor member of the          SECURITY_ATTRIBUTES structure specifies a         security descriptor for a new file mapping object. If lpFileMappingAttributes is NULL, the handle cannot be         inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the         default security descriptor for a file mapping object come from the primary or impersonation token of the         creator. For more information, see         File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flProtect",
        "description": "Specifies the page protection of the file mapping object. All mapped views of the object must be compatible         with this protection.  This parameter can be one of the following values.  ValueMeaning  PAGE_EXECUTE_READ 0x20   Allows views to be mapped for read-only, copy-on-write, or execute access. The file handle that the hFile parameter specifies must be created with the           GENERIC_READ and GENERIC_EXECUTE access rights.   PAGE_EXECUTE_READWRITE 0x40   Allows views to be mapped for read-only, copy-on-write, read/write or execute access. The file handle that the hFile parameter specifies must be created with the           GENERIC_READ, GENERIC_WRITE, and           GENERIC_EXECUTE access rights.   PAGE_EXECUTE_WRITECOPY 0x80   Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to           PAGE_EXECUTE_READ. The file handle that the hFile           parameter specifies must be created with the GENERIC_READ and           GENERIC_EXECUTE access rights. Windows Vista:  This value is not available until Windows Vista with SP1.   PAGE_READONLY 0x02   Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region           results in an access violation. The file handle that  the hFile parameter           specifies must be created with the GENERIC_READ access right.   PAGE_READWRITE 0x04   Allows views to be mapped for read-only, copy-on-write, or read/write access. The file handle that the hFile parameter specifies must be created with the           GENERIC_READ and GENERIC_WRITE access rights.   PAGE_WRITECOPY 0x08   Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to           PAGE_READONLY. The file handle that  the hFile parameter specifies must be created with the          GENERIC_READ access right.     An application can specify one or more of the following attributes for the file mapping object by combining         them with one of the preceding page protection values.  ValueMeaning  SEC_COMMIT 0x8000000   Allocates physical storage in memory or the paging file for all pages.  This is the          default setting.   SEC_IMAGE 0x1000000   Sets the file that is specified to be an executable image file. The SEC_IMAGE attribute must be combined with a page protection value such as           PAGE_READONLY. However, this page protection value has no effect on views of the           executable image file. Page protection for views of an executable image file is determined by the executable           file itself. No other attributes are valid with SEC_IMAGE.   SEC_IMAGE_NO_EXECUTE 0x11000000   Specifies that the file that the  hFile parameter specifies is an executable           image file that will not be executed and the loaded image file will have no forced integrity checks run.           Additionally, mapping a view of a file mapping object created with the           SEC_IMAGE_NO_EXECUTE attribute will not invoke driver callbacks registered using           the PsSetLoadImageNotifyRoutine           kernel API. The SEC_IMAGE_NO_EXECUTE attribute must be combined with the           PAGE_READONLY page protection value. No other attributes are valid with           SEC_IMAGE_NO_EXECUTE. Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  This value is not supported before Windows Server 2012 and Windows 8.   SEC_LARGE_PAGES 0x80000000   Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data           for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a           large page reported by the           GetLargePageMinimum function and to enable           the SeLockMemoryPrivilege           privilege.   SEC_NOCACHE 0x10000000   Sets all pages to noncachable. Applications should not use this flag except when explicitly required           for a device. Using the interlocked functions with memory mapped with SEC_NOCACHE           can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. SEC_NOCACHE requires either SEC_RESERVE or           SEC_COMMIT to be set.   SEC_RESERVE 0x4000000   Reserves all pages without allocating physical storage. The reserved range of pages cannot be used by any other allocation operations until the range of pages is           released. Reserved pages can be identified in subsequent calls to the           VirtualAllocExNuma function. This attribute is           valid only if the hFile parameter is INVALID_HANDLE_VALUE           (that is, a file mapping object that is backed by the system paging file).   SEC_WRITECOMBINE 0x40000000   Sets all pages to  be write-combined. Applications should not use this attribute except when           explicitly required for a device. Using the interlocked functions with memory that is mapped with           SEC_WRITECOMBINE can result in an           EXCEPTION_ILLEGAL_INSTRUCTION exception. SEC_WRITECOMBINE requires either the SEC_RESERVE or           SEC_COMMIT attribute to be set."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMaximumSizeHigh",
        "description": "The high-order DWORD of the maximum size of the file mapping object."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMaximumSizeLow",
        "description": "The low-order DWORD of the maximum size of the file mapping object. If this parameter and the dwMaximumSizeHigh parameter are 0 (zero), the maximum          size of the file mapping object is equal to the current size of the file that the          hFile parameter identifies. An attempt to map a file with a length of 0 (zero) fails with an error code of          ERROR_FILE_INVALID. Applications should test for files with a length of 0 (zero) and          reject those files."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the file mapping object. If this parameter matches the name of an existing file mapping object, the function requests access to the          object with the protection that the flProtect parameter specifies. If this parameter is NULL, the file mapping object is created without a name. If the lpName parameter matches the name of an existing event, semaphore, mutex,          waitable timer, or job object, the function fails and the          GetLastError function returns          ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the          object in the global or session namespace. The remainder of the name can contain any character except the          backslash character (\\). Creating a file mapping object in the global namespace requires the          SeCreateGlobalPrivilege          privilege. For more information, see          Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses          session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the          guidelines so that applications can support multiple users."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nndPreferred",
        "description": "The NUMA node where the physical memory should reside.  ValueMeaning  NUMA_NO_PREFERRED_NODE 0xffffffff   No NUMA node is preferred. This is the same as calling the         CreateFileMapping function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Writes to the disk a byte range within a mapped view of a file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Flushing a range of a mapped view initiates writing of dirty pages within that range to the disk. Dirty pages are those whose contents have changed since the file view was mapped. The FlushViewOfFile function does not flush the file metadata, and it does not wait to  return until  the changes are flushed from the underlying hardware disk cache and physically written to disk. To flush all the dirty pages plus the metadata for the file and ensure that they are physically written to disk, call FlushViewOfFile and then call the FlushFileBuffers function. When flushing a memory-mapped file over a network,  FlushViewOfFile guarantees that the data has been written from the local computer, but not that the data resides on the remote computer. The server can cache the data on the remote side. Therefore,  FlushViewOfFile can return before the data has been physically written to disk. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.  If required, the caller should use SetFileTime to set the timestamp. In Windows Server 2012, this function is supported by the following technologies.  When CsvFs is paused this call might fail with an error indicating that there is a lock conflict. For an example, see  Reading and Writing From a File View. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "FlushViewOfFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpBaseAddress",
        "description": "A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwNumberOfBytesToFlush",
        "description": "The number of bytes to be flushed. If dwNumberOfBytesToFlush is zero, the file is flushed from the base address to the end of the mapping."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Maps a view of a file mapping into the address space of a calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "Mapping a file makes the specified portion of a file visible in the address space of the calling process. For files that are larger than the address space, you can only map a small portion of the file data at one      time. When the first view is complete, you can unmap it and map a new view. To obtain the size of a view, use the VirtualQuery      function. Multiple views of a file (or a file mapping object and its mapped file) are coherent      if they contain identical data at a specified time. This occurs if the file views are derived from any file      mapping object that is backed by the same file. A process can duplicate a file mapping object handle into another      process by using the DuplicateHandle function, or      another process can open a file mapping object by name by using the      OpenFileMapping function. With one important exception, file views derived from any file mapping object that is backed by the same file      are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views      that are mapped by different processes. The exception is related to remote files. Although      MapViewOfFile works with remote files, it does not keep      them coherent. For example, if two computers both map a file as writable, and both change the same page, each      computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged. A mapped view of a file is not guaranteed to be coherent with a file that is being accessed by the      ReadFile or      WriteFile function. Do not store pointers in the memory mapped file; store offsets from the base of the file mapping so that the      mapping can be used at any address. To guard against EXCEPTION_IN_PAGE_ERROR      exceptions, use structured exception handling to protect any code that writes to or reads from a memory mapped      view of a file other than the page file. For more information, see      Reading and Writing From a File View. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.       If required, the caller should use SetFileTime to set the       timestamp. If a file mapping object is backed by the paging file       (CreateFileMapping is called with the       hFile parameter set to INVALID_HANDLE_VALUE), the paging file       must be large enough to hold the entire mapping. If it is not,       MapViewOfFile fails. The initial contents of the pages       in a file mapping object backed by the paging file are 0 (zero). When a file mapping object that is backed by the paging file is created, the caller can  specify whether       MapViewOfFile should reserve and commit pages at the       same time (SEC_COMMIT) or  simply reserve pages       (SEC_RESERVE). Mapping the file makes the entire mapped virtual address range       unavailable to other allocations in the process. After a page from the reserved range is committed, it cannot be       freed or decommitted by calling VirtualFree. Reserved and       committed pages are released when the view is unmapped and the file mapping object is closed. For details, see       the UnmapViewOfFile and       CloseHandle functions. To have a file with executable permissions, an application must call       CreateFileMapping with either       PAGE_EXECUTE_READWRITE or PAGE_EXECUTE_READ,       and then call MapViewOfFile with       FILE_MAP_EXECUTE | FILE_MAP_WRITE or       FILE_MAP_EXECUTE | FILE_MAP_READ. In Windows Server 2012, this function is supported by the following technologies.  When CsvFs is paused this call might fail with an error indicating that there is a lock conflict. For an example, see       Creating Named Shared Memory. ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "MapViewOfFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFileMappingObject",
        "description": "A handle to a file mapping object. The         CreateFileMapping and         OpenFileMapping functions return this handle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The type of access to a file mapping object, which determines the protection of the pages. This parameter can         be one of the following values.  ValueMeaning  FILE_MAP_ALL_ACCESS   A read/write view of the file is mapped. The file mapping object must have been created with           PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection. When used with the MapViewOfFile function,           FILE_MAP_ALL_ACCESS is equivalent to FILE_MAP_WRITE.   FILE_MAP_COPY   A copy-on-write view of the file is mapped. The file mapping object must have been created with           PAGE_READONLY, PAGE_READ_EXECUTE,           PAGE_WRITECOPY, PAGE_EXECUTE_WRITECOPY,           PAGE_READWRITE, or PAGE_EXECUTE_READWRITE protection. When a process writes to a copy-on-write page, the system copies the original page to a new page that is           private to the process. The new page is backed by the paging file. The protection of the new page changes           from copy-on-write to read/write. When copy-on-write access is specified, the system and process commit charge taken is for the entire view           because the calling process can potentially write to every page in the view, making all pages private. The           contents of the new page are never written back to the original file and are lost when the view is           unmapped.   FILE_MAP_READ   A read-only view of the file is mapped. An attempt to write to the file view results in an access           violation. The file mapping object must have been created with PAGE_READONLY,           PAGE_READWRITE, PAGE_EXECUTE_READ, or           PAGE_EXECUTE_READWRITE protection.   FILE_MAP_WRITE   A read/write view of the file is mapped. The file mapping object must have been created with           PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection. When used with MapViewOfFile,           (FILE_MAP_WRITE | FILE_MAP_READ) and           FILE_MAP_ALL_ACCESS are equivalent to FILE_MAP_WRITE.     Each of the preceding values can be combined with the following value.  ValueMeaning  FILE_MAP_EXECUTE   An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must           have been created with PAGE_EXECUTE_READ,           PAGE_EXECUTE_WRITECOPY, or PAGE_EXECUTE_READWRITE           protection. Windows Server 2003 and Windows XP:  This value is available starting with Windows XP with SP2 and            Windows Server 2003 with SP1.     For file mapping objects created with the SEC_IMAGE attribute, the         dwDesiredAccess parameter has no effect and should be set to any valid value such as         FILE_MAP_READ. For more information about access to file mapping objects, see         File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetHigh",
        "description": "A high-order DWORD of the file offset where the view begins."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetLow",
        "description": "A low-order DWORD of the file offset where the view is to begin. The combination         of the high and low offsets must specify an offset within the file mapping. They must also match the  memory         allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To         obtain the memory allocation granularity of the system, use the         GetSystemInfo function, which fills in the members of         a SYSTEM_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwNumberOfBytesToMap",
        "description": "The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified         by CreateFileMapping. If this parameter is 0         (zero), the mapping extends from the specified offset to the end of the file mapping."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Maps a view of a file or a pagefile-backed section into the address     space of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns the base address of the mapped view, if successful. Otherwise, returns NULL and extended error status is available            using GetLastError. ",
    "remarks": "",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "MapViewOfFile2",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileMappingHandle",
        "description": "A HANDLE to a section that is to be mapped                         into the address space of the specified process."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A HANDLE to a process into which the section                     will be mapped."
      },
      {
        "in_out": "_In_",
        "type": "ULONG64",
        "name": "Offset",
        "description": "The offset from the beginning of the section.              This must be 64k aligned."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "The desired base address of the view.                   The address is rounded down to the nearest 64k boundary.                   If this parameter is NULL, the system picks the base                   address."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "ViewSize",
        "description": "The number of bytes to map. A value of zero (0)                specifies that the entire section is to be mapped."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocationType",
        "description": "The type of allocation. This parameter can be zero (0) or one of the following constant values:  MEM_RESERVE - Maps a reserved view MEM_LARGE_PAGES - Maps a large page view"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PageProtection",
        "description": "The desired page protection."
      }
    ],
    "min_client": "Windows 10, version 1703 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Maps a view of a file mapping into the address space of a calling process. A caller can optionally      specify a suggested base memory address for the view.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "Mapping a file makes the specified portion of the file visible in the address space of the calling      process. For files that are larger than the address space, you can only map a small portion of the file data at one      time. When the first view is complete, then you unmap it and map a new view. To obtain the size of a view, use the      VirtualQueryEx function. The initial contents of the pages in a file mapping object backed by the page file are 0 (zero). Typically, the suggested address is used to specify that a file should be mapped at the same address in      multiple processes. This requires the region of address space to be available in all involved processes. No other      memory allocation can take place in the region that is used for mapping, including the use of the      VirtualAlloc or      VirtualAllocEx function to reserve memory. If the lpBaseAddress parameter specifies a base offset, the function succeeds if the       specified memory region is not already in use by the calling process. The system does not ensure that the same       memory region is available for the memory mapped file in other 32-bit processes. Multiple views of a file (or a file mapping object and its mapped file) are coherent      if they contain identical data at a specified time. This occurs if the file views are derived from the same file      mapping object. A process can duplicate a file mapping object handle into another process by using the      DuplicateHandle function, or another process can open      a file mapping object by name by using the      OpenFileMapping function. With one important exception, file views derived from any file mapping object that is backed by the same file      are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views      that are mapped by different processes. The exception is related to remote files. Although      MapViewOfFileEx works with remote files, it does not      keep them coherent. For example, if two computers both map a file as writable, and both change the same page, each      computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged. A mapped view of a file is not guaranteed to be coherent with a file being accessed by the      ReadFile or      WriteFile function. To guard against EXCEPTION_IN_PAGE_ERROR exceptions, use structured exception      handling to protect any code that writes to or reads from a memory mapped view of a file other than the page file.      For more information, see      Reading and Writing From a File View. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.       If required, the caller should use SetFileTime to set the       timestamp. To have a file with executable permissions, an application must call     CreateFileMapping with either      PAGE_EXECUTE_READWRITE or PAGE_EXECUTE_READ, and then call      MapViewOfFileEx with      FILE_MAP_EXECUTE | FILE_MAP_WRITE or      FILE_MAP_EXECUTE | FILE_MAP_READ. In Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "MapViewOfFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFileMappingObject",
        "description": "A handle to a file mapping object. The        CreateFileMapping and        OpenFileMapping functions return this handle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The type of access to a file mapping object, which determines the page protection of the pages. This        parameter can be one of the following values.  ValueMeaning  FILE_MAP_ALL_ACCESS   A read/write view of the file is mapped.  The file mapping object must have been created with           PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection. When used with the MapViewOfFileEx function,           FILE_MAP_ALL_ACCESS is equivalent to FILE_MAP_WRITE.   FILE_MAP_COPY   A copy-on-write view of the file is mapped. The file mapping object must have been created with           PAGE_READONLY, PAGE_READ_EXECUTE,           PAGE_WRITECOPY, PAGE_EXECUTE_WRITECOPY,           PAGE_READWRITE, or PAGE_EXECUTE_READWRITE protection. When a process writes to a copy-on-write page, the system copies the original page to a new page that is           private to the process. The new page is backed by the paging file. The protection of the new page changes           from copy-on-write to read/write. When copy-on-write access is specified, the system and process commit charge taken is for the entire view           because the calling process can potentially write to every page in the view, making all pages private. The           contents of the new page are never written back to the original file and are lost when the view is           unmapped.   FILE_MAP_READ   A read-only view of the file is mapped. An attempt to write to the file view results in an access           violation. The file mapping object must have been created with PAGE_READONLY,           PAGE_READWRITE, PAGE_EXECUTE_READ, or           PAGE_EXECUTE_READWRITE protection.   FILE_MAP_WRITE   A read/write view of the file is mapped. The file mapping object must have been created with           PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection. When used with MapViewOfFileEx,           (FILE_MAP_WRITE | FILE_MAP_READ) and           FILE_MAP_ALL_ACCESS are equivalent to FILE_MAP_WRITE.     Each of the preceding values can be combined with the following value.  ValueMeaning  FILE_MAP_EXECUTE   An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must           have been created with PAGE_EXECUTE_READ,           PAGE_EXECUTE_WRITECOPY, or PAGE_EXECUTE_READWRITE           protection. Windows Server 2003 and Windows XP:  This value is available starting with Windows XP with SP2 and            Windows Server 2003 with SP1.     For file mapping objects created with the SEC_IMAGE attribute, the         dwDesiredAccess parameter has no effect and should be set to any valid value such as         FILE_MAP_READ. For more information  about access to file mapping objects, see         File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetHigh",
        "description": "The high-order DWORD of the file offset where the view is to begin."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetLow",
        "description": "The low-order DWORD of the file offset where the view is to begin. The        combination of the high and low offsets must specify an offset within the file mapping. They must also match the        memory allocation granularity of the system. That is, the offset must be a multiple of the allocation        granularity. To obtain the memory allocation granularity of the system, use the        GetSystemInfo function, which fills in the members of        a SYSTEM_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwNumberOfBytesToMap",
        "description": "The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified        by CreateFileMapping. If this parameter is 0        (zero), the mapping extends from the specified offset to the end of the file mapping."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpBaseAddress",
        "description": "A pointer to the memory address in the calling process address space where mapping begins. This must be a         multiple of the system's memory allocation granularity, or the function fails. To determine the memory         allocation granularity of the system, use the         GetSystemInfo function. If there is not enough         address space at the specified address, the function fails. If lpBaseAddress is NULL, the operating system chooses         the mapping address. In this scenario, the function is equivalent to the         MapViewOfFile function. While it is possible to specify an address that is safe now (not used by the operating system), there is no         guarantee that the address will remain safe over time. Therefore, it is better to let the operating system         choose the address. In this case, you would not store pointers in the memory mapped file, you would store         offsets from the base of the file mapping so that the mapping can be used at any address."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Maps a view of a file mapping into the address space of a calling process and specifies the NUMA node      for the physical memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the return value is NULL. To get extended error information,         call the GetLastError function. ",
    "remarks": "Mapping a file makes the specified portion of the file visible in the address space of the calling      process. For files that are larger than the address space, you can map only a small portion of the file data at one      time. When the first view is complete, then you unmap it and map a new view. To obtain the size of a view, use the      VirtualQueryEx function. The initial contents of the pages in a file mapping object backed by the page file are 0 (zero). If a suggested mapping address is supplied, the file is mapped at the specified address (rounded down to the      nearest 64-KB boundary) if there is enough address space at the specified address. If there is not enough address      space, the function fails. Typically, the suggested address is used to specify that a file should be mapped at the same address in      multiple processes. This requires the region of address space to be available in all involved processes. No other      memory allocation can take place in the region that is used for mapping, including the use of the      VirtualAllocExNuma function to reserve memory. If the lpBaseAddress parameter specifies a base offset, the function succeeds if the       specified memory region is not already in use by the calling process. The system does not ensure that the same       memory region is available for the memory mapped file in other 32-bit processes. Multiple views of a file (or a file mapping object and its mapped file) are coherent      if they contain identical data at a specified time. This occurs if the file views are derived from the same file      mapping object. A process can duplicate a file mapping object handle into another process by using the      DuplicateHandle function, or another process can open      a file mapping object by name by using the      OpenFileMapping function. With one important exception, file views derived from any file mapping object that is backed by the same file      are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views      that are mapped by different processes. The exception is related to remote files. Although      MapViewOfFileExNuma works with remote files, it      does not keep them coherent. For example, if two computers both map a file as writable, and both change the same      page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is not      merged. A mapped view of a file is not guaranteed to be coherent with a file being accessed by the      ReadFile or      WriteFile function. To guard against EXCEPTION_IN_PAGE_ERROR exceptions, use structured exception      handling to protect any code that writes to or reads from a memory mapped view of a file other than the page file.      For more information, see      Reading and Writing From a File View. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.       If required, the caller should use SetFileTime to set the       timestamp. To have a file with executable permissions, an application must call     the CreateFileMappingNuma function with either      PAGE_EXECUTE_READWRITE or PAGE_EXECUTE_READ      and then call the MapViewOfFileExNuma function      with FILE_MAP_EXECUTE | FILE_MAP_WRITE or      FILE_MAP_EXECUTE | FILE_MAP_READ. In Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "MapViewOfFileExNuma",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFileMappingObject",
        "description": "A handle to a file mapping object. The        CreateFileMappingNuma and        OpenFileMapping functions return this handle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The type of access to a file mapping object, which determines the page protection of the pages. This        parameter can be one of the following values.  ValueMeaning  FILE_MAP_ALL_ACCESS   A read/write view of the file is mapped.  The file mapping object must have been created with           PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection. When used with the MapViewOfFileExNuma           function, FILE_MAP_ALL_ACCESS is equivalent to           FILE_MAP_WRITE.   FILE_MAP_COPY   A copy-on-write view of the file is mapped. The file mapping object must have been created with           PAGE_READONLY, PAGE_READ_EXECUTE,           PAGE_WRITECOPY, PAGE_EXECUTE_WRITECOPY,           PAGE_READWRITE, or PAGE_EXECUTE_READWRITE protection. When a process writes to a copy-on-write page, the system copies the original page to a new page that is           private to the process. The new page is backed by the paging file. The protection of the new page changes           from copy-on-write to read/write. When copy-on-write access is specified, the system and process commit           charge taken is for the entire view because the calling process can potentially write to every page in the           view, making all pages private. The contents of the new page are never written back to the original file and           are lost when the view is unmapped.   FILE_MAP_READ   A read-only view of the file is mapped. An attempt to write to the file view results in an access           violation. The file mapping object must have been created with PAGE_READONLY,           PAGE_READWRITE, PAGE_EXECUTE_READ, or           PAGE_EXECUTE_READWRITE protection.   FILE_MAP_WRITE   A read/write view of the file is mapped. The file mapping object must have been created with           PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection. When used with MapViewOfFileExNuma,           (FILE_MAP_WRITE | FILE_MAP_READ) and           FILE_MAP_ALL_ACCESS are equivalent to FILE_MAP_WRITE.     Each of the preceding values can be combined with the following value.  ValueMeaning  FILE_MAP_EXECUTE   An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must           have been created with PAGE_EXECUTE_READ,           PAGE_EXECUTE_WRITECOPY, or PAGE_EXECUTE_READWRITE           protection.     For file mapping objects created with the SEC_IMAGE attribute, the         dwDesiredAccess parameter has no effect and should be set to any valid value such as         FILE_MAP_READ. For more information  about access to file mapping objects, see         File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetHigh",
        "description": "The high-order DWORD of the file offset where the view is to begin."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetLow",
        "description": "The low-order DWORD of the file offset where the view is to begin. The        combination of the high and low offsets must specify an offset within the file mapping. They must also match the        memory allocation granularity of the system. That is, the offset must be a multiple of the allocation        granularity. To obtain the memory allocation granularity of the system, use the        GetSystemInfo function, which fills in the members of        a SYSTEM_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwNumberOfBytesToMap",
        "description": "The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified        by CreateFileMapping. If this parameter is 0        (zero), the mapping extends from the specified offset to the end of the file mapping."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpBaseAddress",
        "description": "A pointer to the memory address in the calling process address space where mapping begins. This must be a         multiple of the system's memory allocation granularity, or the function fails. To determine the memory         allocation granularity of the system, use the         GetSystemInfo function. If there is not enough         address space at the specified address, the function fails. If the lpBaseAddress parameter is NULL, the operating         system chooses the mapping address. While it is possible to specify an address that is safe now (not used by the operating system), there is no         guarantee that the address will remain safe over time. Therefore, it is better to let the operating system         choose the address. In this case, you would not store pointers in the memory mapped file; you would store         offsets from the base of the file mapping so that the mapping can be used at any address."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nndPreferred",
        "description": "The NUMA node where the physical memory should reside.  ValueMeaning  NUMA_NO_PREFERRED_NODE 0xffffffff   No NUMA node is preferred. This is the same as calling the          MapViewOfFileEx function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Maps a view of a file mapping into the address space of a calling      Windows Store app.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "MemoryApi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "With one important exception, file views derived from any file mapping object that is backed by the same file      are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views      that are mapped by different processes. The exception is related to remote files. Although      MapViewOfFileFromApp works with remote files, it      does not keep them coherent. For example, if two computers both map a file as writable, and both change the same      page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is not      merged. ",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "MapViewOfFileFromApp",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFileMappingObject",
        "description": "A handle to a file mapping object. The         CreateFileMappingFromApp  function returns         this handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DesiredAccess",
        "description": "The type of access to a file mapping object, which determines the protection of the pages. This parameter can         be one of the following values.  ValueMeaning  FILE_MAP_ALL_ACCESS   A read/write view of the file is mapped. The file mapping object must have been created with           PAGE_READWRITE protection. When used with the MapViewOfFileFromApp           function, FILE_MAP_ALL_ACCESS is equivalent to           FILE_MAP_WRITE.   FILE_MAP_COPY   A copy-on-write view of the file is mapped. The file mapping object must have been created with           PAGE_READONLY, PAGE_READ_EXECUTE,           PAGE_WRITECOPY, or           PAGE_READWRITE protection. When a process writes to a copy-on-write page, the system copies the original page to a new page that is           private to the process. The new page is backed by the paging file. The protection of the new page changes           from copy-on-write to read/write. When copy-on-write access is specified, the system and process commit charge taken is for the entire view           because the calling process can potentially write to every page in the view, making all pages private. The           contents of the new page are never written back to the original file and are lost when the view is           unmapped.   FILE_MAP_READ   A read-only view of the file is mapped. An attempt to write to the file view results in an access           violation. The file mapping object must have been created with PAGE_READONLY,           PAGE_READWRITE, PAGE_EXECUTE_READ, or           PAGE_EXECUTE_READWRITE protection.   FILE_MAP_WRITE   A read/write view of the file is mapped. The file mapping object must have been created with           PAGE_READWRITE protection. When used with MapViewOfFileFromApp,           (FILE_MAP_WRITE | FILE_MAP_READ) and           FILE_MAP_ALL_ACCESS are equivalent to FILE_MAP_WRITE.     For more information about access to file mapping objects, see         File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "ULONG64",
        "name": "FileOffset",
        "description": "The file offset where the view is to begin. The offset must specify an offset within the file mapping. They         must also match the  memory allocation granularity of the system. That is, the offset must be a multiple of the         allocation granularity. To obtain the memory allocation granularity of the system, use the         GetSystemInfo function, which fills in the members of         a SYSTEM_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytesToMap",
        "description": "The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified         by CreateFileMappingFromApp. If this         parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "Maps a view of a file or a pagefile-backed section into the address     space of the specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns the base address of the mapped view, if successful. Otherwise, returns NULL and extended error status is available            using GetLastError. ",
    "remarks": "",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "MapViewOfFileNuma2",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileMappingHandle",
        "description": "A HANDLE to a section that is to be mapped                         into the address space of the specified process."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A HANDLE to a process into which the section                     will be mapped."
      },
      {
        "in_out": "_In_",
        "type": "ULONG64",
        "name": "Offset",
        "description": "The offset from the beginning of the section.              This must be 64k aligned."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "The desired base address of the view.                   The address is rounded down to the nearest 64k boundary.                   If this parameter is NULL, the system picks the base                   address."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "ViewSize",
        "description": "The number of bytes to map. A value of zero                (0) specifies that the entire section is to be mapped."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocationType",
        "description": "The type of allocation. This parameter can be zero (0) or one of the following constant values:  MEM_RESERVE - Maps a reserved view MEM_LARGE_PAGES - Maps a large page view"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PageProtection",
        "description": "The desired page protection."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PreferredNode",
        "description": "The preferred NUMA node for this memory."
      }
    ],
    "min_client": "Windows 10, version 1703 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Opens a named file mapping object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is an open handle to the specified file mapping object. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "The handle that OpenFileMapping returns can be used       with any function that requires a handle to a file mapping object. When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.       If required, the caller should use SetFileTime to set the       timestamp. When it is no longer needed, the caller should call release the handle returned by       OpenFileMapping with a call to       CloseHandle. In Windows Server 2012, this function is supported by the following technologies.  For an example, see       Creating Named Shared Memory. ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "OpenFileMapping",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the file mapping object. This access is checked against any security descriptor on the target        file mapping object. For a list of values, see        File Mapping Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this parameter is TRUE, a process created by the        CreateProcess function can inherit the handle;        otherwise, the handle cannot be inherited."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the file mapping object to be opened. If there is an open handle to a file mapping object by        this name and the security descriptor on the mapping object does not conflict with the        dwDesiredAccess parameter, the open operation succeeds. The name can have a        \"Global\\\" or \"Local\\\" prefix to explicitly open an object in the global or        session namespace. The remainder of the name can contain any character except the backslash character (\\). For        more information, see        Kernel Object Namespaces. Fast user        switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next        user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal        Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Unmaps a mapped view of a file from the calling process's address space.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Unmapping a mapped view of a file invalidates the range occupied by the view in the address space of the process and makes the range available for other allocations. It removes the working set entry for each unmapped virtual page that was part of the working set of the process and reduces the working set size of the process. It also decrements the share count of the corresponding physical page. Modified pages in the unmapped view are not written to disk until their share count reaches zero, or in other words, until they are unmapped or trimmed from the working sets of all processes that share the pages. Even then, the modified pages are written \"lazily\" to disk; that is, modifications may be cached in memory and written to disk at a later time. To minimize the risk of data loss in the event of a power failure or a system crash, applications should explicitly flush modified pages using the FlushViewOfFile function. Although an application may close the file handle used to create a file mapping object, the system holds the corresponding file open until the last view of the file is unmapped.  Files for which the last view has not yet been unmapped are held open with no sharing restrictions. In Windows Server 2012, this function is supported by the following technologies.  For an example, see  Creating a View Within a File. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "UnmapViewOfFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpBaseAddress",
        "description": "A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to the  MapViewOfFile or  MapViewOfFileEx function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Unmaps a previously mapped view of a file or a     pagefile-backed section.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns TRUE if sucessful. Otherwise, returns FALSE and extended error status is available             using GetLastError. ",
    "remarks": "",
    "return_type": "",
    "category": "Memory Management",
    "name": "UnmapViewOfFile2",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A HANDLE to the process from which the section                     will be unmapped."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "The base address of a previously mapped                   view that is to be unmapped.  This value must be                   identical to the value returned by a previous call                   to MapViewOfFile2."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UnmapFlags",
        "description": "MEM_UNMAP_WITH_TRANSIENT_BOOST or zero (0). MEM_UNMAP_WITH_TRANSIENT_BOOST should be used if the                  pages backing this view should be temporarily boosted                  (with automatic short term decay) because another thread                  will access them shortly."
      }
    ],
    "min_client": "Windows 10, version 1703 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Allocates physical memory pages to be mapped and unmapped within any      Address Windowing Extensions (AWE) region of      a specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. Fewer pages than requested can be allocated.        The caller must check the value of the NumberOfPages parameter on return to see how        many pages are allocated. All allocated page frame numbers are sequentially placed in the memory pointed to by        the UserPfnArray parameter. If the function fails, the return value is FALSE, and no frames are allocated. To get extended error         information, call GetLastError. ",
    "remarks": "The AllocateUserPhysicalPages function      is used to allocate physical memory that can later be mapped within the virtual address space of the process. The SeLockMemoryPrivilege privilege  must be enabled in the caller's token or the function will fail with ERROR_PRIVILEGE_NOT_HELD. For more information, see Privilege Constants. Memory allocated by this function must be physically present in the system.      After the memory is allocated, it is locked down and unavailable to the rest of the virtual memory      management system. Physical pages cannot be simultaneously mapped at more than one virtual address. Physical pages can reside at any physical address. You should make no assumptions about the contiguity of the      physical pages. To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more      information, see Using the Windows Headers. For an example, see AWE Example. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "AllocateUserPhysicalPages",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to a process. The function allocates memory that can later be mapped within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG_PTR",
        "name": "NumberOfPages",
        "description": "The size of the physical memory to allocate, in pages. To determine the page size of the computer, use the        GetSystemInfo function. On output, this parameter        receives the number of pages that are actually allocated, which might be less than the number requested."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "UserPfnArray",
        "description": "A pointer to an array to store the page frame numbers of the allocated memory. The size of the array        that is allocated should be at least the NumberOfPages times the size of the        ULONG_PTR data type.        Do not attempt to modify this buffer. It contains operating system data, and corruption could be         catastrophic. The information in the buffer is not useful to an application."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Frees      physical memory pages that are allocated previously by using      AllocateUserPhysicalPages or AllocateUserPhysicalPagesNuma. If any of these      pages are currently mapped in the Address Windowing Extensions (AWE) region, they are automatically unmapped by this call. This does not      affect the virtual address space that is occupied by a specified Address Windowing Extensions (AWE) region.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. In this case, the NumberOfPages         parameter reflect how many pages have actually been released. To get extended error information, call         GetLastError. ",
    "remarks": "In a multiprocessor environment, this function maintains coherence of the hardware translation buffer. When this function returns, all threads on all processors are guaranteed to see the correct mapping. To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more      information, see Using the Windows      Headers. For an example, see AWE Example. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "FreeUserPhysicalPages",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "The handle to a process.  The function frees memory within the virtual address space of this process."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG_PTR",
        "name": "NumberOfPages",
        "description": "The size of the physical memory to free, in pages.  On return, if the function fails, this parameter indicates        the number of pages that are freed."
      },
      {
        "in_out": "_In_",
        "type": "PULONG_PTR",
        "name": "UserPfnArray",
        "description": "A pointer to an array of page frame numbers of the allocated memory to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Maps      previously allocated physical memory pages at a specified address in an      Address Windowing Extensions (AWE) region.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE and no mapping is done\u00e2\u0080\u0094partial or otherwise.         To get extended error information, call         GetLastError. ",
    "remarks": "The physical pages are unmapped but they are not freed. You must call      FreeUserPhysicalPages to free the      physical pages. Any number of physical memory pages can be specified, but the memory must  not extend outside the virtual      address space that VirtualAlloc allocates. Any      existing address maps are automatically overwritten with the new translations, and the old translations are      unmapped. You cannot map physical memory pages outside the range that is specified in      AllocateUserPhysicalPages. You      can map multiple regions simultaneously, but they cannot overlap. Physical pages can be located at any physical address, but do not make assumptions about the contiguity of the      physical pages. To unmap the current address range, specify NULL as the physical memory page array parameter. Any      currently mapped pages are unmapped, but are not freed. You must call      FreeUserPhysicalPages to free the      physical pages. In a multiprocessor environment, this function maintains hardware translation buffer coherence. On return      from this function, all threads on all processors are guaranteed to see the correct mapping. To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more      information, see Using the Windows      Headers. For an example, see AWE Example. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "MapUserPhysicalPages",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpAddress",
        "description": "A pointer to the starting address of the region of memory to remap.  The value of        lpAddress must be within the address range that the        VirtualAlloc function returns when the Address Windowing Extensions (AWE) region is        allocated."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "NumberOfPages",
        "description": "The size of the physical memory and virtual address space for which to establish translations, in pages.  The        virtual address range is contiguous starting at lpAddress. The physical frames are        specified by the UserPfnArray. The total number of pages cannot extend from the        starting address beyond the end of the range that is specified in        AllocateUserPhysicalPages."
      },
      {
        "in_out": "_In_",
        "type": "PULONG_PTR",
        "name": "UserPfnArray",
        "description": "A pointer to an array of physical page frame numbers.  These frames are mapped by the argument        lpAddress on return from this function. The size of the memory that is allocated should be        at least the NumberOfPages times the size of the data type        ULONG_PTR.         Do not attempt to modify this buffer. It contains operating system data, and corruption could be         catastrophic. The information in the buffer is not useful to an application. If this parameter is NULL, the specified address range is unmapped.  Also, the specified physical pages are not         freed, and you must call FreeUserPhysicalPages to         free them."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Maps previously allocated physical memory pages at a specified address in an      Address Windowing Extensions (AWE) region.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE, and the function does not map or unmap\u00e2\u0080\u0094partial or         otherwise. To get extended error information, call         GetLastError. ",
    "remarks": "The physical pages may be unmapped, but they are not freed. You must call      FreeUserPhysicalPages to free the physical      pages. You can specify any number of physical memory pages, but the memory cannot extend outside the virtual      address space that is allocated by VirtualAlloc. Any      existing address maps are automatically overwritten with the new translations, and the old translations are      unmapped. You cannot map physical memory pages outside the range that is specified in      AllocateUserPhysicalPages. You can map      multiple regions simultaneously, but they cannot overlap. Physical pages can be located at any physical address, but do not make assumptions about the contiguity of the      physical pages. In a multiprocessor environment, this function maintains hardware translation buffer coherence. On return      from this function, all threads on all processors are guaranteed to see the correct mapping. To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more      information, see Using the Windows      Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "MapUserPhysicalPagesScatter",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID*",
        "name": "VirtualAddresses",
        "description": "A pointer to an array of starting addresses of the regions of memory to remap.  Each entry in        VirtualAddresses must be within the address range that the        VirtualAlloc function returns when the Address Windowing Extensions (AWE) region is        allocated. The value in NumberOfPages indicates the size of the array. Entries can be from multiple Address Windowing Extensions (AWE) regions."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "NumberOfPages",
        "description": "The size of the physical memory and virtual address space for which to establish translations, in pages.  The        array at VirtualAddresses specifies the virtual address range."
      },
      {
        "in_out": "_In_",
        "type": "PULONG_PTR",
        "name": "PageArray",
        "description": "A pointer to an array of values that indicates how each corresponding page in        VirtualAddresses should be treated.  A 0 (zero) indicates that the corresponding entry in        VirtualAddresses should be unmapped, and any nonzero value that it has should be mapped.        If this parameter is NULL, then every address in the VirtualAddresses array is         unmapped. The value in NumberOfPages indicates the size of the array."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves a handle to the default heap of the calling process. This handle can then be used in subsequent calls to the heap functions.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the calling process's heap. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The  GetProcessHeap function obtains a handle to the default heap for the calling process. A process can use this handle to allocate memory from the process heap without having to first create a private heap using the  HeapCreate function. Windows Server 2003 and Windows XP:  To enable the low-fragmentation heap for the default heap of the process, call the  HeapSetInformation function with the handle returned by GetProcessHeap. For an example, see Getting Process Heaps. ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "GetProcessHeap",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the number of active heaps and retrieves handles to all of the active heaps for the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "The return value is the number of handles to heaps that are active for the calling process. If the return value is less than or equal to NumberOfHeaps, the function has stored that number of heap handles in the buffer pointed to by ProcessHeaps. If the return value is greater than NumberOfHeaps, the buffer pointed to by ProcessHeaps is too small to hold all the heap handles for the calling process, and the function stores NumberOfHeaps handles in the buffer. Use the return value to allocate a buffer that is large enough to receive all of the handles, and call the function again. If the return value is zero, the function has failed because every process has at least one active heap, the default heap for the  process. To get extended error information, call  GetLastError. ",
    "remarks": "The  GetProcessHeaps function obtains a handle to the default heap of the calling process, plus handles to any additional private heaps  created by calling the  HeapCreate function on any thread in the process. The GetProcessHeaps function is primarily useful for debugging, because some of the private heaps retrieved by the function may have been created by other code running in the process and may be destroyed after GetProcessHeaps returns. Destroying a heap invalidates the handle to the heap, and continued use of such handles can cause undefined behavior in the application. Heap functions should be called only on the default heap of the calling process and on private heaps that the process creates and manages. To obtain a handle to the process heap of the calling process, use the  GetProcessHeap function. For an example, see Getting Process Heaps. ",
    "return_type": "DWORD",
    "category": "Memory Management",
    "name": "GetProcessHeaps",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "NumberOfHeaps",
        "description": "The maximum number of heap handles that can be stored into the buffer pointed to by ProcessHeaps."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "ProcessHeaps",
        "description": "A pointer to a buffer that receives an array of heap handles."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Allocates a block of memory from a heap. The allocated memory is not movable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a pointer to the allocated memory block. If the function fails and you have not specified HEAP_GENERATE_EXCEPTIONS, the return value is NULL. If the function fails and you have specified HEAP_GENERATE_EXCEPTIONS, the function may generate either of the exceptions listed in the following table. The particular exception depends upon the nature of the heap corruption. For more information, see GetExceptionCode.  If the function fails, it does not call SetLastError. An application cannot call GetLastError for extended error information. ",
    "remarks": "If  the HeapAlloc function succeeds, it allocates at least the amount of memory requested. To allocate memory from the process's default heap, use  HeapAlloc with the handle returned by the GetProcessHeap function. To free a block of memory allocated by  HeapAlloc, use the  HeapFree function. Memory allocated by  HeapAlloc is not movable. The address returned by  HeapAlloc is valid until the memory block is freed or reallocated; the memory block does not need to be locked. Because the system cannot compact a private heap, it can become fragmented. Applications that allocate large amounts of memory in various allocation sizes can use the  low-fragmentation heap to reduce heap fragmentation. Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. Setting the HEAP_NO_SERIALIZE value eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap. The HEAP_NO_SERIALIZE value can, therefore, be safely used only in the following situations: For an example, see  AWE Example. ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "HeapAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap from which the memory will be allocated. This handle is returned by the  HeapCreate or  GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The heap allocation options. Specifying any of these values will override the corresponding value specified when the heap was created with  HeapCreate. This parameter can be one or more of the following values.     ValueMeaning  HEAP_GENERATE_EXCEPTIONS 0x00000004   The system will raise an exception to indicate a function failure, such as an out-of-memory condition, instead of returning NULL. To ensure that exceptions are generated for all calls to this function, specify HEAP_GENERATE_EXCEPTIONS in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_GENERATE_EXCEPTIONS in this function call.   HEAP_NO_SERIALIZE 0x00000001   Serialized access will not be used for this allocation.    For more information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call. This value should not be specified when accessing the process's default heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process's default heap.   HEAP_ZERO_MEMORY 0x00000008   The allocated memory will be initialized to zero. Otherwise, the memory is not initialized to zero."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwBytes",
        "description": "The number of bytes to be allocated. If the heap specified by the hHeap parameter is a \"non-growable\" heap, dwBytes must be less than 0x7FFF8. You create a non-growable heap by calling the HeapCreate function with a nonzero value."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Returns  the size of the largest committed free block in the specified heap.   If the Disable heap coalesce on free global flag is set, this function also coalesces adjacent free blocks of memory in the heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the size of the largest committed free block in the heap, in bytes. If the function fails, the return value is zero. To get extended error information, call  GetLastError. In the unlikely case that there is absolutely no space available in the heap, the function return value is zero, and GetLastError returns the value NO_ERROR. ",
    "remarks": "The HeapCompact function is primarily useful for debugging. Ordinarily, the system compacts the heap whenever the HeapFree function is called, and the HeapCompact function returns the size of the largest free block in the heap but does not compact the heap any further. If the Disable heap coalesce on free global flag is set during debugging, the system does not compact the heap and calling the HeapCompact function does compact the heap.  For more information about global flags, see the GFlags documentation. There is no guarantee that an application can successfully allocate a memory block of the size returned by  HeapCompact. Other threads or the commit threshold might prevent such an allocation. Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. Setting the HEAP_NO_SERIALIZE value eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap. The HEAP_NO_SERIALIZE value can, therefore, be safely used only in the following situations: ",
    "return_type": "SIZE_T",
    "category": "Memory Management",
    "name": "HeapCompact",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap. This handle is returned by either the  HeapCreate or  GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The heap access options. This parameter can be the following value.     ValueMeaning  HEAP_NO_SERIALIZE 0x00000001   Serialized access will not be used.    For more information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call. Do not specify this value when accessing the process heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process heap."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a private heap object that can be used by the calling process. The function reserves space in the virtual address space of the process and allocates physical storage for a specified initial portion of this block.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the newly created heap. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The  HeapCreate function creates a private heap object from which the calling process can allocate memory blocks by using the  HeapAlloc function. The initial size determines the number of committed pages that are allocated initially for the heap. The maximum size determines the total number of reserved pages. These pages create a block in the process's virtual address space into which the heap can grow. If requests by  HeapAlloc exceed the current size of committed pages, additional pages are automatically committed from this reserved space, if the physical storage is available. Windows Server 2003 and Windows XP:  By default, the newly created private heap is a standard heap. To enable the low-fragmentation heap, call the  HeapSetInformation function with a handle to the private heap. The memory of a private heap object is accessible only to the process that created it. If a dynamic-link library (DLL) creates a private heap, the heap is created in the address space of the process that calls the DLL, and it is accessible only to that process. The system uses memory from the private heap to store heap support structures, so not all of the specified heap size is available to the process. For example, if the  HeapAlloc function requests 64 kilobytes (K) from a heap with a maximum size of 64K, the request may fail because of system overhead. If HEAP_NO_SERIALIZE is not specified (the simple default), the heap serializes access within the calling process. Serialization ensures mutual exclusion when two or more threads attempt simultaneously to allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. The HeapLock and HeapUnlock functions can be used to block and permit access to a serialized heap. Setting HEAP_NO_SERIALIZE eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, which may cause corruption in the heap. Therefore, HEAP_NO_SERIALIZE can safely be used only in the following situations: If the HeapLock and HeapUnlock functions are called on a heap created with the HEAP_NO_SERIALIZE flag, the results are undefined. To obtain a handle to the default heap for a process, use the GetProcessHeap function. To obtain handles to the default heap and private heaps that are active for the calling process, use the GetProcessHeaps function. Enumerating a Heap ",
    "return_type": "HANDLE",
    "category": "Memory Management",
    "name": "HeapCreate",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flOptions",
        "description": "The heap allocation options. These options affect subsequent access to the new heap through calls to the heap functions. This parameter can be 0 or one or more of the following values.     ValueMeaning  HEAP_CREATE_ENABLE_EXECUTE 0x00040000   All memory blocks that are allocated from this heap allow code execution, if the hardware enforces data execution prevention. Use this flag heap in applications that run code from the heap. If HEAP_CREATE_ENABLE_EXECUTE is not specified and an application attempts to run code from a protected page, the application receives an exception with the status code STATUS_ACCESS_VIOLATION.    HEAP_GENERATE_EXCEPTIONS 0x00000004   The system raises an exception to indicate failure (for example,  an out-of-memory condition) for calls to HeapAlloc and HeapReAlloc instead of returning NULL.   HEAP_NO_SERIALIZE 0x00000001   Serialized access is not used when the heap functions access this heap. This option applies to all subsequent heap function calls. Alternatively, you can specify this option on individual heap function calls.  The low-fragmentation heap (LFH) cannot be enabled for a heap created with this option.  A heap created with this option cannot be locked. For more information about serialized access, see the  Remarks section of this topic."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwInitialSize",
        "description": "The initial size of the heap, in bytes. This value determines the initial amount of memory that is committed for the heap. The value is rounded up to a multiple of the system page size. The value must be smaller than dwMaximumSize. If this parameter is 0, the function commits one page. To determine the size of a page on the host computer, use the  GetSystemInfo function."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwMaximumSize",
        "description": "The maximum size of the heap, in bytes. The  HeapCreate function rounds dwMaximumSize up to a multiple of the system page size and then reserves a block of that size in the process's virtual address space for the heap. If allocation requests made by the  HeapAlloc or  HeapReAlloc functions exceed the size specified by dwInitialSize, the system commits additional pages of memory for the heap, up to the heap's maximum size.  If dwMaximumSize is not zero, the heap size is fixed and cannot grow beyond the maximum size. Also, the largest memory block that can be allocated from the heap is slightly less than 512 KB for a 32-bit process and slightly less than 1,024 KB for a 64-bit process. Requests to allocate larger blocks fail, even if the maximum size of the heap is large enough to contain the block.     If dwMaximumSize is 0, the heap can grow in size. The heap's size is limited only by the available memory. Requests to allocate memory blocks larger than the limit for a fixed-size heap do not automatically fail; instead, the system calls the  VirtualAlloc function to obtain the memory that is needed for large blocks. Applications that need to allocate large memory blocks should set dwMaximumSize to 0."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Destroys the specified heap object.  It decommits and releases all the pages of a private heap object, and it invalidates the handle to the heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Processes can call  HeapDestroy without first calling the  HeapFree function to free memory allocated from the heap. Enumerating a Heap ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapDestroy",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap to be destroyed. This handle is returned by the  HeapCreate function. Do not use the handle to the process heap returned by the  GetProcessHeap function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Frees a memory block allocated from a heap by the  HeapAlloc or  HeapReAlloc function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. An application can call  GetLastError for extended error information. ",
    "remarks": "You should not refer in any way to memory that has been freed by  HeapFree. After that memory is freed, any information that may have been in it is gone forever. If you require information, do not free memory containing the information. Function calls that return information about memory (such as  HeapSize) may not be used with freed memory, as they may return bogus data. Calling HeapFree twice with the same pointer can cause heap corruption, resulting in subsequent calls to HeapAlloc returning the same pointer twice. Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. Setting the HEAP_NO_SERIALIZE value eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap. The HEAP_NO_SERIALIZE value can, therefore, be safely used only in the following situations: For an example, see Getting Process Heaps. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapFree",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap whose memory block is to be freed. This handle is returned by either the  HeapCreate or  GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The heap free options. Specifying the following value overrides the corresponding value specified in the flOptions parameter when the heap was created by using the  HeapCreate function.     ValueMeaning  HEAP_NO_SERIALIZE 0x00000001   Serialized access will not be used. For more information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call. Do not specify this value when accessing the process heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process heap."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpMem",
        "description": "A pointer to the memory block to be freed. This pointer is returned by the  HeapAlloc or  HeapReAlloc function. If this pointer is NULL, the behavior is undefined."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Attempts to acquire the critical section object, or lock, that is associated with a specified heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If the function succeeds, the calling thread owns the heap lock. Only the calling thread will be able to allocate or release memory from the heap. The execution of any other thread of the calling process will be blocked if that thread attempts to allocate or release memory from the heap. Such threads will remain blocked until the thread that owns the heap lock calls the  HeapUnlock function. The  HeapLock function is primarily useful for preventing the allocation and release of heap memory by other threads while the calling thread uses the  HeapWalk function. If the HeapLock function is called on a heap created with the HEAP_NO_SERIALIZATION flag, the results are undefined. Each successful call to  HeapLock must be matched by a corresponding call to HeapUnlock. Failure to call  HeapUnlock will block the execution of any other threads of the calling process that attempt to access the heap. Enumerating a Heap ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapLock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap to be locked. This handle is returned by either the  HeapCreate or  GetProcessHeap function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information about the specified heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To enable the  LFH or the terminate-on-corruption feature, use the  HeapSetInformation function. Windows XP and Windows Server 2003: A look-aside list is a fast memory allocation mechanism that contains only fixed-sized blocks. Look-aside lists are enabled by default for heaps that support them. Starting with Windows Vista, look-aside lists are not used and the LFH is enabled by default. Look-aside lists are faster than general pool allocations that vary in size, because the system does not search for free memory that fits the allocation. In addition, access to look-aside lists is generally synchronized using fast atomic processor exchange instructions instead of mutexes or spinlocks. Look-aside lists can be created by the system or drivers. They can be allocated from paged or nonpaged pool.  The following example uses GetProcessHeap to       obtain a handle to the default process heap and       HeapQueryInformation to retrieve information       about the heap. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapQueryInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "HeapHandle",
        "description": "A handle to the heap whose information is to be retrieved. This handle is returned by either the  HeapCreate or  GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "HEAP_INFORMATION_CLASS",
        "name": "HeapInformationClass",
        "description": "The class of information to be retrieved. This parameter can be the following value from the HEAP_INFORMATION_CLASS enumeration type.  ValueMeaning  HeapCompatibilityInformation 0   Indicates the heap features that are enabled.     The HeapInformation parameter is a pointer to a ULONG variable. If HeapInformation is 0, the heap is a standard heap that does not support look-aside lists. If HeapInformation is 1, the heap supports look-aside lists. For more information, see Remarks. If HeapInformation is 2, the low-fragmentation heap (LFH) has been enabled for the heap. Enabling the LFH disables look-aside lists."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "HeapInformation",
        "description": "A pointer to a buffer that receives the heap information. The format of this data depends on the value of the HeapInformationClass parameter."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "HeapInformationLength",
        "description": "The size of the heap information being queried, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PSIZE_T",
        "name": "ReturnLength",
        "description": "A pointer to a variable that receives the length of data written to the HeapInformation buffer. If the buffer is too small, the function fails and ReturnLength specifies the minimum size required for the buffer.     If you do not want to receive this information, specify NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Reallocates a block of memory from a heap. This function enables you to resize a memory block and change other memory block properties. The allocated memory is not movable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a pointer to the reallocated memory block. If the function fails and you have not specified HEAP_GENERATE_EXCEPTIONS, the return value is NULL. If the function fails and you have specified HEAP_GENERATE_EXCEPTIONS, the function may generate either of the exceptions listed in the following table. For more information, see GetExceptionCode.  If the function fails, it does not call SetLastError. An application cannot call GetLastError for extended error information. ",
    "remarks": "If  HeapReAlloc succeeds, it allocates at least the amount of memory requested. If  HeapReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid. HeapReAlloc is guaranteed to preserve the content of the memory being reallocated, even if the new memory is allocated at a different location. The process of preserving the memory content involves a memory copy operation that is potentially very time-consuming. To free a block of memory allocated by  HeapReAlloc, use the  HeapFree function. Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. Setting the HEAP_NO_SERIALIZE value eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap. The HEAP_NO_SERIALIZE value can, therefore, be safely used only in the following situations: ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "HeapReAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap from which the memory is to be reallocated. This handle is a returned by either the  HeapCreate or  GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The heap reallocation options. Specifying a value overrides the corresponding value specified in the flOptions parameter when the heap was created by using the  HeapCreate function. This parameter can be one or more of the following values.     ValueMeaning  HEAP_GENERATE_EXCEPTIONS 0x00000004   The operating-system raises an exception to indicate a function failure, such as an out-of-memory condition, instead of returning NULL. To ensure that exceptions are generated for all calls to this function, specify HEAP_GENERATE_EXCEPTIONS in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_GENERATE_EXCEPTIONS in this function call.   HEAP_NO_SERIALIZE 0x00000001   Serialized access will not be used. For more information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call. This value should not be specified when accessing the process heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process heap.   HEAP_REALLOC_IN_PLACE_ONLY 0x00000010   There can be no movement when reallocating a memory block. If this value is not specified, the function may move the block to a new location. If this value is specified and the block cannot be resized without moving, the function fails, leaving the original memory block unchanged.   HEAP_ZERO_MEMORY 0x00000008   If the reallocation request is for a larger size, the additional region of memory beyond the original size be initialized to zero. The contents of the memory block up to its original size are unaffected."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpMem",
        "description": "A pointer to the block of memory that the function reallocates. This pointer is returned by an earlier call to the  HeapAlloc or  HeapReAlloc function."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwBytes",
        "description": "The new size of the memory block, in bytes. A memory block's size can be increased or decreased by using this function. If the heap specified by the hHeap parameter is a \"non-growable\" heap, dwBytes must be less than 0x7FFF8. You create a non-growable heap by calling the  HeapCreate function with a nonzero value."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Enables features for a specified heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call         GetLastError. ",
    "remarks": "To retrieve the current settings for the heap, use the      HeapQueryInformation function. Setting the HeapEnableTerminateOnCorruption option is strongly recommended because      it reduces an application's exposure to security exploits that take advantage of a corrupted heap. The following example shows you how to enable the low-fragmentation heap. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapSetInformation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "HeapHandle",
        "description": "A handle to the heap where information is to be set. This handle is returned by either the        HeapCreate or        GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "HEAP_INFORMATION_CLASS",
        "name": "HeapInformationClass",
        "description": "The class of information to be set. This parameter can be one of the following values from the        HEAP_INFORMATION_CLASS enumeration type.  ValueMeaning  HeapCompatibilityInformation 0   Enables heap features. Only the          low-fragmentation heap (LFH) is supported.          However, it is not necessary for applications to enable the LFH because the system uses the LFH as needed to          service memory allocation requests.          Windows XP and Windows Server 2003:  The LFH is not enabled by default. To enable the LFH for the specified heap, set the variable pointed to             by the HeapInformation parameter to 2. After the LFH is enabled for a heap, it             cannot be disabled. The LFH cannot be enabled for heaps created with HEAP_NO_SERIALIZE or for heaps             created with a fixed size. The LFH also cannot be enabled if you are using the heap debugging tools in             Debugging Tools for Windows             or             Microsoft Application Verifier. When a process is run under any debugger, certain heap debug options are automatically enabled for all             heaps in the process. These heap debug options prevent the use of the LFH. To enable the low-fragmentation             heap when running under a debugger, set the _NO_DEBUG_HEAP environment variable             to 1.   HeapEnableTerminationOnCorruption 1   Enables the terminate-on-corruption feature. If the heap manager detects an error in any heap used by the           process, it calls the Windows Error Reporting service and terminates the process. After a process enables this feature, it cannot be disabled. Windows Server 2003 and Windows XP:  This value is not supported until Windows Vista and Windows XP with SP3. The            function succeeds but the HeapEnableTerminationOnCorruption value is            ignored.   HeapOptimizeResources 3   If HeapSetInformation is called with HeapHandle set to NULL, then all heaps in the process with a low-fragmentation heap (LFH) will have their caches optimized,  and the memory will be decommitted if possible.   If a heap pointer is supplied in HeapHandle, then only that heap will be optimized. Note that the HEAP_OPTIMIZE_RESOURCES_INFORMATION  structure passed in HeapInformation must be properly initialized. Note  This value was added in Windows 8.1."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "HeapInformation",
        "description": "The heap information buffer. The format of this data depends on the value of the         HeapInformationClass parameter. If the HeapInformationClass parameter is         HeapCompatibilityInformation, the HeapInformation         parameter is a pointer to a ULONG variable. If the HeapInformationClass parameter is         HeapEnableTerminationOnCorruption, the HeapInformation         parameter should be NULL and HeapInformationLength should         be 0"
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "HeapInformationLength",
        "description": "The size of the HeapInformation buffer, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the size of a memory block allocated from a heap by the      HeapAlloc or      HeapReAlloc function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the requested size of the allocated memory block, in bytes. If the function fails, the return value is (SIZE_T)-1.         The function does not call SetLastError. An         application cannot call GetLastError for extended         error information. If the lpMem parameter refers to a heap allocation that is not in the heap         specified by the hHeap parameter, the behavior of the         HeapSize function is undefined. ",
    "remarks": "Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free      blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever      multiple threads allocate and free memory from the same heap. Setting the      HEAP_NO_SERIALIZE value eliminates mutual exclusion on the heap. Without serialization,      two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely      causing corruption in the heap. The HEAP_NO_SERIALIZE value can, therefore, be safely      used only in the following situations: ",
    "return_type": "SIZE_T",
    "category": "Memory Management",
    "name": "HeapSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap in which the memory block resides. This handle is returned by either the        HeapCreate or        GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The heap size options. Specifying the following value overrides the corresponding value specified in the        flOptions parameter when the heap was created by using the        HeapCreate function.  ValueMeaning  HEAP_NO_SERIALIZE 0x00000001   Serialized access will not be used. For more information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify           HEAP_NO_SERIALIZE in the call to           HeapCreate. In this case, it is not necessary to           additionally specify HEAP_NO_SERIALIZE in this function call. This value should not be specified when accessing the process heap. The system may create additional           threads within the application's process, such as a CTRL+C handler, that simultaneously access the process           heap."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpMem",
        "description": "A pointer to the memory block whose size the function will obtain. This is a pointer returned by the        HeapAlloc or        HeapReAlloc function. The memory block must        be from the heap specified by the hHeap parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases ownership of the critical section object, or lock, that is associated with a specified heap. It reverses the action of the  HeapLock function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  HeapLock function is primarily useful for preventing the allocation and release of heap memory by other threads while the calling thread uses the  HeapWalk function. The  HeapUnlock function is the inverse of  HeapLock. Each call to  HeapLock must be matched by a corresponding call to the  HeapUnlock function. Failure to call  HeapUnlock will block the execution of any other threads of the calling process that attempt to access the heap. If the HeapUnlock function is called on a heap created with the HEAP_NO_SERIALIZATION flag, the results are undefined. Enumerating a Heap ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapUnlock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap to be unlocked. This handle is returned by either the  HeapCreate or  GetProcessHeap function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Validates the specified heap. The function scans all the memory blocks in the heap and verifies that the heap control structures maintained by the heap manager are in a consistent state. You can also use the  HeapValidate function to validate a single memory block within a specified heap without checking the validity of the entire heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the specified heap or memory block is valid, the return value is nonzero. If the specified heap or memory block is invalid, the return value is zero. On a system set up for debugging, the  HeapValidate function then displays debugging messages that describe the part of the heap or memory block that is invalid, and stops at a hard-coded breakpoint so that you can examine the system to determine the source of the invalidity. The  HeapValidate function does not set the thread's last error value. There is no extended error information for this function; do not call GetLastError. ",
    "remarks": "The HeapValidate function is primarily useful for debugging because validation is potentially time-consuming. Validating a heap can block other threads from accessing the heap and can degrade performance, especially on symmetric multiprocessing (SMP) computers. These side effects can last until HeapValidate returns. There are heap control structures for each memory block in a heap, and for the heap as a whole. When you use the  HeapValidate function to validate a complete heap, it checks all of these control structures for consistency. When you use  HeapValidate to validate a single memory block within a heap, it checks only the control structures pertaining to that element.  HeapValidate can only validate allocated memory blocks. Calling  HeapValidate on a freed memory block will return FALSE because there are no control structures to validate. If you want to validate the heap elements enumerated by the  HeapWalk function, you should only call  HeapValidate on the elements that have PROCESS_HEAP_ENTRY_BUSY in the wFlags member of the  PROCESS_HEAP_ENTRY structure.  HeapValidate returns FALSE for all heap elements that do not have this bit set. Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. Setting the HEAP_NO_SERIALIZE value eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap. The HEAP_NO_SERIALIZE value can, therefore, be safely used only in the following situations: ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapValidate",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap to be validated. This handle is returned by either the  HeapCreate or  GetProcessHeap function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The heap access options. This parameter can be the following value.     ValueMeaning  HEAP_NO_SERIALIZE 0x00000001   Serialized access will not be used. For more information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call. This value should not be specified when accessing the process default heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process default heap."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "lpMem",
        "description": "A pointer to a memory block within the specified heap. This parameter may be NULL.     If this parameter is NULL, the function attempts to validate the entire heap specified by hHeap. If this parameter is not NULL, the function attempts to validate the memory block pointed to by lpMem. It does not attempt to validate the rest of the heap."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Enumerates the memory blocks in the specified heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "HeapApi.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. If the heap enumeration terminates successfully by reaching the end of the heap, the function returns         FALSE, and GetLastError         returns the error code ERROR_NO_MORE_ITEMS. ",
    "remarks": "The HeapWalk function is primarily useful for debugging      because enumerating a heap is a potentially time-consuming operation. Locking the heap during enumeration blocks      other threads from accessing the heap and can degrade performance, especially on symmetric multiprocessing (SMP)      computers. The side effects can last until the heap is unlocked. Use the      HeapLock and      HeapUnlock functions to control heap locking during heap      enumeration. To initiate a heap enumeration, call HeapWalk with the      lpData field of the      PROCESS_HEAP_ENTRY structure pointed to by      lpEntry set to NULL. To continue a heap enumeration, call HeapWalk with the same      hHeap and lpEntry values, and with the      PROCESS_HEAP_ENTRY structure unchanged from the      preceding call to HeapWalk. Repeat this process until you      have no need for further enumeration, or until the function returns FALSE and      GetLastError returns      ERROR_NO_MORE_ITEMS, indicating that all of the heap's memory blocks have been      enumerated. No special call of HeapWalk is needed to terminate the      heap enumeration, since no enumeration state data is maintained outside the contents of the      PROCESS_HEAP_ENTRY structure. HeapWalk can fail in a multithreaded application if the      heap is not locked during the heap enumeration. Enumerating a Heap ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "HeapWalk",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "A handle to the heap. This handle is returned by either the        HeapCreate or        GetProcessHeap function."
      },
      {
        "in_out": "_Inout_",
        "type": "LPPROCESS_HEAP_ENTRY",
        "name": "lpEntry",
        "description": "A pointer to a PROCESS_HEAP_ENTRY structure         that maintains state information for a particular heap enumeration. If the HeapWalk function succeeds, returning the value         TRUE, this structure's members contain information about the next memory block in the         heap. To initiate a heap enumeration, set the lpData field of the         PROCESS_HEAP_ENTRY structure to         NULL. To continue a particular heap enumeration, call the         HeapWalk function repeatedly, with no changes to         hHeap, lpEntry, or any of the members of the         PROCESS_HEAP_ENTRY structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Discards the memory contents of a range of memory pages, without decommitting the memory.         The contents of discarded memory is undefined and must be rewritten by the application.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 R2 Update [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "ERROR_SUCCESS if successful; a System Error Code otherwise. ",
    "remarks": "If DiscardVirtualMemory fails, the contents of the region is not altered. Use this function to discard memory contents that are no longer needed, while keeping the memory region itself committed.       Discarding memory may give physical RAM back to the system.       When the region of memory is again accessed by the application, the backing RAM is restored, and the contents of the memory is undefined. ",
    "return_type": "DWORD",
    "category": "Memory Management",
    "name": "DiscardVirtualMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "Page-aligned starting address of the memory to discard."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "Size, in bytes, of the memory region to discard.  Size must be an integer multiple of the system page size."
      }
    ],
    "min_client": "Windows 8.1 Update [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Indicates that the data contained in a range of memory pages is no longer needed by the application and can be discarded by the system if necessary.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 R2 Update [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "ERROR_SUCCESS if successful; a System Error Code otherwise. ",
    "remarks": "To reclaim offered pages, call ReclaimVirtualMemory.       The data in reclaimed pages may have been discarded, in which case the contents of the memory region is undefined and must be rewritten by the application. Do not call OfferVirtualMemory to offer virtual memory that is locked.       Doing so will unlock the specified range of pages. Note that offering and reclaiming virtual memory is similar to using the MEM_RESET and MEM_RESET_UNDO memory allocation flags,       except that OfferVirtualMemory removes the memory from the process working set and restricts access to the offered pages until they are reclaimed. ",
    "return_type": "DWORD",
    "category": "Memory Management",
    "name": "OfferVirtualMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "Page-aligned starting address of the memory to offer."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "Size, in bytes, of the memory region to offer.  Size must be an integer multiple of the system page size."
      },
      {
        "in_out": "_In_",
        "type": "OFFER_PRIORITY",
        "name": "Priority",
        "description": "Priority indicates how important the offered memory is to the application.        A higher priority increases the probability that the offered memory can be reclaimed intact when calling ReclaimVirtualMemory.        The system typically discards lower priority memory before discarding higher priority memory.        Priority must be one of the following values.  ValueMeaning  VMOfferPriorityVeryLow 0x00001000   The offered memory is very low priority, and should be the first discarded.   VMOfferPriorityLow 0x00002000   The offered memory is low priority.   VMOfferPriorityBelowNormal 0x00002000   The offered memory is below normal priority.   VMOfferPriorityNormal 0x00002000   The offered memory is of normal priority to the application, and should be the last discarded."
      }
    ],
    "min_client": "Windows 8.1 Update [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Provides an efficient mechanism to bring into memory potentially discontiguous virtual address ranges      in a process address space.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0 (zero). To get extended error information, call         GetLastError. ",
    "remarks": "The PrefetchVirtualMemory function is       targeted at applications that know with reasonable confidence the set of addresses they will be accessing. If       it's likely that these addresses are no longer resident in memory (i.e. they have been paged out to disk),       calling the PrefetchVirtualMemory function on       those address ranges before access will reduce the overall latency because the API will efficiently bring in       those address ranges from disk using large, concurrent I/O requests where possible. The PrefetchVirtualMemory function allows       applications to make efficient use of disk hardware by issuing large, concurrent I/Os where possible when the       application provides a list of process address ranges that are going to be accessed. Even for a single address       range (e.g. a file mapping), the       PrefetchVirtualMemory function can provide       performance improvements by issuing a single large I/O rather than the many smaller I/Os that would be issued via       page faulting. The PrefetchVirtualMemory function is purely       a performance optimization: prefetching is not necessary for accessing the target address ranges. The prefetched       memory is not added to the target process' working set; it is cached in physical memory. When the prefetched       address ranges are accessed by the target process, they will be added to the working set. Since the PrefetchVirtualMemory function can       never be necessary for correct operation of applications, it is treated as a strong hint by the system and is       subject to usual physical memory constraints where it can completely or partially fail under low-memory       conditions. It can also create memory pressure if called with large address ranges, so applications should only       prefetch address ranges they will actually use. To compile an application that calls this function, define _WIN32_WINNT as      _WIN32_WINNT_WIN8 or higher. For more information, see      Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "PrefetchVirtualMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "Handle to the process whose virtual address ranges are to be prefetched. Use the        GetCurrentProcess function to use the current        process."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "NumberOfEntries",
        "description": "Number of entries in the array pointed to by the VirtualAddresses        parameter."
      },
      {
        "in_out": "_In_",
        "type": "PWIN32_MEMORY_RANGE_ENTRY",
        "name": "VirtualAddresses",
        "description": "Pointer to an array of        WIN32_MEMORY_RANGE_ENTRY structures which        each specify a virtual address range to be prefetched. The virtual address ranges may cover any part of the        process address space accessible by the target process."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Reserved. Must be 0."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Reclaims a range of memory pages that were offered to the system with OfferVirtualMemory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 R2 Update [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns ERROR_SUCCESS if successful and the memory was reclaimed intact. Returns ERROR_BUSY if successful but the memory was discarded and must be rewritten by the application.  In this case, the contents of the memory region is undefined. Returns a System Error Code otherwise. ",
    "remarks": "Reclaimed memory pages can be used by the application, and will be written to the system paging file if paging occurs. If the function returns ERROR_SUCCESS, the data in the reclaimed pages is valid.       If the function returns ERROR_BUSY, the data in the reclaimed pages was discarded by the system and is no longer valid.       For this reason, memory should only be offered to the system if the application does not need or can regenerate the data. ",
    "return_type": "DWORD",
    "category": "Memory Management",
    "name": "ReclaimVirtualMemory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "Page-aligned starting address of the memory to reclaim."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "Size, in bytes, of the memory region to reclaim.  Size must be an integer multiple of the system page size."
      }
    ],
    "min_client": "Windows 8.1 Update [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Reserves, commits, or changes the state  of a region of pages in the virtual address space of the calling process.      Memory allocated by this function is automatically initialized to zero.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "Each page has an associated page state. The      VirtualAlloc function can perform the following      operations: VirtualAlloc cannot reserve a reserved page. It can      commit a page that is already committed. This means you can commit a range of pages, regardless of whether they      have already been committed, and the function will not fail. You can use VirtualAlloc to reserve a block of pages      and then make additional calls to VirtualAlloc to commit      individual pages from the reserved block. This enables a process to reserve a range of its virtual address space      without consuming physical storage until it is needed. If the lpAddress parameter is not NULL, the function uses      the lpAddress and dwSize parameters to compute the region of      pages to be allocated. The current state of the entire range of pages must be compatible with the type of      allocation specified by the flAllocationType parameter. Otherwise, the function fails      and none of the pages are allocated. This compatibility requirement does not preclude committing an already      committed page, as mentioned previously. To execute dynamically generated code, use      VirtualAlloc to allocate memory and the      VirtualProtect function to grant      PAGE_EXECUTE access. The VirtualAlloc function can be used to reserve an      Address Windowing Extensions (AWE)      region of memory within the virtual address space of a specified process. This region of memory can then be used      to map physical pages into and out of virtual memory as required by the application. The      MEM_PHYSICAL and MEM_RESERVE values must be set in the      AllocationType parameter. The MEM_COMMIT value must not be      set. The page protection must be set to PAGE_READWRITE. The VirtualFree function can decommit a committed      page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also      release a reserved page, making it a free page. When creating a region that will be executable, the calling program bears responsibility for ensuring cache      coherency via an appropriate call to      FlushInstructionCache once the code has been set      in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable      results. For an example, see       Reserving and Committing Memory. ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "VirtualAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "The starting address of the region to allocate. If the memory is being reserved, the specified address is        rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is        being committed, the address is rounded down to the next page boundary. To determine the size of a page and the        allocation granularity on the host computer, use the        GetSystemInfo function. If this parameter is        NULL, the system determines where to allocate the region. If this address is within an enclave that you have not initialized by calling InitializeEnclave, VirtualAlloc allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.  If the address in within an enclave that you initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region, in bytes. If the lpAddress parameter is        NULL, this value is rounded up to the next page boundary. Otherwise, the allocated        pages include all pages containing one or more bytes in the range from lpAddress to        lpAddress+dwSize. This means that a 2-byte range straddling        a page boundary causes both pages to be included in the allocated region."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flAllocationType",
        "description": "The type of memory allocation. This parameter must contain one of the following values.  ValueMeaning  MEM_COMMIT 0x00001000   Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified           reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,           the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are           actually accessed. To reserve and commit pages in one step, call           VirtualAlloc with           MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without           MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been reserved. The  resulting           error code is ERROR_INVALID_ADDRESS. An attempt to commit a page that is           already committed does not cause the function to fail. This means that you can commit pages without first           determining the current commitment state of each page. If lpAddress specifies an address within an enclave, flAllocationType must be MEM_COMMIT.   MEM_RESERVE 0x00002000   Reserves a range of the process's virtual address space without allocating any actual physical storage in           memory or in the paging file on disk. You can commit reserved pages in subsequent calls to the           VirtualAlloc function. To reserve and commit pages           in one step, call VirtualAlloc with           MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and           LocalAlloc, cannot use a reserved range of memory           until it is released.   MEM_RESET 0x00080000   Indicates that data in the memory range specified by lpAddress and           dwSize is no longer of interest. The pages should not be read from or written to           the paging file. However, the memory block will be used again later, so it should not be decommitted. This           value cannot be used with any other value. Using this value does not guarantee that the range operated on with MEM_RESET           will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it. When you specify MEM_RESET, the           VirtualAlloc function ignores the value of           flProtect. However, you must still set flProtect to a           valid protection value, such as PAGE_NOACCESS. VirtualAlloc returns an error if you use           MEM_RESET and the range of memory is mapped to a file. A shared view is only           acceptable if it is mapped to a paging file.   MEM_RESET_UNDO 0x1000000   MEM_RESET_UNDO should only be called on an address range to which           MEM_RESET was successfully applied earlier. It indicates that the data in the           specified memory range specified by lpAddress and dwSize           is of interest to the caller and attempts to reverse the effects of MEM_RESET. If           the function succeeds, that means all data in the specified address range is intact. If the function fails,           at least some of the data in the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an           address range which was not MEM_RESET earlier, the behavior is undefined. When you           specify MEM_RESET, the           VirtualAlloc function ignores the value of           flProtect. However, you must still set flProtect to a           valid protection value, such as PAGE_NOACCESS. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  The MEM_RESET_UNDO flag is not supported until Windows 8 and            Windows Server 2012.     This parameter can also specify the following values as indicated.  ValueMeaning  MEM_LARGE_PAGES 0x20000000   Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the           GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.   MEM_PHYSICAL 0x00400000   Reserves an address range that can be used to map           Address Windowing Extensions (AWE)           pages. This value must be used with MEM_RESERVE and no other values.   MEM_TOP_DOWN 0x00100000   Allocates memory at the highest possible address. This can be slower than regular allocations, especially          when there are many allocations.   MEM_WRITE_WATCH 0x00200000   Causes the system to track pages that are written to in the allocated region. If you specify this value,           you must also specify MEM_RESERVE. To retrieve the addresses of the pages that have been written to since the region was allocated or the           write-tracking state was reset, call the           GetWriteWatch function. To reset the write-tracking           state, call GetWriteWatch or           ResetWriteWatch. The write-tracking feature           remains enabled for the memory region until the region is freed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flProtect",
        "description": "The memory protection for the region of pages to be allocated. If the pages are being committed, you can        specify any one of the        memory protection constants. If lpAddress specifies an address within an enclave, flProtect cannot be any of the following values:  PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Reserves, commits, or changes the state  of a region of memory within the virtual address space of a specified process. The      function initializes the memory it allocates to zero.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "Each page has an associated page state. The       VirtualAllocEx function can perform the following       operations: VirtualAllocEx cannot reserve a reserved page. It      can commit a page that is already committed. This means you can commit a range of pages, regardless of whether      they have already been committed, and the function will not fail. You can use VirtualAllocEx to reserve a block of      pages and then make additional calls to VirtualAllocEx      to commit individual pages from the reserved block. This enables a process to reserve a range of its virtual      address space without consuming physical storage until it is needed. If the lpAddress parameter is not NULL, the function uses      the lpAddress and dwSize parameters to compute the region of      pages to be allocated. The current state of the entire range of pages must be compatible with the type of      allocation specified by the flAllocationType parameter. Otherwise, the function fails      and none of the pages is allocated. This compatibility requirement does not preclude committing an already      committed page; see the preceding list. To execute dynamically generated code, use      VirtualAllocEx to allocate memory and the      VirtualProtectEx function to grant      PAGE_EXECUTE access. The VirtualAllocEx function can be used to reserve      an Address Windowing Extensions      (AWE) region of memory within the virtual address space of a specified process. This region of memory can then be      used to map physical pages into and out of virtual memory as required by the application. The      MEM_PHYSICAL and MEM_RESERVE values must be set in the      AllocationType parameter. The MEM_COMMIT value must not be      set. The page protection must be set to PAGE_READWRITE. The VirtualFreeEx function can decommit a committed      page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also      release a reserved page, making it a free page. When creating a region that will be executable, the calling program bears responsibility for ensuring cache      coherency via an appropriate call to      FlushInstructionCache once the code has been set      in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable      results. ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "VirtualAllocEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right. For more information,         see         Process Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "The pointer that specifies a desired starting address for the region of pages that you want to allocate. If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation         granularity. If you are committing memory that is already reserved, the function rounds this address down to the nearest         page boundary. To determine the size of a page and the allocation granularity on the host computer, use the         GetSystemInfo function. If lpAddress is NULL, the function determines where to         allocate the region. If this address is within an enclave that you have not initialized by calling InitializeEnclave, VirtualAllocEx allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.  If the address in within an enclave that you initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region of memory to allocate, in bytes. If lpAddress is NULL, the function rounds         dwSize up to the next page boundary. If lpAddress is not NULL, the function allocates all         pages that contain one or more bytes in the range from lpAddress to         lpAddress+dwSize. This means, for example, that a 2-byte         range that straddles a page boundary causes the function to allocate both pages."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flAllocationType",
        "description": "The type of memory allocation. This parameter must contain one of the following values.  ValueMeaning  MEM_COMMIT 0x00001000   Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified           reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,           the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are           actually accessed. To reserve and commit pages in one step, call           VirtualAllocEx with           MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without           MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been reserved. The resulting           error code is ERROR_INVALID_ADDRESS. An attempt to commit a page that is already committed does not cause the function to fail. This means that           you can commit pages without first determining the current commitment state of each page. If lpAddress specifies an address within an enclave, flAllocationType must be MEM_COMMIT.   MEM_RESERVE 0x00002000   Reserves a range of the process's virtual address space without allocating any actual physical storage in           memory or in the paging file on disk. You commit reserved pages by calling           VirtualAllocEx again with           MEM_COMMIT. To reserve and commit pages in one step, call           VirtualAllocEx with           MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and           LocalAlloc, cannot use reserved memory until it has          been released.   MEM_RESET 0x00080000   Indicates that data in the memory range specified by lpAddress and           dwSize is no longer of interest. The pages should not be read from or written to           the paging file. However, the memory block will be used again later, so it should not be decommitted. This           value cannot be used with any other value. Using this value does not guarantee that the range operated on with MEM_RESET           will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it. When you use MEM_RESET, the           VirtualAllocEx function ignores the value of           fProtect. However, you must still set fProtect to a valid           protection value, such as PAGE_NOACCESS. VirtualAllocEx returns an error if you use           MEM_RESET and the range of memory is mapped to a file. A shared view is only           acceptable if it is mapped to a paging file.   MEM_RESET_UNDO 0x1000000   MEM_RESET_UNDO should only be called on an address range to which           MEM_RESET was successfully applied earlier. It indicates that the data in the           specified memory range specified by lpAddress and dwSize           is of interest to the caller and attempts to reverse the effects of MEM_RESET. If           the function succeeds, that means all data in the specified address range is intact. If the function fails,           at least some of the data in the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an           address range which was not MEM_RESET earlier, the behavior is undefined. When you           specify MEM_RESET, the           VirtualAllocEx function ignores the value of           flProtect. However, you must still set flProtect to a           valid protection value, such as PAGE_NOACCESS. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  The MEM_RESET_UNDO flag is not supported until Windows 8 and            Windows Server 2012.     This parameter can also specify the following values as indicated.  ValueMeaning  MEM_LARGE_PAGES 0x20000000   Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the           GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.   MEM_PHYSICAL 0x00400000   Reserves an address range that can be used to map           Address Windowing Extensions (AWE)           pages. This value must be used with MEM_RESERVE and no other values.   MEM_TOP_DOWN 0x00100000   Allocates memory at the highest possible address. This can be slower than regular allocations, especially          when there are many allocations."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flProtect",
        "description": "The memory protection for the region of pages to be allocated. If the pages are being committed, you can        specify any one of the        memory protection constants. If lpAddress specifies an address within an enclave, flProtect cannot be any of the following values:  PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Reserves, commits, or changes the state  of a region of pages in the virtual address space of the calling process.      Memory allocated by this function is automatically initialized to zero.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps | Windows Store apps]",
    "header": "MemoryApi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "You can call VirtualAllocFromApp from Windows Store apps with just-in-time (JIT) capabilities to use JIT functionality. The app must include the codeGeneration capability in the app manifest file to use JIT capabilities. Each page has an associated page state. The      VirtualAllocFromApp function can perform the following      operations: VirtualAllocFromApp cannot reserve a reserved page. It can      commit a page that is already committed. This means you can commit a range of pages, regardless of whether they      have already been committed, and the function will not fail. You can use VirtualAllocFromApp to reserve a block of pages      and then make additional calls to VirtualAllocFromApp to commit      individual pages from the reserved block. This enables a process to reserve a range of its virtual address space      without consuming physical storage until it is needed. If the BaseAddress parameter is not NULL, the function uses      the BaseAddress and Size parameters to compute the region of      pages to be allocated. The current state of the entire range of pages must be compatible with the type of      allocation specified by the AllocationType parameter. Otherwise, the function fails      and none of the pages are allocated. This compatibility requirement does not preclude committing an already      committed page, as mentioned previously. VirtualAllocFromApp does not allow the creation of executable pages. The VirtualAllocFromApp function can be used to reserve an      Address Windowing Extensions (AWE)      region of memory within the virtual address space of a specified process. This region of memory can then be used      to map physical pages into and out of virtual memory as required by the application. The      MEM_PHYSICAL and MEM_RESERVE values must be set in the      AllocationType parameter. The MEM_COMMIT value must not be      set. The page protection must be set to PAGE_READWRITE. The VirtualFree function can decommit a committed      page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also      release a reserved page, making it a free page. When creating a region that will be executable, the calling program bears responsibility for ensuring cache      coherency via an appropriate call to      FlushInstructionCache once the code has been set      in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable      results. ",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "VirtualAllocFromApp",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "The starting address of the region to allocate. If the memory is being reserved, the specified address is        rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is        being committed, the address is rounded down to the next page boundary. To determine the size of a page and the        allocation granularity on the host computer, use the        GetSystemInfo function. If this parameter is        NULL, the system determines where to allocate the region."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "The size of the region, in bytes. If the BaseAddress parameter is        NULL, this value is rounded up to the next page boundary. Otherwise, the allocated        pages include all pages containing one or more bytes in the range from BaseAddress to        BaseAddress+Size. This means that a 2-byte range straddling        a page boundary causes both pages to be included in the allocated region."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocationType",
        "description": "The type of memory allocation. This parameter must contain one of the following values.  ValueMeaning  MEM_COMMIT 0x00001000   Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified           reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,           the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are           actually accessed. To reserve and commit pages in one step, call           VirtualAllocFromApp with           MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without           MEM_RESERVE and a non-NULL BaseAddress fails unless the entire range has already been reserved. The  resulting           error code is ERROR_INVALID_ADDRESS. An attempt to commit a page that is           already committed does not cause the function to fail. This means that you can commit pages without first           determining the current commitment state of each page.   MEM_RESERVE 0x00002000   Reserves a range of the process's virtual address space without allocating any actual physical storage in           memory or in the paging file on disk. You can commit reserved pages in subsequent calls to the           VirtualAllocFromApp function. To reserve and commit pages           in one step, call VirtualAllocFromApp with           MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and           LocalAlloc, cannot use a reserved range of memory           until it is released.   MEM_RESET 0x00080000   Indicates that data in the memory range specified by BaseAddress and           Size is no longer of interest. The pages should not be read from or written to           the paging file. However, the memory block will be used again later, so it should not be decommitted. This           value cannot be used with any other value. Using this value does not guarantee that the range operated on with MEM_RESET           will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it. When you specify MEM_RESET, the           VirtualAllocFromApp function ignores the value of           Protection. However, you must still set Protection to a           valid protection value, such as PAGE_NOACCESS. VirtualAllocFromApp returns an error if you use           MEM_RESET and the range of memory is mapped to a file. A shared view is only           acceptable if it is mapped to a paging file.   MEM_RESET_UNDO 0x1000000   MEM_RESET_UNDO should only be called on an address range to which           MEM_RESET was successfully applied earlier. It indicates that the data in the           specified memory range specified by BaseAddress and Size           is of interest to the caller and attempts to reverse the effects of MEM_RESET. If           the function succeeds, that means all data in the specified address range is intact. If the function fails,           at least some of the data in the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an           address range which was not MEM_RESET earlier, the behavior is undefined. When you           specify MEM_RESET, the           VirtualAllocFromApp function ignores the value of           Protection. However, you must still set Protection to a           valid protection value, such as PAGE_NOACCESS.     This parameter can also specify the following values as indicated.  ValueMeaning  MEM_LARGE_PAGES 0x20000000   Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the           GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.   MEM_PHYSICAL 0x00400000   Reserves an address range that can be used to map           Address Windowing Extensions (AWE)           pages. This value must be used with MEM_RESERVE and no other values.   MEM_TOP_DOWN 0x00100000   Allocates memory at the highest possible address. This can be slower than regular allocations, especially          when there are many allocations.   MEM_WRITE_WATCH 0x00200000   Causes the system to track pages that are written to in the allocated region. If you specify this value,           you must also specify MEM_RESERVE. To retrieve the addresses of the pages that have been written to since the region was allocated or the           write-tracking state was reset, call the           GetWriteWatch function. To reset the write-tracking           state, call GetWriteWatch or           ResetWriteWatch. The write-tracking feature           remains enabled for the memory region until the region is freed."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Protection",
        "description": "The memory protection for the region of pages to be allocated. If the pages are being committed, you can        specify one of the        memory protection constants. The following constants generate an error:  PAGE_EXECUTE PAGE_EXECUTE_READ PAGE_EXECUTE_READWRITE PAGE_EXECUTE_WRITECOPY"
      }
    ],
    "min_client": "Windows 10 [desktop apps | UWP apps]"
  },
  {
    "n_arguments": 3,
    "description": "Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. ",
    "remarks": "Each page of memory in a process virtual address space has a  Page State. The  VirtualFree function can decommit a range of pages that are in different states, some committed and some uncommitted. This means that you can decommit a range of pages without first determining the current commitment state of each page. Decommitting a page releases its physical storage, either in memory or in the paging file on disk. If a page is decommitted but not released, its state changes to reserved. Subsequently, you can call  VirtualAlloc to commit it, or VirtualFree to release it. Attempts to read from or write to a reserved page results in an access violation exception. The  VirtualFree function can release a range of pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state of each page. The entire range of pages originally reserved by the  VirtualAlloc function must be released at the same time. If a page is released, its state changes to free, and it is available for subsequent allocation operations. After memory is released or decommited, you can never refer to the memory again. Any information that may have been in that memory is gone forever. Attempting to read from or write to a free page results in an access violation exception. If you need to keep information, do not decommit or free memory that contains the information. The  VirtualFree function can be used on an AWE region of memory, and it invalidates any physical page mappings in the region when freeing the address space. However, the physical page is not deleted, and the application can use them. The application must explicitly call  FreeUserPhysicalPages to free the physical pages. When the process is terminated, all resources are cleaned up automatically. To delete an enclave when you finish using it, specify the following values: For an example, see  Reserving and Committing Memory. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualFree",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "A pointer to the base address of the region of pages to be freed.     If the dwFreeType parameter is MEM_RELEASE, this parameter must be the base address returned by the  VirtualAlloc function when the region of pages is reserved."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region of memory to be freed, in bytes.     If the dwFreeType parameter is MEM_RELEASE, this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to  VirtualAlloc. If the dwFreeType parameter is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If lpAddress is the base address returned by  VirtualAlloc and dwSize is 0 (zero), the function decommits the entire region that is allocated by  VirtualAlloc. After that, the entire region is in the reserved state."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFreeType",
        "description": "The type of free operation. This parameter can be one of the following values.  ValueMeaning  MEM_DECOMMIT 0x4000   Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.     The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state. Do not use this value with MEM_RELEASE. The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for an enclave.   MEM_RELEASE 0x8000   Releases the specified region of pages. After this operation, the pages are in the free state.     If you specify this value, dwSize must be 0 (zero), and lpAddress must point to the base address returned by the  VirtualAlloc function when the region is reserved. The function fails if either of these conditions is not met. If any pages in the region are committed currently, the function first decommits, and then releases them. The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state. Do not use this value with MEM_DECOMMIT."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. ",
    "remarks": "Each page of memory in a process virtual address space has a  Page State.  The  VirtualFreeEx function can decommit a range of pages that are in different states, some committed and some uncommitted. This means that you can decommit a range of pages without first determining the current commitment state of each page. Decommitting a page releases its physical storage, either in memory or in the paging file on disk. If a page is decommitted but not released, its state changes to reserved. Subsequently, you can  call  VirtualAllocEx to commit it, or  VirtualFreeEx to release it. Attempting to read from or write to a reserved page results in an access violation exception. The  VirtualFreeEx function can release a range of pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state of each page. The entire range of pages originally reserved by  VirtualAllocEx must be released at the same time. If a page is released, its state changes to free, and it is available for subsequent allocation operations. After memory is released or decommitted, you can never refer to the memory again. Any information that may have been in that memory is gone forever. Attempts to read from or write to a free page results in an access violation exception. If you need to keep information, do not decommit or free memory that  contains the information. The  VirtualFreeEx function can be used on an AWE region of memory and it invalidates any physical page mappings in the region when freeing the address space. However, the physical pages are not deleted, and the application can use them. The application must explicitly call  FreeUserPhysicalPages to free the physical pages. When the  process is terminated, all resources are automatically cleaned up. To delete an enclave when you finish using it, specify the following values: ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualFreeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to a process. The function frees memory within the virtual address space of the process.     The handle must have the PROCESS_VM_OPERATION access right. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "A pointer to the starting address of the region of memory to be freed.     If the dwFreeType parameter is MEM_RELEASE, lpAddress must be the base address returned by the  VirtualAllocEx function when the region is reserved."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region of memory to free, in bytes.     If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to  VirtualAllocEx. If dwFreeType is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If lpAddress is the base address returned by  VirtualAllocEx and dwSize is 0 (zero), the function decommits the entire region that is allocated by  VirtualAllocEx. After that, the entire region is in the reserved state."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFreeType",
        "description": "The type of free operation. This parameter can be one of the following values.  ValueMeaning  MEM_DECOMMIT 0x4000   Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.     The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining their current commitment state. Do not use this value with MEM_RELEASE. The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for an enclave.   MEM_RELEASE 0x8000   Releases the specified region of pages. After the operation, the pages are in the free state.     If you specify this value, dwSize must be 0 (zero), and lpAddress must point to the base address returned by the  VirtualAllocEx function when the region is reserved. The function fails if either of these conditions is not met. If any pages in the region are committed currently, the function first decommits, and then releases them. The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state. Do not use this value with MEM_DECOMMIT."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Locks the specified region of the process's virtual address space into physical memory, ensuring that subsequent access to the region will not incur a page fault.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "All pages in the specified region must be committed. Memory protected with PAGE_NOACCESS cannot be locked. Locking pages into memory may degrade the performance of the system by reducing the available RAM and forcing the system to swap out other critical pages to the paging file. Each version of Windows has a limit on the maximum number of pages a process can lock. This limit is intentionally small to avoid severe performance degradation. Applications that need to lock larger numbers of pages must first call the  SetProcessWorkingSetSize function to increase their minimum and maximum working set sizes. The maximum number of pages that a process can lock is equal to the number of pages in its minimum working set minus a small overhead. Pages that a process has locked remain in physical memory until the process unlocks them or terminates. These pages are guaranteed not to be written to the pagefile while they are locked. To unlock a region of locked pages, use the  VirtualUnlock function. Locked pages are automatically unlocked when the process terminates. This function is not like the  GlobalLock or  LocalLock function in that it does not increment a lock count and translate a handle into a pointer. There is no lock count for virtual pages, so multiple calls to the  VirtualUnlock function are never required to unlock a region of pages. For an example, see  Creating Guard Pages. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualLock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "A pointer to the base address of the region of pages to be locked."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region to be locked, in bytes. The region of affected pages includes all pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes both pages to be locked."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Changes the protection on a region of committed pages in the virtual address space of the calling      process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "You can set the access protection value on committed pages only. If the state of any page in the specified     region is not committed, the function fails and returns without modifying the access protection of any pages in the     specified region. The PAGE_GUARD protection modifier establishes guard pages. Guard pages act as     one-shot access alarms. For more information, see     Creating Guard Pages. It is best to avoid using VirtualProtect to change     page protections on memory blocks allocated by GlobalAlloc,     HeapAlloc, or     LocalAlloc, because multiple memory blocks can exist on a     single page. The heap manager assumes that all pages in the heap grant at least read and write access. When protecting a region that will be executable, the calling program bears responsibility for ensuring cache     coherency via an appropriate call to     FlushInstructionCache once the code has been set     in place.  Otherwise attempts to execute code out of the newly executable region may produce unpredictable     results. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualProtect",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "A pointer an address that describes the starting page of the region of pages whose access protection         attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the         VirtualAlloc or         VirtualAllocEx function using         MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by         separate calls to VirtualAlloc or         VirtualAllocEx using         MEM_RESERVE."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region whose access protection attributes are to be changed, in bytes. The region of        affected pages includes all pages containing one or more bytes in the range from the        lpAddress parameter to        (lpAddress+dwSize). This means that a 2-byte range        straddling a page boundary causes the protection attributes of both pages to be changed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flNewProtect",
        "description": "The memory protection option. This parameter can be one of the         memory protection constants. For mapped views, this value must be compatible with the access protection specified when the view was         mapped (see MapViewOfFile,         MapViewOfFileEx, and         MapViewOfFileExNuma)."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "lpflOldProtect",
        "description": "A pointer to a variable that receives the previous access protection value of the first page in the        specified region of pages. If this parameter is NULL or does not point to a valid        variable, the function fails."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Changes the protection on a region of committed pages in the virtual address space of a specified      process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The access protection value can be set only on committed pages. If the state of any page in the specified      region is not committed, the function fails and returns without modifying the access protection of any pages in      the specified region. The PAGE_GUARD protection modifier establishes guard pages. Guard pages act as      one-shot access alarms. For more information, see      Creating Guard Pages. It is best to avoid using VirtualProtectEx to      change page protections on memory blocks allocated by      GlobalAlloc,      HeapAlloc, or      LocalAlloc, because multiple memory blocks can exist on a      single page. The heap manager assumes that all pages in the heap grant at least read and write access. When protecting a region that will be executable, the calling program bears responsibility for ensuring cache      coherency via an appropriate call to      FlushInstructionCache once the code has been set      in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable      results. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualProtectEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose memory protection is to be changed. The handle must have the        PROCESS_VM_OPERATION access right. For more information, see        Process Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "A pointer to the base address of the region of pages whose access protection attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the         VirtualAlloc or         VirtualAllocEx function using         MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by         separate calls to VirtualAlloc or         VirtualAllocEx using         MEM_RESERVE."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region whose access protection attributes are changed, in bytes. The region of affected       pages includes all pages containing one or more bytes in the range from the lpAddress       parameter to (lpAddress+dwSize). This means that a 2-byte       range straddling a page boundary causes the protection attributes of both pages to be changed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flNewProtect",
        "description": "The memory protection option. This parameter can be one of the         memory protection constants. For mapped views, this value must be compatible with the access protection specified when the view was         mapped (see MapViewOfFile,         MapViewOfFileEx, and         MapViewOfFileExNuma)."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "lpflOldProtect",
        "description": "A pointer to a variable that receives the previous access protection of the first page in the specified        region of pages. If this parameter is NULL or does not point to a valid variable, the        function fails."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Changes the protection on a region of committed pages in the virtual address space of the calling      process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps | Windows Store apps]",
    "header": "MemoryApi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "You can call VirtualProtectFromApp from Windows Store apps with just-in-time (JIT) capabilities to use JIT functionality. The app must include the codeGeneration capability in the app manifest file to use JIT capabilities. You can set the access protection value on committed pages only. If the state of any page in the specified     region is not committed, the function fails and returns without modifying the access protection of any pages in the     specified region. The PAGE_GUARD protection modifier establishes guard pages. Guard pages act as     one-shot access alarms. For more information, see     Creating Guard Pages. It is best to avoid using VirtualProtectFromApp to change     page protections on memory blocks allocated by GlobalAlloc,     HeapAlloc, or     LocalAlloc, because multiple memory blocks can exist on a     single page. The heap manager assumes that all pages in the heap grant at least read and write access. VirtualProtectFromApp allows you to mark pages as executable, but does not allow you to set both write and execute permissions at the same time. When protecting a region that will be executable, the calling program bears responsibility for ensuring cache     coherency via an appropriate call to     FlushInstructionCache once the code has been set     in place.  Otherwise attempts to execute code out of the newly executable region may produce unpredictable     results. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualProtectFromApp",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Address",
        "description": "A pointer an address that describes the starting page of the region of pages whose access protection         attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the         VirtualAlloc, VirtualAllocFromApp, or         VirtualAllocEx function using         MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by         separate calls to VirtualAlloc, VirtualAllocFromApp,  or         VirtualAllocEx using         MEM_RESERVE."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "The size of the region whose access protection attributes are to be changed, in bytes. The region of        affected pages includes all pages containing one or more bytes in the range from the        Address parameter to        (Address+Size). This means that a 2-byte range        straddling a page boundary causes the protection attributes of both pages to be changed."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NewProtection",
        "description": "The memory protection option. This parameter can be one of the         memory protection constants. For mapped views, this value must be compatible with the access protection specified when the view was         mapped (see MapViewOfFile,         MapViewOfFileEx, and         MapViewOfFileExNuma). The following constants generate an error:  PAGE_EXECUTE_READWRITE PAGE_EXECUTE_WRITECOPY  The following constants are allowed only for apps that have the codeGeneration capability:  PAGE_EXECUTE PAGE_EXECUTE_READ"
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "OldProtection",
        "description": "A pointer to a variable that receives the previous access protection value of the first page in the        specified region of pages. If this parameter is NULL or does not point to a valid        variable, the function fails."
      }
    ],
    "min_client": "Windows 10 [desktop apps | UWP apps]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves information about a range of pages in the virtual address space of the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The return value is the actual number of bytes returned in the information buffer. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include ERROR_INVALID_PARAMETER. ",
    "remarks": "VirtualQuery provides information about a region of consecutive pages beginning at a specified address that share the following attributes: The function determines the attributes of the first page in the region and then scans subsequent pages until it scans the entire range of pages or until it encounters a page with a nonmatching set of attributes. The function returns the attributes and the size of the region of pages with matching attributes, in bytes. For example, if there is a 40 megabyte (MB) region of free memory, and  VirtualQuery is called on a page that is 10 MB into the region, the function will obtain a state of MEM_FREE and a size of 30 MB. If a shared copy-on-write page is modified, it becomes private to the process that modified the page. However, the VirtualQuery function will continue to report such pages as MEM_MAPPED (for data views) or MEM_IMAGE (for executable image views) rather than MEM_PRIVATE. To detect whether copy-on-write has occurred for a specific page, either access the page or lock it using the VirtualLock function to make sure the page is resident in memory, then use the QueryWorkingSetEx function to check the Shared bit in the extended working set information for the page. If the Shared bit is clear, the page is private. This function reports on a region of pages in the memory of the calling process, and the  VirtualQueryEx function reports on a region of pages in the memory of a specified process. ",
    "return_type": "SIZE_T",
    "category": "Memory Management",
    "name": "VirtualQuery",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "lpAddress",
        "description": "A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the  GetSystemInfo function. If lpAddress specifies an address above the highest memory address accessible to the process, the function fails with ERROR_INVALID_PARAMETER."
      },
      {
        "in_out": "_Out_",
        "type": "PMEMORY_BASIC_INFORMATION",
        "name": "lpBuffer",
        "description": "A pointer to a  MEMORY_BASIC_INFORMATION structure in which information about the specified page range is returned."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwLength",
        "description": "The size of the buffer pointed to by the lpBuffer parameter, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves information about a range of pages within the virtual address space of a specified process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The return value is the actual number of bytes returned in the information buffer. If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include ERROR_INVALID_PARAMETER. ",
    "remarks": "VirtualQueryEx provides information about a region of consecutive pages beginning at a specified address that share the following attributes: The  VirtualQueryEx function determines the attributes of the first page in the region and then scans subsequent pages until it scans the entire range of pages, or until it encounters a page with a nonmatching set of attributes. The function returns the attributes and the size of the region of pages with matching attributes, in bytes. For example, if there is a 40 megabyte (MB) region of free memory, and  VirtualQueryEx is called on a page that is 10 MB into the region, the function will obtain a state of MEM_FREE and a size of 30 MB. If a shared copy-on-write page is modified, it becomes private to the process that modified the page. However, the VirtualQueryEx function will continue to report such pages as MEM_MAPPED (for data views) or MEM_IMAGE (for executable image views) rather than MEM_PRIVATE. To detect whether copy-on-write has occurred for a specific page, either access the page or lock it using the VirtualLock function to make sure the page is resident in memory, then use the QueryWorkingSet or QueryWorkingSetEx function to check the Shared bit in the extended working set information for the page. If the Shared bit is clear, the page is private. ",
    "return_type": "SIZE_T",
    "category": "Memory Management",
    "name": "VirtualQueryEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process whose memory information is queried. The handle must have been opened with the PROCESS_QUERY_INFORMATION access right, which enables using the handle to read information from the process object. For more information, see  Process Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "lpAddress",
        "description": "A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the  GetSystemInfo function. If lpAddress specifies an address above the highest memory address accessible to the process, the function fails with ERROR_INVALID_PARAMETER."
      },
      {
        "in_out": "_Out_",
        "type": "PMEMORY_BASIC_INFORMATION",
        "name": "lpBuffer",
        "description": "A pointer to a  MEMORY_BASIC_INFORMATION structure in which information about the specified page range is returned."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwLength",
        "description": "The size of the buffer pointed to by the lpBuffer parameter, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Unlocks a specified range of pages in the virtual address space of a process, enabling the system to swap the pages out to the paging file if necessary.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "For the function to succeed, the range specified need not match a range passed to a previous call to the  VirtualLock function, but all pages in the range must be locked. If any of the pages in the specified range are not locked, VirtualUnlock removes such pages from the working set, sets last error to ERROR_NOT_LOCKED, and returns FALSE. Calling  VirtualUnlock on a range of memory that is not locked releases the pages from the process's working set. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "VirtualUnlock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "A pointer to the base address of the region of pages to be unlocked."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the region being unlocked, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes both pages to be unlocked."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Allocates the specified number of bytes from the heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the newly allocated memory object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "Windows memory management does not provide a separate local heap and global heap. Therefore, the GlobalAlloc and LocalAlloc functions are essentially the same. The movable-memory flags GHND and GMEM_MOVABLE add unnecessary overhead and require locking to be used safely. They should be avoided unless documentation specifically states that they should be used. New applications should use the  heap functions to allocate and manage memory unless the documentation specifically states that a global function should be used. For example, the global functions are still used with Dynamic Data Exchange (DDE), the clipboard functions, and OLE data objects. If the GlobalAlloc function succeeds, it allocates at least the amount of memory requested. If the actual amount allocated is greater than the amount requested, the process can use the entire amount. To determine the actual number of bytes allocated, use the  GlobalSize function. If the heap does not contain sufficient free space to satisfy the request,  GlobalAlloc returns NULL. Because NULL is used to indicate an error, virtual address zero is never allocated. It is, therefore, easy to detect the use of a NULL pointer. Memory allocated with this function is guaranteed to be aligned on an 8-byte boundary. To execute dynamically generated code, use the VirtualAlloc function to allocate memory and the VirtualProtect function to grant  PAGE_EXECUTE access. To free the memory, use the  GlobalFree function. It is not safe to free memory allocated with GlobalAlloc using LocalFree. The following code shows a simple use of GlobalAlloc and GlobalFree. ",
    "return_type": "HGLOBAL",
    "category": "Memory Management",
    "name": "GlobalAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFlags",
        "description": "The memory allocation attributes. If zero is specified, the default is GMEM_FIXED. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.     ValueMeaning  GHND 0x0042   Combines GMEM_MOVEABLE and GMEM_ZEROINIT.   GMEM_FIXED 0x0000   Allocates fixed memory. The return value is a pointer.   GMEM_MOVEABLE 0x0002   Allocates movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap. The return value is a handle to the memory object. To translate the handle into a pointer, use the  GlobalLock function. This value cannot be combined with GMEM_FIXED.   GMEM_ZEROINIT 0x0040   Initializes memory contents to zero.   GPTR 0x0040   Combines GMEM_FIXED and GMEM_ZEROINIT.     The following values are obsolete, but are provided for compatibility with 16-bit Windows. They are ignored. GMEM_DDESHARE GMEM_DISCARDABLE GMEM_LOWER GMEM_NOCOMPACT GMEM_NODISCARD GMEM_NOT_BANKED GMEM_NOTIFY GMEM_SHARE"
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwBytes",
        "description": "The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies GMEM_MOVEABLE, the function returns a handle to a memory object that is marked as discarded."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Allocates the specified number of bytes from the heap.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the newly allocated memory object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "Windows memory management does not provide a separate local heap and global heap. Therefore, the LocalAlloc and GlobalAlloc functions are essentially the same. The movable-memory flags LHND, LMEM_MOVABLE, and NONZEROLHND add unnecessary overhead and require locking to be used safely. They should be avoided unless documentation specifically states that they should be used. New applications should use the  heap functions unless the documentation specifically states that a local function should be used. For example, some Windows functions allocate memory that must be freed with LocalFree. If the heap does not contain sufficient free space to satisfy the request,  LocalAlloc returns NULL. Because NULL is used to indicate an error, virtual address zero is never allocated. It is, therefore, easy to detect the use of a NULL pointer. If the LocalAlloc function succeeds, it allocates at least the amount requested. If the amount allocated is greater than the amount requested, the process can use the entire amount. To determine the actual number of bytes allocated, use the  LocalSize function. To free the memory, use the  LocalFree function. It is not safe to free memory allocated with LocalAlloc using GlobalFree. The following code shows a simple use of LocalAlloc and LocalFree. ",
    "return_type": "HLOCAL",
    "category": "Memory Management",
    "name": "LocalAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFlags",
        "description": "The memory allocation attributes. The default is the LMEM_FIXED value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.     ValueMeaning  LHND 0x0042   Combines LMEM_MOVEABLE and LMEM_ZEROINIT.   LMEM_FIXED 0x0000   Allocates fixed memory. The return value is a pointer to the memory object.   LMEM_MOVEABLE 0x0002   Allocates movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap.     The return value is a handle to the memory object. To translate the handle to a pointer, use the  LocalLock function. This value cannot be combined with LMEM_FIXED.   LMEM_ZEROINIT 0x0040   Initializes memory contents to zero.   LPTR 0x0040   Combines LMEM_FIXED and LMEM_ZEROINIT.   NONZEROLHND   Same as LMEM_MOVEABLE.   NONZEROLPTR   Same as LMEM_FIXED.     The following values are obsolete, but are provided for compatibility with 16-bit Windows. They are ignored. LMEM_DISCARDABLE LMEM_NOCOMPACT LMEM_NODISCARD"
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "uBytes",
        "description": "The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies LMEM_MOVEABLE, the function returns a handle to a memory object that is marked as discarded."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves information about the specified global memory object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the allocation values and the lock count for the memory object. If the function fails, the return value is GMEM_INVALID_HANDLE, indicating that the global handle is not valid. To get extended error information, call  GetLastError. ",
    "remarks": "The low-order byte of the low-order word of the return value contains the lock count of the object. To retrieve the lock count from the return value, use the GMEM_LOCKCOUNT mask with the bitwise AND (&) operator. The lock count of memory objects allocated with GMEM_FIXED is always zero. The high-order byte of the low-order word of the return value indicates the allocation values of the memory object. It can be zero or GMEM_DISCARDED. The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the heap functions unless documentation states that a global function should be used. For more information, see Global and Local Functions. ",
    "return_type": "UINT",
    "category": "Memory Management",
    "name": "GlobalFlags",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hMem",
        "description": "A handle to the global memory object. This handle is returned by either the  GlobalAlloc or  GlobalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves information about the specified local memory object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the allocation values and the lock count for the memory object. If the function fails, the return value is LMEM_INVALID_HANDLE, indicating that the local handle is not valid. To get extended error information, call  GetLastError. ",
    "remarks": "The low-order byte of the low-order word of the return value contains the lock count of the object. To retrieve the lock count from the return value, use the LMEM_LOCKCOUNT mask with the bitwise AND (&) operator. The lock count of memory objects allocated with LMEM_FIXED is always zero. The high-order byte of the low-order word of the return value indicates the allocation values of the memory object. It can be zero or LMEM_DISCARDABLE. The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the heap functions unless documentation states that a local function should be used. For more information, see Global and Local Functions. ",
    "return_type": "UINT",
    "category": "Memory Management",
    "name": "LocalFlags",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HLOCAL",
        "name": "hMem",
        "description": "A handle to the local memory object. This handle is returned by either the  LocalAlloc or  LocalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Frees the specified global memory object and invalidates its handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is NULL. If the function fails, the return value is equal to a handle to the global memory object. To get extended error information, call  GetLastError. ",
    "remarks": "If the process examines or modifies the memory after it has been freed, heap corruption may occur or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may be generated. The  GlobalFree function will free a locked memory object. A locked memory object has a lock count greater than zero. The  GlobalLock function locks a global memory object and increments the lock count by one. The  GlobalUnlock function unlocks it and decrements the lock count by one. To get the lock count of a global memory object, use the  GlobalFlags function. If an application is running under a debug version of the system,  GlobalFree will issue a message that tells you that a locked object is being freed. If you are debugging the application,  GlobalFree will enter a breakpoint just before freeing a locked object. This allows you to verify the intended behavior, then continue execution. For an example, see  GlobalAlloc. ",
    "return_type": "HGLOBAL",
    "category": "Memory Management",
    "name": "GlobalFree",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hMem",
        "description": "A handle to the global memory object. This handle is returned by either the  GlobalAlloc or  GlobalReAlloc function. It is not safe to free memory allocated with LocalAlloc."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Frees the specified local memory object and invalidates its handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is NULL. If the function fails, the return value is equal to a handle to the local memory object. To get extended error information, call  GetLastError. ",
    "remarks": "If the process tries to examine or modify the memory after it has been freed, heap corruption may occur or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may be generated. If the hMem parameter is NULL,  LocalFree ignores the parameter and returns NULL. The  LocalFree function will free a locked memory object. A locked memory object has a lock count greater than zero. The  LocalLock function locks a local memory object and increments the lock count by one. The  LocalUnlock function unlocks it and decrements the lock count by one. To get the lock count of a local memory object, use the  LocalFlags function. If an application is running under a debug version of the system,  LocalFree will issue a message that tells you that a locked object is being freed. If you are debugging the application,  LocalFree will enter a breakpoint just before freeing a locked object. This allows you to verify the intended behavior, then continue execution. For an example, see  LocalAlloc. ",
    "return_type": "HLOCAL",
    "category": "Memory Management",
    "name": "LocalFree",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HLOCAL",
        "name": "hMem",
        "description": "A handle to the local memory object. This handle is returned by either the  LocalAlloc or  LocalReAlloc function. It is not safe to free memory allocated with GlobalAlloc."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the handle associated with the specified pointer to a global memory block.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the specified global memory object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "When the  GlobalAlloc function allocates a memory object with GMEM_MOVEABLE, it returns a handle to the object. The  GlobalLock function converts this handle into a pointer to the memory block, and  GlobalHandle converts the pointer back into a handle. ",
    "return_type": "HGLOBAL",
    "category": "Memory Management",
    "name": "GlobalHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "pMem",
        "description": "A pointer to the first byte of the global memory block. This pointer is returned by the  GlobalLock function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the handle associated with the specified pointer to a local memory object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the specified local memory object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "When the  LocalAlloc function allocates a local memory object with LMEM_MOVEABLE, it returns a handle to the object. The  LocalLock function converts this handle into a pointer to the object's memory block, and  LocalHandle converts the pointer back into a handle. ",
    "return_type": "HLOCAL",
    "category": "Memory Management",
    "name": "LocalHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "pMem",
        "description": "A pointer to the first byte of the local memory object. This pointer is returned by the  LocalLock function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Locks a global memory object and returns a pointer to the first byte of the object's memory block.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a pointer to the first byte of the memory block. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects,  GlobalLock increments the count by one, and the  GlobalUnlock function decrements the count by one. Each successful call that a process makes to  GlobalLock for an object must be matched by a corresponding call  to GlobalUnlock. Locked memory will not be moved or discarded, unless the memory object is reallocated by using the  GlobalReAlloc function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded. Memory objects allocated with GMEM_FIXED always have a lock count of zero. For these objects, the value of the returned pointer is equal to the value of the specified handle. If the specified memory block has been discarded or if the memory block has a zero-byte size, this function returns NULL. Discarded objects always have a lock count of zero. ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "GlobalLock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hMem",
        "description": "A handle to the global memory object. This handle is returned by either the  GlobalAlloc or  GlobalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Locks a local memory object and returns a pointer to the first byte of the object's memory block.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a pointer to the first byte of the memory block. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects,  LocalLock increments the count by one, and the  LocalUnlock function decrements the count by one. Each successful call that a process makes to  LocalLock for an object must be matched by a corresponding call to  LocalUnlock. Locked memory will not be moved or discarded unless the memory object is reallocated by using the  LocalReAlloc function. The memory block of a locked memory object remains locked in memory until its lock count is decremented to zero, at which time it can be moved or discarded. Memory objects allocated with LMEM_FIXED always have a lock count of zero. For these objects, the value of the returned pointer is equal to the value of the specified handle. If the specified memory block has been discarded or if the memory block has a zero-byte size, this function returns NULL. Discarded objects always have a lock count of zero. ",
    "return_type": "LPVOID",
    "category": "Memory Management",
    "name": "LocalLock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HLOCAL",
        "name": "hMem",
        "description": "A handle to the local memory object. This handle is returned by either the  LocalAlloc or  LocalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Changes the size or attributes of a specified global memory object. The size can increase or decrease.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the reallocated memory object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "If  GlobalReAlloc reallocates a movable object, the return value is a handle to the memory object. To convert the handle to a pointer, use the  GlobalLock function. If  GlobalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer. If  GlobalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid. ",
    "return_type": "HGLOBAL",
    "category": "Memory Management",
    "name": "GlobalReAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hMem",
        "description": "A handle to the global memory object to be reallocated. This handle is returned by either the  GlobalAlloc or  GlobalReAlloc function."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwBytes",
        "description": "The new size of the memory block, in bytes. If uFlags specifies GMEM_MODIFY, this parameter is ignored."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFlags",
        "description": "The reallocation options. If GMEM_MODIFY is specified, the function modifies the attributes of the memory object only (the dwBytes parameter is ignored.) Otherwise, the function reallocates the memory object. You can optionally combine GMEM_MODIFY with the following value.  ValueMeaning  GMEM_MOVEABLE 0x0002   Allocates movable memory. If the memory is a locked GMEM_MOVEABLE memory block or a GMEM_FIXED memory block and this flag is not specified, the memory can only be reallocated in place.     If this parameter does not specify GMEM_MODIFY, you can use the following value.  ValueMeaning  GMEM_ZEROINIT 0x0040   Causes the additional memory contents to be initialized to zero if the memory object is growing in size."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Changes the size or the attributes of a specified local memory object. The size can increase or decrease.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the reallocated memory object. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "If  LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid. If  LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer. ",
    "return_type": "HLOCAL",
    "category": "Memory Management",
    "name": "LocalReAlloc",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HLOCAL",
        "name": "hMem",
        "description": "A handle to the local memory object to be reallocated. This handle is returned by either the  LocalAlloc or  LocalReAlloc function."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "uBytes",
        "description": "The new size of the memory block, in bytes. If uFlags specifies LMEM_MODIFY, this parameter is ignored."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFlags",
        "description": "The reallocation options. If LMEM_MODIFY is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object. You can optionally combine LMEM_MODIFY with the following value.  ValueMeaning  LMEM_MOVEABLE 0x0002   Allocates fixed or movable memory.     If the memory is a locked LMEM_MOVEABLE memory block or a LMEM_FIXED memory block and this flag is not specified, the memory can only be reallocated in place.     If this parameter does not specify LMEM_MODIFY, you can use the following value.  ValueMeaning  LMEM_ZEROINIT 0x0040   Causes the additional memory contents to be initialized to zero if the memory object is growing in size."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the current size of the specified global memory object, in bytes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the size of the specified global memory object, in bytes. If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The size of a memory block may be larger than the size requested when the memory was allocated. To verify that the specified object's memory block has not been discarded, use the  GlobalFlags function before calling  GlobalSize. ",
    "return_type": "SIZE_T",
    "category": "Memory Management",
    "name": "GlobalSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hMem",
        "description": "A handle to the global memory object. This handle is returned by either the  GlobalAlloc or  GlobalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the current size of the specified local memory object, in bytes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the size of the specified local memory object, in bytes. If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The size of a memory block may be larger than the size requested when the memory was allocated. To verify that the specified object's memory block has not been discarded, call the  LocalFlags function before calling  LocalSize. ",
    "return_type": "UINT",
    "category": "Memory Management",
    "name": "LocalSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HLOCAL",
        "name": "hMem",
        "description": "A handle to the local memory object. This handle is returned by the  LocalAlloc,  LocalReAlloc, or  LocalHandle function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements the lock count associated with a memory object that was allocated with GMEM_MOVEABLE. This function has no effect on memory objects allocated with GMEM_FIXED.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the memory object is still locked after decrementing the lock count, the return value is a nonzero value. If the memory object is unlocked after decrementing the lock count, the function returns zero and GetLastError returns NO_ERROR. If the function fails, the return value is zero and  GetLastError returns a value other than NO_ERROR. ",
    "remarks": "The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, the  GlobalLock function increments the count by one, and  GlobalUnlock decrements the count by one. For each call that a process makes to  GlobalLock for an object, it must eventually call  GlobalUnlock. Locked memory will not be moved or discarded, unless the memory object is reallocated by using the  GlobalReAlloc function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded. Memory objects allocated with GMEM_FIXED always have a lock count of zero. If the specified memory block is fixed memory, this function returns TRUE. If the memory object is already unlocked,  GlobalUnlock returns FALSE and  GetLastError reports ERROR_NOT_LOCKED. A process should not rely on the return value to determine the number of times it must subsequently call  GlobalUnlock for a memory object. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "GlobalUnlock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hMem",
        "description": "A handle to the global memory object. This handle is returned by either the  GlobalAlloc or  GlobalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements the lock count associated with a memory object that was allocated with LMEM_MOVEABLE. This function has no effect on memory objects allocated with LMEM_FIXED.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the memory object is still locked after decrementing the lock count, the return value is nonzero. If the memory object is unlocked after decrementing the lock count, the function returns zero and GetLastError returns NO_ERROR. If the function fails, the return value is zero and  GetLastError returns a value other than NO_ERROR. ",
    "remarks": "The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, the  LocalLock function increments the count by one, and  LocalUnlock decrements the count by one. For each call that a process makes to  LocalLock for an object, it must eventually call  LocalUnlock. Locked memory will not be moved or discarded unless the memory object is reallocated by using the  LocalReAlloc function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded. If the memory object is already unlocked,  LocalUnlock returns FALSE and GetLastError reports ERROR_NOT_LOCKED. Memory objects allocated with LMEM_FIXED always have a lock count of zero and cause the ERROR_NOT_LOCKED error. A process should not rely on the return value to determine the number of times it must subsequently call  LocalUnlock for the memory block. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "LocalUnlock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HLOCAL",
        "name": "hMem",
        "description": "A handle to the local memory object. This handle is returned by either the  LocalAlloc or  LocalReAlloc function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined function registered with the      RegisterBadMemoryNotification function      that is called when one or more bad memory pages are detected.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This callback function does not return a value. ",
    "remarks": "The application is not given the addresses of any bad blocks. To determine which blocks are marked as bad, use      the QueryWorkingSetEx function to examine the      memory in your virtual address space and check to see if the Bad bit flag is set on one      or more of the PSAPI_WORKING_SET_EX_BLOCK      structures in the      PSAPI_WORKING_SET_EX_INFORMATION      structures returned. Do not access that page or your application or possibly the system will crash (the specific      behavior depends on the hardware.) The memory must be freed; when that happens the system will remove the page      from the lists of available pages. When this function is called the bad page(s) that triggered this notification may not be part of the      process and the scan of the address space using      QueryWorkingSetEx may not turn up any bad      pages. To compile an application that calls this function, define _WIN32_WINNT as      _WIN32_WINNT_WIN8 or higher. For more information, see      Using the Windows Headers. ",
    "return_type": "VOID",
    "category": "Memory Management",
    "name": "BadMemoryCallbackRoutine",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "VOID",
        "type": "",
        "name": "VOID",
        "description": ""
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Registers a bad memory notification that is called when one or more bad memory pages are detected and the system      cannot remove at least one of them (for example if the pages contains modified data that has not yet been written      to the pagefile.)",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Registration handle that represents the callback notification. Can be passed to the        UnregisterBadMemoryNotification        function when no longer needed. ",
    "remarks": "To compile an application that calls this function, define _WIN32_WINNT as      _WIN32_WINNT_WIN8 or higher. For more information, see      Using the Windows Headers. ",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "RegisterBadMemoryNotification",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PBAD_MEMORY_CALLBACK_ROUTINE",
        "name": "Callback",
        "description": "A pointer to the application-defined        BadMemoryCallbackRoutine function to        register."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Gets the memory error handling capabilities of the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "To compile an application that calls this function, define _WIN32_WINNT as      _WIN32_WINNT_WIN8 or higher. For more information, see      Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "GetMemoryErrorHandlingCapabilities",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Capabilities",
        "description": "A PULONG that receives one or more of the following flags.  ValueMeaning  MEHC_PATROL_SCRUBBER_PRESENT 1   The hardware can detect and report failed memory."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Closes the specified bad memory notification handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "To compile an application that calls this function, define _WIN32_WINNT as      _WIN32_WINNT_WIN8 or higher. For more information, see      Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "UnregisterBadMemoryNotification",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "RegistrationHandle",
        "description": "Registration handle returned from the        RegisterBadMemoryNotification        function."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Creates a new uninitialized enclave. An enclave  is an isolated region of code and data within the address space for an application. Only code that runs within the enclave can access data within the same enclave.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "Enclaveapi.h (include Winbase.h)",
    "return_value": "If the function succeeds, the return value is the base address of the created enclave. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. For a list of common error codes, see System Error Codes. The following error codes also apply for this function.  ",
    "remarks": "To load data into an enclave after you create it, call LoadEnclaveData. To initialize the enclave after you load the data, call InitializeEnclave. To delete the enclave when you finish using it, call the VirtualFree or VirtualFreeEx function and specify the following values: For information about the Intel Software Guard Extensions (SGX) architecture extension, see Intel Software Guard Extensions. ",
    "return_type": "PVOID",
    "category": "Memory Management",
    "name": "CreateEnclave",
    "is_callback": 0,
    "dll": "Api-ms-win-core-enclave-l1-1-0;  Kernel32.dll;  KernelBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process for which you want to create an enclave."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "The preferred base address of the enclave. Specify NULL to have the operating system assign the base address."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwSize",
        "description": "The size of the enclave that you want to create, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "dwInitialCommittment",
        "description": "The amount of memory to commit for the enclave, in bytes. If the amount of enclave memory available is not sufficient to commit this number of bytes, enclave creation fails. Any memory that remains unused when you initialize the enclave by calling InitializeEnclave is returned to the list of free pages. The value of the dwInitialCommittment parameter must not exceed the value of the dwSize parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flEnclaveType",
        "description": "The architecture type of the enclave that you want to create. To verify that an enclave type is supported, call IsEnclaveTypeSupported. Only a value of ENCLAVE_TYPE_SGX is currently supported, which specifies an enclave for the Intel Software Guard Extensions (SGX) architecture extension."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpEnclaveInformation",
        "description": "A pointer to the architecture-specific information to use to create the enclave. For the ENCLAVE_TYPE_SGX enclave type, you must specify a pointer to an ENCLAVE_CREATE_INFO_SGX structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoLength",
        "description": "The length of the structure that the lpEnclaveInformation parameter points to, in bytes. For the ENCLAVE_TYPE_SGX enclave type, this value must be 4096."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpEnclaveError",
        "description": "An optional pointer to  a variable that receives an enclave error code that is architecture-specific. For the ENCLAVE_TYPE_SGX enclave type, the lpEnclaveError parameter is not used."
      }
    ],
    "min_client": "Windows 10 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Initializes an enclave that you created and loaded with data.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "Enclaveapi.h (include Winbase.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. For a list of common error codes, see System Error Codes. The following error codes also apply for this function.  ",
    "remarks": "To create an enclave, use the CreateEnclave function. To load data into the enclave before you initialize it, use the LoadEnclaveData function. To delete the enclave when you finish using it, call the VirtualFree or VirtualFreeEx function and specify the following values: ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "InitializeEnclave",
    "is_callback": 0,
    "dll": "Api-ms-win-core-enclave-l1-1-0;  Kernel32.dll;  KernelBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process for which the enclave was created."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "Any address within the enclave."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpEnclaveInformation",
        "description": "A pointer to architecture-specific information to use to initialize the enclave. For the ENCLAVE_TYPE_SGX enclave type, specify a pointer to an ENCLAVE_INIT_INFO_SGX structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoLength",
        "description": "The length of the structure that the lpEnclaveInformation parameter points to, in bytes. For the ENCLAVE_TYPE_SGX enclave type, this value must be 4096."
      },
      {
        "in_out": "_In_",
        "type": "LPDWORD",
        "name": "lpEnclaveError",
        "description": "An optional pointer to  a variable that receives an enclave error code that is architecture-specific. For the ENCLAVE_TYPE_SGX enclave type, the lpEnclaveError parameter contains the error that the EINIT instruction generated if the function fails and .GetLastError returns ERROR_ENCLAVE_FAILURE."
      }
    ],
    "min_client": "Windows 10 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves whether the specified type of enclave is supported.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "Enclaveapi.h (include Winbase.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. For a list of common error codes, see System Error Codes. The following error codes also apply for this function.  ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "IsEnclaveTypeSupported",
    "is_callback": 0,
    "dll": "Api-ms-win-core-enclave-l1-1-0;  Kernel32.dll;  KernelBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flEnclaveType",
        "description": "The type of enclave to check. Only a value of ENCLAVE_TYPE_SGX is currently supported, which specifies an enclave for the Intel Software Guard Extensions (SGX) architecture extension."
      }
    ],
    "min_client": "Windows 10 [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "Loads data into an  uninitialized enclave that you created by calling CreateEnclave.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "Enclaveapi.h (include Winbase.h)",
    "return_value": "If all of the data is loaded into the enclave successfully, the return value is nonzero. Otherwise, the return value is zero. To get extended error information, call GetLastError. For a list of common error codes, see System Error Codes. The following error codes also apply for this function.  ",
    "remarks": "To initialize the enclave after you load data into the enclave, call InitializeEnclave. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "LoadEnclaveData",
    "is_callback": 0,
    "dll": "Api-ms-win-core-enclave-l1-1-0;  Kernel32.dll;  KernelBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "A handle to the process for which the enclave was created."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAddress",
        "description": "The address in the enclave where you want to load the data."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpBuffer",
        "description": "A pointer to the data the you want to load into the enclave."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "nSize",
        "description": "The size of the data that you want to load into the enclave, in bytes. This value must be a whole-number multiple of the page size."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flProtect",
        "description": "The memory protection to use for the pages that you want to add to the enclave. For a list of memory protection values, see memory protection constants. This value must not include the following constants:  PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE PAGE_NOACCESS  For the ENCLAVE_TYPE_SGX enclave type, this value can include the enclave specific constants that the following table describes.  ConstantDescription PAGE_ENCLAVE_THREAD_CONTROLThe page contains a thread control structure (TCS). PAGE_ENCLAVE_UNVALIDATEDThe page contents that you supply are excluded from measurement with the EEXTEND instruction of the Intel Software Guard Extensions programming model."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpPageInformation",
        "description": "A pointer to information that describes the pages that you want to add to the enclave. For the ENCLAVE_TYPE_SGX enclave type, the lpPageInformation parameter is not used."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoLength",
        "description": "The length of the structure that the lpPageInformation parameter points to, in bytes. For the ENCLAVE_TYPE_SGX enclave type, this value must be 0."
      },
      {
        "in_out": "_Out_",
        "type": "PSIZE_T",
        "name": "lpNumberOfBytesWritten",
        "description": "A pointer to a variable that receives the number of bytes that LoadEnclaveData copied into the enclave."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpEnclaveError",
        "description": "An optional pointer to  a variable that receives an enclave error code that is architecture-specific. For the ENCLAVE_TYPE_SGX enclave type, the lpEnclaveError parameter is not used."
      }
    ],
    "min_client": "Windows 10 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether the calling process has read access to the memory at the specified address.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the calling process has read access to the specified memory, the return value is zero. If the calling process does not have read access to the specified memory, the return value is nonzero. To get extended error information, call  GetLastError. If the application is compiled as a debugging version, and the process does not have read access to  the specified memory location, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid. ",
    "remarks": "In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "IsBadCodePtr",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "FARPROC",
        "name": "lpfn",
        "description": "A pointer to a memory address."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Verifies that the calling process has read access to the specified range of memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the calling process has read access to all bytes in the specified memory range, the return value is zero. If the calling process does not have read access to all bytes in the specified memory range, the return value is nonzero. If the application is compiled as a debugging version, and the process does not have read access to all bytes in the specified memory range, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid. ",
    "remarks": "This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL. Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner. Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information. If the calling process has read access to some, but not all, of the bytes in the specified memory range, the return value is nonzero. In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "IsBadReadPtr",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lp",
        "description": "A pointer to the first byte of the memory block."
      },
      {
        "in_out": "_In_",
        "type": "UINT_PTR",
        "name": "ucb",
        "description": "The size of the memory block, in bytes. If this parameter is zero, the return value is zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Verifies that the calling process has read access to the specified range of memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by ucchMax, the return value is zero. If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by ucchMax, the return value is nonzero. If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid. ",
    "remarks": "This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL. Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner. Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information. If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero. In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use  structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "IsBadStringPtr",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpsz",
        "description": "A pointer to a null-terminated string, either Unicode or ASCII."
      },
      {
        "in_out": "_In_",
        "type": "UINT_PTR",
        "name": "ucchMax",
        "description": "The maximum size of the string, in TCHARs. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Verifies that the calling process has write access to the specified range of memory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the calling process has write access to all bytes in the specified memory range, the return value is zero. If the calling process does not have write access to all bytes in the specified memory range, the return value is nonzero. If the application is run under a debugger and the process does not have write access to all bytes in the specified memory range, the function causes a first chance STATUS_ACCESS_VIOLATION exception. The debugger can be configured to break for this condition. After resuming process execution in the debugger, the function continues as usual and returns a nonzero value This behavior is by design and serves as a debugging aid. ",
    "remarks": "This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL. Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner. Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information. If the calling process has write access to some, but not all, of the bytes in the specified memory range, the return value is nonzero. In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has write access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception. IsBadWritePtr is not multithread safe. To use it properly on a pointer shared by multiple threads, call it inside a critical region of code that allows only one thread to access the memory being checked. Use operating system\u00e2\u0080\u0093level objects such as critical sections or mutexes or the interlocked functions to create the critical region of code. ",
    "return_type": "BOOL",
    "category": "Memory Management",
    "name": "IsBadWritePtr",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lp",
        "description": "A pointer to the first byte of the memory block."
      },
      {
        "in_out": "_In_",
        "type": "UINT_PTR",
        "name": "ucb",
        "description": "The size of the memory block, in bytes. If this parameter is zero, the return value is zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[GlobalMemoryStatus can return incorrect information. Use the  GlobalMemoryStatusEx function instead.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "On computers with more than 4 GB of memory, the  GlobalMemoryStatus function can return incorrect information, reporting a value of \u00e2\u0080\u00931 to indicate an overflow. For this reason, applications should use the  GlobalMemoryStatusEx function instead. On Intel x86 computers with more than 2 GB and less than 4 GB of memory, the  GlobalMemoryStatus function will always return 2 GB in the dwTotalPhys member of the  MEMORYSTATUS structure. Similarly, if the total available memory is between 2 and 4 GB, the dwAvailPhys member of the  MEMORYSTATUS structure will be rounded down to 2 GB. If the executable is linked using the /LARGEADDRESSAWARE linker option, then the  GlobalMemoryStatus function will return the correct amount of physical memory in both members. The information returned by the  GlobalMemoryStatus function is volatile. There is no guarantee that two sequential calls to this function will return the same information. ",
    "return_type": "void",
    "category": "Memory Management",
    "name": "GlobalMemoryStatus",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPMEMORYSTATUS",
        "name": "lpBuffer",
        "description": "A pointer to a  MEMORYSTATUS structure. The  GlobalMemoryStatus function stores information about current memory availability into this structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]