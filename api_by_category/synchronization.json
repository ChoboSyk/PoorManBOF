[
  {
    "n_arguments": 1,
    "description": "An application-defined completion routine. Specify this address when calling the  QueueUserAPC function. The PAPCFUNC type defines a pointer to this callback function.  APCProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID CALLBACK",
    "category": "Synchronization",
    "name": "APCProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "dwParam",
        "description": "The data passed to the function using the dwData parameter of the  QueueUserAPC function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Adds a user-mode asynchronous procedure call (APC) object to the APC queue of the specified thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. Windows Server 2003 and Windows XP:  There are no error values defined for this function that can be retrieved by calling  GetLastError. ",
    "remarks": "The APC support provided in the operating system allows an application to queue an APC object to a thread. To ensure successful execution of  functions used by the APC, APCs  should be queued only to   threads in the caller's process. Each thread has its own APC queue. The queuing of an APC is a request for the thread to call the APC function. The operating system issues a software interrupt to direct the thread to call the APC function. When a user-mode APC is queued, the thread is not directed to call the APC function unless it is in an alertable state. After the thread is in an alertable state, the thread handles all pending APCs in first in, first out (FIFO) order, and the wait operation returns WAIT_IO_COMPLETION. A thread enters an alertable state by using  SleepEx,  SignalObjectAndWait,  WaitForSingleObjectEx,  WaitForMultipleObjectsEx, or  MsgWaitForMultipleObjectsEx to perform an alertable wait operation. If an application queues an APC before the thread begins running, the thread begins by calling the APC function. After the thread calls an APC function, it calls the APC functions for all APCs in its APC queue. It is possible to sleep or wait for an object within the APC. If you perform an alertable wait inside an APC, it will recursively dispatch the APCs. This can cause a stack overflow. When the thread is terminated using the  ExitThread or  TerminateThread function, the APCs in its APC queue are lost. The APC functions are not called. When the thread is in the process of being terminated, calling QueueUserAPC to add to the thread's APC queue will fail with (31) ERROR_GEN_FAILURE. Note that the ReadFileEx,  SetWaitableTimer, and WriteFileEx functions are implemented using an APC as the completion notification callback mechanism. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "QueueUserAPC",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PAPCFUNC",
        "name": "pfnAPC",
        "description": "A pointer to the application-supplied APC function to be called when the specified thread performs an alertable wait operation. For more information, see  APCProc."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread. The handle must have the THREAD_SET_CONTEXT access right. For more information, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "dwData",
        "description": "A single value that is passed to the APC function pointed to by the pfnAPC parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device. To specify a timeout interval or wait on an alertable thread, use GetOverlappedResultEx.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Ioapiset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The results reported by the  GetOverlappedResult function are those of the specified handle's last overlapped operation to which the specified  OVERLAPPED structure was provided, and for which the operation's results were pending. A pending operation is indicated when the function that started the operation returns FALSE, and the GetLastError function returns ERROR_IO_PENDING. When an I/O operation is pending, the function that started the operation resets the hEvent member of the  OVERLAPPED structure to the nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled state. If the bWait parameter is TRUE,  GetOverlappedResult determines whether the pending operation has been completed by waiting for the event object to be in the signaled state. If the hEvent member of the  OVERLAPPED structure is NULL, the system uses the state of the hFile handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this situation, there is no way to know which operation caused the object's state to be signaled. For an example that uses  GetOverlappedResult, see  Testing for the End of a File. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "GetOverlappedResult",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to the  ReadFile,  WriteFile,  ConnectNamedPipe,  TransactNamedPipe,  DeviceIoControl, or  WaitCommEvent function."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure that was specified when the overlapped operation was started."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesTransferred",
        "description": "A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a  TransactNamedPipe operation, this is the number of bytes that were read from the pipe. For a  DeviceIoControl operation, this is the number of bytes of output data returned by the device driver. For a  ConnectNamedPipe or  WaitCommEvent operation, this value is undefined."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bWait",
        "description": "If this parameter is TRUE, and the Internal member of the lpOverlapped structure is STATUS_PENDING, the function does not return until the operation has been completed. If this parameter is FALSE and the operation is still pending, the function returns FALSE and the  GetLastError function returns ERROR_IO_INCOMPLETE."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device within the  specified time-out interval.  The calling thread can perform an alertable wait.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Ioapiset.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. Common error codes include the following: ",
    "remarks": "The GetOverlappedResultEx function differs from GetOverlappedResult in the following ways: The dwMilliseconds parameter can specify a timeout interval for the operation, and the bAlertable parameter can specify that the calling thread should perform an alertable wait. The results reported by the  GetOverlappedResultEx function are those of the specified handle's last overlapped operation to which the specified  OVERLAPPED structure was provided, and for which the operation's results were pending. A pending operation is indicated when the function that started the operation returns FALSE, and the GetLastError function returns ERROR_IO_PENDING. When an I/O operation is pending, the function that started the operation resets the hEvent member of the  OVERLAPPED structure to the nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled state. Specify a manual-reset event object in the  OVERLAPPED structure. If an auto-reset event object is used, the event handle must not be specified in any other wait operation in the interval between starting the overlapped operation and the call to  GetOverlappedResultEx. For example, the event object is sometimes specified in one of the wait functions to wait for the operation's completion. When the wait function returns, the system sets an auto-reset event's state to nonsignaled, and a subsequent call to  GetOverlappedResultEx with the dwMilliseconds parameter set to INFINITE causes the function to be blocked indefinitely. If the hEvent member of the  OVERLAPPED structure is NULL, the system uses the state of the hFile handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this situation, there is no way to know which operation caused the object's state to be signaled. ",
    "return_type": "WINBASEAPI BOOL",
    "category": "Synchronization",
    "name": "GetOverlappedResultEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to the  ReadFile,  WriteFile,  ConnectNamedPipe,  TransactNamedPipe,  DeviceIoControl, or  WaitCommEvent function."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure that was specified when the overlapped operation was started."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesTransferred",
        "description": "A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a  TransactNamedPipe operation, this is the number of bytes that were read from the pipe. For a  DeviceIoControl operation, this is the number of bytes of output data returned by the device driver. For a  ConnectNamedPipe or  WaitCommEvent operation, this value is undefined."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds.  If dwMilliseconds is zero and the operation is still in progress, the function  returns immediately and the GetLastError function returns ERROR_IO_INCOMPLETE. If dwMilliseconds is nonzero and the operation is still in progress, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses before returning. Use GetLastError to get extended error information. If dwMilliseconds is INFINITE, the function returns only when the object is signaled or an I/O completion routine or APC is queued."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bAlertable",
        "description": "If this parameter is TRUE and the calling thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC. The calling thread then runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed.   A completion routine is queued when the ReadFileEx or WriteFileEx function in which it was specified has completed. The function returns and the completion routine is called only if bAlertable is TRUE, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call QueueUserAPC."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Acquires a slim reader/writer (SRW) lock in exclusive mode.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "AcquireSRWLockExclusive",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Acquires a slim reader/writer (SRW) lock in shared mode.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "AcquireSRWLockShared",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes a condition variable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "Threads  can atomically release a lock and enter the sleeping state using the SleepConditionVariableCS or SleepConditionVariableSRW function. The threads are woken using the WakeConditionVariable or WakeAllConditionVariable function. Condition variables are user-mode objects that cannot be shared across processes. A condition variable cannot be moved or copied. The process must not modify the object, and must instead treat it as logically opaque. Only use the condition variable functions to manage condition variables. For an example that uses this function, see Using Condition Variables. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "InitializeConditionVariable",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PCONDITION_VARIABLE",
        "name": "ConditionVariable",
        "description": "A pointer to the condition variable."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initialize a slim reader/writer (SRW) lock.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "An SRW lock must be initialized before it is used. The InitializeSRWLock function is used to initialize a SRW lock dynamically. To initialize the structure statically, assign the constant SRWLOCK_INIT to the structure variable. An SRW lock cannot be moved or copied. The process must not modify the object, and must instead treat it as logically opaque. Only use the SRW functions to manage SRW locks. SRW locks do not need to be explicitly destroyed. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "InitializeSRWLock",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases a slim reader/writer (SRW) lock that was acquired in exclusive mode.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "ReleaseSRWLockExclusive",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases a slim reader/writer (SRW) lock that was acquired in shared mode.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "ReleaseSRWLockShared",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Sleeps on the specified condition variable and releases the specified critical section as an atomic operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails or the time-out interval elapses, the return value is zero. To get extended error information, call  GetLastError. Possible error codes include ERROR_TIMEOUT, which indicates that the time-out interval has elapsed before another thread has attempted to wake the sleeping thread. ",
    "remarks": "A thread that is sleeping on a condition variable can be woken before the specified time-out interval has elapsed  using the WakeConditionVariable or WakeAllConditionVariable function. In this case, the thread wakes when the wake processing is complete, and not when its time-out interval elapses. After the thread is woken, it re-acquires the critical section it released when the thread entered the sleeping state. Condition variables are subject to spurious wakeups (those not associated with an explicit wake) and stolen wakeups (another thread manages to run before the woken thread). Therefore, you should recheck a predicate (typically in a while loop) after a sleep operation returns. For an example that uses this function, see Using Condition Variables. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "SleepConditionVariableCS",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PCONDITION_VARIABLE",
        "name": "ConditionVariable",
        "description": "A pointer to the condition variable. This variable must be initialized using the InitializeConditionVariable function."
      },
      {
        "in_out": "_Inout_",
        "type": "PCRITICAL_SECTION",
        "name": "CriticalSection",
        "description": "A pointer to the critical section object. This critical section must be entered exactly once by the caller at the time SleepConditionVariableCS is called."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If the time-out interval elapses, the function re-acquires the critical section and returns zero. If dwMilliseconds is zero, the function tests the states of the specified objects and returns immediately. If dwMilliseconds is INFINITE, the function's time-out interval never elapses. For more information, see Remarks."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Sleeps on the specified condition variable and releases the specified lock as an atomic operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the timeout expires the function returns FALSE and GetLastError returns ERROR_TIMEOUT. ",
    "remarks": "If the lock is unlocked when this function is called, the function behavior is undefined. The thread can be woken using the WakeConditionVariable or WakeAllConditionVariable function. Condition variables are subject to spurious wakeups (those not associated with an explicit wake) and stolen wakeups (another thread manages to run before the woken thread). Therefore, you should recheck a predicate (typically in a while loop) after a sleep operation returns. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "SleepConditionVariableSRW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PCONDITION_VARIABLE",
        "name": "ConditionVariable",
        "description": "A pointer to the condition variable. This variable must be initialized using the InitializeConditionVariable function."
      },
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the lock. This lock must be held in the manner specified by the Flags parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. The function returns if the interval elapses. If dwMilliseconds is zero, the function tests the states of the specified objects and returns immediately. If dwMilliseconds is INFINITE, the function's time-out interval never elapses."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "If this parameter is CONDITION_VARIABLE_LOCKMODE_SHARED, the SRW lock is in shared mode. Otherwise, the lock is in exclusive mode."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Attempts to acquire a slim reader/writer (SRW) lock in exclusive mode. If the call is successful, the calling thread takes ownership of the lock.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the lock is successfully acquired, the return value is nonzero. if the current thread could not acquire the lock, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Synchronization",
    "name": "TryAcquireSRWLockExclusive",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread takes ownership of the lock.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the lock is successfully acquired, the return value is nonzero. if the current thread could not acquire the lock, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Synchronization",
    "name": "TryAcquireSRWLockShared",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSRWLOCK",
        "name": "SRWLock",
        "description": "A pointer to the SRW lock."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Wake all threads waiting on the specified condition variable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The WakeAllConditionVariable wakes all      waiting threads while the WakeConditionVariable      wakes only a single thread. Waking one thread is similar to setting an auto-reset event, while waking all threads      is similar to pulsing a manual reset event but more reliable (see      PulseEvent for details). ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "WakeAllConditionVariable",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PCONDITION_VARIABLE",
        "name": "ConditionVariable",
        "description": "A pointer to the condition variable."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Wake a single thread waiting on the specified condition variable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The WakeAllConditionVariable wakes all waiting threads while the WakeConditionVariable wakes only a single thread. Waking one thread is similar to setting an auto-reset event, while waking all threads is similar to pulsing a manual reset event but more reliable (see PulseEvent for details). For an example that uses this function, see Using Condition Variables. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "WakeConditionVariable",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PCONDITION_VARIABLE",
        "name": "ConditionVariable",
        "description": "A pointer to the condition variable."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases all resources used by an unowned critical section object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "Deleting a critical section object releases all system resources used by the object. The caller is responsible for ensuring that the critical section object is unowned and the specified CRITICAL_SECTION structure is not being accessed by any critical section functions called by other threads in the process. After a critical section object has been deleted, do not reference the object in any function that operates on critical sections (such as EnterCriticalSection, TryEnterCriticalSection, and LeaveCriticalSection) other than InitializeCriticalSection and InitializeCriticalSectionAndSpinCount. If you attempt to do so, memory corruption and other unexpected errors can occur. If a critical section is deleted while it is still owned, the state of the threads waiting for ownership of the deleted critical section is undefined. For an example that uses  DeleteCriticalSection, see  Using Critical Section Objects. ",
    "return_type": "void",
    "category": "Synchronization",
    "name": "DeleteCriticalSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object. The object must have been previously initialized with the  InitializeCriticalSection function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. This function can raise EXCEPTION_POSSIBLE_DEADLOCK if a wait operation on the critical section times out. The timeout interval is specified by the following registry value: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CriticalSectionTimeout. Do not handle a possible deadlock exception; instead, debug the application. ",
    "remarks": "The threads of a single process can use a critical section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must call  InitializeCriticalSection or  InitializeCriticalSectionAndSpinCount to initialize the object. To enable mutually exclusive access to a shared resource, each thread calls the  EnterCriticalSection or  TryEnterCriticalSection function to request ownership of the critical section before executing any section of code that accesses the protected resource. The difference is that  TryEnterCriticalSection returns immediately, regardless of whether it obtained ownership of the critical section, while  EnterCriticalSection blocks until the thread can take ownership of the critical section. When it has finished executing the protected code, the thread uses the  LeaveCriticalSection function to relinquish ownership, enabling another thread to become owner and access the protected resource. There is no guarantee about the order in which waiting threads will acquire ownership of the critical section. After a thread has ownership of a critical section, it can make additional calls to  EnterCriticalSection or  TryEnterCriticalSection without blocking its execution. This prevents a thread from deadlocking itself while waiting for a critical section that it already owns. The thread enters the critical section each time  EnterCriticalSection and  TryEnterCriticalSection succeed. A thread must call  LeaveCriticalSection once for each time that it entered the critical section. Any thread of the process can use the  DeleteCriticalSection function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization. If a thread terminates while it has ownership of a critical section, the state of the critical section is undefined. If a critical section is deleted while it is still owned, the state of the threads waiting for ownership of the deleted critical section is undefined. For an example that uses  EnterCriticalSection, see  Using Critical Section Objects. ",
    "return_type": "void",
    "category": "Synchronization",
    "name": "EnterCriticalSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes a critical section object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. Windows Server 2003 and Windows XP:  In low memory situations,  InitializeCriticalSection can raise a STATUS_NO_MEMORY exception. This exception was eliminated starting with Windows Vista. ",
    "remarks": "The threads of a single process can use a critical section object for mutual-exclusion synchronization. There is no guarantee about the order in which threads will obtain ownership of the critical section, however, the system will be fair to all threads. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must initialize the object. After a critical section object has been initialized, the threads of the process can specify the object in the  EnterCriticalSection,  TryEnterCriticalSection, or  LeaveCriticalSection function to provide mutually exclusive access to a shared resource. For similar synchronization between the threads of different processes, use a mutex object. A critical section object cannot be moved or copied. The process must also not modify the object, but must treat it as logically opaque. Use only the critical section functions to manage critical section objects. When you have finished using the critical section, call the  DeleteCriticalSection function. A critical section object must be deleted before it can be reinitialized. Initializing a critical section that has already been initialized results in undefined behavior. ",
    "return_type": "void",
    "category": "Synchronization",
    "name": "InitializeCriticalSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Initializes a critical section object and sets the spin count for the critical section. When a thread tries to acquire a critical section that is locked, the thread spins: it enters a loop which iterates spin count times, checking to see if the lock is released. If the lock is not released before  the loop finishes, the thread goes to sleep to wait for the lock to be released.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function always returns a nonzero value. Windows Server 2003 and Windows XP:  If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call  GetLastError. This behavior was changed starting with Windows Vista. ",
    "remarks": "The threads of a single process can use a critical section object for mutual-exclusion synchronization. There is no guarantee about the order that threads obtain ownership of the critical section. However, the system is fair to all threads. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must initialize the object. You can subsequently modify the spin count by calling the  SetCriticalSectionSpinCount function. After a critical section object is initialized, the threads of the process can specify the object in the EnterCriticalSection, TryEnterCriticalSection, or  LeaveCriticalSection function to provide mutually exclusive access to a shared resource. For similar synchronization between the threads of different processes, use a mutex object. A critical section object cannot be moved or copied. The process must also not modify the object, but must treat it as logically opaque. Use only the critical section functions to manage critical section objects. When you have finished using the critical section, call the  DeleteCriticalSection function. A critical section object must be deleted before it can be reinitialized. Initializing a critical section that is already  initialized results in undefined behavior. The spin count is useful for critical sections of short duration that can experience high levels of contention. Consider a worst-case scenario, in which an application on an SMP system has two or three threads constantly allocating and releasing memory from the heap. The application serializes the heap with a critical section. In the worst-case scenario, contention for the critical section is constant, and each thread makes an processing-intensive call to the  WaitForSingleObject function. However, if the spin count is set properly, the calling thread does not immediately call  WaitForSingleObject when contention occurs. Instead, the calling thread can acquire ownership of the critical section if it is released during the spin operation. You can improve performance significantly by choosing a small spin count for a critical section of short duration. For example, the heap manager uses a spin count of roughly 4,000 for its per-heap critical sections. To compile an application that uses this function, define _WIN32_WINNT as 0x0403 or later. For more information, see  Using the Windows Headers. For an example that uses  InitializeCriticalSectionAndSpinCount, see  Using Critical Section Objects. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "InitializeCriticalSectionAndSpinCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSpinCount",
        "description": "The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spins dwSpinCount times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Initializes a critical section object with a spin count and optional flags.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call  GetLastError. ",
    "remarks": "The threads of a single process can use a critical section object for mutual-exclusion synchronization. There is no guarantee about the order that threads obtain ownership of the critical section, however, the system is fair to all threads. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must initialize the object. You can subsequently modify the spin count by calling the  SetCriticalSectionSpinCount function. After a critical section object is initialized, the threads of the process can specify the object in the EnterCriticalSection, TryEnterCriticalSection, or  LeaveCriticalSection function to provide mutually exclusive access to a shared resource. For similar synchronization between the threads of different processes, use a mutex object. A critical section object cannot be moved or copied. The process must also not modify the object, but must treat it as logically opaque. Use only the critical section functions to manage critical section objects. When you have finished using the critical section, call the  DeleteCriticalSection function. A critical section object must be deleted before it can be reinitialized. Initializing a critical section that is already  initialized results in undefined behavior. The spin count is useful for critical sections of short duration that can experience high levels of contention. Consider a worst-case scenario, in which an application on an SMP system has two or three threads constantly allocating and releasing memory from the heap. The application serializes the heap with a critical section. In the worst-case scenario, contention for the critical section is constant, and each thread makes an processing-intensive call to the  WaitForSingleObject function. However, if the spin count is set properly, the calling thread does not immediately call  WaitForSingleObject when contention occurs. Instead, the calling thread can acquire ownership of the critical section if it is released during the spin operation. You can improve performance significantly by choosing a small spin count for a critical section of short duration. The heap manager uses a spin count of roughly 4000 for its per-heap critical sections. This gives great performance and scalability in almost all worst-case scenarios. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "InitializeCriticalSectionEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSpinCount",
        "description": "The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spin dwSpinCount times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "This parameter can be 0 or the following value.  ValueMeaning  CRITICAL_SECTION_NO_DEBUG_INFO   The critical section is created without debug information."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases ownership of the specified critical section object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The threads of a single process can use a critical-section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical-section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must call the  InitializeCriticalSection or  InitializeCriticalSectionAndSpinCount function to initialize the object. A thread uses the  EnterCriticalSection or  TryEnterCriticalSection function to acquire ownership of a critical section object. To release its ownership, the thread must call  LeaveCriticalSection once for each time that it entered the critical section. If a thread calls  LeaveCriticalSection when it does not have ownership of the specified critical section object, an error occurs that may cause another thread using  EnterCriticalSection to wait indefinitely. Any thread of the process can use the  DeleteCriticalSection function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization. For an example that uses  LeaveCriticalSection, see  Using Critical Section Objects. ",
    "return_type": "void",
    "category": "Synchronization",
    "name": "LeaveCriticalSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the spin count for the specified critical section. Spinning means that when a thread tries to acquire a critical section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not released, the thread goes to sleep.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The function returns the previous spin count for the critical section. ",
    "remarks": "The threads of a single process can use a critical section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must call the  InitializeCriticalSection or  InitializeCriticalSectionAndSpinCount function to initialize the object. You can subsequently modify the spin count by calling the  SetCriticalSectionSpinCount function. The spin count is useful for critical sections of short duration that can experience high levels of contention. Consider a worst-case scenario, in which an application on an SMP system has two or three threads constantly allocating and releasing memory from the heap. The application serializes the heap with a critical section. In the worst-case scenario, contention for the critical section is constant, and each thread makes an processing-intensive call to the  WaitForSingleObject function. However, if the spin count is set properly, the calling thread does not immediately call  WaitForSingleObject when contention occurs. Instead, the calling thread can acquire ownership of the critical section if it is released during the spin operation. You can improve performance significantly by choosing a small spin count for a critical section of short duration. The heap manager uses a spin count of roughly 4000 for its per-heap critical sections. This gives great performance and scalability in almost all worst-case scenarios. To compile an application that uses this function, define _WIN32_WINNT as 0x0403 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "SetCriticalSectionSpinCount",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSpinCount",
        "description": "The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to zero (0). On multiprocessor systems, if the critical section is unavailable, the calling thread spins dwSpinCount times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero. If another thread already owns the critical section, the return value is zero. ",
    "remarks": "The threads of a single process can use a critical section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type CRITICAL_SECTION. Before using a critical section, some thread of the process must call the  InitializeCriticalSection or  InitializeCriticalSectionAndSpinCount function to initialize the object. To enable mutually exclusive use of a shared resource, each thread calls the  EnterCriticalSection or  TryEnterCriticalSection function to request ownership of the critical section before executing any section of code that uses the protected resource. The difference is that  TryEnterCriticalSection returns immediately, regardless of whether it obtained ownership of the critical section, while  EnterCriticalSection blocks until the thread can take ownership of the critical section. When it has finished executing the protected code, the thread uses the  LeaveCriticalSection function to relinquish ownership, enabling another thread to become the owner and gain access to the protected resource. The thread must call  LeaveCriticalSection once for each time that it entered the critical section. Any thread of the process can use the  DeleteCriticalSection function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization. If a thread terminates while it has ownership of a critical section, the state of the critical section is undefined. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "TryEnterCriticalSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCRITICAL_SECTION",
        "name": "lpCriticalSection",
        "description": "A pointer to the critical section object."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Creates or opens a named or unnamed event object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the event object. If the named event object existed         before the function call, the function returns a handle to the existing object and         GetLastError returns         ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call         GetLastError. ",
    "remarks": "The handle returned by CreateEvent has the      EVENT_ALL_ACCESS access right; it can be used in any function that requires a handle to      an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see      Synchronization Object Security      and Access Rights. Any thread of the calling process can specify the event-object handle in a call to one of the      wait functions. The single-object wait functions return      when the state of the specified object is signaled. The multiple-object wait functions can be instructed to      return either when any one or when all of the specified objects are signaled. When a wait function returns, the      waiting thread is released to continue its execution. The initial state of the event object is specified by the bInitialState parameter. Use      the SetEvent function to set the state of an event object to      signaled. Use the ResetEvent function to reset      the state of an event object to nonsignaled. When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to      nonsignaled by the ResetEvent function. Any number of      waiting threads, or threads that subsequently begin wait operations for the specified event object, can be      released while the object's state is signaled. When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is      released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event      object's state remains signaled. Multiple processes can have handles of the same event object, enabling use of the object for interprocess      synchronization. The following object-sharing mechanisms are available: Use the CloseHandle function to close the handle. The      system closes the handle automatically when the process terminates. The event object is destroyed when its last      handle has been closed. For an example that uses CreateEvent, see       Using Event Objects. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateEvent",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpEventAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES structure. If        this parameter is NULL, the handle cannot be inherited by child processes.         The lpSecurityDescriptor member of the structure specifies a         security descriptor for the new         event. If lpEventAttributes is NULL, the event gets a default security descriptor.         The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bManualReset",
        "description": "If this parameter is TRUE, the function creates a manual-reset event object, which requires the use of the        ResetEvent function to set the event state to nonsignaled. If        this parameter is FALSE, the function creates an auto-reset event object, and system automatically resets the        event state to nonsignaled after a single waiting thread has been released."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInitialState",
        "description": "If this parameter is TRUE, the initial state of the event object is signaled; otherwise, it is nonsignaled."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the event object. The name is limited to        MAX_PATH characters. Name comparison is case sensitive.         If lpName matches the name of an existing named event object, this function requests         the EVENT_ALL_ACCESS access right. In this case, the         bManualReset and bInitialState parameters are ignored         because they have already been set by the creating process. If the         lpEventAttributes parameter is not NULL, it determines whether the handle can be         inherited, but its security-descriptor member is ignored. If lpName is NULL, the event object is created without a name. If lpName matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or         file-mapping object), the function fails and the         GetLastError function returns         ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session          namespace. The remainder of the name can contain any character except the backslash character (\\). For more          information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined          for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Creates or opens a named or unnamed event object and returns a handle to the object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the event object. If the named event object existed         before the function call, the function returns a handle to the existing object and         GetLastError returns         ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call         GetLastError. ",
    "remarks": "Any thread of the calling process can specify the event-object handle in a call to one of the      wait functions. The single-object wait functions return      when the state of the specified object is signaled. The multiple-object wait functions can be instructed to      return either when any one or when all of the specified objects are signaled. When a wait function returns, the      waiting thread is released to continue its execution. The initial state of the event object is specified by the dwFlags parameter. Use      the SetEvent function to set the state of an event object to      signaled. Use the ResetEvent function to reset      the state of an event object to nonsignaled. When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to      nonsignaled by the ResetEvent function. Any number of      waiting threads, or threads that subsequently begin wait operations for the specified event object, can be      released while the object's state is signaled. Multiple processes can have handles of the same event object, enabling use of the object for interprocess      synchronization. The following object-sharing mechanisms are available: Use the CloseHandle function to close the handle. The      system closes the handle automatically when the process terminates. The event object is destroyed when its last      handle has been closed. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateEventEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpEventAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES structure. If        lpEventAttributes is NULL, the event handle cannot be inherited by child processes.         The lpSecurityDescriptor member of the structure specifies a         security descriptor for the new         event. If lpEventAttributes is NULL, the event gets a default security descriptor.         The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the event object. The name is limited to        MAX_PATH characters. Name comparison is case sensitive. If lpName is NULL, the event object is created without a name.         If lpName matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or         file-mapping object), the function fails and the         GetLastError function returns         ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session          namespace. The remainder of the name can contain any character except the backslash character (\\). For more          information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined          for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one or more of the following values.  ValueMeaning  CREATE_EVENT_INITIAL_SET 0x00000002   The initial state of the event object is signaled; otherwise, it is nonsignaled.   CREATE_EVENT_MANUAL_RESET 0x00000001   The event must be manually reset using the ResetEvent function. Any number of      waiting threads, or threads that subsequently begin wait operations for the specified event object, can be      released while the object's state is signaled. If this flag is not specified, the system automatically resets the event after releasing a single waiting thread."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access mask for the event object. For a list of access rights, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing named event object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the event object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The  OpenEvent function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the  CreateEvent function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the dwDesiredAccess parameter. The handle can be duplicated by using the DuplicateHandle function. Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "OpenEvent",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The  name of the event to be opened. Name comparisons are case sensitive. This function can open objects in a private namespace. For more information, see Object Namespaces. Terminal Services:  The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Note  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the specified event object to the signaled state and then resets it to the nonsignaled state after releasing the appropriate number of waiting threads.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "A thread waiting on a synchronization object can be momentarily removed from the wait state  by a kernel-mode APC, and then returned to the wait state after the APC is complete.  If the call to  PulseEvent occurs during the time when the thread has been   removed from the wait state, the thread will not be released  because  PulseEvent releases only those threads that are waiting at the moment it is called.  Therefore,  PulseEvent is unreliable and should  not be  used by new applications. Instead, use condition variables. For a manual-reset event object, all waiting threads that can be released immediately are released. The function then resets the event object's state to nonsignaled and returns. For an auto-reset event object, the function resets the state to nonsignaled and returns after releasing a single waiting thread, even if multiple threads are waiting. If no threads are waiting, or if no thread can be released immediately,  PulseEvent simply sets the event object's state to nonsignaled and returns. Note that for a thread using the multiple-object  wait functions to wait for all specified objects to be signaled,  PulseEvent can set the event object's state to signaled and reset it to nonsignaled without causing the wait function to return. This happens if not all of the specified objects are simultaneously signaled. Use extreme caution when using  SignalObjectAndWait  and PulseEvent with Windows 7, since using these APIs among multiple threads can cause an application to deadlock. Threads that are signaled by SignalObjectAndWait  call PulseEvent to signal the waiting object of the SignalObjectAndWait call. In some circumstances, the caller of SignalObjectAndWait can't receive signal state of the waiting object in time, causing a deadlock. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "PulseEvent",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEvent",
        "description": "A handle to the event object. The  CreateEvent or  OpenEvent function returns this handle.     The handle must have the EVENT_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the specified event object to the nonsignaled state.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The state of an event object remains nonsignaled until it is explicitly set to signaled by the  SetEvent or  PulseEvent function. This nonsignaled state blocks the execution of any threads that have specified the event object in a call to one of the  wait functions. The  ResetEvent function is used primarily for manual-reset event objects, which must be set explicitly to the nonsignaled state. Auto-reset event objects automatically change from signaled to nonsignaled after a single waiting thread is released. Resetting an event that is already reset has no effect. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "ResetEvent",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEvent",
        "description": "A handle to the event object. The  CreateEvent or  OpenEvent function returns this handle.     The handle must have the EVENT_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the specified event object to the signaled state.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The state of a manual-reset event object remains signaled until it is set explicitly to the nonsignaled state by the  ResetEvent function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object by calling one of the  wait functions, can be released while the object's state is signaled. The state of an auto-reset event object remains signaled until a single waiting thread is released, at which time the system automatically sets the state to nonsignaled. If no threads are waiting, the event object's state remains signaled. Setting an event that is already set has no effect. Windows Store apps can respond to named events and semaphores as described in How to respond to named events and semaphores. For an example that uses  SetEvent, see  Using Event Objects. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "SetEvent",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEvent",
        "description": "A handle to the event object. The  CreateEvent or  OpenEvent function returns this handle.     The handle must have the EVENT_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Begins one-time initialization.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If INIT_ONCE_CHECK_ONLY is not specified and the function succeeds, the return value is TRUE. If INIT_ONCE_CHECK_ONLY is specified and initialization has completed, the return value is TRUE. Otherwise, the return value is FALSE. To get extended error information, call  GetLastError. ",
    "remarks": "This function can be used for either synchronous or asynchronous one-time initialization. For asynchronous one-time initialization, use the INIT_ONCE_ASYNC flag. To specify a callback function to execute during synchronous one-time initialization, see the InitOnceExecuteOnce function. If this function succeeds, the thread can create a synchronization object and specify in the lpContext parameter of the InitOnceComplete function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. A one-time initialization object cannot be moved or copied. The process must not modify the initialization object, and must instead treat it as logically opaque. Only use the one-time initialization functions to manage one-time initialization objects. For an example that uses  this function, see  Using One-Time Initialization. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "InitOnceBeginInitialize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPINIT_ONCE",
        "name": "lpInitOnce",
        "description": "A pointer to the one-time initialization structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one or more of the following flags.  ValueMeaning  INIT_ONCE_ASYNC 0x00000002UL   Enables multiple initialization attempts to execute in parallel. If this flag is used, subsequent calls to this function will fail unless this flag is also specified.   INIT_ONCE_CHECK_ONLY 0x00000001UL   This function call does not begin initialization. The return value indicates whether initialization has already completed. If the function returns TRUE, the lpContext parameter receives the data."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "fPending",
        "description": "If the function succeeds, this parameter indicates the current initialization status.  If this parameter is TRUE and dwFlags contains INIT_ONCE_CHECK_ONLY, the initialization is pending and the context data is invalid. If this parameter is FALSE, initialization has already completed and the caller can retrieve the context data from the lpContext parameter. If this parameter is TRUE and dwFlags does not contain INIT_ONCE_CHECK_ONLY, initialization has been started and the caller can perform the initialization tasks."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID*",
        "name": "lpContext",
        "description": "An optional parameter that receives the data stored with the one-time initialization structure upon success. The low-order INIT_ONCE_CTX_RESERVED_BITS bits of the data are always zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Completes one-time initialization started with the InitOnceBeginInitialize function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. For an example that uses  this function, see  Using One-Time Initialization. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "InitOnceComplete",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPINIT_ONCE",
        "name": "lpInitOnce",
        "description": "A pointer to the one-time initialization structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one of the following flags.  ValueMeaning  INIT_ONCE_ASYNC 0x00000002UL   Operate in asynchronous mode. This enables multiple completion attempts to execute in parallel. This flag must match the flag passed in the corresponding call to the InitOnceBeginInitialize function. This flag may not be combined with INIT_ONCE_INIT_FAILED.   INIT_ONCE_INIT_FAILED 0x00000004UL   The initialization attempt failed. This flag may not be combined with INIT_ONCE_ASYNC. To fail an asynchronous initialization, merely abandon it (that is, do not call the InitOnceComplete function)."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpContext",
        "description": "A pointer to the data to be stored with the one-time initialization structure. This data is returned in the lpContext parameter passed to subsequent calls to the InitOnceBeginInitialize function. If lpContext points to a value, the low-order INIT_ONCE_CTX_RESERVED_BITS of the value must be zero. If lpContext  points to a data structure, the data structure must be DWORD-aligned."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Executes the specified function successfully one time. No other threads that specify the same one-time initialization structure can execute the specified function while it is being executed by the current thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function is used for synchronous one-time initialization. For asynchronous one-time initialization, use the InitOnceBeginInitialize function with the INIT_ONCE_ASYNC flag. Only one thread at a time can execute the callback function specified by InitFn. Other threads that specify the same one-time initialization structure block until the callback finishes. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. For an example that uses  this function, see  Using One-Time Initialization. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "InitOnceExecuteOnce",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PINIT_ONCE",
        "name": "InitOnce",
        "description": "A pointer to the one-time initialization structure."
      },
      {
        "in_out": "_In_",
        "type": "PINIT_ONCE_FN",
        "name": "InitFn",
        "description": "A pointer to an application-defined InitOnceCallback function."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PVOID",
        "name": "Parameter",
        "description": "A parameter to be passed to the callback function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID*",
        "name": "Context",
        "description": "A parameter that receives data stored with the one-time initialization structure upon success. The low-order INIT_ONCE_CTX_RESERVED_BITS bits of the data are always zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes a one-time initialization structure.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "The InitOnceInitialize function is used to initialize a one-time initialization structure dynamically. To initialize the structure statically, assign the constant INIT_ONCE_STATIC_INIT to the structure variable. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. A one-time initialization object cannot be moved or copied. The process must not modify the initialization object, and must instead treat it as logically opaque. Only use the one-time initialization functions to manage one-time initialization objects. The following example calls InitOnceInitialize to initialize the one-time initialization structure named InitOnce. Alternatively, the structure can be declared as a global variable as shown in Using One-Time Initialization. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "InitOnceInitialize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PINIT_ONCE",
        "name": "InitOnce",
        "description": "A pointer to the one-time initialization structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONG values.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAdd",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONG values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAddAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONG values. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAddRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONG values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAddNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONGLONG values.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAdd64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONGLONG values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAddAcquire64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONGLONG values. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAddRelease64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition operation on the specified LONGLONG values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the result of the operation. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAdd64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAddNoFence64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONG values.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedAnd compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedAndAcquire or InterlockedAndRelease instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONG values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAndAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONG values. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAndRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONG values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAndNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified char values.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedAnd8 compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedAnd8Acquire or InterlockedAnd8Release instead. Note ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd8",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified char values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd8_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd8Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified char values. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented as an inline function using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd8_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd8Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified char values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented as an inline function using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd8_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd8NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified SHORT values.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedAnd16 compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedAnd16Acquire or InterlockedAnd16Release instead. Note ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified SHORT values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd16_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified SHORT values. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd16_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd16Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified SHORT values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONGLONG values.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedAnd64Acquire or InterlockedAnd64Release instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONGLONG values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd64Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONGLONG values. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd64Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic AND operation on the specified LONGLONG values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedAnd64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedAnd64NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and complements it. The operation is atomic.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "FORCEINLINE BOOLEAN FORCEINLINE",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndComplement",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG64 value and complements it. The operation is atomic.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "BOOLEAN __cdecl",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndComplement64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG64 volatile*",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and sets it to 0. The operation is atomic, and it is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandreset_acq. ",
    "return_type": "unsigned char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndResetAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile",
        "name": "",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "",
        "type": "_In_",
        "name": "LONG",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and sets it to 0. The operation is atomic, and it is performed using memory release semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandreset_rel. ",
    "return_type": "unsigned char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndResetRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and sets it to 1. The operation is atomic, and it is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandset_acq. ",
    "return_type": "UCHAR",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndSetAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and sets it to 1. The operation is atomic, and it is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandset_rel. ",
    "return_type": "UCHAR",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndSetRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and sets it to 0. The operation is atomic.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandreset. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "UCHAR",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndReset",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LONG volatile*",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG64 value and sets it to 0. The operation is atomic.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandreset64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "BOOLEAN",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndReset64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LONG64 volatile*",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Tests the specified bit of the specified LONG value and sets it to 1. The operation is atomic.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The value of the specified bit. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _interlockedbittestandset. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "UCHAR",
    "category": "Synchronization",
    "name": "InterlockedBitTestAndSet",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LONG volatile*",
        "name": "Base",
        "description": "A pointer to a variable."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Bit",
        "description": "The bit position to be tested."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares the specified 64-bit values and exchanges with the specified 128-bit value based on the outcome of the comparison.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variable pointed to by the Destination parameter must be aligned on a 128-bit boundary. See _aligned_malloc. To determine whether the processor supports this operation, call the IsProcessorFeaturePresent function with PF_COMPARE64_EXCHANGE128. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompare64Exchange128. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedCompare64ExchangeAcquire128 or InterlockedCompare64ExchangeRelease128 instead. ",
    "return_type": "LONG64 __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompare64Exchange128",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG64 volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "ExchangeHigh",
        "description": "The high-order part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "ExchangeLow",
        "description": "The low-order part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares the specified 64-bit values and exchanges with the specified 128-bit value based on the outcome of the comparison. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function performs an atomic comparison of the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variable pointed to by the Destination parameter must be aligned on a 128-bit boundary. See _aligned_malloc. To determine whether the processor supports this operation, call the IsProcessorFeaturePresent function with PF_COMPARE64_EXCHANGE128. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompare64Exchange128_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG64 __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompare64ExchangeAcquire128",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG64 volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "ExchangeHigh",
        "description": "The high-order part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "ExchangeLow",
        "description": "The low-order part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares the specified 64-bit values and exchanges with the specified 128-bit value based on the outcome of the comparison. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variable pointed to by the Destination parameter must be aligned on a 128-bit boundary. See _aligned_malloc. To determine whether the processor supports this operation, call the IsProcessorFeaturePresent function with PF_COMPARE64_EXCHANGE128. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompare64Exchange128_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG64 __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompare64ExchangeRelease128",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG64 volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "ExchangeHigh",
        "description": "The high-order part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "ExchangeLow",
        "description": "The low-order part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG64",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 32-bit values and exchanges with another 32-bit value based on the outcome of the comparison.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The parameters for this function must be aligned on a 32-bit boundary; otherwise, the function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedCompareExchangeAcquire or InterlockedCompareExchangeRelease instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 32-bit values and exchanges with another 32-bit value based on the outcome of the comparison. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "This function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedCompareExchange function. For more information, see WinBase.h. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangeAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 32-bit values and exchanges with another 32-bit value based on the outcome of the comparison. The exchange is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "This function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange_rel. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedCompareExchange function. For more information, see WinBase.h. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangeRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 32-bit values and exchanges with another 32-bit value based on the outcome of the comparison. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The parameters for this function must be aligned on a 32-bit boundary; otherwise, the function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangeNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Comparand",
        "description": ""
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 64-bit values and exchanges with another 64-bit value based on the outcome of the comparison.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedCompareExchangeAcquire64 or InterlockedCompareExchangeRelease64 instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange64",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 64-bit values and exchanges with another 64-bit value based on the outcome of the comparison. The exchange is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the previous value of the Destination parameter. ",
    "remarks": "This function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange64_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedCompareExchange64 function. For more information, see WinBase.h. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangeAcquire64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 64-bit values and exchanges with another 64-bit value based on the outcome of the comparison. The exchange is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "This function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange64_rel. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedCompareExchange64 function. For more information, see WinBase.h. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangeRelease64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Comparand",
        "description": "The value to compare to   Destination."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 64-bit values and exchanges with another 64-bit value based on the outcome of the comparison. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangeNoFence64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 16-bit values and exchanges with another 16-bit value based on the outcome of the comparison.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The parameters for this function must be aligned on a 16-bit boundary; otherwise, the function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange16. This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 16-bit values and exchanges with another 16-bit value based on the outcome of the comparison. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "This function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange16_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedCompareExchange16 function. For more information, see WinBase.h. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 16-bit values and exchanges with another 16-bit value based on the outcome of the comparison. The exchange is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "This function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The variables for  this function must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange16_rel. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedCompareExchange16 function. For more information, see WinBase.h. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange16Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 16-bit values and exchanges with another 16-bit value based on the outcome of the comparison. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. The parameters for this function must be aligned on a 16-bit boundary; otherwise, the function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchange16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 128-bit values and exchanges with another 128-bit value based on the outcome of the comparison.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns 1 if ComparandResult equals the original value of the Destination parameter, or 0 if ComparandResult does not equal the original value of the Destination parameter. ",
    "remarks": "The  function compares the Destination value with the ComparandResult value: The parameters for this function must be aligned on a 16-byte boundary; otherwise, the function will behave unpredictably on x64 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is only available on x64-based systems, and it is implemented using a compiler intrinsic. For more information, see the WinBase.h header file and _InterlockedCompareExchange128. This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "unsigned char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchange128",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the destination value.  This parameter is an array of two 64-bit integers considered as a 128-bit field."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "ExchangeHigh",
        "description": "The high part of the exchange value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "ExchangeLow",
        "description": "The low part of the exchange value."
      },
      {
        "in_out": "_Inout_",
        "type": "LONGLONG*",
        "name": "ComparandResult",
        "description": "The value to compare to. This parameter is an array of two 64-bit integers considered as a 128-bit field."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified pointer values and exchanges with another pointer value based on the outcome of the comparison.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. On a 64-bit system, the parameters are 64 bits and must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchangePointer. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedCompareExchangePointerAcquire or InterlockedCompareExchangePointerRelease instead. Note ",
    "return_type": "PVOID __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangePointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID volatile*",
        "name": "Destination",
        "description": "A pointer to a pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified pointer values and exchanges with another pointer value based on the outcome of the comparison. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. On a 64-bit system, the parameters are 64 bits and must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchangePointer_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedCompareExchangePointer function. For more information, see WinBase.h. ",
    "return_type": "PVOID __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangePointerAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID volatile*",
        "name": "Destination",
        "description": "A pointer to a pointer to the destination value."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified pointer values and exchanges with another pointer value based on the outcome of the comparison. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. On a 64-bit system, the parameters are 64 bits and must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchangePointer_rel. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedCompareExchangePointer function. For more information, see WinBase.h. ",
    "return_type": "PVOID __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangePointerRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID volatile*",
        "name": "Destination",
        "description": "A pointer to a pointer to the destination value."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified pointer values and exchanges with another pointer value based on the outcome of the comparison. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The function compares the Destination value with the Comparand value. If the Destination value is equal to the Comparand value, the Exchange value is stored in the address specified by Destination. Otherwise, no operation is performed. On a 64-bit system, the parameters are 64 bits and must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedCompareExchangePointer_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "void* __cdecl",
    "category": "Synchronization",
    "name": "InterlockedCompareExchangePointerNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "void volatile*",
        "name": "Destination",
        "description": "A pointer to a pointer to the destination value."
      },
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "Exchange",
        "description": "The exchange value."
      },
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "Comparand",
        "description": "The value to compare to Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 32-bit variable as an atomic operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedDecrementAcquire or InterlockedDecrementRelease instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrement",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 32-bit variable as an atomic operation. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement_acq. This function is supported only on Itanium-based systems. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedDecrement function. For more information, see WinBase.h. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrementAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 32-bit variable as an atomic operation. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement_rel. This function is supported only on Itanium-based systems. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedDecrement function. For more information, see WinBase.h. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrementRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 32-bit variable as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrementNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 16-bit variable as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement16. This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrement16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 16-bit variable as an atomic operation. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement16_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedDecrement16 function. For more information, see WinBase.h. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrement16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 16-bit variable as an atomic operation. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement16_rel. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedDecrement16 function. For more information, see WinBase.h. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrement16Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 16-bit variable as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrement16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": ""
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 64-bit variable as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedDecrementAcquire64 or InterlockedDecrementRelease64 instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrement64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 64-bit variable as an atomic operation. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrementAcquire64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 64-bit variable as an atomic operation. The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrementRelease64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Decrements (decreases by one) the value of the specified 64-bit variable as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting decremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedDecrement64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedDecrementNoFence64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be decremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 32-bit variable to the specified value as an atomic operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedExchangeAcquire instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchange",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 32-bit variable to the specified value as an atomic operation. The operation is performed using acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Sets a 64-bit variable to the specified value as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets an 8-bit variable to the specified value as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange8. This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchange8",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 16-bit variable to the specified value as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange16. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedExchangeAcquire64 instead. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchange16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the value to be exchanged. The function sets this variable to ExChange, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "ExChange",
        "description": "The value to be exchanged with the value pointed to by Destination."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 16-bit variable to the specified value as an atomic operation. The operation is performed using acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange16_acq. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchange16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 16-bit variable to the specified value as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchange16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to ExChange, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Destination."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 64-bit variable to the specified value as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedExchangeAcquire64 instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchange64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 64-bit variable to the specified value as an atomic operation. The operation is performed using acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAcquire64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile",
        "name": "Target",
        "description": "A pointer to the value to exchange. The function sets the value of this parameter to the value of the Value parameter, and returns the prior value of this parameter."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be compared to the value of the Target parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets a 64-bit variable to the specified value as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of the Target parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchange64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeNoFence64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Target",
        "description": "A pointer to the value to be exchanged. The function sets this variable to Value, and returns its prior value."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be exchanged with the value pointed to by Target."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Atomically exchanges a pair of addresses.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial address pointed to by the Target parameter. ",
    "remarks": "This function copies the address passed as the second parameter to the first and returns the original address of the first. On a 64-bit system, the parameters are 64 bits and the Target parameter must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and the Target parameter must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangePointer. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedExchangePointerAcquire instead. Note ",
    "return_type": "PVOID __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangePointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID volatile*",
        "name": "Target",
        "description": "A pointer to the address to exchange. The function sets the  address pointed to by the Target parameter (*Target) to the address that is the value of the Value parameter, and returns the prior value of the Target parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Value",
        "description": "The address to be exchanged with the address pointed to by the Target parameter (*Target)."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Atomically exchanges a pair of addresses. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial address pointed to by the Target parameter. ",
    "remarks": "This function copies the address passed as the second parameter to the first and returns the original address of the first. On a 64-bit system, the parameters are 64 bits and must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangePointer_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "PVOID __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangePointerAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID volatile*",
        "name": "Target",
        "description": "A pointer to the address to exchange. The function sets the address pointed to by the Target parameter (*Target) to the address that is the value of the Value parameter, and returns the prior value of the Target parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Value",
        "description": "The address to be exchanged with the address pointed to by the Target parameter (*Target)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Atomically exchanges a pair of addresses. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial address pointed to by the Target parameter. ",
    "remarks": "This function copies the address passed as the second parameter to the first and returns the original address of the first. On a 64-bit system, the parameters are 64 bits and the Target parameter must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and the Target parameter must be aligned on 32-bit boundaries. On a 16-bit system, the parameters are 16 bits and the Target parameter must be aligned on 32-bit boundaries. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangePointer_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "void* __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangePointerNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "void volatile*",
        "name": "Target",
        "description": "A pointer to the address to exchange. The function sets the  address pointed to by the Target parameter (*Target) to the address that is the value of the Value parameter, and returns the prior value of the Target parameter."
      },
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "Value",
        "description": "The address to be exchanged with the address pointed to by the Target parameter (*Target)."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic subtraction of two values.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "unsigned long",
    "category": "Synchronization",
    "name": "InterlockedExchangeSubtract",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "unsigned long volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable is replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "Value",
        "description": "The value to be subtracted from the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 32-bit values.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for  this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedExchangeAddAcquire instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAdd",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 32-bit values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for  this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAddAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 32-bit values.The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for  this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAddRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 32-bit values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for  this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAddNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 64-bit values.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedExchangeAddAcquire64 instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAdd64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 64-bit values. The operation is performed with acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAddAcquire64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 64-bit values.The operation is performed with release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAddRelease64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic addition of two 64-bit values. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the initial value of  the Addend parameter. ",
    "remarks": "The  function performs an atomic addition of Value to the value pointed to by Addend. The result is stored in the address specified by Addend. The function returns the initial value of the variable pointed to by Addend. The variables for this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedExchangeAdd64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedExchangeAddNoFence64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to a variable. The value of this variable will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The value to be added to the variable pointed to by the Addend parameter."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 32-bit variable as an atomic operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedIncrementAcquire or InterlockedIncrementRelease instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrement",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 32-bit variable as an atomic operation. The operation is performed using acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedIncrement function. For more information, see WinBase.h. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrementAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 32-bit variable as an atomic operation. The operation is performed using release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement_rel. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedIncrement function. For more information, see WinBase.h. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrementRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 32-bit variable as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrementNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 16-bit variable as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement16. This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrement16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 16-bit variable as an atomic operation. The operation is performed using acquire memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement16_acq. For processors that do not support acquire memory ordering semantics, this function is defined as a call to the InterlockedIncrement function. For more information, see WinBase.h. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrement16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 16-bit variable as an atomic operation. The operation is performed using release memory ordering semantics.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement16_rel. For processors that do not support release memory ordering semantics, this function is defined as a call to the InterlockedIncrement function. For more information, see WinBase.h. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrement16Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 16-bit variable as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrement16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 64-bit variable as an atomic operation.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedIncrementAcquire64 or InterlockedIncrementRelease64 instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrement64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 64-bit variable as an atomic operation. The operation is performed using acquire memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrementAcquire64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 64-bit variable as an atomic operation. The operation is performed using release memory ordering semantics.",
    "library": "",
    "min_server": "",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems.  See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrementRelease64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Increments (increases by one) the value of the specified 64-bit variable as an atomic operation. The operation is performed atomically, but without using memory barriers.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the resulting incremented value. ",
    "remarks": "The variable pointed to by the Addend parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See _aligned_malloc. The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedIncrement64_rel. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedIncrementNoFence64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Addend",
        "description": "A pointer to the variable to be incremented."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONG values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedOr compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedOrAcquire or InterlockedOrRelease instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONG values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOrAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONG values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOrRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONG values.  The operation is performed atomically, but without using memory barriers.The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr_rel. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOrNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified char values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedOr8 compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedOr8Acquire or InterlockedOr8Release instead. Note ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr8",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified char values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr8_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr8Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified char values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr8_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr8Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified char values. The operation is performed atomically, but without using memory barriers. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr8_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr8NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified SHORT values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedOr16 compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedOr16Acquire or InterlockedOr16Release instead. Note ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified SHORT values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr16_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified SHORT values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr16_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr16Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified SHORT values.  The operation is performed atomically, but without using memory barriers.The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONGLONG values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedOr64Acquire or InterlockedOr64Release instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONGLONG values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr64Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONGLONG values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr64Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic OR operation on the specified LONGLONG values.  The operation is performed atomically, but without using memory barriers. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedOr64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedOr64NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONG values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedXor compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedXorAcquire or InterlockedXorRelease instead. Note ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONG values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXorAcquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONG values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXorRelease",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONG values. The operation is performed atomically, but without using memory barriers. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXorNoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONG volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Mask",
        "description": ""
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified char values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedXor8 compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedXor8Acquire or InterlockedXor8Release instead. Note ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor8",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified char values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor8_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor8Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified char values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor8_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor8Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified char values.  The operation is performed atomically, but without using memory barriers.The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor8_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "char __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor8NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "char volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified SHORT values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the _InterlockedXor16 compiler intrinsic directly. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedXor16Acquire or InterlockedXor16Release instead. Note ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor16",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified SHORT values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor16_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor16Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified SHORT values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor16_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "SHORT __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor16Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "SHORT volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "SHORT",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified SHORT values.  The operation is performed atomically, but without using memory barriers. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor16_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "short __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor16NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "short volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "short",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONGLONG values. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor64. This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order. Itanium-based systems:  For performance-critical applications, use InterlockedXor64Acquire or InterlockedXor64Release instead. Note ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor64",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONGLONG values. The operation is performed with acquire memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor64_acq. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor64Acquire",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONGLONG values. The operation is performed with release memory ordering semantics. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor64_rel. This function is supported only on Itanium-based systems. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor64Release",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Destination",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Value",
        "description": "The second operand."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Performs an atomic XOR operation on the specified LONGLONG values. The operation is performed atomically, but without using memory barriers. The function prevents more than one thread from using the same variable simultaneously.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the original value of the Destination parameter. ",
    "remarks": "The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions. This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and _InterlockedXor64_nf. This function generates no memory barriers (or fences) and does not guarantee that independent memory operations before or after it are completed in order. ",
    "return_type": "LONGLONG __cdecl",
    "category": "Synchronization",
    "name": "InterlockedXor64NoFence",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LONGLONG volatile*",
        "name": "Value",
        "description": "A pointer to the first operand. This value will be replaced with the result of the operation."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "Mask",
        "description": "The second operand."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates or opens a named or unnamed mutex object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the newly created mutex object. If the function fails, the return value is NULL. To get extended error information, call GetLastError. If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object,  GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function. ",
    "remarks": "The handle returned by  CreateMutex has the MUTEX_ALL_ACCESS access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see  Synchronization Object Security and Access Rights. If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory. Any thread of the calling process can specify the mutex-object handle in a call to one of the  wait functions. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the bInitialOwner flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the  ReleaseMutex function to release its ownership. The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call  ReleaseMutex once for each time that the mutex satisfied a wait. Two or more processes can call  CreateMutex to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the bInitialOwner flag to FALSE; otherwise, it can be difficult to be certain which process has initial ownership. Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available: Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed. For an example that uses  CreateMutex, see  Using Mutex Objects. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateMutex",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpMutexAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure. If this parameter is NULL, the handle cannot be inherited by child processes.     The lpSecurityDescriptor member of the structure specifies a security descriptor for the new mutex. If lpMutexAttributes is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInitialOwner",
        "description": "If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.     If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored. If lpName is NULL, the mutex object is created without a name. If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the  GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Creates or opens a named or unnamed mutex object and returns a handle to the object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the newly created mutex object. If the function fails, the return value is NULL. To get extended error information, call GetLastError. If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object,  GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function. ",
    "remarks": "If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory. Any thread of the calling process can specify the mutex-object handle in a call to one of the  wait functions. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the dwFlags parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the  ReleaseMutex function to release its ownership. The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call  ReleaseMutex once for each time that the mutex satisfied a wait. Two or more processes can call  CreateMutex to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the CREATE_MUTEX_INITIAL_OWNER flag; otherwise, it can be difficult to be certain which process has initial ownership. Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available: Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateMutexEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpMutexAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure. If this parameter is NULL, the mutex handle cannot be inherited by child processes.     The lpSecurityDescriptor member of the structure specifies a security descriptor for the new mutex. If lpMutexAttributes is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.            If lpName is NULL, the mutex object is created without a name. If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the  GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be 0 or the following value.  ValueMeaning  CREATE_MUTEX_INITIAL_OWNER 0x00000001   The object creator is the initial owner of the mutex."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access mask for the mutex object. For a list of access rights, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing named mutex object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the mutex object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. If a named mutex does not exist, the function fails and GetLastError returns ERROR_FILE_NOT_FOUND. ",
    "remarks": "The  OpenMutex function enables multiple processes to open handles of the same mutex object. The function succeeds only if some process has already created the mutex by using the  CreateMutex function. The calling process can use the returned handle in any function that requires a handle to a mutex object, such as the  wait functions, subject to the limitations of the access specified in the dwDesiredAccess parameter. The handle can be duplicated by using the DuplicateHandle function. Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed. If your multithreaded application must repeatedly create, open, and close a named mutex object, a race condition can occur. In this situation, it is better to use CreateMutex instead of OpenMutex, because CreateMutex opens a mutex if it exists and creates it if it does not. For an example that uses  OpenMutex, see  Using Named Objects. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "OpenMutex",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the mutex object. Only the SYNCHRONIZE access right is required to use a mutex; to change the mutex's security, specify MUTEX_ALL_ACCESS. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the mutex to be opened. Name comparisons are case sensitive.     This function can open objects in a private namespace. For more information, see Object Namespaces. Terminal Services:  The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Note  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Releases ownership of the specified mutex object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  ReleaseMutex function fails if the calling thread does not own the mutex object. A thread obtains ownership of a mutex either by creating it with the bInitialOwner parameter set to TRUE or by specifying its handle in a call to one of the  wait functions. When the thread no longer needs to own the mutex object, it calls the  ReleaseMutex function so that another thread can acquire ownership. A thread  can specify a  mutex that it already owns in a call to one of the wait functions without blocking its execution. This prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call  ReleaseMutex one time for each time that it obtained ownership (either through CreateMutex or a wait function). For an example that uses  ReleaseMutex, see  Using Mutex Objects. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "ReleaseMutex",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hMutex",
        "description": "A handle to the mutex object. The  CreateMutex or  OpenMutex function returns this handle."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Adds a security identifier (SID) to the specified boundary descriptor.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Namespaceapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The AddSIDToBoundaryDescriptor function must be called once for each SID to be added to the boundary descriptor. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "AddSIDToBoundaryDescriptor",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "BoundaryDescriptor",
        "description": "A handle to the boundary descriptor. The CreateBoundaryDescriptor function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "PSID",
        "name": "RequiredSid",
        "description": "A pointer to a SID structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Adds a new required security identifier (SID) to the specified boundary descriptor.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "A process can create a private namespace only with an integrity level that is  equal to or lower than the  current integrity level of the process. Therefore, a high integrity-level process can create a high, medium or low integrity-level namespace. A medium integrity-level process can create only a medium or low integrity-level namespace. A process would usually specify a namespace at the same integrity level as the process for protection against squatting attacks by lower integrity-level processes. The security descriptor that the creator places on the namespace determines who can open the namespace. So a low or medium integrity-level process could be given permission to open a high integrity level namespace if the security descriptor of the namespace permits it. To compile an application that uses this function, define _WIN32_WINNT as 0x0601 or later. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "AddIntegrityLabelToBoundaryDescriptor",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "BoundaryDescriptor",
        "description": "A handle to the boundary descriptor. The CreateBoundaryDescriptor function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "PSID",
        "name": "IntegrityLabel",
        "description": "A pointer to a SID structure that represents the mandatory integrity level for the namespace. Use one of the following RID values to create the SID:  SECURITY_MANDATORY_UNTRUSTED_RID SECURITY_MANDATORY_LOW_RID SECURITY_MANDATORY_MEDIUM_RID SECURITY_MANDATORY_SYSTEM_RID SECURITY_MANDATORY_PROTECTED_PROCESS_RID  For more information, see Well-Known SIDs."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Closes an open namespace handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Namespace.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "BOOLEAN",
    "category": "Synchronization",
    "name": "ClosePrivateNamespace",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "The namespace handle. This handle is created by CreatePrivateNamespace or OpenPrivateNamespace."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "If this parameter is PRIVATE_NAMESPACE_FLAG_DESTROY (0x00000001), the namespace is destroyed."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Creates a boundary descriptor.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the boundary descriptor. If the function fails, the return value is NULL. To get extended error information, call         GetLastError. ",
    "remarks": "A new boundary descriptor must have at least one security identifier (SID). To add a SID to a boundary descriptor, use the AddSIDToBoundaryDescriptor function. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateBoundaryDescriptor",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "Name",
        "description": "The name of the boundary descriptor."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "This parameter is reserved for future use."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a private namespace.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns a handle to the new namespace. If the function fails, the return value is NULL. To get extended error information, call         GetLastError. ",
    "remarks": "Other applications can access the namespace using the OpenPrivateNamespace function. The application that created the namespace can use the ClosePrivateNamespace function to close the handle to the namespace. The handle is also closed when the creating process terminates. After the namespace handle is closed, subsequent calls to OpenPrivateNamespace fail, but all operations on objects in the namespace succeed. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreatePrivateNamespace",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpPrivateNamespaceAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES structure that specifies the security attributes of the namespace object."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpBoundaryDescriptor",
        "description": "A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The CreateBoundaryDescriptor function creates a boundary descriptor."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAliasPrefix",
        "description": "The prefix for the namespace. To create an object in this namespace, specify the object name as prefix\\objectname. The system supports multiple private namespaces with the same name, as long as they define different boundaries."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes the specified boundary descriptor.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Namespaceapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "DeleteBoundaryDescriptor",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "BoundaryDescriptor",
        "description": "A handle to the boundary descriptor. The CreateBoundaryDescriptor function returns this handle."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Opens a private namespace.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The function returns the handle to the existing namespace. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "OpenPrivateNamespace",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpBoundaryDescriptor",
        "description": "A descriptor that defines how the namespace is to be isolated. The CreateBoundaryDescriptor function creates a boundary descriptor."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAliasPrefix",
        "description": "The prefix for the namespace. To create an object in this namespace, specify the object name as prefix\\objectname."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Creates or opens a named or unnamed semaphore object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and  GetLastError returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "The handle returned by  CreateSemaphore has the SEMAPHORE_ALL_ACCESS access right; it can be used in any function that requires a handle to a semaphore object, provided that the caller has been granted access. If an semaphore is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the semaphore when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see  Synchronization Object Security and Access Rights. The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The lInitialCount parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the lMaximumCount parameter. Any thread of the calling process can specify the semaphore-object handle in a call to one of the  wait functions. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the ReleaseSemaphore function, which increments the count of the semaphore object. Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available: Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed. For an example that uses  CreateSemaphore, see  Using Semaphore Objects. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateSemaphore",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSemaphoreAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES         structure. If this parameter is NULL, the handle cannot be inherited by child         processes. The lpSecurityDescriptor member of the structure specifies a security descriptor         for the new semaphore. If this parameter is NULL, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lInitialCount",
        "description": "The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to lMaximumCount. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the  ReleaseSemaphore function."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lMaximumCount",
        "description": "The maximum count for the semaphore object. This value must be greater than zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the semaphore object. The name is limited to MAX_PATH characters. Name comparison is case sensitive. If lpName matches the name of an existing named semaphore object, this function requests the SEMAPHORE_ALL_ACCESS access right. In this case, the lInitialCount and lMaximumCount parameters are ignored because they have already been set by the creating process. If the lpSemaphoreAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored. If lpName is NULL, the semaphore object is created without a name. If lpName matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the  GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Creates or opens a named or unnamed semaphore object and returns a handle to the object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and  GetLastError returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The lInitialCount parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the lMaximumCount parameter. Any thread of the calling process can specify the semaphore-object handle in a call to one of the  wait functions. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the ReleaseSemaphore function, which increments the count of the semaphore object. Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available: Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateSemaphoreEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSemaphoreAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure. If this parameter is NULL, the semaphore handle cannot be inherited by child processes.     The lpSecurityDescriptor member of the structure specifies a security descriptor for the new semaphore. If this parameter is NULL, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lInitialCount",
        "description": "The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to lMaximumCount. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the  ReleaseSemaphore function."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lMaximumCount",
        "description": "The maximum count for the semaphore object. This value must be greater than zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to MAX_PATH characters. Name comparison is case sensitive. If lpName matches the name of an existing named semaphore object, the lInitialCount and lMaximumCount parameters are ignored because they have already been set by the creating process. If the lpSemaphoreAttributes parameter is not NULL, it determines whether the handle can be inherited. If lpName is NULL, the semaphore object is created without a name. If lpName matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the  GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is reserved and must be 0."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access mask for the semaphore object. For a list of access rights, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing named semaphore object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the semaphore object. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The  OpenSemaphore function enables multiple processes to open handles of the same semaphore object. The function succeeds only if some process has already created the semaphore by using the  CreateSemaphore function. The calling process can use the returned handle in any function that requires a handle to a semaphore object, such as the  wait functions, subject to the limitations of the access specified in the dwDesiredAccess parameter. The handle can be duplicated by using the DuplicateHandle function. Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "OpenSemaphore",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The name of the semaphore to be opened. Name comparisons are case sensitive.     This function can open objects in a private namespace. For more information, see Object Namespaces. Terminal Services:  The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Note  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Increases the count of the specified semaphore object by a specified amount.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The state of a semaphore object is signaled when its count is greater than zero and nonsignaled when its count is equal to zero. The process that calls the  CreateSemaphore function specifies the semaphore's initial count. Each time a waiting thread is released because of the semaphore's signaled state, the count of the semaphore is decreased by one. Typically, an application uses a semaphore to limit the number of threads using a resource. Before a thread uses the resource, it specifies the semaphore handle in a call to one of the  wait functions. When the wait function returns, it decreases the semaphore's count by one. When the thread has finished using the resource, it calls  ReleaseSemaphore to increase the semaphore's count by one. Another use of  ReleaseSemaphore is during an application's initialization. The application can create a semaphore with an initial count of zero. This sets the semaphore's state to nonsignaled and blocks all threads from accessing the protected resource. When the application finishes its initialization, it uses  ReleaseSemaphore to increase the count to its maximum value, to permit normal access to the protected resource. It is not possible to reduce the semaphore object count using  ReleaseSemaphore, because lReleaseCount cannot be a negative number. To temporarily restrict or reduce access, create a loop in which you call the  WaitForSingleObject function with a time-out interval of zero until the semaphore count has been reduced sufficiently. (Note that other threads can reduce the count while this loop is being executed.) To restore access, call  ReleaseSemaphore with the release count equal to the number of times  WaitForSingleObject was called in the loop. For an example that uses  ReleaseSemaphore, see  Using Semaphore Objects. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "ReleaseSemaphore",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hSemaphore",
        "description": "A handle to the semaphore object. The  CreateSemaphore or  OpenSemaphore function returns this handle. This handle must have the SEMAPHORE_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lReleaseCount",
        "description": "The amount by which the semaphore object's current count is to be increased. The value must be greater than zero. If the specified amount would cause the semaphore's count to exceed the maximum count that was specified when the semaphore was created, the count is not changed and the function returns FALSE."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPLONG",
        "name": "lpPreviousCount",
        "description": "A pointer to a variable to receive the previous count for the semaphore. This parameter can be NULL if the previous count is not required."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes the head of a singly linked list.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Interlockedapi.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "All list items must be aligned on a  MEMORY_ALLOCATION_ALIGNMENT boundary. Unaligned items can cause unpredictable results. See _aligned_malloc. To add items to the list, use the  InterlockedPushEntrySList function. To remove items from the list, use the  InterlockedPopEntrySList function. For an example, see  Using Singly Linked Lists. ",
    "return_type": "void",
    "category": "Synchronization",
    "name": "InitializeSListHead",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list. This structure is for system use only."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Removes all items from a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  InterlockedAPI.h on Windows 8 and Windows Server 2012 (include Windows.h)",
    "return_value": "The return value is a pointer to the items removed from the list. If the list is empty, the return value is NULL. ",
    "remarks": "All list items must be aligned on a MEMORY_ALLOCATION_ALIGNMENT boundary; otherwise, this function will behave unpredictably. See _aligned_malloc. For an example, see  Using Singly Linked Lists. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "InterlockedFlushSList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "Pointer to an SLIST_HEADER structure that represents the head of the singly linked list. This structure is for system use only."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Removes an item from the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  InterlockedAPI.h on Windows 8 and Windows Server 2012 (include Windows.h)",
    "return_value": "The return value is a pointer to the item removed from the list. If the list is empty, the return value is NULL. ",
    "remarks": "All list items must be aligned on a MEMORY_ALLOCATION_ALIGNMENT boundary; otherwise, this function will behave unpredictably. See _aligned_malloc. For an example, see  Using Singly Linked Lists. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "InterlockedPopEntrySList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "Pointer to an SLIST_HEADER structure that represents the head of a singly linked list."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Inserts an item at the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  InterlockedAPI.h on Windows 8 and Windows Server 2012 (include Windows.h)",
    "return_value": "The return value is the previous first item in the list. If the list was previously empty, the return value is NULL. ",
    "remarks": "All list items must be aligned on a MEMORY_ALLOCATION_ALIGNMENT boundary; otherwise, this function will behave unpredictably. See _aligned_malloc. For an example, see  Using Singly Linked Lists. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "InterlockedPushEntrySList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "Pointer to an SLIST_HEADER structure that represents the head of a singly linked list."
      },
      {
        "in_out": "_Inout_",
        "type": "PSLIST_ENTRY",
        "name": "ListEntry",
        "description": "Pointer to an  SLIST_ENTRY structure that represents an item in a singly linked list."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Inserts a singly-linked list at the front of another singly linked list. Access to the lists is synchronized on a multiprocessor system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h on Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  InterlockedAPI.h on Windows 8 and Windows Server 2012 (include Windows.h)",
    "return_value": "The return value is the previous first item in the list specified by the ListHead parameter. If the list was previously empty, the return value is NULL. ",
    "remarks": "All list items must be aligned on a MEMORY_ALLOCATION_ALIGNMENT boundary; otherwise, this function will behave unpredictably. See _aligned_malloc. Windows 8 and Windows Server 2012:  This function has been superceded by InterlockedPushListSListEx. When compiling with NTDDI_VERSION set to  NTDDI_WIN8 or greater, calls to InterlockedPushListSList will go to InterlockedPushListSListEx instead. ",
    "return_type": "PSLIST_ENTRY FASTCALL",
    "category": "Synchronization",
    "name": "InterlockedPushListSList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "Pointer to an SLIST_HEADER structure that represents the head of a singly linked list. The list specified by the List and ListEnd parameters is inserted at the front of this list."
      },
      {
        "in_out": "_Inout_",
        "type": "PSLIST_ENTRY",
        "name": "List",
        "description": "Pointer to an  SLIST_ENTRY structure that represents the first item in the  list to be inserted."
      },
      {
        "in_out": "_Inout_",
        "type": "PSLIST_ENTRY",
        "name": "ListEnd",
        "description": "Pointer to an  SLIST_ENTRY structure that represents the last item in the  list to be inserted."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "The number of items in the list to be inserted."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Inserts a singly-linked list at the front of another singly linked list. Access to the lists is synchronized on a multiprocessor system. This version of the method does not use the __fastcall calling convention.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Interlockedapi.h (include Windows.h)",
    "return_value": "The return value is the previous first item in the list specified by the ListHead parameter. If the list was previously empty, the return value is NULL. ",
    "remarks": "All list items must be aligned on a MEMORY_ALLOCATION_ALIGNMENT boundary; otherwise, this function will behave unpredictably. See _aligned_malloc. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "InterlockedPushListSListEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "Pointer to an SLIST_HEADER structure that represents the head of a singly linked list. The list specified by the List and ListEnd parameters is inserted at the front of this list."
      },
      {
        "in_out": "_Inout_",
        "type": "PSLIST_ENTRY",
        "name": "List",
        "description": "Pointer to an  SLIST_ENTRY structure that represents the first item in the  list to be inserted."
      },
      {
        "in_out": "_Inout_",
        "type": "PSLIST_ENTRY",
        "name": "ListEnd",
        "description": "Pointer to an  SLIST_ENTRY structure that represents the last item in the  list to be inserted."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "The number of items in the list to be inserted."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the number of entries in the specified singly linked list.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Interlockedapi.h on Windows 8 and Windows Server 2012",
    "return_value": "The function returns the number of entries in the list, up to a maximum value of 65535. ",
    "remarks": "The system does not limit the number of entries in a singly linked list. However, the return value of QueryDepthSList is truncated to 16 bits, so the maximum value it can return is 65535. If the specified singly linked list contains more than 65535 entries, QueryDepthSList returns the number of entries in the list modulo 65535. For example, if the specified list contains 65536 entries, QueryDepthSList returns zero. The return value of QueryDepthSList should not be relied upon in multithreaded applications because the item count can be changed at any time by another thread. ",
    "return_type": "USHORT",
    "category": "Synchronization",
    "name": "QueryDepthSList",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list. This structure is for system use only.  The list must  be previously initialized with the InitializeSListHead function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the first entry in a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinNT.h (include Windows.h)",
    "return_value": "The return value is a pointer to the first entry in the list. If the list is empty, the return value is NULL. ",
    "remarks": "",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "RtlFirstEntrySList",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list. This structure is for system use only.  The list must  be previously initialized with the InitializeSListHead function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes the head of a singly linked list.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Calls to the InitializeSListHead function are forwarded to the RtlInitializeSListHead function. Applications should call InitializeSListHead instead of calling this function directly. ",
    "return_type": "void",
    "category": "Synchronization",
    "name": "RtlInitializeSListHead",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list. This structure is for system use only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Removes all items from a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The return value is a pointer to the items removed from the list. If the list is empty, the return value is NULL. ",
    "remarks": "Calls to the InterlockedFlushSList function are forwarded to the RtlInterlockedFlushSList function. Applications should call InterlockedFlushSList instead of calling this function directly. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "RtlInterlockedFlushSList",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of the singly linked list. This structure is for system use only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Removes an item from the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The return value is a pointer to the item removed from the list. If the list is empty, the return value is NULL. ",
    "remarks": "Calls to the InterlockedPopEntrySList function are forwarded to the RtlInterlockedPopEntrySList function. Applications should call InterlockedPopEntrySList instead of calling this function directly. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "RtlInterlockedPopEntrySList",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Inserts an item at the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The return value is the previous first item in the list. If the list was previously empty, the return value is NULL. ",
    "remarks": "Calls to the InterlockedPushEntrySList function are forwarded to the RtlInterlockedPushEntrySList function. Applications should call InterlockedPushEntrySList instead of calling this function directly. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Synchronization",
    "name": "RtlInterlockedPushEntrySList",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list."
      },
      {
        "in_out": "_In_",
        "type": "PSLIST_ENTRY",
        "name": "ListEntry",
        "description": "A pointer to an  SLIST_ENTRY structure that represents an item in a singly linked list."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the number of entries in the specified singly linked list.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winnt.h (include Windows.h)",
    "return_value": "The function returns the number of entries in the list. ",
    "remarks": "Calls to the QueryDepthSList function are forwarded to the RtlQueryDepthSList function. Applications should call QueryDepthSList instead of calling this function directly. ",
    "return_type": "WORD",
    "category": "Synchronization",
    "name": "RtlQueryDepthSList",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to an SLIST_HEADER structure that represents the head of a singly linked list. This structure is for system use only.  The list must  be previously initialized with the InitializeSListHead function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes a synchronization barrier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "SynchAPI.h",
    "return_value": "The DeleteSynchronizationBarrier function always returns TRUE. ",
    "remarks": "DeleteSynchronizationBarrier releases a synchronization barrier when it is no longer needed. It is safe to call DeleteSynchronizationBarrier immediately after calling EnterSynchronizationBarrier because that function ensures that all threads in the barrier have finished using it before allowing the barrier to be released. If a synchronization barrier will never be deleted, threads can specify the SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE flag when they enter the barrier. This flag causes the function to skip the extra work required for deletion safety, which can improve performance. All threads using the barrier must specify this flag; if any thread does not, the flag is ignored. Be careful when using SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE, because deleting a barrier while this flag is in effect  may result in an invalid handle access and cause one or more threads to become permanently blocked. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "DeleteSynchronizationBarrier",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPSYNCHRONIZATION_BARRIER",
        "name": "lpBarrier",
        "description": "A pointer to the synchronization barrier to delete."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Causes the calling thread to wait at a synchronization barrier until the maximum number of threads      have entered the barrier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Synchapi.h",
    "return_value": "TRUE for the last thread to signal the barrier. Threads that signal the barrier        before the last thread signals it receive a return value of FALSE. ",
    "remarks": "The default behavior for threads entering a synchronization barrier is to spin until the maximum spin count of      the barrier is reached, and then block. This allows threads to resume quickly if the last thread enters the      barrier in a relatively short time.  However, if the last thread takes relatively longer to arrive, threads      already in the barrier block so they stop consuming processor time while waiting. A thread can override the default behavior of the barrier by specifying      SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY or      SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY. However, keep in mind that using these flags      can affect performance. Spinning indefinitely keeps a processor from servicing other threads, while premature      blocking incurs the overhead of swapping the thread off the processor, awakening the thread when it unblocks, and      swapping it back onto the processor again. In general it is better to allow the barrier to manage threads and use      these flags only if performance testing indicates the application would benefit from them. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "EnterSynchronizationBarrier",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPSYNCHRONIZATION_BARRIER",
        "name": "lpBarrier",
        "description": "A pointer to an initialized synchronization barrier. Use the        InitializeSynchronizationBarrier        function to initialize the barrier. SYNCHRONIZATION_BARRIER is an opaque        structure that should not be modified by the application."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags that control the behavior of threads that enter this barrier. This parameter can be one or more of        the following values.  ValueMeaning  SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY    Specifies that the thread entering the barrier should block immediately until the last thread enters the          barrier. For more information, see Remarks.   SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY    Specifies that the thread entering the barrier should spin until the last thread enters the barrier, even          if the spinning thread exceeds the barrier's maximum spin count. For more information, see Remarks.   SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE    Specifies that the function can skip the work required to ensure that it is safe to delete the barrier,          which can improve performance. All threads that enter this barrier must specify the flag; otherwise, the flag          is ignored. This flag should be used only if the barrier will never be deleted."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Initializes a new synchronization barrier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "SynchAPI.h (include Windows.h)",
    "return_value": "TRUE if the barrier was successfully initialized. If the barrier was not        successfully initialized, this function returns FALSE. Use        GetLastError to get extended error information. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "InitializeSynchronizationBarrier",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPSYNCHRONIZATION_BARRIER",
        "name": "lpBarrier",
        "description": "A pointer to the SYNCHRONIZATION_BARRIER structure to initialize. This is an        opaque structure that should not be modified by applications."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lTotalThreads",
        "description": "The maximum number of threads that can enter this barrier. After the maximum number of threads have entered        the barrier, all threads continue."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lSpinCount",
        "description": "The number of times an individual thread should spin while waiting for other threads to arrive at the        barrier. If this parameter is -1, the thread spins 2000 times. If the thread exceeds        lSpinCount, the thread blocks unless it called        EnterSynchronizationBarrier with        SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Updates a timer-queue timer that was created by the  CreateTimerQueueTimer function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapilegacyset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function cannot be called while the thread is using impersonation. The resulting behavior is undefined. You can call  ChangeTimerQueueTimer in a timer callback. If you call  ChangeTimerQueueTimer on a one-shot timer (its period is zero) that has already expired, the timer is not updated. Do not call  ChangeTimerQueueTimer after calling  DeleteTimerQueueTimer on a handle. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "ChangeTimerQueueTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "TimerQueue",
        "description": "A handle to the timer queue. This handle is returned by the  CreateTimerQueue function.     If this parameter is NULL, the timer is associated with the default timer queue."
      },
      {
        "in_out": "_Inout_",
        "type": "HANDLE",
        "name": "Timer",
        "description": "A handle to the timer-queue timer. This handle is returned by the  CreateTimerQueueTimer function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DueTime",
        "description": "The time after which the timer should expire, in milliseconds."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Period",
        "description": "The period of the timer, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the  DeleteTimerQueueTimer function or reset using  ChangeTimerQueueTimer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Creates a queue for timers. Timer-queue timers are lightweight objects that enable you to specify a callback function to be called at a specified time.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapilegacyset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is a handle to the timer queue. This handle can be used only in functions that require a handle to a timer queue. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "To add a timer to the queue, call the  CreateTimerQueueTimer function. To remove a timer from the queue, call the  DeleteTimerQueueTimer function. When you are finished with the queue of timers, call the  DeleteTimerQueueEx function to delete the timer queue. Any pending timers in the queue are canceled and deleted. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. For an example that uses  CreateTimerQueue, see  Using Timer Queues. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateTimerQueue",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Creates a timer-queue timer. This timer expires at the specified due time, then after every specified period. When the timer expires, the callback function is called.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapilegacyset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If the DueTime and Period parameters are both nonzero, the timer will be signaled first at the due time, then periodically. The callback is called every time the period elapses, whether or not the previous callback has finished executing. Callback functions are queued to the thread pool. These threads are subject to scheduling delays, so the timing can vary depending on what else is happening in the application or the system. The time that the system spends in sleep or hibernation does not count toward the expiration of the timer. The timer is signaled when the cumulative amount of elapsed time the system spends in the waking state matches the timer's due time or period. Windows Server 2003 and Windows XP:  The time that the system spends in sleep or hibernation counts toward the expiration of the timer.  If the timer expires while the system is sleeping, the timer is signaled immediately when the system wakes. To cancel a timer, call the  DeleteTimerQueueTimer function. To cancel all timers in a timer queue, call the  DeleteTimerQueueEx function. By default, the thread pool has a maximum of 500 threads. To raise this limit, use the WT_SET_MAX_THREADPOOL_THREAD macro defined in WinNT.h. Use this macro when specifying the Flags parameter. The macro parameters are the desired flags and the new limit (up to (2<<16)-1 threads). However, note that your application can improve its performance by keeping the number of worker threads low. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. For an example that uses  CreateTimerQueueTimer, see  Using Timer Queues. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "CreateTimerQueueTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "phNewTimer",
        "description": "A pointer to a buffer that receives a handle to the timer-queue timer on return. When this handle has expired and is no longer required, release it by calling DeleteTimerQueueTimer."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "TimerQueue",
        "description": "A handle to the timer queue. This handle is returned by the  CreateTimerQueue function. If this parameter is NULL, the timer is associated with the default timer queue."
      },
      {
        "in_out": "_In_",
        "type": "WAITORTIMERCALLBACK",
        "name": "Callback",
        "description": "A pointer to the application-defined function of type WAITORTIMERCALLBACK to be executed when the timer expires. For more information, see  WaitOrTimerCallback."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Parameter",
        "description": "A single parameter value that will be passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "DueTime",
        "description": "The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Period",
        "description": "The period of the timer, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "This parameter can be one or more of the following values from WinNT.h.  ValueMeaning  WT_EXECUTEDEFAULT 0x00000000   By default, the callback function is queued to a non-I/O worker thread.   WT_EXECUTEINTIMERTHREAD 0x00000020   The callback function is invoked by the timer thread itself. This flag should be used only for short tasks or it could affect other timer operations.     The callback function is queued as an APC. It should not perform alertable wait operations.   WT_EXECUTEINIOTHREAD 0x00000001   This flag is not used. Windows Server 2003 and Windows XP:  The callback function is queued to an I/O worker thread. This flag should be used if the function should be executed in a thread that waits in an alertable state.    I/O worker threads were removed starting with Windows Vista and Windows Server 2008.   WT_EXECUTEINPERSISTENTTHREAD 0x00000080   The callback function is queued to a thread that never terminates. It does not guarantee that the same thread is used each time. This flag should be used only for short tasks or it could affect other timer operations.    This flag must be set if the thread calls functions that use APCs. For more information, see Asynchronous Procedure Calls. Note that currently no worker thread is truly persistent, although no worker thread will terminate if there are any pending I/O requests.   WT_EXECUTELONGFUNCTION 0x00000010   The callback function can perform a long wait. This flag helps the system to decide if it should create a new thread.   WT_EXECUTEONLYONCE 0x00000008   The timer will be set to the signaled state only once. If this flag is set, the Period parameter must be zero.   WT_TRANSFER_IMPERSONATION 0x00000100   Callback functions will use the current access token, whether it is a process or impersonation token. If this flag is not specified, callback functions execute only with the process token. Windows XP:  This flag is not supported until Windows XP with SP2 and Windows Server 2003."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes a timer queue. Any pending timers in the queue are canceled and deleted.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "DeleteTimerQueue does not wait for all callback functions associated with the timer to complete. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. For an example that uses  DeleteTimerQueue, see  Using Timer Queues. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "DeleteTimerQueue",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TimerQueue",
        "description": "A handle to the timer queue. This handle is returned by the  CreateTimerQueue function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Deletes a timer queue. Any pending timers in the queue are canceled and deleted.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapilegacyset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Do not make blocking calls to  DeleteTimerQueueEx from within a timer callback. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "DeleteTimerQueueEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TimerQueue",
        "description": "A handle to the timer queue. This handle is returned by the  CreateTimerQueue function."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "CompletionEvent",
        "description": "A handle to the event object to be signaled when the function is successful and all callback functions have completed. This parameter can be NULL.     If this parameter is INVALID_HANDLE_VALUE, the function waits for all callback functions to complete before returning. If this parameter is NULL, the function marks the timer for deletion and returns immediately. However, most callers should wait for the callback function to complete so they can perform any needed cleanup."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Removes a timer from the timer queue and optionally waits for currently running timer callback functions to complete before deleting the timer.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Threadpoolapilegacyset.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the error code is ERROR_IO_PENDING, it is not necessary to call this function again. For any other error, you should retry the call. ",
    "remarks": "This function cannot be called while the thread is using impersonation. The resulting behavior is undefined. You can set CompletionEvent to INVALID_HANDLE_VALUE when calling this function from within the timer callback of another timer as long as the callback function is not executed in the timer thread. However, a deadlock may occur if two callback functions attempt a blocking  DeleteTimerQueueTimer call on each others' timers. Furthermore, you cannot make a blocking deletion call on a timer associated with the callback. Be careful when making a blocking DeleteTimerQueueTimer call on a persistent thread. If the timer being deleted was created with   WT_EXECUTEINPERSISTENTTHREAD, a deadlock may occur. If there are outstanding callback functions and  CompletionEvent is NULL, the function will fail and set the error code to ERROR_IO_PENDING. This indicates that there are outstanding callback functions. Those callbacks either will execute or are in the middle of executing. The timer is cleaned up when the callback function is finished executing. To cancel all timers in a timer queue, call the  DeleteTimerQueueEx function. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "DeleteTimerQueueTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "TimerQueue",
        "description": "A handle to the timer queue. This handle is returned by the  CreateTimerQueue function.     If the timer was created using the default timer queue, this parameter should be NULL."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Timer",
        "description": "A handle to the timer-queue timer. This handle is returned by the  CreateTimerQueueTimer function."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "CompletionEvent",
        "description": "A handle to the event object to be signaled when the system has canceled the timer and all callback functions  have completed. This parameter can be NULL.     If this parameter is INVALID_HANDLE_VALUE, the function waits for any running timer callback functions to complete before returning. If this parameter is NULL, the function marks the timer for deletion and returns immediately. If the timer has already expired, the timer callback function will run to completion. However, there is no notification sent when the timer callback function has completed. Most callers should not use this option, and should wait for running timer callback functions to complete so they can perform any needed cleanup."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input event objects, which you specify using the dwWakeMask parameter.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)  ",
    "remarks": "The  MsgWaitForMultipleObjects function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses. When bWaitAll is TRUE, the function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects have also been set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled. When bWaitAll is TRUE, the function's wait is completed only when the states of all objects have been set to signaled and an input event has been received. Therefore, setting bWaitAll to TRUE prevents input from being processed until the state of all objects in the pHandles array have been set to signaled. For this reason, if you set bWaitAll to TRUE, you should use a short timeout value in dwMilliseconds. If you have a thread that creates windows waiting for all objects in the pHandles array, including input events specified by dwWakeMask, with no timeout interval, the system will deadlock. This is because threads that create windows must process messages. DDE sends message to all windows in the system. Therefore, if a thread creates windows, do not set the bWaitAll parameter to TRUE in calls to  MsgWaitForMultipleObjects made from that thread. When bWaitAll is FALSE, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled. MsgWaitForMultipleObjects does not return if there is unread input of the specified type in the message queue after the thread has called a function to check the queue. This is because functions such as  PeekMessage,  GetMessage,  GetQueueStatus, and  WaitMessage check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to  MsgWaitForMultipleObjects will not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored. The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects. The  MsgWaitForMultipleObjects function can specify handles of any of the following object types in the pHandles array: The QS_ALLPOSTMESSAGE and QS_POSTMESSAGE flags differ in when they are cleared. QS_POSTMESSAGE is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages. QS_ALLPOSTMESSAGE is cleared when you call GetMessage or PeekMessage without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be useful when you call PeekMessage multiple times to get messages in different ranges. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "MsgWaitForMultipleObjects",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nCount",
        "description": "The number of object handles in the array pointed to by pHandles. The maximum number of object handles is MAXIMUM_WAIT_OBJECTS minus one."
      },
      {
        "in_out": "_In_",
        "type": "const HANDLE*",
        "name": "pHandles",
        "description": "An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.     If one of these handles is closed while the wait is still pending, the function's behavior is undefined. The handles must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bWaitAll",
        "description": "If this parameter is TRUE, the function returns when the states of all objects in the pHandles array have been set to signaled and an input event has been received. If this parameter is FALSE, the function returns when the state of any one of the objects is set to signaled or an input event has been received. In this case, the return value indicates the object whose state caused the function to return."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the specified objects are signaled."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwWakeMask",
        "description": "The input types for which an input event object handle will be added to the array of object handles. This parameter can be any combination of the following values.  ValueMeaning  QS_ALLEVENTS 0x04BF   An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue. This value is a combination of QS_INPUT, QS_POSTMESSAGE, QS_TIMER, QS_PAINT, and QS_HOTKEY.   QS_ALLINPUT 0x04FF   Any message is in the queue. This value is a combination of QS_INPUT, QS_POSTMESSAGE, QS_TIMER, QS_PAINT, QS_HOTKEY, and QS_SENDMESSAGE.   QS_ALLPOSTMESSAGE 0x0100   A posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage without filtering messages.   QS_HOTKEY 0x0080   A WM_HOTKEY message is in the queue.   QS_INPUT 0x407   An input message is in the queue. This value is a combination of QS_MOUSE, QS_KEY, and           QS_RAWINPUT.   QS_KEY 0x0001   A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.   QS_MOUSE 0x0006   A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on). This value is a combination of QS_MOUSEMOVE and QS_MOUSEBUTTON.   QS_MOUSEBUTTON 0x0004   A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).   QS_MOUSEMOVE 0x0002   A WM_MOUSEMOVE message is in the queue.   QS_PAINT 0x0020   A WM_PAINT message is in the queue.   QS_POSTMESSAGE 0x0008   A posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages.   QS_RAWINPUT 0x0400    A raw input message is in the queue. For more information, see  Raw Input.   QS_SENDMESSAGE 0x0040   A message sent by another thread or application is in the queue.   QS_TIMER 0x0010   A WM_TIMER message is in the queue."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects, which you specify using the dwWakeMask parameter.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)  ",
    "remarks": "The  MsgWaitForMultipleObjectsEx function determines whether the conditions specified by dwWakeMask and dwFlags have been met. If the conditions have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses. When dwFlags is zero, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled. MsgWaitForMultipleObjectsEx does not return if there is unread input of the specified type in the message queue after the thread has called a function to check the queue, unless you use the MWMO_INPUTAVAILABLE flag. This is because functions such as  PeekMessage,  GetMessage,  GetQueueStatus, and  WaitMessage check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to  MsgWaitForMultipleObjectsEx will not return until new input of the specified type arrives, unless you use the MWMO_INPUTAVAILABLE flag. If this flag is not used, the existing unread input (received prior to the last time the thread checked the queue) is ignored. The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the system decreases the count of a semaphore object by one. For more information, see the documentation for the individual synchronization objects. The  MsgWaitForMultipleObjectsEx function can specify handles of any of the following object types in the pHandles array: The QS_ALLPOSTMESSAGE and QS_POSTMESSAGE flags differ in when they are cleared. QS_POSTMESSAGE is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages. QS_ALLPOSTMESSAGE is cleared when you call GetMessage or PeekMessage without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be useful when you call PeekMessage multiple times to get messages in different ranges. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "MsgWaitForMultipleObjectsEx",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nCount",
        "description": "The number of object handles in the array pointed to by pHandles. The maximum number of object handles is MAXIMUM_WAIT_OBJECTS minus one."
      },
      {
        "in_out": "_In_",
        "type": "const HANDLE*",
        "name": "pHandles",
        "description": "An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section later in this topic. The array can contain handles to multiple types of objects. It may not contain multiple copies of the same handle.     If one of these handles is closed while the wait is still pending, the function's behavior is undefined. The handles must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwWakeMask",
        "description": "The input types for which an input event object handle will be added to the array of object handles. This parameter can be one or more of the following values.  ValueMeaning  QS_ALLEVENTS 0x04BF   An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue.     This value is a combination of QS_INPUT, QS_POSTMESSAGE, QS_TIMER, QS_PAINT, and QS_HOTKEY.   QS_ALLINPUT 0x04FF   Any message is in the queue. This value is a combination of QS_INPUT, QS_POSTMESSAGE, QS_TIMER, QS_PAINT, QS_HOTKEY, and QS_SENDMESSAGE.   QS_ALLPOSTMESSAGE 0x0100   A posted message is in the queue.     This value is cleared when you call GetMessage or PeekMessage without filtering messages.   QS_HOTKEY 0x0080   A WM_HOTKEY message is in the queue.   QS_INPUT 0x407   An input message is in the queue.     This value is a combination of QS_MOUSE, QS_KEY, and QS_RAWINPUT.   QS_KEY 0x0001   A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.   QS_MOUSE 0x0006   A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).     This value is a combination of QS_MOUSEMOVE and QS_MOUSEBUTTON.   QS_MOUSEBUTTON 0x0004   A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).   QS_MOUSEMOVE 0x0002   A WM_MOUSEMOVE message is in the queue.   QS_PAINT 0x0020   A WM_PAINT message is in the queue.   QS_POSTMESSAGE 0x0008   A posted message is in the queue.     This value is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages.   QS_RAWINPUT 0x0400    A raw input message is in the queue. For more information, see  Raw Input.   QS_SENDMESSAGE 0x0040   A message sent by another thread or application is in the queue.   QS_TIMER 0x0010   A WM_TIMER message is in the queue."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The wait type. This parameter can be one or more of the following values.  ValueMeaning   0   The function returns when any one of the objects is signaled. The return value indicates the object whose state caused the function to return.   MWMO_ALERTABLE 0x0002   The function also returns if an APC has been queued to the thread with  QueueUserAPC while the thread is in the waiting state.   MWMO_INPUTAVAILABLE 0x0004   The function returns if input exists for the queue, even if the input has been seen (but not removed) using a call to another function, such as  PeekMessage.   MWMO_WAITALL 0x0001   The function returns when all objects in the pHandles array are signaled and an input event has been received, all at the same time."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Signals one object and waits on another object as a single operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.  ",
    "remarks": "The SignalObjectAndWait function  provides a more efficient way to signal one object and then wait on another compared to separate function calls such as  SetEvent followed by WaitForSingleObject. The  SignalObjectAndWait function can wait for the following objects: For more information, see  Synchronization Objects. A thread can use the SignalObjectAndWait function to ensure that a  worker thread is in a wait state before signaling an object. For example, a thread and a worker thread may use handles to event objects to synchronize their work. The thread executes code such as the following: The worker thread executes code such as the following: Note that the \"signal\" and \"wait\" are not guaranteed to be performed as an atomic operation. Threads executing on other processors can observe the signaled state of the first object before the thread calling SignalObjectAndWait begins its wait on the second object. Use extreme caution when using  SignalObjectAndWait  and PulseEvent with Windows 7, since using these APIs among multiple threads can cause an application to deadlock. Threads that are signaled by SignalObjectAndWait  call PulseEvent to signal the waiting object of the SignalObjectAndWait call. In some circumstances, the caller of SignalObjectAndWait can't receive signal state of the waiting object in time, causing a deadlock. Use caution when using the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and COM CoInitialize. Therefore, if you have a thread that creates windows, be sure to call SignalObjectAndWait from a different thread. If this is not possible, you can use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, but the functionality is not equivalent. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "SignalObjectAndWait",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hObjectToSignal",
        "description": "A handle to the object to be signaled. This object can be a semaphore, a mutex, or an event.     If the handle is a semaphore, the SEMAPHORE_MODIFY_STATE access right is required. If the handle is an event, the EVENT_MODIFY_STATE access right is required. If the handle is a mutex and the caller does not own the mutex, the function fails with ERROR_NOT_OWNER."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hObjectToWaitOn",
        "description": "A handle to the object to wait on. The SYNCHRONIZE access right is required; for more information, see  Synchronization Object Security and Access Rights. For a list of the object types whose handles you can specify, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled and no completion or asynchronous procedure call (APC) objects are queued. If dwMilliseconds is zero, the function tests the object's state, checks for queued completion routines or APCs, and returns immediately. If dwMilliseconds is INFINITE, the function's time-out interval never elapses."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bAlertable",
        "description": "If this parameter is TRUE, the function returns when the system queues an I/O completion routine or APC function, and the thread calls the function. If FALSE, the function does not return, and the thread does not call the completion routine or APC function.     A completion routine is queued when the  function call that queued the APC has completed. This function returns and the completion routine is called only if bAlertable is TRUE, and the calling thread is the thread that queued the APC."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Cancels a registered wait operation issued by the  RegisterWaitForSingleObject function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If any callback functions associated with the timer have not completed when UnregisterWait is called, UnregisterWait unregisters the wait on the callback functions and fails with the ERROR_IO_PENDING error code. The error code does not indicate that the function has failed, and the function does not need to be called again. If your code requires an error code to set only when the unregister operation has failed, call UnregisterWaitEx instead. To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "UnregisterWait",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "WaitHandle",
        "description": "The wait handle. This handle is returned by the  RegisterWaitForSingleObject function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)  ",
    "remarks": "The  WaitForMultipleObjects function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses. When bWaitAll is TRUE, the function's wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects are also set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled. When bWaitAll is FALSE, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled. The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects. To wait on more than MAXIMUM_WAIT_OBJECTS handles, use one of the following methods: The  WaitForMultipleObjects function can specify handles of any of the following object types in the lpHandles array: Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the CoInitialize function. Therefore, if you have a thread that creates windows, use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, rather than  WaitForMultipleObjects. For an example, see  Waiting for Multiple Objects. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "WaitForMultipleObjects",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nCount",
        "description": "The number of object handles in the array pointed to by lpHandles. The maximum number of object handles is MAXIMUM_WAIT_OBJECTS. This parameter cannot be zero."
      },
      {
        "in_out": "_In_",
        "type": "const HANDLE*",
        "name": "lpHandles",
        "description": "An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles to objects of different types. It may not contain multiple copies of the same handle. If one of these handles is closed while the wait is still pending, the function's behavior is undefined. The handles must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bWaitAll",
        "description": "If this parameter is TRUE, the function returns when the state of all objects in the lpHandles array is signaled. If FALSE, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the specified objects are signaled."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)  ",
    "remarks": "The  WaitForMultipleObjectsEx function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses. When bWaitAll is TRUE, the function's wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects are also set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled. When bWaitAll is FALSE, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled. The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects. To wait on more than MAXIMUM_WAIT_OBJECTS handles, use one of the following methods: The  WaitForMultipleObjectsEx function can specify handles of any of the following object types in the lpHandles array: Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the CoInitialize function. Therefore, if you have a thread that creates windows, use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, rather than  WaitForMultipleObjectsEx. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "WaitForMultipleObjectsEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nCount",
        "description": "The number of object handles to wait for in the array pointed to by lpHandles. The maximum number of object handles is MAXIMUM_WAIT_OBJECTS. This parameter cannot be zero."
      },
      {
        "in_out": "_In_",
        "type": "const HANDLE*",
        "name": "lpHandles",
        "description": "An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.     If one of these handles is closed while the wait is still pending, the function's behavior is undefined. The handles must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bWaitAll",
        "description": "If this parameter is TRUE, the function returns when the state of all objects in the lpHandles array is set to signaled. If FALSE, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bAlertable",
        "description": "If this parameter is TRUE and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return and the completion routine or APC function is not executed. A completion routine is queued when the  ReadFileEx or  WriteFileEx function in which it was specified has completed. The wait function returns and the completion routine is called only if bAlertable is TRUE and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call  QueueUserAPC."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Waits until the specified object is in the signaled state or the time-out interval elapses.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.  ",
    "remarks": "The  WaitForSingleObject function checks the current state of the specified object. If the object's state is nonsignaled, the calling thread enters the wait state until the object is signaled or the time-out interval elapses. The function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. The  WaitForSingleObject function can wait for the following objects: Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the CoInitialize function. Therefore, if you have a thread that creates windows, use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, rather than  WaitForSingleObject. For an example, see  Using Mutex Objects. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "WaitForSingleObject",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHandle",
        "description": "A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.     If this handle is closed while the wait is still pending, the function's behavior is undefined. The handle must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled. Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  The dwMilliseconds value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep. Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  The dwMilliseconds value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Waits until the specified object is in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.  ",
    "remarks": "The  WaitForSingleObjectEx function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses. The function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. The  WaitForSingleObjectEx function can wait for the following objects: Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the CoInitialize function. Therefore, if you have a thread that creates windows, use  MsgWaitForMultipleObjects or  MsgWaitForMultipleObjectsEx, rather than  WaitForSingleObjectEx. For an example, see  Named Pipe Server Using Completion Routines. ",
    "return_type": "DWORD",
    "category": "Synchronization",
    "name": "WaitForSingleObjectEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHandle",
        "description": "A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.     If this handle is closed while the wait is still pending, the function's behavior is undefined. The handle must have the SYNCHRONIZE access right. For more information, see  Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled or an I/O completion routine or APC is queued."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bAlertable",
        "description": "If this parameter is TRUE and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed. A completion routine is queued when the  ReadFileEx or  WriteFileEx function in which it was specified has completed. The wait function returns and the completion routine is called only if bAlertable is TRUE, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call  QueueUserAPC."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Waits for the value at the specified address to change.",
    "library": "Synchronization.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "SynchAPI.h (include Windows.h)",
    "return_value": "TRUE if the wait succeeded. If the operation fails, the function returns FALSE. If the wait fails, call GetLastError to obtain extended error information. In particular, if the operation times out, GetLastError  returns ERROR_TIMEOUT. ",
    "remarks": "Windows Store apps developers may need to obtain synchronization.lib by installing the Windows Software Development Kit (SDK) for Windows 8. The WaitOnAddress function can be used by a thread to wait for a particular value to change from some undesired value to any other value. WaitOnAddress is more efficient than using the Sleep function inside a while loop because WaitOnAddress does not interfere with the thread scheduler. WaitOnAddress is also simpler to use than an event object because it is not necessary to create and initialize an event and then make sure it is synchronized correctly with the value. WaitOnAddress is not affected by low-memory conditions, other than potentially waking the thread early as noted below. Any thread that changes the value at the address on which threads are waiting should call WakeByAddressSingle to wake a single waiting thread or  WakeByAddressAll to wake all waiting threads. If WakeByAddressSingle is called, other waiting threads continue to wait. The following example shows how to use WaitOnAddress. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "WaitOnAddress",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "VOID volatile*",
        "name": "Address",
        "description": "The address on which to wait. If the value at Address differs from the value at CompareAddress, the function returns immediately. If the values are the same, the function does not return until another thread signals that the value at Address has changed by calling WakeByAddressSingle or WakeByAddressAll or the timeout elapses, whichever comes first."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CompareAddress",
        "description": "A pointer to the location of the previously observed value at Address. The function returns when the value at Address differs from the value at CompareAddress."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "AddressSize",
        "description": "The size of the value, in bytes. This parameter can be 1, 2, 4, or 8."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The number of milliseconds to wait before the operation times out. If this parameter is INFINITE, the thread waits indefinitely."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "An application-defined function that serves as the starting address for a timer callback or a registered wait callback. Specify this address when calling the  CreateTimerQueueTimer,  RegisterWaitForSingleObject function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Winnt.h on Windows 8 and Windows Server 2012",
    "return_value": "This function does not return a value. ",
    "remarks": "This callback function must not call the  TerminateThread function. For an example that uses this callback function, see  Using Timer Queues. ",
    "return_type": "VOID CALLBACK",
    "category": "Synchronization",
    "name": "WaitOrTimerCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpParameter",
        "description": "The thread data passed to the function using a parameter of the  CreateTimerQueueTimer or  RegisterWaitForSingleObject function."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "TimerOrWaitFired",
        "description": "If this parameter is TRUE, the wait timed out. If this parameter is FALSE, the wait event has been signaled. (This parameter is always TRUE for timer callbacks.)"
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Wakes all threads that are waiting for the value of an address to change.",
    "library": "Synchronization.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "SynchAPI.h (include Windows.h);  SynchAPI.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Windows Store apps developers may need to obtain synchronization.lib by installing the Windows Software Development Kit (SDK) for Windows 8. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "WakeByAddressAll",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Address",
        "description": "The address to signal. If any threads have previously called        WaitOnAddress for this address, the system wakes all        of the waiting threads."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Wakes one thread that is waiting for the value of an address to change.",
    "library": "Synchronization.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "SynchAPI.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Windows Store apps developers may need to obtain synchronization.lib by installing the Windows Software Development Kit (SDK) for Windows 8. ",
    "return_type": "VOID",
    "category": "Synchronization",
    "name": "WakeByAddressSingle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Address",
        "description": "The address to signal. If another thread has previously called        WaitOnAddress for this address, the system wakes the        waiting thread. If multiple threads are waiting for this address, the system wakes the first thread to        wait."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the specified waitable timer to the inactive state.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  CancelWaitableTimer function does not change the signaled state of the timer. It stops the timer before it can be set to the signaled state and cancels outstanding APCs. Therefore, threads performing a wait operation on the timer remain waiting until they time out or the timer is reactivated and its state is set to signaled. If the timer is already in the signaled state, it remains in that state. To reactivate the timer, call the  SetWaitableTimer function. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "CancelWaitableTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTimer",
        "description": "A handle to the timer object. The  CreateWaitableTimer or  OpenWaitableTimer function returns this handle. The handle must have the TIMER_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates or opens a waitable timer object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and  GetLastError returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "The handle returned by  CreateWaitableTimer is created with the TIMER_ALL_ACCESS access right; it can be used in any function that requires a handle to a timer object, provided that the caller has been granted access. If a timer is created from a service or thread that is impersonating a different user, you can either apply a security descriptor to the timer when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see  Synchronization Object Security and Access Rights. Any thread of the calling process can specify the timer object handle in a call to one of the  wait functions. Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization. Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. To associate a timer with a window, use the SetTimer function. For an example that uses  CreateWaitableTimer, see  Using Waitable Timer Objects. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateWaitableTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpTimerAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.  If lpTimerAttributes is NULL, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bManualReset",
        "description": "If this parameter is TRUE, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpTimerName",
        "description": "The name of the timer object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.     If lpTimerName is NULL, the timer object is created without a name. If lpTimerName matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and  GetLastError returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Creates or opens a waitable timer object and returns a handle to the object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and  GetLastError returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "Any thread of the calling process can specify the timer object handle in a call to one of the  wait functions. Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization. Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed. To associate a timer with a window, use the SetTimer function. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "CreateWaitableTimerEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpTimerAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure. If this parameter is NULL, the timer handle cannot be inherited by child processes.  If lpTimerAttributes is NULL, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpTimerName",
        "description": "The name of the timer object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.     If lpTimerName is NULL, the timer object is created without a name. If lpTimerName matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and  GetLastError returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be 0 or the following value.  ValueMeaning  CREATE_WAITABLE_TIMER_MANUAL_RESET 0x00000001   The timer must be manually reset. Otherwise, the system automatically resets the timer after releasing a single waiting thread."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access mask for the timer object. For a list of access rights, see  Synchronization Object Security and Access Rights."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Opens an existing named waitable timer object.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the timer object. If the function fails, the return value is NULL. To get extended error information, call         GetLastError. ",
    "remarks": "The  OpenWaitableTimer function enables multiple processes to open handles to the same timer object. The function succeeds only if some process has already created the timer using the  CreateWaitableTimer function. The calling process can use the returned handle in any function that requires the handle to a timer object, such as the  wait functions, subject to the limitations of the access specified in the dwDesiredAccess parameter. The returned handle can be duplicated by using the DuplicateHandle function. Use the CloseHandle function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "HANDLE",
    "category": "Synchronization",
    "name": "OpenWaitableTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the timer object. The function fails if the security descriptor of the specified object does        not permit the requested access for the calling process. For a list of access rights, see        Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bInheritHandle",
        "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpTimerName",
        "description": "The name of the timer object. The name is limited to MAX_PATH characters. Name comparison is case sensitive. This function can open objects in a private namespace. For more information, see Object Namespaces. Terminal Services:  The name can have a \"Global\\\" or \"Local\\\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see  Kernel Object Namespaces. Note  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Activates the specified waitable timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Timers are initially inactive. To activate a timer, call  SetWaitableTimer. If the timer is already active when you call  SetWaitableTimer, the timer is stopped, then it is reactivated. Stopping the timer in this manner does not set the timer state to signaled, so threads blocked in a wait operation on the timer remain blocked. However, it does cancel any pending completion routines. When the specified due time arrives, the timer becomes inactive and the optional APC is queued to the thread that set the timer. The state of the timer is set to signaled, the timer is reactivated using the specified period, and the thread that set the timer calls the completion routine when it enters an alertable wait state. If the timer is set before the thread enters an alertable wait state, the APC is canceled. For more information, see  QueueUserAPC. Note that APCs do not work as well as other signaling mechanisms  for thread pool threads because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered. Instead of using the pfnCompletionRoutine parameter or another APC-based signaling mechanism, use a waitable object such as a timer created with CreateThreadpoolTimer. For I/O, use  an I/O completion object created with CreateThreadpoolIo or an hEvent-based OVERLAPPED structure where the event can be passed to the SetThreadpoolWait function. If the thread that set the timer terminates and there is an associated completion routine, the timer is canceled. However, the state of the timer remains unchanged. If there is no completion routine, then terminating the thread has no effect on the timer. When a manual-reset timer is set to the signaled state, it remains in this state until  SetWaitableTimer is called to reset the timer. As a result, a periodic manual-reset timer is set to the signaled state when the initial due time arrives and remains signaled until it is reset. When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object. If the system time is adjusted, the due time of any outstanding absolute timers is adjusted. To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see  Using the Windows Headers. To use a timer to schedule an event for a window, use the SetTimer function. For an example that uses  SetWaitableTimer, see  Using Waitable Timer Objects. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "SetWaitableTimer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTimer",
        "description": "A handle to the timer object. The  CreateWaitableTimer or  OpenWaitableTimer function returns this handle.     The handle must have the TIMER_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "const LARGE_INTEGER*",
        "name": "pDueTime",
        "description": "The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the  FILETIME structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see  System Time."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lPeriod",
        "description": "The period of the timer, in milliseconds. If lPeriod is zero, the timer is signaled once. If lPeriod is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the  CancelWaitableTimer function or reset using  SetWaitableTimer. If lPeriod is less than zero, the function fails."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTIMERAPCROUTINE",
        "name": "pfnCompletionRoutine",
        "description": "A pointer to an optional completion routine. The completion routine is application-defined function of type PTIMERAPCROUTINE to be executed when the timer is signaled. For more information on the timer callback function, see  TimerAPCProc. For more information about APCs and thread pool threads, see Remarks."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpArgToCompletionRoutine",
        "description": "A pointer to a structure that is passed to the completion routine."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fResume",
        "description": "If this parameter is TRUE, restores a system in suspended power conservation mode when the timer state is set to signaled. Otherwise, the system is not restored. If the system does not support a restore, the call succeeds, but GetLastError returns ERROR_NOT_SUPPORTED."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Activates the specified waitable timer and provides context information for the timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h on Windows 7 and Windows Server 2008 R2 (include Windows.h);  Synchapi.h on Windows 8 and Windows Server 2012",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The SetWaitableTimerEx function is similar to the SetWaitableTimer function, except SetWaitableTimerEx can be used to specify a context string and a tolerable delay for expiration of the timer. To compile an application that uses this function, define _WIN32_WINNT as 0x0601 or later. For more information, see Using the Windows Headers. Timers are initially inactive. To activate a timer, call  SetWaitableTimerEx. If the timer is already active when you call  SetWaitableTimerEx, the timer is stopped, then it is reactivated. Stopping the timer in this manner does not set the timer state to signaled, so threads blocked in a wait operation on the timer remain blocked. However, it does cancel any pending completion routines. When the specified due time arrives, the timer becomes inactive and the optional APC is queued to the thread that set the timer. The state of the timer is set to signaled, the timer is reactivated using the specified period, and the thread that set the timer calls the completion routine when it enters an alertable wait state. If the timer is set before the thread enters an alertable wait state, the APC is canceled. For more information, see  QueueUserAPC. Note that APCs do not work as well as other signaling mechanisms  for thread pool threads because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered. Instead of using the pfnCompletionRoutine parameter or another APC-based signaling mechanism, use a waitable object such as a timer created with CreateThreadpoolTimer. For I/O, use  an I/O completion object created with CreateThreadpoolIo or an hEvent-based OVERLAPPED structure where the event can be passed to the SetThreadpoolWait function. If the thread that set the timer terminates and there is an associated completion routine, the timer is canceled. However, the state of the timer remains unchanged. If there is no completion routine, then terminating the thread has no effect on the timer. When a manual-reset timer is set to the signaled state, it remains in this state until  SetWaitableTimerEx is called to reset the timer. As a result, a periodic manual-reset timer is set to the signaled state when the initial due time arrives and remains signaled until it is reset. When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object. If the system time is adjusted, the due time of any outstanding absolute timers is adjusted. If the thread that called SetWaitableTimerEx exits, the timer is canceled. This stops the timer before it can be set to the signaled state and cancels outstanding APCs; it does not change the signaled state of the timer. To use a timer to schedule an event for a window, use the SetTimer function. ",
    "return_type": "BOOL",
    "category": "Synchronization",
    "name": "SetWaitableTimerEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTimer",
        "description": "A handle to the timer object. The CreateWaitableTimer or OpenWaitableTimer function returns this handle. The handle must have the TIMER_MODIFY_STATE access right. For more information, see  Synchronization Object Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "const LARGE_INTEGER*",
        "name": "lpDueTime",
        "description": "The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the  FILETIME structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see  System Time."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lPeriod",
        "description": "The period of the timer, in milliseconds. If lPeriod is zero, the timer is signaled once. If lPeriod is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the  CancelWaitableTimer function or reset using  SetWaitableTimerEx. If lPeriod is less than zero, the function fails."
      },
      {
        "in_out": "_In_",
        "type": "PTIMERAPCROUTINE",
        "name": "pfnCompletionRoutine",
        "description": "A pointer to an optional completion routine. The completion routine is application-defined function of type PTIMERAPCROUTINE to be executed when the timer is signaled. For more information on the timer callback function, see  TimerAPCProc.  For more information about APCs and thread pool threads, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpArgToCompletionRoutine",
        "description": "A pointer to a structure that is passed to the completion routine."
      },
      {
        "in_out": "_In_",
        "type": "PREASON_CONTEXT",
        "name": "WakeContext",
        "description": "Pointer to a REASON_CONTEXT structure that contains context information for the timer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TolerableDelay",
        "description": "The tolerable delay for expiration time, in milliseconds."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "An application-defined timer completion routine. Specify this address when calling the  SetWaitableTimer function. The PTIMERAPCROUTINE type defines a pointer to this callback function.  TimerAPCProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The completion routine is executed by the thread that activates the timer using  SetWaitableTimer. However, the thread must be in an alertable state. For more information, see  Asynchronous Procedure Calls. For an example, see  Using a Waitable Timer with an Asynchronous Procedure Call. ",
    "return_type": "VOID CALLBACK",
    "category": "Synchronization",
    "name": "TimerAPCProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpArgToCompletionRoutine",
        "description": "The value passed to the function using the lpArgToCompletionRoutine parameter of the  SetWaitableTimer function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimerLowValue",
        "description": "The low-order portion of the UTC-based time at which the timer was signaled. This value corresponds to the dwLowDateTime member of the  FILETIME structure. For more information about UTC-based time, see  System Time."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimerHighValue",
        "description": "The high-order portion of the UTC-based time at which the timer was signaled. This value corresponds to the dwHighDateTime member of the FILETIME structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]