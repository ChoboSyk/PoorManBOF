[
  {
    "n_arguments": 4,
    "description": "The ControlTrace function flushes, queries, updates, or     stops the specified event tracing session.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. This function supersedes the FlushTrace,      QueryTrace,      StopTrace, and      UpdateTrace functions. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "ControlTrace",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to an event tracing session, or NULL. You must specify        SessionHandle if SessionName is        NULL. However, ETW ignores the handle if SessionName is not        NULL. The handle is returned by the        StartTrace function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SessionName",
        "description": "Name of an event tracing session, or NULL. You must specify        SessionName if SessionHandle is        NULL.  To specify the NT Kernel Logger session, set SessionName to        KERNEL_LOGGER_NAME."
      },
      {
        "in_out": "_Inout_",
        "type": "PEVENT_TRACE_PROPERTIES",
        "name": "Properties",
        "description": "Pointer to an initialized         EVENT_TRACE_PROPERTIES structure. This structure         should be zeroed out before it is used. If ControlCode specifies EVENT_TRACE_CONTROL_STOP,         EVENT_TRACE_CONTROL_QUERY or EVENT_TRACE_CONTROL_FLUSH,         you only need to set the Wnode.BufferSize, Wnode.Guid,         LoggerNameOffset, and LogFileNameOffset members of the         EVENT_TRACE_PROPERTIES structure. If the         session is a private session, you also need to set LogFileMode. You can use the         maximum session name (1024 characters) and maximum log file name (1024 characters) lengths to calculate the         buffer size and offsets if not known.  If ControlCode specifies         EVENT_TRACE_CONTROL_UPDATE, on input, the members must specify the new values for the         properties to update. On output, Properties contains the properties and statistics         for the event tracing session. You can update the following properties.  MemberUse EnableFlagsSet this member to 0 to disable all kernel providers. Otherwise, you must specify the kernel providers that you want to enable or keep enabled. Applies only to NT Kernel Logger sessions. FlushTimerSet this member if you want to change the time to wait before flushing buffers. If this member is 0, the member is not updated. LogFileNameOffsetSet this member if you want to switch to another log file. If this member is 0, the file name is not updated. If the offset is not zero and you do not change the log file name, the function returns an error. LogFileModeSet this member if you want to turn EVENT_TRACE_REAL_TIME_MODE on and off. To turn real time consuming off, set this member to 0. To turn real time consuming on, set this member to EVENT_TRACE_REAL_TIME_MODE and it will be OR'd with the current modes. MaximumBuffersSet this member if you want to change the maximum number of buffers that ETW uses. If this member is 0, the member is not updated.    For private logger sessions, you can update only the LogFileNameOffset and         FlushTimer members. If you are using a newly initialized         EVENT_TRACE_PROPERTIES structure, the only         members you need to specify, other than the members you are updating, are         Wnode.BufferSize, Wnode.Guid, and         Wnode.Flags. If you use the property structure you passed to         StartTrace, make sure the         LogFileNameOffset member is 0 unless you are changing the log file name. If you call the ControlTrace function to query the         current session properties and then update those properties to update the session, make sure you set         LogFileNameOffset to 0 (unless you are changing the log file name) and set         EVENT_TRACE_PROPERTIES.Wnode.Flags to         WNODE_FLAG_TRACED_GUID. Starting with Windows 10, version 1703:  For better performance in cross process scenarios, you can now pass filtering in to ControlTrace for  system wide private loggers. You will need to pass in the new EVENT_TRACE_PROPERTIES_V2 structure to include filtering information. See Configuring and Starting a Private Logger Session for more details."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ControlCode",
        "description": "Requested control function. You can specify one of the following values.     ValueMeaning  EVENT_TRACE_CONTROL_FLUSH   Flushes the session's active buffers. Typically, you do not need to flush buffers yourself. However, you may want to flush buffers if the event rate is low and you are delivering events in real time. Windows 2000:  This value is not supported.   EVENT_TRACE_CONTROL_QUERY   Retrieves session properties and statistics.   EVENT_TRACE_CONTROL_STOP   Stops the session. The session handle is no longer valid.   EVENT_TRACE_CONTROL_UPDATE   Updates the session properties.     Note that it is not safe to flush buffers or stop a trace session from DllMain."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Enables or disables the specified classic event trace provider.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. Up to eight trace sessions can enable and receive events from the same manifest-based provider; however, only one trace session can enable a classic provider. If more than one session tried to enable a classic provider, the first session would stop receiving events when the second session enabled the same provider. For example, if Session A enabled Provider 1 and then Session B enabled Provider 1, only Session B would receive events from Provider 1. The provider remains enabled for the session until the session disables the provider. If the application that started the session ends without disabling the provider, the provider remains enabled. The  EnableTrace function calls the  ControlCallback function implemented by the event trace provider, if defined. The provider defines its interpretation of being enabled or disabled. Typically, if a provider has been enabled, it generates events, but while it is disabled, it does not. The  ControlCallback function can call the  GetTraceEnableFlags,  GetTraceEnableLevel, and  GetTraceLoggerHandle functions to obtain the values specified for the EnableFlag, EnableLevel, and SessionHandle parameters, respectively. You can call this function one time to enable a provider before the provider registers itself. After the provider registers itself, ETW calls the provider's ControlCallback function. If you try to enable the provider for multiple sessions before the provider registers itself, ETW will only enable the provider for the last session. For example, if you enable the provider to Session A and then enable the provider to Session B, when the provider registers itself, the provider is only enabled for Session B. You do not call EnableTrace to enable kernel providers. To enable kernel providers, set the EnableFlags member of EVENT_TRACE_PROPERTIES which you then pass to StartTrace. The StartTrace function enables the selected kernel providers. To determine the level and keywords used to enable a manifest-based provider, use one of the following commands: For classic providers, it is up to the provider to document and make available to potential controllers the severity levels or enable flags that it supports. If the provider wants to be enabled by any controller, the provider should accept 0 for the severity level and enable flags and interpret 0 as a request to perform default logging (whatever that may be). If you use EnableTrace to enable a manifest-based provider, the following translation occurs: On Windows 8.1,Windows Server 2012 R2, and later, payload filters can be used by the EnableTraceEx2 function to filter on specific conditions in a logger session. For an example that uses  EnableTrace, see  Example that Creates a Session and Enables a manifest-based provider. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EnableTrace",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Enable",
        "description": "If TRUE, the provider is enabled; otherwise, the provider is disabled."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EnableFlag",
        "description": "Provider-defined value that specifies the class of events for which the provider generates events. A provider that generates only one class of events will typically ignore this flag. If the provider is more complex, the provider could use the TraceGuidReg parameter of RegisterTraceGuids to register more than one class of events. For example, if the provider has a database component, a UI component, and a general processing component, the provider could register separate event classes for these components. This would then allow the controller the ability to turn on tracing in only the database component.  The provider calls GetTraceEnableFlags from its ControlCallback function to obtain the enable flags."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EnableLevel",
        "description": "Provider-defined value that specifies the level of information the event generates. For example, you can use this value to indicate the severity level of the events (informational, warning, error) you want the provider to generate.     Specify a value from zero to 255. ETW defines the following severity levels that you can use. Higher numbers imply that you get lower levels as well. For example, if you specify TRACE_LEVEL_WARNING, you also receive all warning, error, and fatal events.  ValueMeaning  TRACE_LEVEL_CRITICAL 1   Abnormal exit or termination events   TRACE_LEVEL_ERROR 2   Severe error events   TRACE_LEVEL_WARNING 3   Warning events such as allocation failures   TRACE_LEVEL_INFORMATION 4   Non-error events such as entry or exit events   TRACE_LEVEL_VERBOSE 5   Detailed trace events"
      },
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "ControlGuid",
        "description": "GUID of the event trace provider that you want to enable or disable."
      },
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle of the event tracing session to which you want to enable, disable, or change the logging level of the provider. The  StartTrace function returns this handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 9,
    "description": "Enables or disables the specified event trace provider.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. The provider defines its interpretation of being enabled or disabled. Typically, if a provider has been enabled, it generates events, but while it is disabled, it does not. To include all events that a provider provides, set MatchAnyKeyword to zero (for a manifest-based provider and 0xFFFFFFFF for a classic provider). To include specific events, set the MatchAnyKeyword mask to those specific events. For example, if the provider defines an event for its initialization and cleanup routines (set keyword bit 0), an event for its file operations (set keyword bit 1), and an event for its calculation operations (set keyword bit 2), you can set MatchAnyKeyword to 5 to receive initialization and cleanup events and calculation events. If the provider defines more complex event keywords, for example, the provider defines an event that sets bit 0 for read and bit 1 for local access and a second event that sets bit 0 for read and bit 2 for remote access, you could set MatchAnyKeyword to 1 to receive all read events, or you could set MatchAnykeyword to 1 and MatchAllKeywords to 3 to receive local reads only. If an event's keyword is zero, the provider will write the event to the session, regardless of the MatchAnyKeyword and MatchAllKeyword masks. When you call EnableTraceEx the provider may or may  not be registered. If the provider is registered, ETW calls the provider's callback function, if it implements one, and the session begins receiving events. If the provider is not registered, ETW will call the provider's callback function when it registers itself, if it implements one, and the session will begin receiving events. If the provider is not registered, the provider's callback function will not receive the source ID or filter data. You can call EnableTraceEx one time to enable a provider before the provider registers itself. If the provider is registered and already enabled to your session, you can also use this function to update the Level, MatchAnyKeyword, MatchAllKeyword, EnableProperty and  EnableFilterDesc parameters that determine which events the provider writes. You do not call EnableTraceEx to enable kernel providers. To enable kernel providers, set the EnableFlags member of EVENT_TRACE_PROPERTIES which you then pass to StartTrace. The StartTrace function enables the selected kernel providers. Up to eight trace sessions can enable and receive events from the same manifest-based provider; however, only one trace session can enable a classic provider. If more than one session tried to enable a classic provider, the first session would stop receiving events when the second session enabled the same provider. For example, if Session A enabled Provider 1 and then Session B enabled Provider 1, only Session B would receive events from Provider 1. The provider remains enabled for the session until the session disables the provider. If the application that started the session ends without disabling the provider, the provider remains enabled. To determine the level and keywords used to enable a manifest-based provider, use one of the following commands: For classic providers, it is up to the provider to document and make available to potential controllers the severity levels or enable flags that it supports. If the provider wants to be enabled by any controller, the provider should accept 0 for the severity level and enable flags and interpret 0 as a request to perform default logging (whatever that may be). If you use EnableTraceEx to enable a classic provider, the following translation occurs: A provider can define filters that a session uses to filter events based on event data. With the level and keywords that you provide, ETW determines whether the event is written to the session but with filters, the provider uses the filter data to determine whether it writes the event to the session. For example, if the provider generates process events, it could define a data filter that filters process events based on the process identifier. If the identifier of the process did not match the identifier that you passed as filter data, the provider would prevent event from being written to your session. On Windows 8.1,Windows Server 2012 R2, and later, payload filters can be used by the EnableTraceEx2 function to filter on specific conditions in a logger session. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EnableTraceEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "ProviderId",
        "description": "GUID of the event trace provider that you want to enable or disable."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "SourceId",
        "description": "GUID that uniquely identifies the session that is enabling or disabling the provider. Can be NULL. If the provider does not implement EnableCallback, the GUID is not used."
      },
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "TraceHandle",
        "description": "Handle of the event tracing session to which you want to enable or disable the provider. The  StartTrace function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "IsEnabled",
        "description": "Set to 1 to receive events  when the provider is registered; otherwise, set to 0 to no longer receive events from the provider."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Level",
        "description": "Provider-defined value that specifies the level of detail included in the event.     Specify one of the following levels that are defined in Winmeta.h. Higher numbers imply that you get lower levels as well. For example, if you specify TRACE_LEVEL_WARNING, you also receive all warning, error, and critical events. \t\t\t\t\t  ValueMeaning  TRACE_LEVEL_CRITICAL 1   Abnormal exit or termination events   TRACE_LEVEL_ERROR 2   Severe error events   TRACE_LEVEL_WARNING 3   Warning events such as allocation failures   TRACE_LEVEL_INFORMATION 4   Non-error events such as entry or exit events   TRACE_LEVEL_VERBOSE 5   Detailed trace events"
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "MatchAnyKeyword",
        "description": "Bitmask of keywords that determine the category of events that you want the provider to write. The provider writes the event if any of the event's keyword bits match any of the bits set in this mask. See Remarks."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "MatchAllKeyword",
        "description": "This bitmask is optional. This mask further restricts the category of  events that you want the provider to write. If the event's keyword meets the MatchAnyKeyword condition, the provider will write the event only if all of the bits in this mask exist in the event's keyword. This mask is not used if MatchAnyKeyword is zero. See Remarks."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EnableProperty",
        "description": "Optional information that ETW can include when writing the event. The data is written to the extended data item section of the event. To include the optional information, specify one or more of the following flags; otherwise, set to zero.  ValueMeaning  EVENT_ENABLE_PROPERTY_SID   Include the security identifier (SID) of the user in the extended data.   EVENT_ENABLE_PROPERTY_TS_ID   Include the terminal session identifier in the extended data."
      },
      {
        "in_out": "_In_opt_",
        "type": "PEVENT_FILTER_DESCRIPTOR",
        "name": "EnableFilterDesc",
        "description": "An EVENT_FILTER_DESCRIPTOR structure that points to the filter data. The provider uses to filter data to prevent events that match the filter criteria from being written to the session; the provider determines the layout of the data and how it applies the filter to the event's data. A session can pass only one filter to the provider. A session can call the TdhEnumerateProviderFilters function to determine the filters that it can pass to the provider."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The EnableTraceEx2 function     enables or disables the specified event trace provider.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7 and Windows Server 2008 R2",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. The provider defines its interpretation of being enabled or disabled. Typically, if a provider has been enabled, it generates events, but while it is disabled, it does not. Event Tracing for Windows (ETW) supports several categories of filtering. Every time EnableTraceEx2 is called, the filters for the provider in that session are replaced by the new parameters defined by the parameters passed to the EnableTraceEx2 function. Multiple filters passed in a single EnableTraceEx2 call can be combined with an additive effect. To disable filtering and thereby enable all providers/events in the logging session, call EnableTraceEx2 with the EnableParameters parameter pointed to an ENABLE_TRACE_PARAMETERS structure with the FilterDescCount member set to 0. Each filter passed to the EnableTraceEx2 function is specified by a Type member in the EVENT_FILTER_DESCRIPTOR. An array of  EVENT_FILTER_DESCRIPTOR structures is passed in the ENABLE_TRACE_PARAMETERS structure passed in the EnableParameters parameter to the EnableTraceEx2 function. Each type of filter (a specific Type member) may only appear once in a call to the EnableTraceEx2 function, however, some filter  types allow multiple conditions to be included in a single filter. The maximum number of filters that can be included in a call to EnableTraceEx2 is set by  MAX_EVENT_FILTERS_COUNT defined to be 8 in the Evntprov.h header file.  Each filter type has its own size or entity limits based on the specific Type member in the EVENT_FILTER_DESCRIPTOR structure.  The list  below indicates these limits.  To include all events that a provider provides, set MatchAnyKeyword to zero (for a      manifest-based provider or TraceLogging provider      and 0xFFFFFFFF for a      classic provider). To      include specific events, set the MatchAnyKeyword mask to those specific events. To indicate that you wish to enable a Provider Group, use the EVENT_ENABLE_PROPERTY_PROVIDER_GROUP flag on the EnableProperty member of  EnableParameters. For      example, if the provider defines an event for its initialization and cleanup routines (set keyword bit 0), an      event for its file operations (set keyword bit 1), and an event for its calculation operations (set keyword bit      2), you can set MatchAnyKeyword to 5 to receive initialization and cleanup events and      calculation events. If the provider defines more complex event keywords, for example, the provider defines an event that sets bit      0 for read and bit 1 for local access and a second event that sets bit 0 for read and bit 2 for remote access, you      could set MatchAnyKeyword to 1 to receive all read events, or you could set MatchAnykeyword to 1 and      MatchAllKeywords to 3 to receive local reads only. If an event's keyword is zero, the provider will write the event to the session, regardless of the      MatchAnyKeyword and MatchAllKeyword masks. When you call EnableTraceEx2 the provider may or may      not be registered. If the provider is registered, ETW calls the provider's callback function, if it implements      one, and the session begins receiving events. If the provider is not registered, ETW will call the provider's      callback function when it registers itself, if it implements one, and the session will begin receiving events. If      the provider is not registered, the provider's callback function will not receive the source ID or filter data.      You can call EnableTraceEx2 one time to enable a      provider before the provider registers itself. If the provider is registered and already enabled to your session, you can also use this function to update      the Level, MatchAnyKeyword,      MatchAllKeyword parameters, and the EnableProperty and      EnableFilterDesc members of EnableParameters. On Windows 8.1,Windows Server 2012 R2, and later, event payload , scope, and stack       walk filters can be used by the EnableTraceEx2       function and the ENABLE_TRACE_PARAMETERS and       EVENT_FILTER_DESCRIPTOR structures to filter on       specific conditions in a logger session. For more information on event payload filters, see the       TdhCreatePayloadFilter, and       TdhAggregatePayloadFilters functions and       the ENABLE_TRACE_PARAMETERS,       EVENT_FILTER_DESCRIPTOR, and       PAYLOAD_FILTER_PREDICATE structures. You do not call EnableTraceEx2 to enable kernel       providers. To enable kernel providers, set the EnableFlags member of       EVENT_TRACE_PROPERTIES which you then pass to       StartTrace. The       StartTrace function enables the selected kernel       providers. Up to eight trace sessions can enable and receive events from the same manifest-based provider or TraceLogging provider; however, only one trace session can enable a classic provider. If more than one session tried to enable a classic provider, the first session would stop receiving events when the second session enabled the same provider. For example, if Session A enabled Provider 1 and then Session B enabled Provider 1, only Session B would receive events from Provider 1. The provider remains enabled for the session until the session disables the provider. If the application that started the session ends without disabling the provider, the provider remains enabled. To determine the level and keywords used to enable a manifest-based provider, use one of the following       commands: For classic providers, it is up to the provider to document and make available to potential controllers the severity levels or enable flags that it supports. If the provider wants to be enabled by any controller, the provider should accept 0 for the severity level and enable flags and interpret 0 as a request to perform default logging (whatever that may be). If you use EnableTraceEx2 to enable a classic provider, the following translation occurs: If EnableTraceEx2 returns       ERROR_INVALID_PARAMETER when enabling filtering, you can turn on tracing to view       debugging messages about the failure. This requires a checked build. The following example shows you how to use the       EnableTraceEx2 with payload filters using the       TdhCreatePayloadFilter and       TdhAggregatePayloadFilters functions to       filter on specific conditions in a logger session. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EnableTraceEx2",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7 and Windows Server 2008 R2",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "TraceHandle",
        "description": "A handle of the event tracing session to which you want to enable or disable the provider. The        StartTrace function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "ProviderId",
        "description": "A GUID of the event trace provider that you want to enable or disable."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ControlCode",
        "description": "You can specify one of the following control codes:  ValueMeaning  EVENT_CONTROL_CODE_DISABLE_PROVIDER   Disables the provider.   EVENT_CONTROL_CODE_ENABLE_PROVIDER   Enables the provider. The session receives events  when the provider is registered.   EVENT_CONTROL_CODE_CAPTURE_STATE   Requests that the provider log its state information. First you would enable the provider and then call          EnableTraceEx2 with this control code to capture          state information."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Level",
        "description": "A provider-defined value that specifies the level of detail included in the event. Specify one of the        following levels that are defined in the Winmeta.h header file. Higher numbers imply        that you get lower levels as well. For example, if you specify TRACE_LEVEL_WARNING, you also receive all        warning, error, and critical events.        ValueMeaning  TRACE_LEVEL_CRITICAL 1   Abnormal exit or termination events   TRACE_LEVEL_ERROR 2   Severe error events   TRACE_LEVEL_WARNING 3   Warning events such as allocation failures   TRACE_LEVEL_INFORMATION 4   Non-error events such as entry or exit events   TRACE_LEVEL_VERBOSE 5   Detailed trace events"
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "MatchAnyKeyword",
        "description": "A bitmask of keywords that determine the category of events that you want the provider to write. The        provider writes the event if any of the event's keyword bits match any of the bits set in this mask. See        Remarks."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "MatchAllKeyword",
        "description": "This bitmask is optional. This mask further restricts the category of  events that you want the provider to write. If the event's keyword meets the MatchAnyKeyword condition, the provider will write the event only if all of the bits in this mask exist in the event's keyword. This mask is not used if MatchAnyKeyword is zero. See Remarks."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Timeout",
        "description": "Set to zero to enable the trace asynchronously; this is the default. If the timeout value is zero, this function calls the provider's enable callback and returns immediately. To enable the trace synchronously, specify a timeout value, in milliseconds. If you specify a timeout value, this function calls the provider's enable callback and waits until the callback exits or the timeout expires. To wait forever, set to INFINITE."
      },
      {
        "in_out": "_In_opt_",
        "type": "PENABLE_TRACE_PARAMETERS",
        "name": "EnableParameters",
        "description": "The trace parameters used to enable the provider. For details, see ENABLE_TRACE_PARAMETERS and ENABLE_TRACE_PARAMETERS_V1."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  EnumerateTraceGuids function retrieves information about registered event trace providers that are running on the computer.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. For information on registering event trace providers, see  RegisterTraceGuids. You can use the TRACE_GUID_PROPERTIES.LoggerId member to determine which session enabled the provider if TRACE_GUID_PROPERTIES.IsEnable is TRUE. The list will not include kernel providers. The following example shows you how to call this function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EnumerateTraceGuids",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PTRACE_GUID_PROPERTIES*",
        "name": "GuidPropertiesArray",
        "description": "An array of pointers to  TRACE_GUID_PROPERTIES structures."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PropertyArrayCount",
        "description": "Number of elements in the GuidPropertiesArray array."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "GuidCount",
        "description": "Actual number of event tracing providers registered on the computer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Use this function to retrieve information about trace providers that are registered on the computer.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. If TraceQueryInfoClass is TraceGuidQueryInfo, ETW returns the data in a TRACE_GUID_INFO block that is a header to the information. The info block contains a TRACE_PROVIDER_INSTANCE_INFO block for each provider that uses the same GUID. Each instance info block contains a TRACE_ENABLE_INFO structure for each session that enabled the provider. For information on registering event trace providers, see  EventRegister and RegisterTraceGuids. The following example shows you how to call this function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EnumerateTraceGuidsEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACE_QUERY_INFO_CLASS",
        "name": "TraceQueryInfoClass",
        "description": "Determines the type of information to include with the list of registered providers. For possible values, see the TRACE_QUERY_INFO_CLASS enumeration."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "InBuffer",
        "description": "GUID of the provider or provider group whose information you want to retrieve. Specify the GUID only if TraceQueryInfoClass is TraceGuidQueryInfo or TraceGroupQueryInfo."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InBufferSize",
        "description": "Size, in bytes, of the data InBuffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "OutBuffer",
        "description": "Application-allocated buffer that contains the enumerated information. The format of the information depends on the value of TraceQueryInfoClass. For details, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "OutBufferSize",
        "description": "Size, in bytes, of the OutBuffer buffer. If the function succeeds, the ReturnLength parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and the ReturnLength parameter receives the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and the ReturnLength parameter receives the required buffer size."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "Actual size of the data in OutBuffer, in bytes."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  FlushTrace function causes an event tracing session to immediately deliver buffered events for the specified session. (An event tracing session does not deliver events until an active buffer is full.)",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Controllers call this function. Typically, you do not need to flush buffers yourself. However, you may want to flush buffers if the event rate is low and you are delivering events in real time. Note that it is not safe to flush buffers from DllMain. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "FlushTrace",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session for whose buffers you want to flush, or NULL. You must specify SessionHandle if SessionName is NULL. However, ETW ignores the handle if SessionName is not NULL. The handle is returned by the  StartTrace function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SessionName",
        "description": "Pointer to a null-terminated string that specifies the name of the event tracing session whose buffers you want to flush, or NULL. You must specify SessionName if SessionHandle is NULL. To specify the NT Kernel Logger session, set SessionName to KERNEL_LOGGER_NAME."
      },
      {
        "in_out": "_Inout_",
        "type": "PEVENT_TRACE_PROPERTIES",
        "name": "Properties",
        "description": "Pointer to an  initialized EVENT_TRACE_PROPERTIES structure.     If you are using a newly initialized structure, you only need to set the Wnode.BufferSize, Wnode.Guid,  LoggerNameOffset, and LogFileNameOffset members of the structure. You can use the maximum session name (1024 characters) and maximum log file name (1024 characters) lengths to calculate the buffer size and offsets if not known.  On output, the structure receives the property settings and session statistics of the event tracing session, which  reflect the state of the session after the flush."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The QueryAllTraces function retrieves the properties     and statistics for all event tracing sessions started on the computer for which the caller has permissions to     query.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. This function retrieves the trace sessions that the caller has permissions to query. Users running with      elevated administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,      LocalService, NetworkService can view all tracing sessions. This function does not return private logging sessions. To retrieve information for a single session, use the      ControlTrace function and set the      ControlCode parameter to EVENT_TRACE_CONTROL_QUERY. The following example shows how to call this function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "QueryAllTraces",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PEVENT_TRACE_PROPERTIES*",
        "name": "PropertyArray",
        "description": "An array of pointers to         EVENT_TRACE_PROPERTIES structures that receive         session properties and statistics for the event tracing sessions. You only need to set the Wnode.BufferSize,         LoggerNameOffset , and LogFileNameOffset  members of the         EVENT_TRACE_PROPERTIES structure. The other         members should all be set to zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PropertyArrayCount",
        "description": "Number of structures in the PropertyArray array. This value must be less than or        equal to 64, the maximum number of event tracing sessions that ETW supports."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "SessionCount",
        "description": "Actual number of event tracing sessions started on the computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  QueryTrace function retrieves the property settings and session statistics for the specified event tracing session.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Controllers call this function. To update the property settings and session statistics for an event tracing session, call the  UpdateTrace function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "QueryTrace",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session for whose properties and statistics you want to query, or NULL. You must specify SessionHandle if SessionName is NULL. However, ETW ignores the handle if SessionName is not NULL. The handle is returned by the  StartTrace function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SessionName",
        "description": "Pointer to a null-terminated string that specifies the name of the event tracing session whose properties and statistics you want to query, or NULL. You must specify SessionName if SessionHandle is NULL. To specify the NT Kernel Logger session, set SessionName to KERNEL_LOGGER_NAME."
      },
      {
        "in_out": "_Inout_",
        "type": "PEVENT_TRACE_PROPERTIES",
        "name": "Properties",
        "description": "Pointer to an  initialized EVENT_TRACE_PROPERTIES structure.     You only need to set the Wnode.BufferSize member of the EVENT_TRACE_PROPERTIES structure. You can use the maximum session name (1024 characters) and maximum log file name (1024 characters) lengths to calculate the buffer size and offsets if not known.  On output, the structure members contain the property settings and session statistics for the event tracing session.  Starting with Windows 10, version 1703:  For better performance in cross process scenarios, you can now pass filtering in to QueryTrace for  system wide private loggers. You will need to pass in the new EVENT_TRACE_PROPERTIES_V2 structure to include filtering information. See Configuring and Starting a Private Logger Session for more details."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The StartTrace function registers and starts an event     tracing session.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Event trace controllers call this function. The session remains active until you stop the session, the computer is restarted or the maximum file size is      reached for non-circular logs. To stop an event tracing session, call the      ControlTrace function and set the      ControlCode parameter to EVENT_TRACE_CONTROL_STOP. You cannot start  more than one session with the same session GUID. Windows Server 2003:  You can start more than one session with the same session GUID. For the logger to be a system logger and receive events from SystemTraceProvider, any of the following must be true: Because system loggers receive special kernel events, they are subject to additional restrictions: To specify an NT Kernel Logger session, set SessionName to       KERNEL_LOGGER_NAME and the Wnode.Guid member of       Properties to SystemTraceControlGuid. If you do not specify       the GUID as SystemTraceControlGuid, ETW will override the GUID value and set it to       SystemTraceControlGuid. Windows 2000:  To start the kernel session, the session name must be KERNEL_LOGGER_NAME and the GUID must be SystemTraceControlGuid. To specify a private logger session, set Wnode.Guid member of      Properties to the provider's control GUID, not the private logger session's control      GUID. The provider must have registered the GUID before you call      StartTrace. You do not use this function to start a global logger session. For details on starting a global logger      session, see      Configuring and Starting the Global Logger Session. For an example that uses StartTrace, see       Configuring and Starting an Event Tracing Session. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "StartTrace",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PTRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session. Do not use this handle if the function fails. Do not compare the session handle to INVALID_HANDLE_VALUE; the         session handle is 0 if the handle is not valid."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SessionName",
        "description": "Null-terminated string that contains the name of the event tracing session. The session name is limited to         1,024 characters, is case-insensitive, and must be unique. Windows 2000:  Session names are case-sensitive. As a result, duplicate session names are allowed. However, to reduce          confusion, you should make sure your session names are unique. This function copies the session name that you provide to the offset that the         LoggerNameOffset member of Properties points to."
      },
      {
        "in_out": "_Inout_",
        "type": "PEVENT_TRACE_PROPERTIES",
        "name": "Properties",
        "description": "Pointer to an EVENT_TRACE_PROPERTIES         structure that specifies the behavior of the session. The following are key members of the structure to set:  Wnode.BufferSize Wnode.Guid Wnode.ClientContext Wnode.Flags LogFileMode LogFileNameOffset LoggerNameOffset  Depending on the type of log file you choose to create, you may also need to specify a value for MaximumFileSize. See the Remarks section for more information on setting the Properties parameter and the behavior of the session. Starting with Windows 10, version 1703:  For better performance in cross process scenarios, you can now pass filtering in to StartTrace when starting system wide private loggers. You will need to pass in the new EVENT_TRACE_PROPERTIES_V2 structure to include filtering information. See Configuring and Starting a Private Logger Session for more details."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  StopTrace function stops the specified event tracing session.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Controllers call this function. If LogFileMode contains EVENT_TRACE_FILE_MODE_PREALLOCATE,      StartTrace extends the log file to      MaximumFileSize bytes. The file occupies the entire space during logging, for both      circular and sequential logs. When you stop the logger, the log file is reduced to the size needed. Note that it is not safe to stop a trace session from DllMain. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "StopTrace",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session that you want to stop, or NULL. You must        specify SessionHandle if SessionName is        NULL. However, ETW ignores the handle if SessionName is not        NULL. The handle is returned by the        StartTrace function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SessionName",
        "description": "Pointer to a null-terminated string that specifies the name of the event tracing session that you want to        stop, or NULL. You must specify SessionName if        SessionHandle is NULL. To specify the NT Kernel Logger session, set SessionName to        KERNEL_LOGGER_NAME."
      },
      {
        "in_out": "_Out_",
        "type": "PEVENT_TRACE_PROPERTIES",
        "name": "Properties",
        "description": "Pointer to an EVENT_TRACE_PROPERTIES        structure that receives the final properties and statistics for the session. If you are using a newly        initialized structure, you only need to set the Wnode.BufferSize,        Wnode.Guid,  LoggerNameOffset, and        LogFileNameOffset members of the structure. You can use the maximum session name        (1024 characters) and maximum log file name (1024 characters) lengths to calculate the buffer size and offsets        if not known.  Starting with Windows 10, version 1703:  For better performance in cross process scenarios, you can now pass filtering in to StopTrace for  system wide private loggers. You will need to pass in the new EVENT_TRACE_PROPERTIES_V2 structure to include filtering information. See Configuring and Starting a Private Logger Session for more details."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The TraceQueryInformation function      queries event tracing session settings for the specified information class.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8 and Windows Server 2012",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The TraceQueryInformation function queries       event tracing session settings for the specified information class. Call this function after calling       StartTrace. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TraceQueryInformation",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8 and Windows Server 2012",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "A handle of the event tracing session that wants to capture the specified information. The        StartTrace function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "TRACE_QUERY_INFO_CLASS",
        "name": "InformationClass",
        "description": "The information class to query. The information that the class captures is included in the extended data        section of the event. For a list of information classes that you can query, see the        TRACE_QUERY_INFO_CLASS enumeration."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "TraceInformation",
        "description": "A pointer to a buffer to receive the returned information class specific data. The information class        determines the contents of this parameter. For example, for the TraceStackTracingInfo        information class, this parameter is an array of        CLASSIC_EVENT_ID structures. The structures specify        the event GUIDs for which stack tracing is enabled. The array is limited to 256 elements."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InformationLength",
        "description": "The size, in bytes, of the data returned in the TraceInformation buffer. If the        function fails, this value indicates the required size of the TraceInformation buffer        that is needed."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer a value that receives the size, in bytes, of the specific data returned in the        TraceInformation buffer."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The TraceSetInformation function      enables or disables event tracing session settings for  the specified information class.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7 and Windows Server 2008 R2",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "Call this function after calling StartTrace. If the InformationClass parameter is set to      TraceStackTracingInfo, calling this function enables stack tracing of the specified      kernel events. Subsequent calls to this function overwrites the previous list of kernel events for which stack      tracing is enabled. To disable stack tracing, call this function with InformationClass      set to TraceStackTracingInfo and InformationLength set to      0. The extended data section of the event will include the call stack. The      StackWalk_Event MOF class defines the layout of the      extended data. Typically, on 64-bit computers, you cannot capture the kernel stack in certain contexts when page faults are       not allowed. To enable walking the kernel stack on x64, set the       DisablePagingExecutive Memory Management registry value to 1. The       DisablePagingExecutive registry value is located under the following registry       key:  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management You should consider the cost of setting this registry value before doing so. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TraceSetInformation",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7 and Windows Server 2008 R2",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "A handle of the event tracing session that wants to capture the specified information. The  StartTrace function returns this handle."
      },
      {
        "in_out": "_In_",
        "type": "TRACE_INFO_CLASS",
        "name": "InformationClass",
        "description": "The information class to enable or disable. The information that the class captures is included in the        extended data section of the event. For a list of information classes that you can enable, see the        TRACE_INFO_CLASS enumeration."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "TraceInformation",
        "description": "A pointer to information class specific data; the information class determines the contents of this        parameter. For example, for the TraceStackTracingInfo information class, this        parameter is an array of CLASSIC_EVENT_ID structures.        The structures specify the event GUIDs for which stack tracing is enabled. The array is limited to 256        elements."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InformationLength",
        "description": "The size, in bytes, of the data in the TraceInformation buffer."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  UpdateTrace function updates the property setting of the specified event tracing session.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Controllers call this function. On input, the members must specify the new values for the properties to update. You can update the following properties.  For private logger sessions, you can only update LogFileNameOffset and FlushTimer. If you are using a newly initialized EVENT_TRACE_PROPERTIES structure, the only members you need to specify, other than the members you are updating, are Wnode.BufferSize, Wnode.Guid, and Wnode.Flags. If you use the property structure you passed to StartTrace, make sure the  LogFileNameOffset member is 0 unless you are changing the log file name. If you call the ControlTrace function to query the current session properties and then update those properties to update the session, make sure you set LogFileNameOffset to 0 (unless you are changing the log file name) and set EVENT_TRACE_PROPERTIES.Wnode.Flags to WNODE_FLAG_TRACED_GUID. To obtain the property settings and session statistics for an event tracing session, call the  ControlTrace function. For an example that uses  UpdateTrace, see  Updating an Event Tracing Session. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "UpdateTrace",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session to update, or NULL. You must specify SessionHandle if SessionName is NULL. However, ETW ignores the handle if SessionName is not NULL. The handle is returned by the  StartTrace function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SessionName",
        "description": "Pointer to a null-terminated string that specifies the name of the event tracing session to update, or NULL. You must specify SessionName if SessionHandle is NULL. To specify the NT Kernel Logger session, set SessionName to KERNEL_LOGGER_NAME."
      },
      {
        "in_out": "_Inout_",
        "type": "PEVENT_TRACE_PROPERTIES",
        "name": "Properties",
        "description": "Pointer to an  initialized  EVENT_TRACE_PROPERTIES structure.  On input, the members must specify the new values for the properties to update. For information on which properties you can update, see Remarks. On output, the structure members contains the updated settings and statistics for the event tracing session."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Providers implement this function to receive enable or disable notification requests from controllers.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "You should return ERROR_SUCCESS if the callback succeeds. Note that ETW ignores the return value for this function except when a controller calls EnableTrace to enable a provider and the provider has not yet called RegisterTraceGuids. When this occurs, RegisterTraceGuids will return the return value of this callback if the registration was successful. ",
    "remarks": "This function is specified using the  RegisterTraceGuids function. When the controller calls the EnableTrace function to enable, disable, or change the enable flags or level, ETW calls this callback. The provider enables or disables itself based the RequestCode value. Typically, the provider uses this value to set a global flag to indicate its enabled state. The provider defines its interpretation of being enabled or disabled. Generally, if a provider is enabled, it generates events, but while it is disabled, it does not. ETW does not pass the enable flags and enable level that the controller passes to the EnableTrace function to this callback. To retrieve this information, call the GetTraceEnableFlags and  GetTraceEnableLevel functions, respectively. You also need to retrieve the session handle in this callback for future calls. To retrieve the session handle, call the GetTraceLoggerHandle function. Your callback function must not call anything that may incur LoadLibrary (more specifically, anything that requires a loader lock). For an example implementation of a  ControlCallback function, see  Writing Classic Events. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "ControlCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WMIDPREQUESTCODE",
        "name": "RequestCode",
        "description": "Request code. Specify one of the following values.     ValueMeaning  WMI_ENABLE_EVENTS   Enables the provider.   WMI_DISABLE_EVENTS   Disables the provider."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Provider-defined context. The provider uses the RequestContext parameter of   RegisterTraceGuids to specify the context."
      },
      {
        "in_out": "_In_",
        "type": "ULONG*",
        "name": "Reserved",
        "description": "Reserved for internal use."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a  WNODE_HEADER structure that contains information about the event tracing session for which the provider is being enabled or disabled."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  CreateTraceInstanceId function creates a unique transaction identifier and maps it to a class GUID registration handle. You then use the transaction identifier when calling the TraceEventInstance function.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. ETW creates the identifier in the user-mode process, thus it can return the same number for different processes. The value starts over at one when InstanceId reaches the maximum value for a ULONG. Only user-mode providers can call the CreateTraceInstanceId function; drivers cannot call this function. For an example that uses  CreateTraceInstanceId, see  Tracing Event Instances. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "CreateTraceInstanceId",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "RegHandle",
        "description": "Handle to a registered event trace class. The  RegisterTraceGuids function returns this handle in the RegHandle member of the TRACE_GUID_REGISTRATION structure."
      },
      {
        "in_out": "_Out_",
        "type": "PEVENT_INSTANCE_INFO",
        "name": "pInstInfo",
        "description": "Pointer to an  EVENT_INSTANCE_INFO structure. The InstanceId member of this structure contains the transaction identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetTraceEnableFlags function retrieves the enable flags passed by the controller to indicate which category of events to trace.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "Returns the value the controller specified in the EnableFlag parameter when calling the  EnableTrace function. To determine if the function failed or the controller set the enable flags to 0, follow these steps: ",
    "remarks": "Providers can use this value to control which events that it generates. For example, a provider can group events into logical categories of events and use this value to enable or disable their generation. For an example that uses  GetTraceEnableFlags, see  Retrieving Event Data Using MOF. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "GetTraceEnableFlags",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to an event tracing session, obtained by calling the  GetTraceLoggerHandle function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetTraceEnableLevel function retrieves the severity level passed by the controller to indicate the level of logging the provider should perform.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "Returns the value the controller specified in the EnableLevel parameter when calling the  EnableTrace function. To determine if the function failed or the controller set the enable flags to 0, follow these steps: ",
    "remarks": "Providers use this value to control the severity of events that it generates. For example, providers can use this value to determine if it should generate informational, warning, or error events. For an example that uses  GetTraceEnableLevel, see  Retrieving Event Data Using MOF. ",
    "return_type": "UCHAR",
    "category": "Event Tracing",
    "name": "GetTraceEnableLevel",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to an event tracing session, obtained by calling the  GetTraceLoggerHandle function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetTraceLoggerHandle function retrieves the handle of the event tracing session.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, it returns the event tracing session handle. If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call the  GetLastError function. ",
    "remarks": "You use the handle when calling the  GetTraceEnableFlags and  GetTraceEnableLevel functions to retrieve the enable flags and level values passed to the EnableTrace function. For an example that uses  GetTraceLoggerHandle, see  Retrieving Event Data Using MOF. ",
    "return_type": "TRACEHANDLE",
    "category": "Event Tracing",
    "name": "GetTraceLoggerHandle",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a  WNODE_HEADER structure. ETW passes this structure to the provider's  ControlCallback function in the Buffer parameter. The HistoricalContext member of WNODE_HEADER contains the session's handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The  RegisterTraceGuids function registers an event trace provider and the event trace classes that it uses to generate events. This function also specifies the function the provider uses  to enable and disable tracing.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. If the provider's ControlGuid has been previously registered and enabled, subsequent registrations that reference the same ControlGuid are automatically enabled. A process can register up to 1,024 provider GUIDs; however, you should limit the number of providers that your process registers to one or two. This limit includes those registered using this function and the EventRegister function. Prior to Windows Vista:  There is no limit to the number of providers that a process can register. For an example that uses  RegisterTraceGuids, see  Writing Classic Events. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "RegisterTraceGuids",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WMIDPREQUEST",
        "name": "RequestAddress",
        "description": "Pointer to a  ControlCallback function that receives notification when the provider is enabled or disabled by an event tracing session. The EnableTrace function calls the callback."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "RequestContext",
        "description": "Pointer to an optional provider-defined context that ETW passes to the function specified by RequestAddress."
      },
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "ControlGuid",
        "description": "GUID of the registering provider."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "GuidCount",
        "description": "Number of elements in the TraceGuidReg array. \t\t\t\t\tIf TraceGuidReg is NULL, set this parameter to 0."
      },
      {
        "in_out": "_Inout_",
        "type": "PTRACE_GUID_REGISTRATION",
        "name": "TraceGuidReg",
        "description": "Pointer to an array of   TRACE_GUID_REGISTRATION structures.    Each element identifies a category of events that the provider provides.  On input, the Guid member of each structure contains an event trace class GUID assigned by the registering provider. The class GUID identifies a category of events that the provider provides. Providers use the same class GUID to set the Guid member of EVENT_TRACE_HEADER when calling the TraceEvent function to log the event.  On output, the RegHandle member receives a handle to the event's class GUID registration. If the provider calls the TraceEventInstance function, use the RegHandle member of TRACE_GUID_REGISTRATION to set the RegHandle member of EVENT_INSTANCE_HEADER. This parameter can be NULL if the provider calls only the TraceEvent function to log events. If the provider calls the TraceEventInstance function to log events, this parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "MofImagePath",
        "description": "This parameter is not supported, set to NULL. You should use Mofcomp.exe to register the MOF resource during the setup of your application. For more information see, Publishing Your Event Schema. Windows XP with SP1, Windows XP and Windows 2000:  Pointer to an optional string that specifies the path of the DLL or executable program that contains the resource specified by MofResourceName. This parameter can be NULL if the event provider and consumer use another mechanism to share information about the event trace classes used by the provider."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "MofResourceName",
        "description": "This parameter is not supported, set to NULL. You should use Mofcomp.exe to register the MOF resource during the setup of your application. For more information see, Publishing Your Event Schema. Windows XP with SP1, Windows XP and Windows 2000:  Pointer to an optional string that specifies the string resource of MofImagePath. The string resource contains the name of the binary MOF file that describes the event trace classes supported by the provider."
      },
      {
        "in_out": "_Out_",
        "type": "PTRACEHANDLE",
        "name": "RegistrationHandle",
        "description": "Pointer to the provider's registration handle. Use this handle when you call the  UnregisterTraceGuids function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  TraceEvent function sends an event to an event tracing session.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. Before the provider can call this function, the  provider The event is either written to a log file, sent to event trace consumers in real time, or both. The LogFileMode member of the  EVENT_TRACE_PROPERTIES structure passed to the  StartTrace defines where the event is sent. The trace events are written in the order in which they occur. To trace a set of related events, use the  TraceEventInstance function. On Windows Vista, you should use the EventWrite function to log events. For an example that uses  TraceEvent, see  Tracing Events. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TraceEvent",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session that records the event. The provider obtains the handle when it calls the GetTraceLoggerHandle function in its ControlCallback implementation."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_TRACE_HEADER",
        "name": "EventTrace",
        "description": "Pointer to an  EVENT_TRACE_HEADER structure. Event-specific data is optionally appended to the structure. The largest event you can log is 64K. You must specify values for the following members of the  EVENT_TRACE_HEADER structure.     Size Guid or GuidPtr Flags  Depending on the complexity of the information your provider provides, you should also consider specifying values for the following members.  Class.Type Class.Level"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The  TraceEventInstance function sends an event to an event tracing session. The event uses an instance identifier to associate the event with a transaction. This function may also be used to trace hierarchical relationships between related events.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. Before the provider can call this function, the  provider The event is either written to a log file, sent to event trace consumers in real time, or both. The LogFileMode member of the  EVENT_TRACE_PROPERTIES structure passed to the  StartTrace defines where the event is sent. The trace events are written in the order in which they occur. To trace unrelated events, use the  TraceEvent function. Windows XP:  Does not work correctly. For an example of generating related sets of events using  CreateTraceInstanceId and  TraceEventInstance, see  Tracing Event Instances. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TraceEventInstance",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session that records the event instance. The provider obtains the handle when it calls the GetTraceLoggerHandle function in its ControlCallback implementation."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_INSTANCE_HEADER",
        "name": "EventTrace",
        "description": "Pointer to an  EVENT_INSTANCE_HEADER structure. Event-specific data is optionally appended to the structure. The largest event you can log is 64K. You must specify values for the following members of the  EVENT_INSTANCE_HEADER structure.     Size Flags RegHandle  Depending on the complexity of the information your provider provides, you should also consider specifying values for the following members.  Class.Type Class.Level  To trace hierarchical relationships between related events, also set the ParentRegHandle member."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_INSTANCE_INFO",
        "name": "pInstInfo",
        "description": "Pointer to an  EVENT_INSTANCE_INFO structure, which contains the registration handle for this event trace class and the instance identifier. Use the  CreateTraceInstanceId function to initialize the structure."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_INSTANCE_INFO",
        "name": "pParentInstInfo",
        "description": "Pointer to an  EVENT_INSTANCE_INFO structure, which contains the registration handle for the parent event trace class and its instance identifier. Use the  CreateTraceInstanceId function to initialize the structure. Set to NULL if you are not tracing a hierarchical relationship."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  TraceMessage function sends an informational message to an event tracing session.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. Using the TraceEvent function is the preferred way to log an event. On Windows Vista, you should use the EventWrite function to log events. The trace events are written in the order in which they occur. If you need to access message tracing functionality from a wrapper function, call the  TraceMessageVa version of this function. Consumers will have to use the EventCallback callback to receive and process the events if the MessageFlags parameter does not contain the TRACE_MESSAGE_GUID flag. If you do not specify the TRACE_MESSAGE_GUID flag, the consumer will not be able to use the EventClassCallback because the Header.Guid member of the   EVENT_TRACE structure will not contain the event trace class GUID. Note that the members of the EVENT_TRACE and EVENT_TRACE_HEADER structures that correspond to the MessageFlags flags are set only if the corresponding flag is specified. For example, the ThreadId and ProcessId members of EVENT_TRACE_HEADER are populated only if you specify the TRACE_MESSAGE_SYSTEMINFO flag. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TraceMessage",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session that records the event. The provider obtains the handle when it calls the GetTraceLoggerHandle function in its ControlCallback implementation."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageFlags",
        "description": "Adds additional information to the beginning of the provider-specific data section of the event. The provider-specific data section of the event will contain data only for those flags that are set. The variable list of argument data will follow this information. This parameter can be one or more of the following values.     FlagMeaning  TRACE_MESSAGE_COMPONENTID    Include the component identifier in the message. The MessageGuid parameter contains the component identifier.   TRACE_MESSAGE_GUID   Include the event trace class GUID in the message. The MessageGuid parameter contains the event trace class  GUID.   TRACE_MESSAGE_SEQUENCE   Include a sequence number in the message. The sequence number starts at one. To use this flag, the controller must have set the EVENT_TRACE_USE_GLOBAL_SEQUENCE or EVENT_TRACE_USE_LOCAL_SEQUENCE log file mode when creating the session.   TRACE_MESSAGE_SYSTEMINFO   Include the thread identifier and process identifier in the message.   TRACE_MESSAGE_TIMESTAMP   Include a time stamp in the message.     TRACE_MESSAGE_COMPONENTID and TRACE_MESSAGE_GUID are mutually exclusive. The information is included in the event data in the following order:  Sequence number Event trace class GUID (or component identifier) Time stamp Thread identifier Process identifier"
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "MessageGuid",
        "description": "Class GUID or component ID that identifies the message. Depends if MessageFlags contains the TRACE_MESSAGE_COMPONENTID or TRACE_MESSAGE_GUID flag."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "MessageNumber",
        "description": "Number that uniquely identifies each occurrence of the message. You must define the value specified for this parameter; the value should be meaningful to the application."
      },
      {
        "in_out": "...",
        "type": "",
        "name": "...",
        "description": "A list of variable arguments to be appended to the message. Use this list to specify your provider-specific event data. The list must be composed of pairs of arguments, as described in the following table.     Data TypeMeaning  PVOID   Pointer to the argument data.   size_t   The size of the argument data, in bytes.      \t\t\t\t\t\tTerminate the list using an argument pair consisting of a pointer to NULL and zero. \t\t\t\t\t\t The caller must ensure that the sum of the sizes of the arguments + 72 does not exceed the size of the event tracing session's buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  TraceMessageVa function sends an informational message with variable arguments to an event tracing session.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. Using the TraceEvent function is the preferred way to log an event. On Windows Vista, you should use the EventWrite function to log events. The trace events are written in the order in which they occur. If you do not need to access the message tracing functionality from a wrapper function, you can call the  TraceMessage version of this function. Consumers will have to use the EventCallback callback to receive and process the events if the MessageFlags parameter does not contain the TRACE_MESSAGE_GUID flag. If you do not specify the TRACE_MESSAGE_GUID flag, the consumer will not be able to use the EventClassCallback because the Header.Guid member of the   EVENT_TRACE structure will not contain the event trace class GUID. Note that the members of the EVENT_TRACE and EVENT_TRACE_HEADER structures that correspond to the MessageFlags flags are set only if the corresponding flag is specified. For example, the ThreadId and ProcessId members of EVENT_TRACE_HEADER are populated only if you specify the TRACE_MESSAGE_SYSTEMINFO flag. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TraceMessageVa",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "SessionHandle",
        "description": "Handle to the event tracing session that records the event. The provider obtains the handle when it calls the GetTraceLoggerHandle function in its ControlCallback implementation."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageFlags",
        "description": "Adds additional information to the beginning of the provider-specific data section of the event. The provider-specific data section of the event will contain data only for those flags that are set. The variable list of argument data will follow this information. This parameter can be one or more of the following values.     FlagMeaning  TRACE_MESSAGE_GUID   Include the event trace class GUID in the message. The MessageGuid parameter contains the event trace class  GUID.   TRACE_MESSAGE_SEQUENCE   Include a sequence number in the message. The sequence number starts at one. To use this flag, the controller must have set the EVENT_TRACE_USE_GLOBAL_SEQUENCE or EVENT_TRACE_USE_LOCAL_SEQUENCE log file mode when creating the session.   TRACE_MESSAGE_SYSTEMINFO   Include the thread identifier and process identifier in the message.   TRACE_MESSAGE_TIMESTAMP   Include a time stamp in the message.     The information is included in the event data in the following order:  Sequence number Event trace class GUID Time stamp Thread identifier Process identifier"
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "MessageGuid",
        "description": "Class GUID that identifies the event trace message."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "MessageNumber",
        "description": "Number that uniquely identifies each occurrence of the message. You must define the value specified for this parameter; the value should be meaningful to the application."
      },
      {
        "in_out": "_In_",
        "type": "va_list",
        "name": "MessageArgList",
        "description": "List of variable arguments to be appended to the message. The list must be composed of pairs of arguments, as described in the following table.     Data TypeMeaning  PVOID   Pointer to the argument data.   size_t   The size of the argument data, in bytes.      \t\t\t\t\t\tTerminate the list using an argument pair consisting of a pointer to NULL and zero. \t\t\t\t\t\t \t\t\t\t\t\t The caller must ensure that the sum of the sizes of the arguments + 72 does not exceed the size of the event tracing session's buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  UnregisterTraceGuids function unregisters an event trace provider and its event trace classes.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the  system error codes. The following table includes some common errors and their causes.  ",
    "remarks": "Providers call this function. The event trace provider must have been registered previously by calling the  RegisterTraceGuids function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "UnregisterTraceGuids",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "RegistrationHandle",
        "description": "Handle to the event trace provider, obtained from an earlier call to the  RegisterTraceGuids function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "A tracing function for publishing events when an attempted security vulnerability exploit is detected in your user-mode application.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2016 [desktop apps | Windows Store apps]",
    "header": "SecurityBaseAPI.h",
    "return_value": "Returns ERROR_SUCCESS if successful or one of the following values on error.  ",
    "remarks": "The CveEventWrite function publishes a CVE-based event. This function should be called only in scenarios where an attempt to exploit a known, patched vulnerability is detected by the application. Ideally, this function call should be added as part of the fix (update) itself. The default consumer for this event is EventLog-Application. To enable another consumer, the provider can be added to the consumer session. Provider GUID: 85a62a0d-7e17-485f-9d4f-749a287193a6 Source Name: Microsoft-Windows-Audit-CVE or Audit-CVE ",
    "return_type": "LONG",
    "category": "Event Tracing",
    "name": "CveEventWrite",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "CveId",
        "description": "A pointer to the CVE ID associated with the vulnerability for which this event is being raised."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "AdditionalDetails",
        "description": "A pointer to a string giving additional details that the event producer may want to provide to the consumer of this event."
      }
    ],
    "min_client": "Windows 10 [desktop apps | UWP apps]"
  },
  {
    "n_arguments": 7,
    "description": "Providers implement this function to receive enable or disable notification requests.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntprov.h",
    "return_value": "This callback function does not return a value. ",
    "remarks": "To specify that you want to receive notification when a session enables or disables your provider, set the EnableCallback parameter when calling the EventRegister function. Classic providers needed to specify and implement a callback because it used the information that was passed to the callback to determine the types of events to log and the level of verboseness to use when logging the events. However, with manifest-based providers, the callback is optional and is used for informational purposes; you do not need to specify or implement the callback when registering the provider unless your provider supports filtering. Providers can now just write events and ETW will determine if the event is logged to the session. If you want to verify that the event should be written before writing the event, you can call either the EventEnabled or  EventProviderEnabled function. Each time a new session enables the provider or a current session updates the provider, ETW calls the provider's callback function, if implemented. The level value that ETW passes to the callback is the highest level value specified amongst all the sessions. For example, if session A enabled the provider for warning (3) events and then session B enabled the provider for critical (1) events, the level value for the second callback is also 3, not 1. The MatchAnyKeyword value that ETW passes to the callback is a composite value of all MatchAnyKeyword values specified for all sessions that enabled the provider. The same is true for the MatchAllKeywords value. The SourceId and FilterData values are those values passed to the EnableTraceEx call. Your callback function must not call anything that may incur LoadLibrary (more specifically, anything that requires a loader lock). ",
    "return_type": "void NTAPI",
    "category": "Event Tracing",
    "name": "EnableCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "SourceId",
        "description": "GUID that identifies the session that enabled the provider. The value is GUID_NULL if EnableTraceEx did not specify a source identifier."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "IsEnabled",
        "description": "Indicates if the session is enabling or disabling the provider. A value of zero indicates that the session is disabling the provider. A value of 1 indicates that the session is enabling the provider. Beginning with Windows 7, this value can be one of the following values:  ValueMeaning  EVENT_CONTROL_CODE_DISABLE_PROVIDER 0   The session is disabling the provider.   EVENT_CONTROL_CODE_ENABLE_PROVIDER 1   The session is enabling the provider.    EVENT_CONTROL_CODE_CAPTURE_STATE 2   The session is requesting that the provider log its state information. The provider determines the state information that it logs.     If you receive a value (for example,  EVENT_CONTROL_CODE_CAPTURE_STATE) that you do not support, ignore the value (do not fail)."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Level",
        "description": "Provider-defined value that specifies the verboseness of the events that the provider writes. The provider must write the event if this value is less than or equal to the level value that the event defines.  This value is passed in the Level parameter of the  EnableTraceEx function or the EnableLevel parameter of EnableTrace."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "MatchAnyKeyword",
        "description": "Bitmask of keywords that the provider uses to determine the category of events that it writes.  This value is passed in the MatchAnyKeyword parameter of the  EnableTraceEx function or the EnableFlag parameter of EnableTrace."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "MatchAllKeywords",
        "description": "This bitmask is optional. This mask further restricts the category of  events that the provider writes.  This value is passed in the MatchAllKeywords parameter of the  EnableTraceEx function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PEVENT_FILTER_DESCRIPTOR",
        "name": "FilterData",
        "description": "A list of filter data that one or more sessions passed to the provider. A session can specify only one filter but the list will contain filters from all sessions that used filter data to enable the provider. The filter data is valid only within the callback, so providers should make a local copy of the data."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "CallbackContext",
        "description": "Context of the callback defined when the provider called EventRegister to register itself."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Creates, queries, and sets the current activity identifier used by the     EventWriteTransfer function.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful. ",
    "remarks": "The EVENT_ACTIVITY_CTRL_GET_ID control code returns a GUID with all zeros (GUID_NULL) if the identifier has not been set. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventActivityIdControl",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ControlCode",
        "description": "A control code that specifies if you want to create, query or set the current activity identifier. You can specify one of the following codes.  ValueMeaning  EVENT_ACTIVITY_CTRL_GET_ID   Sets the ActivityId parameter to the current identifier value from thread local storage.   EVENT_ACTIVITY_CTRL_SET_ID   Uses the identifier in the ActivityId parameter to set the value of the current identifier in the thread local storage.   EVENT_ACTIVITY_CTRL_CREATE_ID   Creates a new identifier and sets the ActivityId parameter to the value of the new identifier.   EVENT_ACTIVITY_CTRL_GET_SET_ID   Performs the following:  Copies the current identifier from thread local storage. Sets the current identifier in thread local storage to the new identifier specified in the ActivityId parameter. Sets the ActivityId parameter to the copy of the previous current identifier.    EVENT_ACTIVITY_CTRL_CREATE_SET_ID   Performs the following:  Copies the current identifier from thread local storage. Creates a new identifier and sets the current identifier in thread local storage to the new identifier. Sets the ActivityId parameter to the copy of the previous current identifier."
      },
      {
        "in_out": "_Inout_",
        "type": "LPGUID",
        "name": "ActivityId",
        "description": "A GUID that uniquely identifies the activity. To determine  when this parameter is an input parameter, an output parameter or both, see the descriptions for the ControlCodes parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Links events together when tracing events in an end-to-end scenario.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful or one of the following values on error.  ",
    "remarks": "Beginning with Windows 7 and Windows Server 2008 R2, use      EventWriteEx to write transfer events in an end-to-end      scenario. Use this function when several components want to relate their events in an end-to-end tracing scenario. For      example, components A, B, and C perform work on a related activity and want to link their events so that a      consumer can consume  all the events related to that activity.  ETW uses thread local storage to make available      to the next component the previous component's activity identifier. The component retrieves from the local      storage the previous component's identifier and sets the related activity identifier to it. The consumer can then      use the related activity identifier to walk the chain of the events from one component to the next. If each component defined their own activity identifier, the components can make the following calls to link       the events: Event data written with this function requires a manifest. Since the manifest is embedded in the provider, the provider must be available for a consumer  to consume the data written by the provider. ETW decides based on the event descriptor if the event is written to a session (for details, see      EnableTraceEx). ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventWriteTransfer",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle of the provider. The handle comes from        EventRegister."
      },
      {
        "in_out": "_In_",
        "type": "PCEVENT_DESCRIPTOR",
        "name": "EventDescriptor",
        "description": "Metadata that identifies the event to write. For details, see        EVENT_DESCRIPTOR."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "ActivityId",
        "description": "GUID that uniquely identifies this activity. If NULL, ETW gets the identifier        from the thread local storage. For details on getting this identifier, see        EventActivityIdControl."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "RelatedActivityId",
        "description": "Activity identifier from the previous component. Use this parameter to link your component's events to the        previous component's events. To get the activity identifier that was set for the previous component, see the        descriptions for the ControlCode parameter of the        EventActivityIdControl        function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UserDataCount",
        "description": "Number of EVENT_DATA_DESCRIPTOR structures        in UserData. The maximum number is 128."
      },
      {
        "in_out": "_In_opt_",
        "type": "PEVENT_DATA_DESCRIPTOR",
        "name": "UserData",
        "description": "The event data to write. Allocate a block of memory that contains one or more        EVENT_DATA_DESCRIPTOR structures. Set this        parameter to NULL if UserDataCount is zero. The data must        be in the order specified in the manifest."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Determines if the event is enabled for any session.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntprov.h",
    "return_value": "Returns TRUE if the event is enabled for a session; otherwise, FALSE. ",
    "remarks": "Typically, providers do not call this function to determine if a session is expecting this event, they simply      write the event and ETW determines if the event is logged to the session. Providers may want to call this function if they need to perform extra work to generate the event. Calling      this function first to determine if a session is expecting this event or not, may save resources and time. The provider would call this function if the provider generated an      EVENT_DESCRIPTOR structure for the event from the      manifest. If the event descriptor is not available, call the      EventProviderEnabled function. ",
    "return_type": "Boolean",
    "category": "Event Tracing",
    "name": "EventEnabled",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle of the provider. The handle comes from        EventRegister. Note  A valid registration handle        must be used."
      },
      {
        "in_out": "_In_",
        "type": "PCEVENT_DESCRIPTOR",
        "name": "EventDescriptor",
        "description": "Describes the event. For details, see EVENT_DESCRIPTOR."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Determines if the event is enabled for any session.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntprov.h",
    "return_value": "Returns TRUE if the event is enabled for a session; otherwise, returns        FALSE. ",
    "remarks": "Typically, providers do not call this function to determine if a session is expecting this event; they simply      write the event and ETW determines if the event is logged to the session. Providers may want to call this function if they need to perform extra work to generate the event. In this      case, calling this function first (to determine if a session is expecting this event or not) may save resources      and time. The provider would call this function if the provider did not generate an      EVENT_DESCRIPTOR structure for the event from the      manifest. If the event descriptor is available, call the      EventEnabled function. ",
    "return_type": "Boolean",
    "category": "Event Tracing",
    "name": "EventProviderEnabled",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle of the provider. The handle comes from        EventRegister."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Level",
        "description": "Level of detail included in the event. Specify one of the following levels that are defined in Winmeta.h.        Higher numbers imply that you get lower levels as well. For example, if you specify TRACE_LEVEL_WARNING, you        also receive all warning, error, and fatal events.  ValueMeaning  WINEVENT_LEVEL_CRITICAL 1   Abnormal exit or termination events.   WINEVENT_LEVEL_ERROR 2   Severe error events.   WINEVENT_LEVEL_WARNING 3   Warning events such as allocation failures.   WINEVENT_LEVEL_INFO 4   Non-error events such as entry or exit events.   WINEVENT_LEVEL_VERBOSE 5   Detailed trace events."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "Keyword",
        "description": "Bitmask that specifies the event category. This mask should be the same keyword mask that you defined in        the manifest for the event."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Registers the provider.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful. ",
    "remarks": "Use this function to register your provider if you call      EventWrite to write your events. A process can register up to 1,024 provider GUIDs; however, you should limit the number of providers that       your process registers to one or two. This limit includes those registered using this function and the       RegisterTraceGuids function. Prior to Windows Vista:  There is no limit to the number of providers that a process can register. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventRegister",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "ProviderId",
        "description": "GUID that uniquely identifies the provider."
      },
      {
        "in_out": "_In_opt_",
        "type": "PENABLECALLBACK",
        "name": "EnableCallback",
        "description": "Callback that ETW  calls to notify you when a session enables or disables your provider. Can be        NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "CallbackContext",
        "description": "Provider-defined context data to pass to the callback when the provider is enabled or disabled. Can be        NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PREGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle. The handle is used by most provider function calls. Before your provider exits, you        must pass this handle to EventUnregister to        free the handle."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Performs operations on a registration     object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Type: ULONG If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventSetInformation",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Type: REGHANDLE Registration handle returned by        EventRegister."
      },
      {
        "in_out": "_In_",
        "type": "EVENT_INFO_CLASS",
        "name": "InformationClass",
        "description": "Type: EVENT_INFO_CLASS Type of operation to be performed on the registration object."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "EventInformation",
        "description": "Type: PVOID The input buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InformationLength",
        "description": "Type: ULONG Size of the input buffer."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Removes the provider's registration. You must call this function before your process exits.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful. ",
    "remarks": "For private sessions, you must stop the trace (call the      ControlTrace function with the      ControlCode parameter set to EVENT_TRACE_CONTROL_STOP) before calling this      function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventUnregister",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle returned by        EventRegister."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Use this function to write an event.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful or one of the following values on error.  ",
    "remarks": "Event data written with this function requires a manifest to consume the data. ETW decides based on the event descriptor if the event is written to a session (for details, see      EnableTraceEx). If you call the EventActivityIdControl      function to specify an activity identifier for the event,      EventWrite retrieves the identifier from thread local      storage and includes it with the event. For an example that uses EventWrite, see       Writing Manifest-based Events. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventWrite",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle of the provider. The handle comes from        EventRegister."
      },
      {
        "in_out": "_In_",
        "type": "PCEVENT_DESCRIPTOR",
        "name": "EventDescriptor",
        "description": "Metadata that identifies the event to write. For details, see        EVENT_DESCRIPTOR."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UserDataCount",
        "description": "Number of EVENT_DATA_DESCRIPTOR structures        in UserData. The maximum number is 128."
      },
      {
        "in_out": "_In_opt_",
        "type": "PEVENT_DATA_DESCRIPTOR",
        "name": "UserData",
        "description": "The event data to write. Allocate a block of memory that contains one or more        EVENT_DATA_DESCRIPTOR structures. Set this        parameter to NULL if UserDataCount is zero. The data must be        in the order specified in the manifest."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "Use this function to write an event.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful or one of the following values on error.  ",
    "remarks": "Event data written with this function requires a manifest. Since the manifest is embedded in the provider, the      provider must be available for a consumer  to consume the data written by the provider. Use the ActivityId and RelatedActivityId parameters when      several components want to relate their events in an end-to-end tracing scenario. For example, components A, B,      and C perform work on a related activity and want to link their events so that a consumer can consume  all the      events related to that activity.  ETW uses thread local storage to make available to the next component the      previous component's activity identifier. The component retrieves from the local storage the previous component's      identifier and sets the related activity identifier to it. The consumer can then use the related activity      identifier to walk the chain of the events from one component to the next. If each component defined their own activity identifier, the components can make the following calls to link       the events: A provider can define filters that a session uses to filter events based on event data. With level and keywords, ETW determines whether the event is written to the session but with filters, the provider uses the filter data to determine whether it writes the event to the session. For example, if your provider generates process events, you could define a data filter that filters process events based on the process identifier. If the identifier of the process did not match the identifier that the session passed as filter data, you would set (perform a bitwise OR) the Filter parameter to the session's instance identifier to prevent the event from being written to that session. For an example that uses EventWrite, see       Writing Manifest-based Events. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventWriteEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle of the provider. The handle comes from        EventRegister."
      },
      {
        "in_out": "_In_",
        "type": "PCEVENT_DESCRIPTOR",
        "name": "EventDescriptor",
        "description": "A descriptor that contains the metadata that identifies the event to write. For details, see        EVENT_DESCRIPTOR."
      },
      {
        "in_out": "_In_",
        "type": "ULONG64",
        "name": "Filter",
        "description": "The instance identifiers that identify the session to which the event will not written. Use a bitwise OR        to specify multiple identifiers. Set to zero if you do not support filters or if the event is being written to        all sessions (no filters failed). For information on getting the identifier for a session, see the        FilterData parameter of your        EnableCallback callback."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Reserved. Must be zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "ActivityId",
        "description": "GUID that uniquely identifies this activity. If NULL, ETW gets the identifier        from the thread local storage. For details on getting this identifier, see        EventActivityIdControl."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "RelatedActivityId",
        "description": "Activity identifier from the previous component. Use this parameter to link your component's events to the        previous component's events. To get the activity identifier that was set for the previous component, see the        descriptions for the ControlCode parameter of the        EventActivityIdControl        function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UserDataCount",
        "description": "Number of EVENT_DATA_DESCRIPTOR structures        in UserData. The maximum number is 128."
      },
      {
        "in_out": "_In_opt_",
        "type": "PEVENT_DATA_DESCRIPTOR",
        "name": "UserData",
        "description": "The event data to write. Allocate a block of memory that contains one or more        EVENT_DATA_DESCRIPTOR structures. Set this        parameter to NULL if UserDataCount is zero. The data must be        in the order specified in the manifest."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Writes an event that contains a string as its data.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Evntprov.h",
    "return_value": "Returns ERROR_SUCCESS if successful or one of the following values on error.  ",
    "remarks": "The provider does not need a manifest to use this function to write the event, unlike the      EventWrite function which does require a manifest.      Consumers also do not need a manifest to consume events written with this function. This function gets the acitivity identifier from the thread local storage, if set. ETW decides based on the level and keyword mask whether  the event is written to a session (for details, see      EnableTraceEx). This function cannot be used to write events to the Admin or Operational channels. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventWriteString",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGHANDLE",
        "name": "RegHandle",
        "description": "Registration handle of the provider. The handle comes from        EventRegister."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Level",
        "description": "Level of detail included in the event. If the provider uses a manifest to define the event, set this value        to the same level defined in the manifest. If the event is not defined in a manifest, set this value to 0 to        ensure the event is written, otherwise, the event is written based on the level rule defined in        EnableTraceEx."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "Keyword",
        "description": "Bitmask that specifies the event category. If the provider uses a manifest to define the event, set this        value to the same keyword mask defined in the manifest. If the event is not defined in a manifest, set this        value to 0 to ensure the event is written, otherwise, the event is written based on the keyword rules defined        in EnableTraceEx."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "String",
        "description": "Null-terminated string to write as the event data."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Consumers implement this function to  receive statistics about each buffer of events that ETW delivers to an event trace consumer. ETW calls this function after the events for each buffer are delivered.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "To continue processing events, return TRUE. Otherwise, return FALSE. \t\t\t\t\tReturning FALSE will terminate the ProcessTrace function. ",
    "remarks": "To specify the function that ETW calls to deliver the buffer statistics, set the  BufferCallback member of the  EVENT_TRACE_LOGFILE structure that you pass to the  OpenTrace function. For an example implementation of a  BufferCallback function, see  Retrieving Event Data Using MOF. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "BufferCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_TRACE_LOGFILE",
        "name": "Buffer",
        "description": "Pointer to an  EVENT_TRACE_LOGFILE structure that contains information about the buffer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CloseTrace function closes a trace.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Consumers call this function. If you are processing events from a log file, you call this function only after the       ProcessTrace function returns. However, if you are       processing real-time events, you can call this function before       ProcessTrace returns. If you call this function before       ProcessTrace returns, the       CloseTrace function returns ERROR_CTX_CLOSE_PENDING. The       ERROR_CTX_CLOSE_PENDING code indicates that the CloseTrace       function call was successful; the  ProcessTrace function       will stop processing events after it processes all events in its buffers       (ProcessTrace will not receive any new events after you       call the CloseTrace function). You can call the       CloseTrace function from your       BufferCallback,       EventCallback, or       EventClassCallback callback. Prior to Windows Vista:  You can call CloseTrace only after ProcessTrace returns. For an example that uses CloseTrace, see       Retrieving Event Data Using MOF. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "CloseTrace",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TRACEHANDLE",
        "name": "TraceHandle",
        "description": "Handle to the trace to close. The OpenTrace function        returns this handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Consumers implement this function to receive events from a session.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "The function does not return a value. ",
    "remarks": "To specify the function that ETW calls to deliver the events, set the  EventCallback member of the  EVENT_TRACE_LOGFILE structure that you pass to the  OpenTrace function. This callback receives all events that the session generates from the time you call the  OpenTrace function to open the trace. Call the ProcessTrace function to begin receiving the events. The event data for the first event you always receive contains the TRACE_LOGFILE_HEADER information. All the other events you receive contain provider-specific event data. You use the Header.Guid and Header.Class.Type members of EVENT_TRACE to determine the type of event you received. If you are consuming events from your own provider and know the layout of the data, this is not an issue. Otherwise, to interpret the event, the provider must have published their event schema in the \\\\root\\wmi namespace. For information on using an event's MOF schema to interpret the event, see Consuming Events. For an example implementation of an  EventCallback function, see  Retrieving Event Data Using MOF. ",
    "return_type": "VOID",
    "category": "Event Tracing",
    "name": "EventCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_TRACE",
        "name": "pEvent",
        "description": "Pointer to an  EVENT_TRACE structure that contains the event information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Consumers implement this callback to receive events from a session.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "The function does not return a value. ",
    "remarks": "To specify the function that ETW calls to deliver events, set the  EventRecordCallback member of the  EVENT_TRACE_LOGFILE structure (you pass this structure to the  OpenTrace function). You must also set the ProcessTraceMode member to PROCESS_TRACE_MODE_EVENT_RECORD. This callback receives all events that the session generates from the time you call the  OpenTrace function. Call the ProcessTrace function to begin receiving the events. For information on parsing the event data, see Retrieving Event Data Using TDH. ",
    "return_type": "VOID",
    "category": "Event Tracing",
    "name": "EventRecordCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "EventRecord",
        "description": "Pointer to an  EVENT_RECORD structure that contains the event information."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The OpenTrace function opens a real-time trace session or     log file for consuming.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, it returns a handle to the trace. If the function fails, it returns INVALID_PROCESSTRACE_HANDLE. If the function returns INVALID_PROCESSTRACE_HANDLE, you can use the         GetLastError function to obtain extended error         information. The following table lists some common errors and their causes.  ",
    "remarks": "Consumers call this function. After calling OpenTrace, call the      ProcessTrace function to process the events. When you have      finished processing events, call the CloseTrace      function. Note that you can process events from only one real-time session. Windows Vista and earlier: If the function fails it will returns INVALID_HANDLE_VALUE. To avoid      compile-time errors, cast INVALID_HANDLE_VALUE to TRACEHANDLE as follows:      (TRACEHANDLE)INVALID_HANDLE_VALUE. For an example that uses OpenTrace, see       Using TdhFormatProperty to Consume Event Data       or Retrieving Event Data Using MOF. ",
    "return_type": "TRACEHANDLE",
    "category": "Event Tracing",
    "name": "OpenTrace",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PEVENT_TRACE_LOGFILE",
        "name": "Logfile",
        "description": "Pointer to an EVENT_TRACE_LOGFILE structure.        The structure specifies the source from which to consume events (from a log file or the session in real time)        and specifies the callbacks the consumer wants to use to receive the events."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The ProcessTrace function delivers events from one or     more event tracing sessions to the consumer.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Consumers call this function. You must call the OpenTrace function prior to      calling ProcessTrace. The ProcessTrace function delivers the events to the      consumer's  BufferCallback,      EventCallback, and      EventClassCallback callback functions. The ProcessTrace function sorts the events      chronologically and delivers all events generated between StartTime and      EndTime. Note that events can appear out of order if the session specifies system time      as the clock (low resolution) and the volume of events is high. In this case, it is possible for multiple events      to contain the same time stamp. If multiple events contain the same time stamp, ETW cannot guarantee the order of      those events. The ProcessTrace function blocks the thread until it       delivers all events, the BufferCallback       function returns FALSE, or you call       CloseTrace. If the consumer is consuming events in real       time, the ProcessTrace function returns after the       controller stops the trace session. (Note that there may be a several-second delay before the function       returns.) Windows Server 2003:  You can call CloseTrace only after        ProcessTrace returns. For an example that uses ProcessTrace, see       Using TdhFormatProperty to Consume Event Data       or Retrieving Event Data Using MOF. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "ProcessTrace",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTRACEHANDLE",
        "name": "HandleArray",
        "description": "Pointer to an array of trace handles obtained from earlier calls to the         OpenTrace function. The number of handles that you can         specify is limited to 64. The array can contain the handles to multiple log files, but only one real-time trace session."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "HandleCount",
        "description": "Number of elements in HandleArray."
      },
      {
        "in_out": "_In_",
        "type": "LPFILETIME",
        "name": "StartTime",
        "description": "Pointer to an optional FILETIME structure that        specifies the beginning time period for which you want to receive events. The function does not deliver events        recorded prior to StartTime."
      },
      {
        "in_out": "_In_",
        "type": "LPFILETIME",
        "name": "EndTime",
        "description": "Pointer to an optional FILETIME structure that         specifies the ending time period for which you want to receive events. The function does not deliver events         recorded after  EndTime. Windows Server 2003:  This value is ignored for real-time event delivery."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The TdhAggregatePayloadFilters function aggregates multiple payload filters for a single provider into a single data structure for use with the EnableTraceEx2 function.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "On Windows 8.1,Windows Server 2012 R2, and later, event payload filters can be used by the EnableTraceEx2 function to filter on the specific content of the event in a logger session. The TdhAggregatePayloadFilters function aggregates payload filters for a single provider into a single data structure for use with the EnableTraceEx2 function. The TdhAggregatePayloadFilters allocates and fills in an opaque data structure for an aggregated payload filter. When the aggregated payload filter is no longer needed, the TdhCleanupPayloadEventFilterDescriptor function is used to free memory allocated for the aggregated  payload filter in the  EVENT_FILTER_DESCRIPTOR structure returned. For an example that uses  the TdhAggregatePayloadFilters function to aggregate payload filters to use in filtering on specific conditions in a logger session, see  the example for the EnableTraceEx2 function. ",
    "return_type": "ULONG TDHAPI",
    "category": "Event Tracing",
    "name": "TdhAggregatePayloadFilters",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "ULONG",
        "name": "PayloadFilterCount",
        "description": "The count of payload filters."
      },
      {
        "in_out": "",
        "type": "PVOID",
        "name": "PayloadFilterPtrs",
        "description": "An array of event payload single filters,         each created by a call to the TdhCreatePayloadFilter  function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PBOOLEAN",
        "name": "EventMatchAllFlags",
        "description": "An array of Boolean values  that correspond to         each payload filter passed in the PayloadFilterPtrs parameter and indicates how events are handled when multiple conditions are specified..  This parameter only affects situations where multiple         payload filters are being specified for the same event.   When a Boolean value is TRUE, an event will be written to a session if any of         the specified conditions specified in the filter are  TRUE. If this flag is set to TRUE on one or more filters for         the same event Id or event version, then the event is only written if all         the flagged filters for the event are satisfied.  When a Boolean value is FALSE, an event will be written to a session only if all of         the specified conditions specified in the filter are  TRUE. If this flag is set to FALSE on one or more filters for         the same event Id or event version, then the event is written if any of         the non-flagged filters are satisfied."
      },
      {
        "in_out": "_Out_",
        "type": "PEVENT_FILTER_DESCRIPTOR",
        "name": "EventFilterDescriptor",
        "description": "A pointer to an EVENT_FILTER_DESCRIPTOR structure to be used with the EnableTraceEx2 function.  The EVENT_FILTER_DESCRIPTOR structure will         contain a pointer to the aggregated payload filters, which have been         allocated by this function.   When the caller is finished using this         EVENT_FILTER_DESCRIPTOR structure with the EnableTraceEx2 function,  the  TdhCleanupPayloadEventFilterDescriptor  function should be called to free the allocated memory."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The TdhCleanupPayloadEventFilterDescriptor function frees the aggregated structure of payload filters created using the TdhAggregatePayloadFilters function.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "On Windows 8.1,Windows Server 2012 R2, and later, event payload filters can be used by the EnableTraceEx2 function to filter on specific content of the event in a logger session. The TdhCleanupPayloadEventFilterDescriptor function is used to free memory allocated that is returned by the TdhAggregatePayloadFilters function. For an example that uses  the TdhCleanupPayloadEventFilterDescriptor  function to free memory used by aggregate payload filters, see  the example for the EnableTraceEx2 function. ",
    "return_type": "ULONG TDHAPI",
    "category": "Event Tracing",
    "name": "TdhCleanupPayloadEventFilterDescriptor",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PEVENT_FILTER_DESCRIPTOR",
        "name": "PayloadEventFilterDescriptor",
        "description": "A pointer to an EVENT_FILTER_DESCRIPTOR structure that contains aggregated filters where the allocated memory is to be freed. The EVENT_FILTER_DESCRIPTOR structure  passed was created by calling the TdhAggregatePayloadFilters function.   If the call is successful, allocated memory is released for the aggregated filters and the fields in the returned EVENT_FILTER_DESCRIPTOR structure are re-initialized"
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Frees any resources associated with the input decoding handle.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG This function returns ERROR_SUCCESS on completion. ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhCloseDecodingHandle",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TDH_HANDLE",
        "name": "Handle",
        "description": "Type: TDH_HANDLE The decoding handle to be closed."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The TdhCreatePayloadFilter function  creates  a single filter for a single payload to be used with the EnableTraceEx2 function.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "On Windows 8.1,Windows Server 2012 R2, and later, event payload filters can be used by the EnableTraceEx2 function to filter on the specific content of  event in a logger session. The TdhCreatePayloadFilter function is used to create a single payload filter for a single payload to be used with the EnableTraceEx2 function.  The TdhCreatePayloadFilter allocates and fills in an opaque data structure for a single payload filter. When the payload filter is no longer needed, the TdhDeletePayloadFilter function is used to free memory allocated for a payload filter. For a single provider, multiple events can have distinct payload filters.  There can also be multiple filters for the same event, with a payload being passed to the session if any or all of the event's filters pass it. The EnableTraceEx2 function takes an array of EVENT_FILTER_DESCRIPTOR structures in  the ENABLE_TRACE_PARAMETERS structures passed in the EnableParameters parameter. There can only be one entry in the array for each event filter type. The TdhAggregatePayloadFilters function can be used  to aggregate a list of  payload filters for a single provider created using the TdhCreatePayloadFilter into a single data structure and return an EVENT_FILTER_DESCRIPTOR for use with the EnableTraceEx2 function. For an example that uses  the TdhCreatePayloadFilter function to create payload filters to use in filtering on specific conditions in a logger session, see  the example for the EnableTraceEx2 function. ",
    "return_type": "ULONG TDHAPI",
    "category": "Event Tracing",
    "name": "TdhCreatePayloadFilter",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "ProviderGuid",
        "description": "A GUID that identifies the manifest provider of the EventDescriptor parameter."
      },
      {
        "in_out": "_In_",
        "type": "PCEVENT_DESCRIPTOR",
        "name": "EventDescriptor",
        "description": "A pointer to the event descriptor whose payload will be filtered."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "EventMatchANY",
        "description": "A Boolean value that indicates how events are handled when multiple conditions are specified. When this parameter is TRUE, an event will be written to a session if any of         the specified conditions specified in the filter are  TRUE. When this parameter is FALSE, an event will be written to a session only if all of         the specified conditions specified in the filter are  TRUE."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PayloadPredicateCount",
        "description": "The number of conditions specified in the filter.         This value must be less than or equal to the ETW_MAX_PAYLOAD_PREDICATES constant defined in the Tdh.h header file."
      },
      {
        "in_out": "_In_",
        "type": "PPAYLOAD_FILTER_PREDICATE",
        "name": "PayloadPredicates",
        "description": "A pointer to an array of  PAYLOAD_FILTER_PREDICATE structures that contain the list conditions that the filter specifies."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "PayloadFilter",
        "description": "On success, this parameter returns a pointer to a single payload filter that is properly sized and built for the specified conditions. When the caller is finished using the returned payload filter with the EnableTraceEx2 function,  the TdhDeletePayloadFilter function should be called to free the allocated memory."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The TdhDeletePayloadFilter function frees the memory allocated for  a single payload filter by the TdhCreatePayloadFilter function.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "On Windows 8.1,Windows Server 2012 R2, and later, event payload filters can be used by the EnableTraceEx2 function to filter on the specific  content of the event in a logger session. The TdhDeletePayloadFilter function is used to free memory allocated for a single payload filter that is returned by the TdhCreatePayloadFilter function. ",
    "return_type": "ULONG TDHAPI",
    "category": "Event Tracing",
    "name": "TdhDeletePayloadFilter",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID*",
        "name": "PayloadFilterDescriptor",
        "description": "A pointer to a single payload filter allocated by the TdhCreatePayloadFilter function."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The TdhEnumerateManifestProviderEvents function retrieves the list of events present in the provider manifest.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "",
    "return_type": "ULONG TDHAPI",
    "category": "Event Tracing",
    "name": "TdhEnumerateManifestProviderEvents",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "ProviderGuid",
        "description": "A GUID that identifies the manifest provider whose list of events you want to retrieve."
      },
      {
        "in_out": "_Out_",
        "type": "PPROVIDER_EVENT_INFO",
        "name": "ProviderInfo",
        "description": "A user-allocated buffer to receive the list of events. For details, see the PROVIDER_EVENT_INFO  structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "BufferSize",
        "description": "The size, in bytes, of the buffer pointed to by the ProviderInfo parameter. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the specified field metadata for a given provider.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "This function uses the XML manifest or WMI MOF class to retrieve the information. The following example shows how to enumerate information contained in the manifest or MOF class for the requested field. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhEnumerateProviderFieldInformation",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "pGuid",
        "description": "GUID that identifies the provider whose information you want to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "EVENT_FIELD_TYPE",
        "name": "EventFieldType",
        "description": "Specify the type of field for which you want to retrieve information. For possible values, see the EVENT_FIELD_TYPE enumeration."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PPROVIDER_FIELD_INFOARRAY",
        "name": "pBuffer",
        "description": "User-allocated buffer to receive the field information. For details, see the PROVIDER_FIELD_INFOARRAY structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "pBufferSize",
        "description": "Size, in bytes, of the pBuffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The TdhEnumerateProviderFilters function enumerates the filters that the specified provider defined in the manifest.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "This function uses the XML manifest to retrieve the information. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhEnumerateProviderFilters",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "pGuid",
        "description": "GUID that identifies the provider whose filters you want to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TdhContextCount",
        "description": "Not used."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTDH_CONTEXT",
        "name": "pTdhContext",
        "description": "Not used."
      },
      {
        "in_out": "_In_",
        "type": "ULONG*",
        "name": "FilterCount",
        "description": "The number of filter structures that the pBuffer buffer contains. Is zero if the pBuffer buffer is insufficient."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PPROVIDER_FILTER_INFO*",
        "name": "pBuffer",
        "description": "User-allocated buffer to receive the filter information. For details, see the PROVIDER_FILTER_INFO structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "pBufferSize",
        "description": "Size, in bytes, of the pBuffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a list of providers that have registered a MOF class or manifest file on the computer.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "Because the number of registered event providers may fluctuate between calls to  this function, you should place this function in a loop that loops until the returned value is no longer ERROR_INSUFFICIENT_BUFFER. For an example that shows how to enumerate providers, see Enumerating Providers. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhEnumerateProviders",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PPROVIDER_ENUMERATION_INFO",
        "name": "pBuffer",
        "description": "Array of providers that publicly define  their events on the computer. For details, see the PROVIDER_ENUMERATION_INFO structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "pBufferSize",
        "description": "Size, in bytes, of the pBuffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "Formats a property value for display.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "Typically, you call this function in a loop.  Use the TRACE_EVENT_INFO.TopLevelPropertyCount member to control the loop (the TdhGetEventInformation function returns the  TRACE_EVENT_INFO structure). Before entering the loop, you set the UserData and UserDataLength parameters to the value of the UserData and UserDataLength members of the EVENT_RECORD structure, respectively. The EVENT_RECORD structure is passed to your EventRecordCallback callback function. Determine whether the property is an array. The property is an array if the EVENT_PROPERTY_INFO.Flags member is set to PropertyParamCount or the EVENT_PROPERTY_INFO.count member is greater than 1. Call the TdhFormatProperty function in a loop based on the number of elements in the array. After calling the TdhFormatProperty function, use the UserDataConsumed parameter value to set the new values of the UserData and UserDataLength parameters (Subtract UserDataConsumed from UserDataLength and use UserDataLength to increment the UserData pointer). If the property is an IP V6 address, you must set the PropertyLength parameter to the size of the IN6_ADDR structure. The property is considered an IP V6 address if the following conditions are met: For an example that shows how to call this function , see Using TdhFormatProperty to Consume Event Data. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhFormatProperty",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTRACE_EVENT_INFO",
        "name": "EventInfo",
        "description": "A TRACE_EVENT_INFO structure that contains the event information. To get this structure, call the TdhGetEventInformation function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PEVENT_MAP_INFO",
        "name": "MapInfo",
        "description": "An EVENT_MAP_INFO structure that maps integer and bit values to strings. To get this structure, call the TdhGetEventMapInformation function. To get the name of the map, use the MapNameOffset member of the EVENT_PROPERTY_INFO structure. If you do not provide the map information for a mapped property, the function formats the integer or bit value."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PointerSize",
        "description": "The size of a pointer value in the event data. To get the size, access the EVENT_RECORD.EventHeader.Flags member. The pointer size is 4 bytes if the EVENT_HEADER_FLAG_32_BIT_HEADER flag is set; otherwise, it is 8 bytes if the EVENT_HEADER_FLAG_64_BIT_HEADER flag is set. The EVENT_RECORD structure is passed to your EventRecordCallback callback function."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "PropertyInType",
        "description": "The input type of the property. Use the InType member of the EVENT_PROPERTY_INFO structure to set this parameter."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "PropertyOutType",
        "description": "The output type of the property. Use the OutType member of the EVENT_PROPERTY_INFO structure to set this parameter."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "PropertyLength",
        "description": "The length, in bytes, of the property. Use the Length member of the EVENT_PROPERTY_INFO structure to set this parameter."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "UserDataLength",
        "description": "The size, in bytes, of the UserData buffer. See Remarks."
      },
      {
        "in_out": "_In_",
        "type": "PBYTE",
        "name": "UserData",
        "description": "The buffer that contains the event data. See Remarks."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "BufferSize",
        "description": "The size, in bytes, of the Buffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PWCHAR",
        "name": "Buffer",
        "description": "A caller-allocated buffer that contains the formatted property value. To determine the required buffer size, set this parameterto NULL and BufferSize to zero."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "UserDataConsumed",
        "description": "The length, in bytes, of the consumed event data. Use this value to adjust the values of the UserData and UserDataLength parameters. See Remarks."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the value of a decoding parameter.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhGetDecodingParameter",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TDH_HANDLE",
        "name": "Handle",
        "description": "Type: TDH_HANDLE A valid decoding handle."
      },
      {
        "in_out": "_Inout_",
        "type": "PTDH_CONTEXT",
        "name": "TdhContext",
        "description": "Type: PTDH_CONTEXT Array of context values. The array must not contain duplicate context types."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves metadata about an event.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "If the event is a WPP or legacy ETW event, you can specify context information that is used to help parse the event information. The event is a WPP event if the EVENT_HEADER_FLAG_TRACE_MESSAGE flag is set in the Flags member of EVENT_HEADER (see the EventHeader member of EVENT_RECORD). The event is a legacy ETW event if the EVENT_HEADER_FLAG_CLASSIC_HEADER flag is set. For an example that shows how to retrieve metadata about an event, see Using TdhFormatProperty to Consume Event Data. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhGetEventInformation",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "pEvent",
        "description": "The event record passed to your EventRecordCallback callback. For details, see the EVENT_RECORD structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TdhContextCount",
        "description": "Number of elements in pTdhContext."
      },
      {
        "in_out": "_In_",
        "type": "PTDH_CONTEXT",
        "name": "pTdhContext",
        "description": "Array of context values for WPP or classic ETW events only; otherwise, NULL. For details, see the TDH_CONTEXT structure.  The array must not contain duplicate context types."
      },
      {
        "in_out": "_Out_",
        "type": "PTRACE_EVENT_INFO",
        "name": "pBuffer",
        "description": "User-allocated buffer to receive the event information. For details, see the TRACE_EVENT_INFO structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "pBufferSize",
        "description": "Size, in bytes, of the pBuffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves information about the event map contained in the event.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "You cannot use this function to retrieve event map information for WPP events. For maps defined in a manifest, the string will contain a space at the end of the string. For example, if the value is mapped to \"Monday\" in the manifest, the string is returned as \"Monday \". For an example that shows how to call this function, see Using TdhGetProperty to Consume Event Data. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhGetEventMapInformation",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "pEvent",
        "description": "The event record passed to your EventRecordCallback callback. For details, see the EVENT_RECORD structure."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "pMapName",
        "description": "Null-terminated Unicode string that contains the name of the map attribute value. The name comes from the MapNameOffset member of the EVENT_PROPERTY_INFO structure."
      },
      {
        "in_out": "_Out_",
        "type": "PEVENT_MAP_INFO",
        "name": "pBuffer",
        "description": "User-allocated buffer to receive the event map. The map could be a value map, bitmap, or pattern map. For details, see the EVENT_MAP_INFO structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "pBufferSize",
        "description": "Size, in bytes, of the pBuffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The TdhGetManifestEventInformation function retrieves metadata about an event in  a manifest.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "",
    "return_type": "ULONG TDHAPI",
    "category": "Event Tracing",
    "name": "TdhGetManifestEventInformation",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "ProviderGuid",
        "description": "A GUID that identifies the manifest provider whose event metadata you want to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_DESCRIPTOR",
        "name": "EventDescriptor",
        "description": "A pointer to the event descriptor that contains information such as event id, version, op-code, and keyword. For details, see the EVENT_DESCRIPTOR structure"
      },
      {
        "in_out": "_Out_",
        "type": "PTRACE_EVENT_INFO",
        "name": "Buffer",
        "description": "A user-allocated buffer to receive the metadata about an event in  a provider manifest. For details, see the TRACE_EVENT_INFO structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "BufferSize",
        "description": "The size, in bytes, of the buffer pointed to by the Buffer parameter. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Retrieves a property value from the event data.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "If the event is a WPP or classic ETW event, you can specify context information that is used to help parse the event information. The event is a WPP event if the EVENT_HEADER_FLAG_TRACE_MESSAGE flag is set in the Flags member of EVENT_HEADER (see the EventHeader member of EVENT_RECORD). The event is a legacy ETW event if the EVENT_HEADER_FLAG_CLASSIC_HEADER flag is set. For a list of properties for WPP events and their data types, see PROPERTY_DATA_DESCRIPTOR. For an example that shows how to call this function to retrieve the value of a top-level property or the member of a structure, see Using TdhGetProperty to Consume Event Data. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhGetProperty",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "pEvent",
        "description": "The event record passed to your EventRecordCallback callback. For details, see the EVENT_RECORD structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TdhContextCount",
        "description": "Number of elements in pTdhContext."
      },
      {
        "in_out": "_In_",
        "type": "PTDH_CONTEXT",
        "name": "pTdhContext",
        "description": "Array of context values for WPP or classic ETW events only; otherwise, NULL. For details, see the TDH_CONTEXT structure.  The array must not contain duplicate context types."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PropertyDataCount",
        "description": "Number of data descriptor structures in pPropertyData."
      },
      {
        "in_out": "_In_",
        "type": "PPROPERTY_DATA_DESCRIPTOR",
        "name": "pPropertyData",
        "description": "Array of PROPERTY_DATA_DESCRIPTOR structures that defines the property to retrieve.  If you called  the TdhGetPropertySize function to retrieve the required buffer size for the property, you can use the same data descriptors. If you are retrieving a property that is not a member of a structure, you can specify a single data descriptor. If you are retrieving a property that is a member of a structure, specify an array of two  data descriptors (structures cannot contain or reference other structures)."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BufferSize",
        "description": "Size of the pBuffer buffer, in bytes. You can get this value from the pPropertySize parameter when calling TdhGetPropertySize function."
      },
      {
        "in_out": "_Out_",
        "type": "PBYTE",
        "name": "pBuffer",
        "description": "User-allocated buffer that receives the property data."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves the size of one or more property values in the event data.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "If the event is a WPP or classic ETW event, you can specify context information that is used to help parse the event information. The event is a WPP event if the EVENT_HEADER_FLAG_TRACE_MESSAGE flag is set in the Flags member of EVENT_HEADER (see the EventHeader member of EVENT_RECORD). The event is a legacy ETW event if the EVENT_HEADER_FLAG_CLASSIC_HEADER flag is set. For an example that shows how to call this function, see Using TdhGetProperty to Consume Event Data. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhGetPropertySize",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "pEvent",
        "description": "The event record passed to your EventRecordCallback callback. For details, see the EVENT_RECORD structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TdhContextCount",
        "description": "Number of elements in pTdhContext."
      },
      {
        "in_out": "_In_",
        "type": "PTDH_CONTEXT",
        "name": "pTdhContext",
        "description": "Array of context values for WPP or classic ETW events only, otherwise, NULL. For details, see the TDH_CONTEXT structure.  The array must not contain duplicate context types."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PropertyDataCount",
        "description": "Number of data descriptor structures in pPropertyData."
      },
      {
        "in_out": "_In_",
        "type": "PPROPERTY_DATA_DESCRIPTOR",
        "name": "pPropertyData",
        "description": "Array of PROPERTY_DATA_DESCRIPTOR structures that define the property whose size you want to retrieve. You can pass this same array  to the TdhGetProperty function to retrieve the property data. If you are retrieving the size of a property that is not a member of a structure, you can specify a single data descriptor. If you are retrieving the size of a property that is a member of a structure, specify an array of two  data descriptors (structures cannot contain or reference other structures). For more information on specifying this parameter, see the example code below."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pPropertySize",
        "description": "Size of the property, in bytes. Use this value to allocate the buffer passed in the pBuffer parameter of the TdhGetProperty function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the formatted WPP message embedded into an EVENT_RECORD structure.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "To retrieve a specific property instead of the decoded event message without specifying a property name, call TdhGetWppProperty. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhGetWppMessage",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TDH_HANDLE",
        "name": "Handle",
        "description": "Type: TDH_HANDLE A valid decoding handle."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "EventRecord",
        "description": "Type: PEVENT_RECORD The event record passed to your EventRecordCallback callback."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "BufferSize",
        "description": "Type: PULONG Size of the Buffer parameter, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PBYTE",
        "name": "Buffer",
        "description": "Type: PBYTE User-allocated buffer that receives the property data."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves a specific property associated with a WPP message.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "To retrieve only the decoded event message without specifying a property name, call TdhGetWppMessage. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhGetWppProperty",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TDH_HANDLE",
        "name": "Handle",
        "description": "Type: TDH_HANDLE A valid decoding handle."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_RECORD",
        "name": "EventRecord",
        "description": "Type: PEVENT_RECORD The event record passed to your EventRecordCallback callback."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "PropertyName",
        "description": "Type: PWSTR The name of the property to retrieve. For a list of  possible values, see PROPERTY_DATA_DESCRIPTOR."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "BufferSize",
        "description": "Type: PULONG Size of the Buffer parameter, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PBYTE",
        "name": "Buffer",
        "description": "Type: PBYTE User-allocated buffer that receives the property data."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Loads the manifest used to decode a log file.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "To consume events, TDH requires the provider's manifest. Typically, you decode the log file on a computer that contains the provider. Since the provider includes the mainifest as a resource, TDH uses the provider to get the manifest. To decode the log file on a computer that does not contain the provider, you must first use the  TraceRpt.exe executable to export the manifest (see the \u00e2\u0080\u0093export switch) from the provider on a computer that does contain the provider. After you have the manifest file, you can decode the log file on a computer that does not contain the provider. You need to call this function before decoding the first event. For example, you can call this function before calling the OpenTrace function. After processing all the events, call the TdhUnloadManifest function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhLoadManifest",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "Manifest",
        "description": "The full path to the manifest."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Takes a NULL-terminated path to a binary file that contains metadata resources needed to decode a specific event provider.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "The GUIDs     and BinaryPath string are cached. When metadata is      requested for a given event or provider, but the provider is not installed in the system, the cache     of binaries will be searched. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhLoadManifestFromBinary",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "BinaryPath",
        "description": "Type: PWSTR Path to the ETW provider binary that contains the metadata resources."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Opens a decoding handle.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "Call TdhCloseDecodingHandle to free the returned handle. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhOpenDecodingHandle",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PTDH_HANDLE",
        "name": "Handle",
        "description": "Type: PTDH_HANDLE A valid decoding handle."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information for the specified field from the event descriptions for those field values that match the given value.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "This function uses the XML manifest or WMI MOF class to retrieve the information. The following example shows how to query information contained in the manifest or MOF class for the requested field. ",
    "return_type": "ULONG __stdcall",
    "category": "Event Tracing",
    "name": "TdhQueryProviderFieldInformation",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "pGuid",
        "description": "GUID that identifies the provider whose information you want to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "EventFieldValue",
        "description": "Retrieve information about the field if the field's value matches this value. If the field type is a keyword, the information is retrieved for each event keyword bit contained in the mask."
      },
      {
        "in_out": "_In_",
        "type": "EVENT_FIELD_TYPE",
        "name": "EventFieldType",
        "description": "Specify the type of field for which you want to retrieve information. For possible values, see the EVENT_FIELD_TYPE enumeration."
      },
      {
        "in_out": "_Out_",
        "type": "PPROVIDER_FIELD_INFOARRAY",
        "name": "pBuffer",
        "description": "User-allocated buffer to receive the field information. For details, see the PROVIDER_FIELD_INFOARRAY structure."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "pBufferSize",
        "description": "Size, in bytes, of the pBuffer buffer. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_INSUFFICIENT_BUFFER and sets this parameter to the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the value of a  decoding parameter.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Type: ULONG Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhSetDecodingParameter",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TDH_HANDLE",
        "name": "Handle",
        "description": "Type: TDH_HANDLE A valid decoding handle."
      },
      {
        "in_out": "_In_",
        "type": "PTDH_CONTEXT",
        "name": "TdhContext",
        "description": "Type: PTDH_CONTEXT Array of context values. The array must not contain duplicate context types."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Unloads the manifest that was loaded by the TdhLoadManifest function.",
    "library": "Tdh.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Tdh.h",
    "return_value": "Returns ERROR_SUCCESS if successful. Otherwise, this function returns one of the following return codes in addition to others.  ",
    "remarks": "You must call this function after processing all the events. For example, you can call this function after calling CloseTrace. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "TdhUnloadManifest",
    "is_callback": 0,
    "dll": "Tdh.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "Manifest",
        "description": "The full path to the loaded manifest."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Adds or modifies the permissions of the specified provider or session.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012;  Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntcons.h",
    "return_value": "Returns ERROR_SUCCESS if successful. ",
    "remarks": "By default, only the administrator of the computer, users in the Performance Log Users group, and services       running as LocalSystem, LocalService, NetworkService can control trace sessions and provide and consume event       data. Only users with administrative privileges and services running as LocalSystem can start and control an       NT Kernel Logger session. Windows Server 2003:  Only users with administrator privileges can control trace sessions and consume event data; any user can provide event data. Windows XP and Windows 2000:  Any user can control trace sessions and provide and consume event data. Users with administrator privileges can control trace sessions if the tool that they use to control the session       is started from a Command Prompt window that is opened with       Run as administrator.... To grant a restricted user the ability to control trace sessions, you can add them to the Performance Log Users      group or call this function to grant them permission. For example, you can grant user A permission to start and      stop a trace session and grant user B permission to only query the session. To restrict who can log events to the session, see the TRACELOG_LOG_EVENT permission. The ACL on the log file determines who can consume event data from the log file. To consume events from a      session in real-time, you must grant the user TRACELOG_ACCESS_REALTIME permission or the user must be a member of      the Performance Log Users group. You can also specify the provider's GUID to restrict who can register the provider and who can enable the      provider. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventAccessControl",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "Guid",
        "description": "GUID that uniquely identifies the provider or session whose permissions you want to add or modify."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Operation",
        "description": "Type of operation to perform, for example, add a DACL to the session's GUID or provider's GUID. For        possible values, see the EVENTSECURITYOPERATION        enumeration."
      },
      {
        "in_out": "_In_",
        "type": "PSID",
        "name": "Sid",
        "description": "The security identifier (SID) of the user  or group to whom you want to grant or deny permissions."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Rights",
        "description": "You can specify one or more of the following permissions:  ValueMeaning  WMIGUID_QUERY   Allows the user to query information about the trace session. Set this permission on the session's          GUID.   TRACELOG_CREATE_REALTIME   Allows the user to start or update a real-time session. Set this permission on the session's GUID.   TRACELOG_CREATE_ONDISK   Allows the user to start or update a session that writes events  to a log file. Set this permission on          the session's GUID.   TRACELOG_GUID_ENABLE   Allows the user to enable the provider. Set this permission on the provider's GUID.   TRACELOG_ACCESS_KERNEL_LOGGER   Not used.   TRACELOG_LOG_EVENT   Allows the user to log events to a trace session if session is running in  SECURE mode (the session set          the EVENT_TRACE_SECURE_MODE flag in the LogFileMode member of EVENT_TRACE_PROPERTIES).   TRACELOG_ACCESS_REALTIME   Allows a user to consume events in real-time. Set this permission on the session's GUID.   TRACELOG_REGISTER_GUIDS   Allows the user to register the provider.  Set this permission on the provider's GUID."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "AllowOrDeny",
        "description": "If TRUE, grant the user permissions to the session or provider; otherwise, deny        permissions. This value is ignored if the value of Operation is EventSecuritySetSACL        or EventSecurityAddSACL."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the permissions for the specified controller or provider.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntcons.h",
    "return_value": "Returns ERROR_SUCCESS if successful. The function returns the following return code if an error occurs:  ",
    "remarks": "If the GUID does not exist in the registry, ETW returns the default permissions for a provider or controller. For details on specifying the GUID in the registry, see EventAccessControl. For information on accessing the components of the security descriptor, see Getting Information from an ACL, the GetSecurityDescriptorDacl, GetSecurityDescriptorSacl, and GetAce functions, and the ACE structure. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventAccessQuery",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "Guid",
        "description": "GUID that uniquely identifies the provider or session."
      },
      {
        "in_out": "_Inout_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "Buffer",
        "description": "Application-allocated buffer that will contain the security descriptor of the controller or provider."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "BufferSize",
        "description": "Size of the security descriptor buffer, in bytes. If the function succeeds, this parameter receives the size of the buffer used. If the buffer is too small, the function returns ERROR_MORE_DATA and this parameter receives the required buffer size. If the buffer size is zero on input, no data is returned in the buffer and this parameter receives the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Removes the permissions defined in the registry for the specified provider or session.",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Evntcons.h",
    "return_value": "Returns ERROR_SUCCESS if successful. ",
    "remarks": "After removing the permission from the registry, the default permissions apply to the provider or session. For      details on the default permissions, see      EventAccessControl. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "EventAccessRemove",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "Guid",
        "description": "GUID that uniquely identifies the provider or session whose permissions you want to remove from the        registry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[Do not implement this function; it may be unavailable in subsequent versions.]",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "The function does not return a value. ",
    "remarks": "To associate each  EventClassCallback function with the class GUID of the event trace class it processes, use the  SetTraceCallback function. To stop the  EventClassCallback from receiving events, call the  RemoveTraceCallback function. To processes all events that the session generates, see the  EventCallback function. If you use both EventCallback and EventClassCallback to receive events, the event is always sent to EventCallback and is only sent to EventClassCallback if the event matches the class GUID associated with the callback. You use the Header.Class.Type member of EVENT_TRACE to determine the type of event you received. If you are consuming events from your own provider and know the layout of the data, this is not an issue. Otherwise, to interpret the event, the provider must have published their event schema in the \\\\root\\wmi namespace. For information on using an event's MOF schema to interpret the event, see Consuming Events. ",
    "return_type": "VOID",
    "category": "Event Tracing",
    "name": "EventClassCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PEVENT_TRACE",
        "name": "pEvent",
        "description": "Pointer to an  EVENT_TRACE structure that contains the  event information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[Do not use this function; it may be unavailable in subsequent versions.]",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Consumers call this function. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "RemoveTraceCallback",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "pGuid",
        "description": "Pointer to the class GUID of the event trace class for which the callback receives events. Use the same        class GUID that you passed to the SetTraceCallback        to begin receiving the events."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[Do not use this function; it may be unavailable in subsequent versions. Instead, filter      for the event trace class in your      EventRecordCallback function.]",
    "library": "Sechost.lib on Windows 8.1 and Windows Server 2012 R2;  Advapi32.lib on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Evntrace.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the         system error codes. The following table includes some         common errors and their causes.  ",
    "remarks": "Consumers call this function. You can only specify one callback function for an event trace class. If you specify more than one callback      function for the even trace class, the last callback function receives the events for that event trace class. To stop the callback function from receiving events for the event trace class, call the      RemoveTraceCallback function. The callback      automatically stops receiving callbacks when you close the trace. You can use this function to receive events written using one of the      TraceEvent functions. You cannot use this function to      consume events from a provider that used one of the      EventWrite functions to log events. ",
    "return_type": "ULONG",
    "category": "Event Tracing",
    "name": "SetTraceCallback",
    "is_callback": 0,
    "dll": "Sechost.dll on Windows 8.1 and Windows Server 2012 R2;  Advapi32.dll on Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista and Windows XP",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "pGuid",
        "description": "Pointer to the class GUID of an event trace class for which you want to receive events. For a list of        kernel provider class GUIDs, see        NT Kernel Logger Constants."
      },
      {
        "in_out": "_In_",
        "type": "PEVENT_CALLBACK",
        "name": "EventCallback",
        "description": "Pointer to an EventClassCallback        function used to process events belonging to the event trace class."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]