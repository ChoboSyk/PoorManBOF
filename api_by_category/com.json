[
  {
    "n_arguments": 4,
    "description": "Locates an object by means of its moniker, activates the object if it is inactive, and retrieves a pointer to the specified interface on that object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the following error codes, or any of the error values returned by the IMoniker::BindToObject method.  ",
    "remarks": "BindMoniker is a helper function supplied as a convenient way for a client that has the moniker of an object to obtain a pointer to one of that object's interfaces. BindMoniker packages the following calls: CreateBindCtx creates a bind context object that supports the system implementation of IBindContext. The pmk parameter is actually a pointer to the IMoniker implementation on a moniker object. This implementation's BindToObject method supplies the pointer to the requested interface pointer. If you have several monikers to bind in quick succession and if you know that those monikers will activate the same object, it may be more efficient to call the IMoniker::BindToObject method directly, which enables you to use the same bind context object for all the monikers. See the IBindCtx interface for more information. Container applications that allow their documents to contain linked objects are a special client that generally does not make direct calls to IMoniker methods. Instead, the client manipulates the linked objects through the IOleLink interface. The default handler implements this interface and calls the appropriate IMoniker methods as needed. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "BindMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPMONIKER",
        "name": "pmk",
        "description": "A pointer to the object's moniker. See IMoniker."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "grfOpt",
        "description": "This parameter is reserved for future use and must be 0."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "iidResult",
        "description": "The interface identifier to be used to communicate with the object."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID*",
        "name": "ppvResult",
        "description": "The address of pointer variable that receives the interface pointer requested in iidResult. Upon successful return, *ppvResult contains the requested interface pointer. If an error occurs, *ppvResult is NULL. If the call is successful, the caller is responsible for releasing the pointer with a call to the object's IUnknown::Release method."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Looks up a CLSID in the registry, given a ProgID.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "Given a ProgID, CLSIDFromProgID looks up its associated CLSID in the registry. If the ProgID cannot be found in the registry, CLSIDFromProgID creates an OLE 1 CLSID for the ProgID and a CLSID entry in the registry. Because of the restrictions placed on OLE 1 CLSID values, CLSIDFromProgID and CLSIDFromString are the only two functions that can be used to generate a CLSID for an OLE 1 object. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CLSIDFromProgID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpszProgID",
        "description": "A pointer to the ProgID whose CLSID is requested."
      },
      {
        "in_out": "_Out_",
        "type": "LPCLSID",
        "name": "lpclsid",
        "description": "Receives a pointer to the retrieved CLSID on return."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Triggers automatic installation if the COMClassStore policy is enabled.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "CLSCTX_ENABLE_CODE_DOWNLOAD enables automatic installation of missing classes through IntelliMirror/Application Management from the Active Directory. If this flag is not specified, the COMClassStore Policy (\"Download missing COM components\") determines the behavior (default: no download). If the COMClassStore Policy enables automatic installation, CLSCTX_NO_CODE_DOWNLOAD can be used to explicitly disallow download for an activation. If either of the following registry values are enabled (meaning set to 1), automatic download of missing classes is enabled: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CLSIDFromProgIDEx",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpszProgID",
        "description": "A pointer to the ProgID whose CLSID is requested."
      },
      {
        "in_out": "_Out_",
        "type": "LPCLSID",
        "name": "lpclsid",
        "description": "Receives a pointer to the retrieved CLSID on return."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Converts a string generated by the StringFromCLSID function back into the original CLSID.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CLSIDFromString",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpsz",
        "description": "The string representation of the CLSID."
      },
      {
        "in_out": "_Out_",
        "type": "LPCLSID",
        "name": "pclsid",
        "description": "A pointer to the CLSID."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Converts a CLSID into a string of printable characters. Different CLSIDs always convert to different strings.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and S_OK. ",
    "remarks": "StringFromCLSID calls the StringFromGUID2 function to convert a globally unique identifier (GUID) into a string of printable characters. The caller is responsible for freeing the memory allocated for the string by calling the CoTaskMemFree function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "StringFromCLSID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID to be converted."
      },
      {
        "in_out": "_Out_",
        "type": "LPOLESTR*",
        "name": "lplpsz",
        "description": "The address of a pointer variable that receives a pointer to the resulting string. The string that represents rclsid includes enclosing braces."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Increments a global per-process reference count.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "The current reference count. ",
    "remarks": "Servers can call CoAddRefServerProcess to increment a global per-process reference count. This function is particularly helpful to servers that are implemented with multiple threads, either multi-apartmented or free-threaded. Servers of these types must coordinate the decision to shut down with activation requests across multiple threads. Calling CoAddRefServerProcess increments a global per-process reference count, and calling CoReleaseServerProcess decrements that count. When that count reaches zero, OLE automatically calls CoSuspendClassObjects, which prevents new activation requests from coming in. This permits the server to deregister its class objects from its various threads without worry that another activation request may come in. New activation requests result in launching a new instance of the local server process. The simplest way for a local server application to make use of these functions is to call CoAddRefServerProcess in the constructor for each of its instance objects, and in each of its IClassFactory::LockServer methods when the fLock parameter is TRUE. The server application should also call CoReleaseServerProcess in the destruction of each of its instance objects, and in each of its LockServer methods when the fLock parameter is FALSE. Finally, the server application should pay attention to the return code from CoReleaseServerProcess and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call CoRevokeClassObject and CoUninitialize. If these functions are used at all, they must be called in both the object instances and the LockServer method, otherwise the server application may be shut down prematurely. In-process servers typically should not call CoAddRefServerProcess or CoReleaseServerProcess. ",
    "return_type": "ULONG",
    "category": "COM",
    "name": "CoAddRefServerProcess",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "This function passes the foreground privilege (the privilege to set the foreground window) from one process to another. The process that has the foreground privilege can call this function to pass that privilege on to a local COM server process. Note that calling CoAllowSetForegroundWindow only confers the privilege; it does not set the foreground window itself. Foreground and focus are only taken away from the client application when the target COM server calls either SetForegroundWindow or another API that does so indirectly.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "The system restricts which processes can call the      SetForegroundWindow and      AllowSetForegroundWindow functions to      set the foreground window. As a result, an application is blocked from stealing the focus from another application      even when the user is interacting with it. Use CoAllowSetForegroundWindow to pass on the foreground privilege from a process that has it to a process that does not yet have it. This can be done transitively: passing the privilege from one process to another, and then to another, and so on. CoAllowSetForegroundWindow enables a user      that has a custom interface to get the same behavior that happens for OLE interfaces where a change of window is      expected (primarily associated with linking and embedding). Behind the scenes, the IForegroundTransfer interface is used to yield the foreground window between processes. A standard COM-provided proxy already implements IForegroundTransfer, so you don't have to do any extra work if you're using a standard proxy. Just call CoAllowSetForegroundWindow to transfer the foreground privilege to any out-of-process COM object. The following example demonstrates how a client process can create a local COM server, call CoAllowSetForegroundWindow to transfer the foreground privilege, and then call a function on  the COM server that in turn directly or indirectly calls SetForegroundWindow. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoAllowSetForegroundWindow",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IUnknown*",
        "name": "pUnk",
        "description": "A pointer to the IUnknown interface on the proxy of the        target COM server."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvReserved",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Adds an unmarshaler CLSID to the allowed list for the calling process only.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2012",
    "header": "Combaseapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "Don't call the CoAllowUnmarshalerCLSID function until after CoInitializeSecurity has been called in the current process. The CoAllowUnmarshalerCLSID function provides more granular control over unmarshaling policy than is provided by the policy options. If the process applies any unmarshaling policy, the effect of the CoAllowUnmarshalerCLSID function is to make the policy comparatively weaker. For this reason, only call CoAllowUnmarshalerCLSID when the security impact is well understood. Usually, this is used to facilitate applying a stronger unmarshaling policy option for the broad attack surface reduction this provides, when a specific unmarshaler CLSID not allowed by that option is needed due to other constraints. For example, it's appropriate to call the CoAllowUnmarshalerCLSID function when an unmarshaler is known or believed to have a vulnerability but is required by an app. Also, it's appropriate to call CoAllowUnmarshalerCLSID if the unmarshaler is used in multiple processes, but only as part of an uncommon feature. Don't use the CoAllowUnmarshalerCLSID function as a replacement for hardening the unmarshaler. ",
    "return_type": "HRESULT WINOLEAPI",
    "category": "COM",
    "name": "CoAllowUnmarshalerCLSID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsid",
        "description": "The CLSID of the unmarshaler to be added to the per-process allowed list."
      }
    ],
    "min_client": "Windows 8"
  },
  {
    "n_arguments": 2,
    "description": "Requests cancellation of an outbound DCOM method call pending on a specified thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "CoCancelCall calls CoGetCancelObject and then ICancelMethodCalls::Cancel on the cancel object for the call being executed. This function does not locate cancel objects for asynchronous calls. The object server can determine if the call has been canceled by periodically calling CoTestCancel. If the call has been canceled, the object server should clean up and return control to the client. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoCancelCall",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwThreadId",
        "description": "The identifier of the thread on which the pending DCOM call is to be canceled. If this parameter is 0, the call is on the current thread."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulTimeout",
        "description": "The number of seconds CoCancelCall waits for the server to complete the outbound call after the client requests cancellation."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Makes a private copy of the specified proxy.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "CoCopyProxy makes a private copy of the specified proxy. Typically, this function is called when a client needs to change the authentication information of its proxy through a call to either CoSetProxyBlanket or IClientSecurity::SetBlanket without changing this information for other clients. CoSetProxyBlanket affects all the users of an instance of a proxy, so creating a private copy of the proxy through a call to CoCopyProxy and then calling CoSetProxyBlanket (or IClientSecurity::SetBlanket) using the copy eliminates the problem. This helper function encapsulates the following sequence of common calls (error handling excluded): Local interfaces may not be copied. IUnknown and IClientSecurity are examples of existing local interfaces. Copies of the same proxy have a special relationship with respect to QueryInterface. Given a proxy, a, of the IA interface of a remote object, suppose a copy of a is created, called b. In this case, calling QueryInterface from the b proxy for IID_IA will not retrieve the IA interface on b, but the one on a, the original proxy with the \"default\" security settings for the IA interface. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoCopyProxy",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IUnknown*",
        "name": "pProxy",
        "description": "A pointer to the IUnknown interface on the proxy to be copied. This parameter cannot be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "IUnknown**",
        "name": "ppCopy",
        "description": "Address of the pointer variable that receives the interface pointer to the copy of the proxy. This parameter cannot be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Creates an aggregatable object capable of context-dependent marshaling.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_OUTOFMEMORY, as well as the following value.  ",
    "remarks": "The CoCreateFreeThreadedMarshaler function enables an object to efficiently marshal interface pointers between threads in the same process. If your objects do not support interthread marshaling, you have no need to call this function. It is intended for use by free-threaded DLL servers that must be accessed directly by all threads in a process, even those threads associated with single-threaded apartments. It custom-marshals the real memory pointer over into other apartments as a bogus \"proxy\" and thereby gives direct access to all callers, even if they are not free-threaded. The CoCreateFreeThreadedMarshaler function performs the following tasks: The aggregating object's implementation of IMarshal should delegate QueryInterface calls for IID_IMarshal to the IUnknown of the free-threaded marshaler. Upon receiving a call, the free-threaded marshaler performs the following tasks: Values for dwDestContext come from the MSHCTX enumeration. MSHCTX_INPROC indicates that the interface pointer is to be marshaled between different threads in the same process. Because both threads have access to the same address space, the client thread can dereference the pointer directly rather than having to direct calls to a proxy. In all other cases, a proxy is required, so CoCreateFreeThreadedMarshaler delegates the marshaling job to COM's default implementation. Great care should be exercised in using the CoCreateFreeThreadedMarshaler function. This is because the performance of objects which aggregate the free-threaded marshaler is obtained through a calculated violation of the rules of COM, with the ever-present risk of undefined behavior unless the object operates within certain restrictions. The most important restrictions are: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoCreateFreeThreadedMarshaler",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "punkOuter",
        "description": "A pointer to the aggregating object's controlling IUnknown."
      },
      {
        "in_out": "_Out_",
        "type": "LPUNKNOWN*",
        "name": "ppunkMarshal",
        "description": "Address of the pointer variable that receives the interface pointer to the aggregatable marshaler."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Creates a GUID, a unique 128-bit integer used for CLSIDs and interface identifiers.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": " Errors returned by UuidCreate are wrapped as an HRESULT. ",
    "remarks": "The CoCreateGuid function calls the RPC function UuidCreate, which creates a GUID, a globally unique 128-bit integer. Use CoCreateGuid when you need an absolutely unique number that you will use as a persistent identifier in a distributed environment.To a very high degree of certainty, this function returns a unique value \u00e2\u0080\u0093 no other invocation, on the same or any other system (networked or not), should return the same value. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoCreateGuid",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "GUID*",
        "name": "pguid",
        "description": "A pointer to the requested GUID."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Creates a single uninitialized object of the class associated with a specified CLSID.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "The CoCreateInstance function provides a convenient shortcut by connecting to the class object associated with the specified CLSID, creating an uninitialized instance, and releasing the class object. As such, it encapsulates the following functionality: It is convenient to use CoCreateInstance when you need to create only a single instance of an object on the local machine. If you are creating an instance on remote computer, call CoCreateInstanceEx. When you are creating multiple instances, it is more efficient to obtain a pointer to the class object's IClassFactory interface and use its methods as needed. In the latter case, you should use the CoGetClassObject function. In the CLSCTX enumeration, you can specify the type of server used to manage the object. The constants can be CLSCTX_INPROC_SERVER, CLSCTX_INPROC_HANDLER, CLSCTX_LOCAL_SERVER, CLSCTX_REMOTE_SERVER or any combination of these values. The constant CLSCTX_ALL is defined as the combination of all four. For more information about the use of one or a combination of these constants, see CLSCTX. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoCreateInstance",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID associated with the data and code that will be used to create the object."
      },
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnkOuter",
        "description": "If NULL, indicates that the object is not being created as part of an aggregate. If non-NULL, pointer to the aggregate object's IUnknown interface (the controlling IUnknown)."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsContext",
        "description": "Context in which the code that manages the newly created object will run. The values are taken from the enumeration CLSCTX."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of the interface to be used to communicate with the object."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID*",
        "name": "ppv",
        "description": "Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the requested interface pointer. Upon failure, *ppv contains NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Creates an instance of a specific class on a specific computer.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "CoCreateInstanceEx creates a single uninitialized object associated with the given CLSID on a specified remote computer. This is an extension of the function CoCreateInstance, which creates an object on the local computer only. In addition, rather than requesting a single interface and obtaining a single pointer to that interface, CoCreateInstanceEx makes it possible to specify an array of structures, each pointing to an interface identifier (IID) on input, and, on return, containing (if available) a pointer to the requested interface and the return value of the QueryInterface call for that interface. This permits fewer round trips between computers. This function encapsulates three calls: first, to CoGetClassObject to connect to the class object associated with the specified CLSID, specifying the location of the class; second, to IClassFactory::CreateInstance to create an uninitialized instance, and finally, to IClassFactory::Release, to release the class object. The object so created must still be initialized through a call to one of the initialization interfaces (such as IPersistStorage::Load). Two functions, CoGetInstanceFromFile and CoGetInstanceFromIStorage encapsulate both the instance creation and initialization from the obvious sources. The COSERVERINFO structure passed as the pServerInfo parameter contains the security settings that COM will use when creating a new instance of the specified object. Note that this parameter does not influence the security settings used when making method calls on the instantiated object. Those security settings are configurable, on a per-interface basis, with the CoSetProxyBlanket function. Also see, IClientSecurity::SetBlanket. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoCreateInstanceEx",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID of the object to be created."
      },
      {
        "in_out": "_In_",
        "type": "IUnknown*",
        "name": "punkOuter",
        "description": "If this parameter non-NULL, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the new instance's controlling IUnknown. Aggregation is currently not supported cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non-NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsCtx",
        "description": "A value from the CLSCTX enumeration."
      },
      {
        "in_out": "_In_",
        "type": "COSERVERINFO*",
        "name": "pServerInfo",
        "description": "Information about the computer on which to instantiate the object. See COSERVERINFO. This parameter can be NULL, in which case the object is instantiated on the local computer or at the computer specified in the registry under the class's RemoteServerName value, according to the interpretation of the dwClsCtx parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCount",
        "description": "The number of structures in pResults. This value must be greater than 0."
      },
      {
        "in_out": "_Inout_",
        "type": "MULTI_QI*",
        "name": "pResults",
        "description": "An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface (pIID), the location to return the interface pointer (pItf) and the return value of the call to QueryInterface (hr)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Creates an instance of a specific class on a specific computer from within an app container.",
    "library": "Combase.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Combaseapi.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "The CoCreateInstanceFromApp function is the same as the  CoCreateInstanceEx function, with the following differences.  ",
    "return_type": "HRESULT WINOLEAPI",
    "category": "COM",
    "name": "CoCreateInstanceFromApp",
    "is_callback": 0,
    "dll": "Combase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID of the object to be created."
      },
      {
        "in_out": "_In_opt_",
        "type": "IUnknown*",
        "name": "punkOuter",
        "description": "If this parameter non-NULL, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the new instance's controlling IUnknown. Aggregation is currently not supported cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non-NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsCtx",
        "description": "A value from the CLSCTX enumeration."
      },
      {
        "in_out": "_In_opt_",
        "type": "void*",
        "name": "reserved",
        "description": "Reserved for future use."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCount",
        "description": "The number of structures in pResults. This value must be greater than 0."
      },
      {
        "in_out": "_Inout_",
        "type": "MULTI_QI*",
        "name": "pResults",
        "description": "An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface (pIID), the location to return the interface pointer (pItf) and the return value of the call to QueryInterface (hr)."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Undoes the action of a call to CoEnableCallCancellation. Disables cancellation of synchronous calls on the calling thread when all calls to CoEnableCallCancellation are balanced by calls to CoDisableCallCancellation.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "When call cancellation is enabled on a thread, marshaled synchronous calls from that thread to objects on the same computer can suffer serious performance degradation. By default, then, synchronous calls cannot be canceled, even if a cancel object is available. To enable call cancellation, you must call CoEnableCallCancellation first. When call cancellation is disabled, attempts to gain a pointer to a call object will fail. If the calling thread already has a pointer to a call object, calls on that object will fail. Unless you want to enable call cancellation on a thread at all times, you should pair calls to CoEnableCallCancellation with calls to CoDisableCallCancellation. Call cancellation is disabled only if each successful call to CoEnableCallCancellation is balanced by a successful call to CoDisableCallCancellation. A call will be cancelable or not depending on the state of the thread at the time the call was made. Subsequently enabling or disabling call cancellation has no effect on any calls that are pending on the thread. If a thread is uninitialized and then reinitialized by calls to CoUninitialize and CoInitialize, call cancellation is disabled on the thread, even if it was enabled when the thread was uninitialized. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoDisableCallCancellation",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pReserved",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Enables cancellation of synchronous calls on the calling thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values S_OK, E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY. ",
    "remarks": "When call cancellation is enabled on a thread, marshaled synchronous calls from that thread to objects on the same computer can suffer serious performance degradation. By default, synchronous calls cannot be canceled, even if a cancel object is available. To enable call cancellation, you must call CoEnableCallCancellation first. Unless you want to enable call cancellation on a thread at all times, you should pair calls to CoEnableCallCancellation with calls to CoDisableCallCancellation. Call cancellation is disabled only if CoDisableCallCancellation has been called once for each time CoEnableCallCancellation was called successfully. A call will be cancelable or not depending on the state of the thread at the time the call was made. Subsequently enabling or disabling call cancellation has no effect on any calls that are pending on the thread. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoEnableCallCancellation",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pReserved",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Disconnects all proxy connections that are being maintained on behalf of all interface pointers that point to objects in the current context.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, as well as the following values.  ",
    "remarks": "The CoDisconnectContext function is used to support unloading services in shared service hosts where you must unload your service's binaries without affecting other COM servers that are running in the same process. If you control the process lifetime and you do not unload until the process exits, the COM infrastructure will perform the necessary cleanup automatically and you do not have to call this function. The CoDisconnectContext function enables a server to correctly disconnect all external clients of all objects in the current context. Default contexts cannot be disconnected. To use CoDisconnectContext, you must first create a context that can be disconnected and register your class factories for objects from which you want to disconnect within that context. You can do this with the IContextCallback interface. If CoDisconnectContext returns RPC_E_TIMEOUT, this does not indicate that the function did not disconnect the objects, but that not all disconnections could be completed in the time specified by dwTimeout because of outstanding calls on the objects. All objects will be disconnected after all calls on them have been completed. It is not safe to unload the DLL that hosts the service until CoDisconnectContext returns S_OK. If the function returns RPC_E_TIMEOUT, the service may perform other clean-up. The service must call the function until it returns S_OK, and then it can safely unload its DLL. The CoDisconnectContext function performs the following tasks: The CoDisconnectContext function has the following limitations: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoDisconnectContext",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimeout",
        "description": "The time in milliseconds after which CoDisconnectContext returns even if the proxy connections for all objects have not been disconnected. INFINITE is an acceptable value for this parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Disconnects all remote process connections being maintained on behalf of all the interface pointers that point to a specified object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function returns S_OK to indicate that all connections to remote processes were successfully deleted. ",
    "remarks": "The CoDisconnectObject function enables a server to correctly disconnect all external clients to the object specified by pUnk.  It performs the following tasks: An object's client does not call CoDisconnectObject to disconnect itself from the server (clients should use IUnknown::Release for this purpose). Rather, an OLE server calls CoDisconnectObject to forcibly disconnect an object's clients, usually in response to a user closing the server application. Similarly, an OLE container that supports external links to its embedded objects can call CoDisconnectObject to destroy those links. Again, this call is normally made in response to a user closing the application. The container should first call IOleObject::Close for all its OLE objects, each of which should send IAdviseSink::OnClose notifications to their various clients. Then the container can call CoDisconnectObject to close any existing connections. CoDisconnectObject does not necessarily disconnect out-of-process clients immediately. If any marshaled calls are pending on the server object, CoDisconnectObject disconnects the object only when those calls have returned. In the meantime, CoDisconnectObject sets a flag that causes any new marshaled calls to return CO_E_OBJNOTCONNECTED. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoDisconnectObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to any interface derived from IUnknown on the object to be disconnected."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "This parameter is reserved and must be 0."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Converts the MS-DOS representation of the time and date to a FILETIME structure used by Windows.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the function succeeds, the return value is TRUE; otherwise, it is FALSE, probably because of invalid arguments. ",
    "remarks": "An MS-DOS date has the following format.  An MS-DOS time has the following format.  ",
    "return_type": "BOOL",
    "category": "COM",
    "name": "CoDosDateTimeToFileTime",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "nDosDate",
        "description": "The MS-DOS date."
      },
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "nDosTime",
        "description": "The MS-DOS time."
      },
      {
        "in_out": "_Out_",
        "type": "FILETIME*",
        "name": "lpFileTime",
        "description": "A pointer to the FILETIME structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Waits for and dispatches incoming calls and input to the components in an ASTA thread, until its reference count reaches zero.",
    "library": "",
    "min_server": "",
    "header": "Combaseapi.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is supported only in an ASTA, where it supports the ASTA lifetime pattern. ",
    "return_type": "void WINOLEAPI",
    "category": "COM",
    "name": "CoEnterApplicationThreadLifetimeLoop",
    "is_callback": 0,
    "dll": "Combase.dll",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Returns the current time as a FILETIME structure.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function returns S_OK to indicate success. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoFileTimeNow",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "FILETIME*",
        "name": "lpFileTime",
        "description": "A pointer to the FILETIME structure that receives the current time."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Converts a FILETIME into MS-DOS date and time values.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the function succeeds, the return value is TRUE; otherwise, it is FALSE. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "COM",
    "name": "CoFileTimeToDosDateTime",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "FILETIME*",
        "name": "lpFileTime",
        "description": "A pointer to the FILETIME structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPWORD",
        "name": "lpDosDate",
        "description": "Receives the MS-DOS date."
      },
      {
        "in_out": "_Out_",
        "type": "LPWORD",
        "name": "lpDosTime",
        "description": "Receives the MS-DOS time."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Frees all the DLLs that have been loaded with the CoLoadLibrary function (called internally by CoGetClassObject), regardless of whether they are currently in use.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function does not return a value. ",
    "remarks": "To unload libraries, CoFreeAllLibraries uses a list of loaded DLLs for each process that the COM library maintains. The CoUninitialize and OleUninitialize functions call CoFreeAllLibraries internally, so applications usually have no need to call this function directly. ",
    "return_type": "void",
    "category": "COM",
    "name": "CoFreeAllLibraries",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Loads a specific DLL into the caller's process.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the function succeeds, the return value is a handle to the loaded library; otherwise, it is NULL. ",
    "remarks": "The CoGetClassObject function does not call CoLoadLibrary. CoLoadLibrary loads a DLL specified by the lpszLibName parameter into the process that called CoGetClassObject. Containers should not call CoLoadLibrary directly. Internally, a reference count is kept on the loaded DLL by using CoLoadLibrary to increment the count and the CoFreeLibrary function to decrement it. ",
    "return_type": "HINSTANCE",
    "category": "COM",
    "name": "CoLoadLibrary",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpszLibName",
        "description": "The name of the library to be loaded."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bAutoFree",
        "description": "This parameter is maintained for compatibility with 16-bit applications, but is ignored."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Provides a pointer to an interface on a class object associated with a specified CLSID. CoGetClassObject locates, and if necessary, dynamically loads the executable code required to do this.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "A class object in OLE is an intermediate object that supports an interface that permits operations common to a group of objects. The objects in this group are instances derived from the same object definition represented by a single CLSID. Usually, the interface implemented on a class object is IClassFactory, through which you can create object instances of a given definition (class). A call to CoGetClassObject creates, initializes, and gives the caller access (through a pointer to an interface specified with the riid parameter) to the class object. The class object is the one associated with the CLSID that you specify in the rclsid parameter. The details of how the system locates the associated code and data within a computer are transparent to the caller, as is the dynamic loading of any code that is not already loaded. If the class context is CLSCTX_REMOTE_SERVER, indicating remote activation is required, the COSERVERINFO structure provided in the pServerInfo parameter allows you to specify the computer on which the server is located. For information on the algorithm used to locate a remote server when pServerInfo is NULL, refer to the CLSCTX enumeration. There are two places to find a CLSID for a class: To create and initialize embedded or linked OLE document objects, it is not necessary to call CoGetClassObject directly. Instead, call the OleCreate or OleCreateXXX function. These functions encapsulate the entire object instantiation and initialization process, and call, among other functions, CoGetClassObject. The riid parameter specifies the interface the client will use to communicate with the class object. In most cases, this interface is IClassFactory. This provides access to the CreateInstance method, through which the caller can then create an uninitialized object of the kind specified in its implementation. All classes registered in the system with a CLSID must implement IClassFactory. In rare cases, however, you may want to specify some other interface that defines operations common to a set of objects. For example, in the way OLE implements monikers, the interface on the class object is IParseDisplayName, used to transform the display name of an object into a moniker. The dwClsContext parameter specifies the execution context, allowing one CLSID to be associated with different pieces of code in different execution contexts. The CLSCTX enumeration specifies the available context flags. CoGetClassObject consults (as appropriate for the context indicated) both the registry and the class objects that are currently registered by calling the CoRegisterClassObject function. To release a class object, use the class object's Release method. The function CoRevokeClassObject is to be used only to remove a class object's CLSID from the system registry. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetClassObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID associated with the data and code that you will use to create the objects."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsContext",
        "description": "The context in which the executable code is to be run. To enable a remote activation, include CLSCTX_REMOTE_SERVER. For more information on the context values and their use, see the CLSCTX enumeration."
      },
      {
        "in_out": "_In_opt_",
        "type": "COSERVERINFO*",
        "name": "pServerInfo",
        "description": "A pointer to computer on which to instantiate the class object. If this parameter is NULL, the class object is instantiated on the current computer or at the computer specified under the class's RemoteServerName key, according to the interpretation of the dwClsCtx parameter. See COSERVERINFO."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "Reference to the identifier of the interface, which will be supplied in ppv on successful return. ..."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID*",
        "name": "ppv",
        "description": "The address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the requested interface pointer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Frees a library that, when loaded, was specified to be freed explicitly.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The CoFreeLibrary function should be called to free a library that is to be freed explicitly. This is established when the library is loaded with the bAutoFree parameter of CoLoadLibrary set to FALSE. It is illegal to free a library explicitly when the corresponding CoLoadLibrary call specifies that it be freed automatically (the bAutoFree parameter is set to TRUE). ",
    "return_type": "void",
    "category": "COM",
    "name": "CoFreeLibrary",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HINSTANCE",
        "name": "hInst",
        "description": "A handle to the library module to be freed, as returned by the CoLoadLibrary function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Unloads any DLLs that are no longer in use, probably because the DLL no longer has any instantiated COM objects outstanding.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function does not return a value. ",
    "remarks": "Applications can call CoFreeUnusedLibraries periodically to free resources. It is most efficient to call it either at the top of a message loop or in some idle-time task. CoFreeUnusedLibraries internally calls DllCanUnloadNow for DLLs that implement and export that function. ",
    "return_type": "void",
    "category": "COM",
    "name": "CoFreeUnusedLibraries",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Unloads any DLLs that are no longer in use and whose unload delay has expired.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function does not return a value. ",
    "remarks": "COM supplies functions to reclaim memory held by DLLs containing components. The most commonly used function is CoFreeUnusedLibraries. CoFreeUnusedLibraries does not immediately release DLLs that have no active object. There is a 10-minute delay for multithreaded apartments (MTAs) and neutral apartments (NAs). For single-threaded apartments (STAs), there is no delay. The 10-minute delay for CoFreeUnusedLibraries is to avoid multithread race conditions caused by unloading a component DLL. This default delay may be too long for many applications. COM maintains a list of active DLLs that have had components loaded for the apartments that can be hosted on the thread where this function is called. When CoFreeUnusedLibrariesEx is called, each DLL on that list has its DllCanUnloadNow function called. If DllCanUnloadNow returns S_FALSE (or is not exported), this DLL is not ready to be unloaded. If DllCanUnloadNow returns S_OK, this DLL is moved off the active list to a \"candidate-for-unloading\" list. Adding the DLL to the candidate-for-unloading list time-stamps the DLL dwUnloadDelay milliseconds from when this move occurs. When CoFreeUnusedLibrariesEx (or CoFreeUnusedLibraries) is called again, at least dwUnloadDelay milliseconds from the call that moved the DLL to the candidate-for-unloading list, the DLL is actually freed from memory. If COM uses the component DLL while the DLL is on the candidate-for-unloading list, it is moved back to the active list. Setting dwUnloadDelay to 0 may have unexpected consequences. The component DLL may need some time for cleanup after it returns from the DllCanUnloadNow function. For example, if the DLL had its own worker threads, using a value of 0 would most likely lead to a problem because the code executing on these threads would be unmapped, caused by the unloading of the DLL before the worker threads have a chance to exit. Also, using too brief of a value for dwUnloadDelay can lead to performance issues because there is more overhead in reloading a DLL than letting it page out. This behavior is triggered by the DLL supplying components with threading models set to Free, Neutral, or Both. For a threading model set to Apartment (or if no threading model is specified), dwUnloadDelay is treated as 0 because these components are tied to the single thread hosting the apartment. ",
    "return_type": "void",
    "category": "COM",
    "name": "CoFreeUnusedLibrariesEx",
    "is_callback": 0,
    "dll": "ComBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwUnloadDelay",
        "description": "The delay in milliseconds between the time that the DLL has stated it can be unloaded until it becomes a candidate to unload. Setting this parameter to INFINITE uses the system default delay (10 minutes). Setting this parameter to 0 forces the unloading of any DLLs without any delay."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "This parameter is reserved and must be 0."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the current apartment type and type qualifier.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "Returns S_OK if the call succeeded. Otherwise, one of the following error codes is returned.  ",
    "remarks": "On Windows platforms prior to Windows 7, the following actions must be taken on a thread to query the apartment type: In multithreaded scenarios, there is a race condition which can potentially cause an Access Violation within the process when executing the above sequence of operations. The CoGetApartmentType function is recommended as it does not potentially incur the Access Violation. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetApartmentType",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "APTTYPE*",
        "name": "pAptType",
        "description": "APTTYPE enumeration value that specifies the type of the current apartment."
      },
      {
        "in_out": "_Out_",
        "type": "APTTYPEQUALIFIER*",
        "name": "pAptQualifier",
        "description": "APTTYPEQUALIFIER enumeration value that specifies the type qualifier of the current apartment."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Gets a reference to the current ASTA thread to participate in ASTA cooperative lifetime management.",
    "library": "",
    "min_server": "",
    "header": "Combaseapi.h",
    "return_value": "This function can return one of these values.  ",
    "remarks": "This function is supported only in an ASTA, where it supports the ASTA lifetime pattern. The thread reference object returned by this function should be stored as a field in an STA object. It can't be marshaled or stored in the Global Interface Table, and it fails quickly if called from the wrong thread. ",
    "return_type": "HRESULT WINOLEAPI",
    "category": "COM",
    "name": "CoGetApplicationThreadReference",
    "is_callback": 0,
    "dll": "Combase.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "IUnknown**",
        "name": "ppThreadReference",
        "description": "Receives the IUnknown interface for the thread lifetime object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the context of the current call on the current thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "CoGetCallContext retrieves the context of the current call on the current thread. The riid parameter specifies the interface on the context to be retrieved. This is one of the functions provided to give the server access to any contextual information of the caller. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetCallContext",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "Interface identifier (IID) of the call context that is being requested. If you are using the default call context supported by standard marshaling, IID_IServerSecurity is available. For COM+ applications using role-based security, IID_ISecurityCallContext is available."
      },
      {
        "in_out": "_Out_",
        "type": "void**",
        "name": "ppInterface",
        "description": "Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppInterface contains the requested interface pointer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Returns a pointer to a DWORD that contains the apartment ID of the caller's thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "If the caller is not running on the same computer, this function does not return the apartment ID and the return value is S_FALSE. There is no guarantee that the information returned from this API is not tampered with, so do not use the ID that is returned to make security decisions. The ID can only be used for logging and diagnostic purposes. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetCallerTID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwTID",
        "description": "Receives the apartment ID of the caller's thread. For a single threaded apartment (STA), this is the current thread ID. For a multithreaded apartment (MTA), the value is 0.  For a neutral apartment (NA), the value is -1."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Obtains a pointer to a call control interface, normally ICancelMethodCalls, on the cancel object corresponding to an outbound COM method call pending on the same or another client thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "If two or more calls are pending on the same thread through nested calls, the thread ID may not be sufficient to identify the call to be canceled. In this case, CoGetCancelObject returns a cancel interface corresponding to the innermost call that is pending on the thread and has registered a cancel object. This function does not locate cancel objects for asynchronous calls. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetCancelObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwThreadId",
        "description": "The identifier of the thread on which the pending COM call is to be canceled. If this parameter is 0, the call is on the current thread."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "iid",
        "description": "The globally unique identifier of an interface on the cancel object for the call to be canceled. This argument is usually IID_ICancelMethodCalls."
      },
      {
        "in_out": "_Out_",
        "type": "void**",
        "name": "ppUnk",
        "description": "Receives the address of a pointer to the interface specified by riid."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Returns a pointer to an implementation of IObjContext for the current context.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetContextToken",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "ULONG_PTR*",
        "name": "pToken",
        "description": "A pointer to an implementation of IObjContext for the current context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Returns the logical thread identifier of the current physical thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "This function retrieves the identifier of the current logical thread under which this physical thread is operating. The current physical thread takes on the logical thread identifier of any client thread that makes a COM call into this application. Similarly, the logical thread identifier of the current physical thread is used to denote the causality for outgoing COM calls from this physical thread. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetCurrentLogicalThreadId",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "GUID*",
        "name": "pguid",
        "description": "A pointer to a GUID that contains the logical thread ID on return."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Returns a value that is unique to the current thread. CoGetCurrentProcess can be used to avoid thread ID reuse problems.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "The function returns the unique identifier of the current thread. ",
    "remarks": "Using the value returned from a call to CoGetCurrentProcess can help you in maintaining tables that are keyed by threads or in uniquely identifying a thread to other threads or processes. CoGetCurrentProcess returns a value that is effectively unique, because it is not used again until 2\u00b3\u00b2 more threads have been created on the current workstation or until the workstation is restarted. The value returned by CoGetCurrentProcess will uniquely identify the same thread for the life of the caller. Because thread IDs can be reused without notice as threads are created and destroyed, this value is more reliable than the value returned by the GetCurrentThreadId function. ",
    "return_type": "DWORD",
    "category": "COM",
    "name": "CoGetCurrentProcess",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Creates a new object and initializes it from a file using IPersistFile::Load.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "CoGetInstanceFromFile creates a new object and initializes it from a file using IPersistFile::Load. The result of this function is similar to creating an instance with a call to CoCreateInstanceEx, followed by an initializing call to IPersistFile::Load, with the following important distinctions: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetInstanceFromFile",
    "is_callback": 0,
    "dll": "ComBase.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "COSERVERINFO*",
        "name": "pServerInfo",
        "description": "A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the authentication setting to be used. This parameter can be NULL, in which case the object is instantiated on the current computer, at the computer specified under the RemoteServerName registry value for the class, or at the computer where the pwszName file resides if the ActivateAtStorage value is specified for the class or there is no local registry information."
      },
      {
        "in_out": "_In_opt_",
        "type": "CLSID*",
        "name": "pClsid",
        "description": "A pointer to the class identifier of the object to be created. This parameter can be NULL, in which case there is a call to GetClassFile, using pwszName as its parameter to get the class of the object to be instantiated."
      },
      {
        "in_out": "_In_opt_",
        "type": "IUnknown*",
        "name": "punkOuter",
        "description": "When non-NULL, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non-NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsCtx",
        "description": "Values from the CLSCTX enumeration."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "grfMode",
        "description": "Specifies how the file is to be opened. See STGM Constants."
      },
      {
        "in_out": "_In_",
        "type": "OLECHAR*",
        "name": "pwszName",
        "description": "The file used to initialize the object with IPersistFile::Load. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCount",
        "description": "The number of structures in pResults. This parameter must be greater than 0."
      },
      {
        "in_out": "_Inout_",
        "type": "MULTI_QI*",
        "name": "pResults",
        "description": "An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface (pIID), the location to return the interface pointer (pItf) and the return value of the call to QueryInterface (hr)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Creates a new object and initializes it from a storage object through an internal call to IPersistFile::Load.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "CoGetInstanceFromIStorage creates a new object and initializes it from a storage object using IPersistFile::Load. The result of this function is similar to creating an instance with a call to CoCreateInstanceEx, followed by an initializing call to IPersistFile::Load, with the following important distinctions: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetInstanceFromIStorage",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "COSERVERINFO*",
        "name": "pServerInfo",
        "description": "A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the authentication setting to be used. This parameter can be NULL, in which case the object is instantiated on the current computer, at the computer specified under the RemoteServerName registry value for the class, or at the computer where the pstg storage object resides if the ActivateAtStorage value is specified for the class or there is no local registry information."
      },
      {
        "in_out": "_In_opt_",
        "type": "CLSID*",
        "name": "pClsid",
        "description": "A pointer to the class identifier of the object to be created. This parameter can be NULL, in which case there is a call to IStorage::Stat to find the class of the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "IUnknown*",
        "name": "punkOuter",
        "description": "When non-NULL, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non-NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsCtx",
        "description": "Values from the CLSCTX enumeration."
      },
      {
        "in_out": "_In_",
        "type": "struct IStorage*",
        "name": "pstg",
        "description": "A pointer to the storage object used to initialize the object with IPersistFile::Load. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCount",
        "description": "The number of structures in pResults. This parameter must be greater than 0."
      },
      {
        "in_out": "_Inout_",
        "type": "MULTI_QI*",
        "name": "pResults",
        "description": "An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface (pIID), the location to return the interface pointer (pItf) and the return value of the call to QueryInterface (hr)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Instantiates the appropriate interceptor for the specified interface to be intercepted and returns the newly created interceptor.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Callobj.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetInterceptor",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "iidIntercepted",
        "description": "A reference to the identifier of the interface for which an interceptor is to be returned."
      },
      {
        "in_out": "_In_",
        "type": "IUnknown*",
        "name": "punkOuter",
        "description": "If this parameter is NULL, the object is not being created as part of an aggregate. Otherwise, this parameter is a pointer to the aggregate object's IUnknown interface (the controlling IUnknown)."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "iid",
        "description": "A reference to the identifier of the interface desired on the interceptor."
      },
      {
        "in_out": "_Out_",
        "type": "void**",
        "name": "ppv",
        "description": "The address of a pointer variable that receives the interface pointer requested in iid. Upon successful return, **ppv contains the requested interceptor pointer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Unmarshals a buffer containing an interface pointer and releases the stream when an interface pointer has been marshaled from another thread to the calling thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values S_OK and E_INVALIDARG, as well as any of the values returned by CoUnmarshalInterface. ",
    "remarks": "The CoGetInterfaceAndReleaseStream function performs the following tasks: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetInterfaceAndReleaseStream",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTREAM",
        "name": "pStm",
        "description": "A pointer to the IStream interface on the stream to be unmarshaled."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "iid",
        "description": "A reference to the identifier of the interface requested from the unmarshaled object."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID*",
        "name": "ppv",
        "description": "The address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the requested interface pointer to the unmarshaled interface."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a pointer to the default OLE task memory allocator (which supports the system implementation of the IMalloc interface) so applications can call its methods to manage memory.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values S_OK, E_INVALIDARG, and E_OUTOFMEMORY. ",
    "remarks": "The pointer to the IMalloc interface pointer received through the ppMalloc parameter cannot be used from a remote process; each process must have its own allocator. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetMalloc",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMemContext",
        "description": "This parameter must be 1."
      },
      {
        "in_out": "_Out_",
        "type": "LPMALLOC*",
        "name": "ppMalloc",
        "description": "The address of an IMalloc* pointer variable that receives the interface pointer to the memory allocator."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Returns an upper bound on the number of bytes needed to marshal the specified interface pointer to the specified object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_UNEXPECTED, as well as the following values.  ",
    "remarks": "This function performs the following tasks: You do not explicitly call this function unless you are implementing IMarshal, in which case your marshaling stub should call this function to get the correct size of the data packet to be marshaled. The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetMarshalSizeMax",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulSize",
        "description": "A pointer to the upper-bound value on the size, in bytes, of the data packet to be written to the marshaling stream. If this parameter is 0, the size of the packet is unknown."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the IUnknown interface."
      },
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the interface to be marshaled. This interface must be derived from the IUnknown interface."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDestContext",
        "description": "The destination context where the specified interface is to be unmarshaled. Values for dwDestContext come from the enumeration MSHCTX."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pvDestContext",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "mshlflags",
        "description": "Indicates whether the data to be marshaled is to be transmitted back to the client processthe normal case or written to a global table, where it can be retrieved by multiple clients. Values come from the enumeration MSHLFLAGS."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Converts a display name into a moniker that identifies the object named, and then binds to the object identified by the moniker.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "CoGetObject encapsulates calls to the COM library functions CreateBindCtx, MkParseDisplayName, and IMoniker::BindToObject. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "pszName",
        "description": "The display name of the object to be created."
      },
      {
        "in_out": "_In_opt_",
        "type": "BIND_OPTS*",
        "name": "pBindOptions",
        "description": "The binding options used to create a moniker that creates the actual object. For details, see BIND_OPTS. This parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of an interface that is implemented on the object to be created."
      },
      {
        "in_out": "_Out_",
        "type": "void**",
        "name": "ppv",
        "description": "The address of a pointer to the interface specified by riid on the object that is created."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the context for the current object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "CoGetObjectContext retrieves the context for the object from which it is called, and returns a pointer to an interface that can be used to manipulate context properties. Context properties are used to provide services to configured components running within COM+ applications. For components running within COM applications, the following interfaces are supported for accessing context properties: IComThreadingInfo, IContext, and IContextCallback. For components running within COM+ applications, the following interfaces are supported for accessing context properties: IObjectContext, IObjectContextActivity, IObjectContextInfo, and IContextState. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetObjectContext",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the ID of an interface that is implemented on the context object.  For objects running within COM applications, IID_IComThreadingInfo, IID_IContext, and IID_IContextCallback are available. For objects running within COM+ applications, IID_IObjectContext, IID_IObjectContextActivity IID_IObjectContextInfo, and IID_IContextState are available."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID*",
        "name": "ppv",
        "description": "The address of a pointer to the interface specified by riid on the context object."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the CLSID of the DLL that implements the proxy and stub for the specified interface.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "The CoGetPSClsid function looks at the HKEY_CLASSES_ROOT\\Interfaces\\{string form of riid}\\ProxyStubClsid32 key in the registry to determine the CLSID of the DLL to load in order to create the proxy and stub for the interface specified by riid. This function also returns the CLSID for any interface IID registered by CoRegisterPSClsid within the current process. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetPSClsid",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "The interface whose proxy/stub CLSID is to be returned."
      },
      {
        "in_out": "_Out_",
        "type": "CLSID*",
        "name": "pClsid",
        "description": "Specifies where to store the proxy/stub CLSID for the interface specified by riid."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Creates a default, or standard, marshaling object in either the client process or the server process, depending on the caller, and returns a pointer to that object's IMarshal implementation.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "The CoGetStandardMarshal function creates a default, or standard, marshaling object in either the client process or the server process, as may be necessary, and returns that object's IMarshal pointer to the caller. If you implement IMarshal, you may want your implementation to call CoGetStandardMarshal as a way of delegating to COM's default implementation any destination contexts that you do not fully understand or want to handle. Otherwise, you can ignore this function, which COM calls as part of its internal marshaling procedures. When the COM library in the client process receives a marshaled interface pointer, it looks for a CLSID to be used in creating a proxy for the purposes of unmarshaling the packet. If the packet does not contain a CLSID for the proxy, COM calls CoGetStandardMarshal, passing a NULLpUnk value. This function creates a standard proxy in the client process and returns a pointer to that proxy's implementation of IMarshal. COM uses this pointer to call CoUnmarshalInterface to retrieve the pointer to the requested interface. If your OLE server application's implementation of IMarshal calls CoGetStandardMarshal, you should pass both the IID of (riid), and a pointer to (pUnk), the interface being requested. This function performs the following tasks: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetStandardMarshal",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the IUnknown interface."
      },
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the interface to be marshaled."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDestContext",
        "description": "The destination context where the specified interface is to be unmarshaled. Values come from the enumeration MSHCTX. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL)."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pvDestContext",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "mshlflags",
        "description": "Indicates whether the data to be marshaled is to be transmitted back to the client process (the normal case) or written to a global table where it can be retrieved by multiple clients. Values come from the MSHLFLAGS enumeration."
      },
      {
        "in_out": "_Out_",
        "type": "LPMARSHAL*",
        "name": "ppMarshal",
        "description": "The address of IMarshal* pointer variable that receives the interface pointer to the standard marshaler."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates an aggregated standard marshaler for use with lightweight client-side handlers.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function returns S_OK. ",
    "remarks": "The server calls CoGetStdMarshalEx passing in the flag SMEXF_SERVER. This creates a server side standard marshaler (known as a stub manager). The handler calls CoGetStdMarshalEx passing in the flag SMEXF_HANDLER. This creates a client side standard marshaler (known as a proxy manager). Note that when calling this function, the handler must pass the original controlling unknown that was passed to the handler when the handler was created. This will be the system implemented controlling unknown. Failure to pass the correct IUnknown results in an error returned. On success, the ppUnkInner returned is the controlling unknown of the inner object. The server and handler must keep this pointer, and may use it to call IUnknown::QueryInterface for the IMarshal interface. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetStdMarshalEx",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnkOuter",
        "description": "A pointer to the controlling IUnknown."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "smexflags",
        "description": "One of two values indicating whether the aggregated standard marshaler is on the client side or the server side. These flags are defined in the STDMSHLFLAGS enumeration.  ValueMeaning  SMEXF_SERVER 0x01   Indicates a server-side aggregated standard marshaler.   SMEXF_HANDLER 0x0   Indicates a client-side (handler) aggregated standard marshaler."
      },
      {
        "in_out": "_Out_",
        "type": "LPUNKNOWN*",
        "name": "ppUnkInner",
        "description": "On successful return, address of pointer to the IUnknown interface on the newly-created aggregated standard marshaler. If an error occurs, this value is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the default values of the Security Descriptors of the machine-wide launch and access permissions, as well as launch and access limits.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return one of these values.  ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetSystemSecurityPermissions",
    "is_callback": 0,
    "dll": "ComBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "COMSD",
        "name": "comSDType",
        "description": "A value from the COMSD enumeration. Specifies the type of the requested system security permissions, such as launch permissions, access permissions, launch restrictions, and access restrictions."
      },
      {
        "in_out": "_Out_",
        "type": "PSECURITY_DESCRIPTOR*",
        "name": "ppSD",
        "description": "Pointer to a caller-supplied variable that this routine sets to the address of a buffer containing the SECURITY_DESCRIPTOR for the system security permissions. Memory will be allocated by CoGetSystemSecurityPermissions and should be freed by caller with LocalFree."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the CLSID of an object that can emulate the specified object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values, as well as any error values returned by the CLSIDFromString function.  ",
    "remarks": "CoGetTreatAsClass returns the TreatAs entry in the registry for the specified object. The TreatAs entry, if set, is the CLSID of a registered object (an application) that can emulate the object in question. The TreatAs entry is set through a call to the CoTreatAsClass function. Emulation allows an application to open and edit an object of a different format, while retaining the original format of the object. Objects of the original CLSID are activated and treated as objects of the second CLSID. When the object is saved, this may result in loss of edits not supported by the original format. If there is no TreatAs entry for the specified object, this function returns the CLSID of the original object (clsidOld). ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoGetTreatAsClass",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsidOld",
        "description": "The CLSID of the object that can be emulated (treated as) an object with a different CLSID."
      },
      {
        "in_out": "_Out_",
        "type": "LPCLSID",
        "name": "pClsidNew",
        "description": "A pointer to where the CLSID that can emulate clsidOld objects is retrieved. This parameter cannot be NULL. If there is no emulation information for clsidOld objects, the clsidOld parameter is supplied."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Called by message dispatchers on an ASTA thread after dispatching a windows message to provide an opportunity for short-running infrastructural COM calls and other high-priority or short-running COM work to be dispatched between messages. This helps to provide similar responsiveness to these infrastructural calls in an ASTA as in a classic STA, even when there is a long stream of window messages to be handled.",
    "library": "Ole32.lib",
    "min_server": "",
    "header": "Messagedispatcherapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "This function dispatches any high-priority COM calls or work that are queued on the ASTA thread, then returns. It returns quickly if there is no work to perform.  This function silently does nothing when called on non-ASTA threads. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoHandlePriorityEventsFromMessagePump",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "Enables the server to impersonate the client of the current call for the duration of the call.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function supports the standard return values, including S_OK. ",
    "remarks": "This method allows the server to impersonate the client of the current call for the duration of the call. If you do not call CoRevertToSelf, COM reverts automatically for you. This function will fail unless the object is being called with RPC_C_AUTHN_LEVEL_CONNECT or higher authentication in effect (which is any authentication level except RPC_C_AUTHN_LEVEL_NONE). This function encapsulates the following sequence of common calls (error handling excluded): CoImpersonateClient encapsulates the process of getting a pointer to an instance of IServerSecurity that contains data about the current call, calling its ImpersonateClient method, and then releasing the pointer. One call to CoRevertToSelf (or IServerSecurity::RevertToSelf) will undo any number of  calls to impersonate the client. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoImpersonateClient",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes the COM library on the current thread and identifies the concurrency model as single-thread apartment (STA).",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "You need to initialize the COM library on a thread before you call any of the library functions except CoGetMalloc, to get a pointer to the standard allocator, and the memory allocation functions. After the concurrency model for a thread is set, it cannot be changed. A call to CoInitialize on an apartment that was previously initialized as multithreaded will fail and return RPC_E_CHANGED_MODE. CoInitializeEx provides the same functionality as CoInitialize and also provides a parameter to explicitly specify the thread's concurrency model. CoInitialize calls CoInitializeEx and specifies the concurrency model as single-thread apartment. Applications developed today should call CoInitializeEx rather than CoInitialize. Typically, the COM library is initialized on a thread only once. Subsequent calls to CoInitialize or CoInitializeEx on the same thread will succeed, as long as they do not attempt to change the concurrency model, but will return S_FALSE. To close the COM library gracefully, each successful call to CoInitialize or CoInitializeEx, including those that return S_FALSE, must be balanced by a corresponding call to CoUninitialize. However, the first thread in the application that calls CoInitialize with 0 (or CoInitializeEx with COINIT_APARTMENTTHREADED) must be the last thread to call CoUninitialize. Otherwise, subsequent calls to CoInitialize on the STA will fail and the application will not work. Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call CoInitialize, CoInitializeEx, or CoUninitialize from the DllMain function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoInitialize",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pvReserved",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Initializes the COM library for use by the calling thread, sets the thread's concurrency model, and creates a new apartment for the thread if one is required.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "CoInitializeEx must be called at least once, and is usually called only once, for each thread that uses the COM library. Multiple calls to CoInitializeEx by the same thread are allowed as long as they pass the same concurrency flag, but subsequent valid calls return S_FALSE. To close the COM library gracefully on a thread, each successful call to CoInitialize or CoInitializeEx, including any call that returns S_FALSE, must be balanced by a corresponding call to CoUninitialize. You need to initialize the COM library on a thread before you call any of the library functions except CoGetMalloc, to get a pointer to the standard allocator, and the memory allocation functions.  Otherwise, the COM function will return CO_E_NOTINITIALIZED. After the concurrency model for a thread is set, it cannot be changed. A call to CoInitialize on an apartment that was previously initialized as multithreaded will fail and return RPC_E_CHANGED_MODE. Objects created in a single-threaded apartment (STA) receive method calls only from their apartment's thread, so calls are serialized and arrive only at message-queue boundaries (when the PeekMessage or SendMessage function is called).  Objects created on a COM thread in a multithread apartment (MTA) must be able to receive method calls from other threads at any time. You would typically implement some form of concurrency control in a multithreaded object's code using synchronization primitives such as critical sections, semaphores, or mutexes to help protect the object's data.   When an object that is configured to run in the neutral threaded apartment (NTA) is called by a thread that is in either an STA or the MTA, that thread transfers to the NTA. If this thread subsequently calls CoInitializeEx, the call fails and returns RPC_E_CHANGED_MODE. Because OLE technologies are not thread-safe, the OleInitialize function calls CoInitializeEx with the COINIT_APARTMENTTHREADED flag. As a result, an apartment that is initialized for multithreaded object concurrency cannot use the features enabled by OleInitialize. Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call CoInitialize, CoInitializeEx, or CoUninitialize from the DllMain function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoInitializeEx",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pvReserved",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCoInit",
        "description": "The concurrency model and initialization options for the thread. Values for this parameter are taken from the COINIT enumeration. Any combination of values from COINIT can be used, except that the COINIT_APARTMENTTHREADED and COINIT_MULTITHREADED flags cannot both be set. The default is COINIT_MULTITHREADED."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 9,
    "description": "Registers security and sets the default security values for the process.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "The CoInitializeSecurity function initializes the security layer and sets the specified values as the security default. If a process does not call CoInitializeSecurity, COM calls it automatically the first time an interface is marshaled or unmarshaled, registering the system default security. No default security packages are registered until then. This function is called exactly once per process, either explicitly or implicitly. It can be called by the client, server, or both. For legacy applications and other applications that do not explicitly call CoInitializeSecurity, COM calls this function implicitly with values from the registry. If you set processwide security using the registry and then call CoInitializeSecurity, the AppID registry values will be ignored and the CoInitializeSecurity values will be used. CoInitializeSecurity can be used to override both computer-wide access permissions and application-specific access permissions, but not to override the computer-wide restriction policy. If pSecDesc points to an AppID, the EOAC_APPID flag must be set in dwCapabilities and, when the EOAC_APPID flag is set, all other parameters to CoInitializeSecurity are ignored. CoInitializeSecurity looks for the authentication level under the AppID key in the registry and uses it to determine the default security. For more information about how the AppID key is used to set security, see Setting Process-Wide Security Through the Registry. If pSecDesc is a pointer to an IAccessControl object, the EOAC_ACCESS_CONTROL flag must be set and dwAuthnLevel cannot be none. The IAccessControl object is used to determine who can call the process. DCOM will AddRef the IAccessControl and will Release it when CoUninitialize is called. The state of the IAccessControl object should not be changed. If pSecDesc is a pointer to a SECURITY_DESCRIPTOR, neither the EOAC_APPID nor the EOAC_ACCESS_CONTROL flag can be set in dwCapabilities. The owner and group of the SECURITY_DESCRIPTOR must be set, and until DCOM supports auditing, the system ACL must be NULL. The access-control entries (ACEs) in the discretionary ACL (DACL) of the SECURITY_DESCRIPTOR are used to find out which callers are permitted to connect to the process's objects. A DACL with no ACEs allows no access, while a NULL DACL will allow calls from anyone. For more information on ACLs and ACEs, see Access Control Model. Applications should call AccessCheck (not IsValidSecurityDescriptor) to ensure that their SECURITY_DESCRIPTOR is correctly formed prior to calling CoInitializeSecurity. Passing pSecDesc as NULL is strongly discouraged. An appropriate alternative might be to use a SECURITY_DESCRIPTOR that allows Everyone. If pSecDesc is NULL, the flags in dwCapabilities determine how CoInitializeSecurity defines the access permissions that a server will use, as follows: The CoInitializeSecurity function returns an error if both the EOAC_APPID and EOAC_ACCESS_CONTROL flags are set in dwCapabilities. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoInitializeSecurity",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "pSecDesc",
        "description": "The access permissions that a server will use to receive calls. This parameter is used by COM only when a server calls CoInitializeSecurity. Its value is a pointer to one of three types: an AppID, an IAccessControl object, or a SECURITY_DESCRIPTOR, in absolute format. See the Remarks section for more information."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "cAuthSvc",
        "description": "The count of entries in the asAuthSvc parameter. This parameter is used by COM only when a server calls CoInitializeSecurity. If this parameter is 0, no authentication services will be registered and the server cannot receive secure calls. A value of -1 tells COM to choose which authentication services to register, and if this is the case, the asAuthSvc parameter must be NULL. However, Schannel will never be chosen as an authentication service by the server if this parameter is -1."
      },
      {
        "in_out": "_In_opt_",
        "type": "SOLE_AUTHENTICATION_SERVICE*",
        "name": "asAuthSvc",
        "description": "An array of authentication services that a server is willing to use to receive a call. This parameter is used by COM only when a server calls CoInitializeSecurity. For more information, see SOLE_AUTHENTICATION_SERVICE."
      },
      {
        "in_out": "_In_opt_",
        "type": "void*",
        "name": "pReserved1",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAuthnLevel",
        "description": "The default authentication level for the process. Both servers and clients use this parameter when they call CoInitializeSecurity. COM will fail calls that arrive with a lower authentication level. By default, all proxies will use at least this authentication level. This value should contain one of the authentication level constants. By default, all calls to IUnknown are made at this level."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwImpLevel",
        "description": "The default impersonation level for proxies. The value of this parameter is used only when the process is a client. It should be a value from the impersonation level constants, except for RPC_C_IMP_LEVEL_DEFAULT, which is not for use with CoInitializeSecurity. Outgoing calls from the client always use the impersonation level as specified. (It is not negotiated.) Incoming calls to the client can be at any impersonation level. By default, all IUnknown calls are made with this impersonation level, so even security-aware applications should set this level carefully. To determine which impersonation levels each authentication service supports, see the description of the authentication services in COM and Security Packages. For more information about impersonation levels, see Impersonation."
      },
      {
        "in_out": "_In_opt_",
        "type": "void*",
        "name": "pAuthList",
        "description": "A pointer to SOLE_AUTHENTICATION_LIST, which is an array of SOLE_AUTHENTICATION_INFO structures. This list indicates the information for each authentication service that a client can use to call a server. This parameter is used by COM only when a client calls CoInitializeSecurity."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCapabilities",
        "description": "Additional capabilities of the client or server, specified by setting one or more EOLE_AUTHENTICATION_CAPABILITIES values. Some of these value cannot be used simultaneously, and some cannot be set when particular authentication services are being used. For more information about these flags, see the Remarks section."
      },
      {
        "in_out": "_In_opt_",
        "type": "void*",
        "name": "pReserved3",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Installs the requested COM server application.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoInstall",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IBindCtx*",
        "name": "pbc",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is reserved and must be 0."
      },
      {
        "in_out": "_In_",
        "type": "uCLSSPEC*",
        "name": "pClassSpec",
        "description": "A pointer to a uCLSSPEC structure. The tyspec member must be set to TYSPEC_CLSID and the clsid member must be set to the CLSID to be installed. For more information see TYSPEC."
      },
      {
        "in_out": "_In_",
        "type": "QUERYCONTEXT*",
        "name": "pQuery",
        "description": "A pointer to a QUERYCONTEXT structure. The dwContext member must be set to the desired CLSCTX value."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "pszCodeBase",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Tells the service control manager to flush any cached RPC binding handles for the specified computer.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "The OLE Service Control Manager is used by COM to send component activation requests to other machines. To do this, the OLE Service Control Manager maintains a cache of RPC binding handles to send activation requests to computer, keyed by computer name. Under normal circumstances, this works well, but in some scenarios, such as Web farms and load-balancing situations, the ability to purge this cache of specific handles might be needed in order to facilitate rebinding to a different physical server by the same name. CoInvalidateRemoteMachineBindings is used for this purpose. The OLE Service Control Manager will flush unused binding handles over time. It is not necessary to call CoInvalidateRemoteMachineBindings to do this. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoInvalidateRemoteMachineBindings",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "pszMachineName",
        "description": "The computer name for which binding handles should be flushed, or an empty string to signify that all handles in the cache should be flushed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether a remote object is connected to the corresponding in-process object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the object is not remote or if it is remote and still connected, the return value is TRUE; otherwise, it is FALSE. ",
    "remarks": "The CoIsHandlerConnected function determines the status of a remote object. You can use it to determine when to release a remote object. You specify the remote object by giving the function a pointer to its controlling IUnknown interface (the pUnk parameter). A value of TRUE returned from the function indicates either that the specified object is not remote, or that it is remote and is still connected to its remote handler. A value of FALSE returned from the function indicates that the object is remote but is no longer connected to its remote handler; in this case, the caller should respond by releasing the object. ",
    "return_type": "BOOL",
    "category": "COM",
    "name": "CoIsHandlerConnected",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the controlling IUnknown interface on the remote object."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether the specified CLSID represents an OLE 1 object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the CLSID refers to an OLE 1 object, the return value is TRUE; otherwise, it is FALSE. ",
    "remarks": "The CoIsOle1Class function determines whether an object class is from OLE 1. You can use it to prevent linking to embedded OLE 1 objects within a container, which OLE 1 objects do not support. After a container has determined that copied data represents an embedded object, the container code can call CoIsOle1Class to determine whether the embedded object is an OLE 1 object. If CoIsOle1Class returns TRUE, the container does not offer CF_LINKSOURCE as one of its clipboard formats. This is one of several OLE compatibility functions. The following compatibility functions, listed below, can be used to convert the storage formats of objects between OLE 1 and OLE. ",
    "return_type": "BOOL",
    "category": "COM",
    "name": "CoIsOle1Class",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID to be checked."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Called either to lock an object to ensure that it stays in memory, or to release such a lock.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK. ",
    "remarks": "The CoLockObjectExternal function must be called in the process in which the object actually resides (the EXE process, not the process in which handlers may be loaded). The CoLockObjectExternal function prevents the reference count of an object from going to zero, thereby \"locking\" it into existence until the lock is released. The same function (with different parameters) releases the lock. The lock is implemented by having the system call IUnknown::AddRef on the object. The system then waits to call IUnknown::Release on the object until a later call to CoLockObjectExternal with fLock set to FALSE. This function can be used to maintain a reference count on the object on behalf of the end user, because it acts outside of the object, as does the user. The end user has explicit control over the lifetime of an application, even if there are external locks on it. That is, if a user decides to close the application, it must shut down. In the presence of external locks (such as the lock set by CoLockObjectExternal), the application can call the CoDisconnectObject function to force these connections to close prior to shutdown. Calling CoLockObjectExternal sets a strong lock on an object. A strong lock keeps an object in memory, while a weak lock does not. Strong locks are required, for example, during a silent update to an OLE embedding. The embedded object's container must remain in memory until the update process is complete. There must also be a strong lock on an application object to ensure that the application stays alive until it has finished providing services to its clients. All external references place a strong reference lock on an object. The CoLockObjectExternal function is typically called in the following situations: There are several things to be aware of when you use CoLockObjectExternal in the implementation of LockContainer. An embedded object would call LockContainer on its container to keep it running (to lock it) in the absence of other reasons to keep it running. When the embedded object becomes visible, the container must weaken its connection to the embedded object with a call to the OleSetContainedObject function, so other connections can affect the object. Unless an application manages all aspects of its application and document shutdown completely with calls to CoLockObjectExternal, the container must keep a private lock count in LockContainer so that it exits when the lock count reaches zero and the container is invisible. Maintaining all aspects of shutdown, and thereby avoiding keeping a private lock count, means that CoLockObjectExternal should be called whenever one of the following conditions occur: For debugging purposes, it may be useful to keep a count of the number of external locks (and unlocks) set on the application. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoLockObjectExternal",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the IUnknown interface on the object to be locked or unlocked."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fLock",
        "description": "Indicates whether the object is to be locked or released. If this parameter is TRUE, the object is kept in memory, independent of AddRef/Release operations, registrations, or revocations. If this parameter is FALSE, the lock previously set with a call to this function is released."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fLastUnlockReleases",
        "description": "If the lock is the last reference that is supposed to keep an object alive, specify TRUE to release all pointers to the object (there may be other references that are not supposed to keep it alive). Otherwise, specify FALSE. If fLock is TRUE, this parameter is ignored."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Marshals an HRESULT to the specified stream, from which it can be unmarshaled using the CoUnmarshalHresult function.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "An HRESULT is process-specific, so an HRESULT that is valid in one process might not be valid in another. If you are writing your own implementation of IMarshal and need to marshal an HRESULT from one process to another, either as a parameter or a return code, you must call this function. In other circumstances, you will have no need to call this function. This function performs the following tasks: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoMarshalHresult",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTREAM",
        "name": "pstm",
        "description": "A pointer to the marshaling stream. See IStream."
      },
      {
        "in_out": "_In_",
        "type": "HRESULT",
        "name": "hresult",
        "description": "The HRESULT in the originating process."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Unmarshals an HRESULT type from the specified stream.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "You do not explicitly call this function unless you are performing custom marshaling (that is, writing your own implementation of IMarshal), and your implementation needs to unmarshal an HRESULT. You must use CoUnmarshalHresult to unmarshal HRESULT values previously marshaled by a call to the CoMarshalHresult function. This function performs the following tasks: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoUnmarshalHresult",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTREAM",
        "name": "pstm",
        "description": "A pointer to the stream from which the HRESULT is to be unmarshaled."
      },
      {
        "in_out": "_Out_",
        "type": "HRESULT*",
        "name": "phresult",
        "description": "A pointer to the unmarshaled HRESULT."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Writes into a stream the data required to initialize a proxy object in some client process.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, the stream-access error values returned by IStream, as well as the following values.  ",
    "remarks": "The CoMarshalInterface function marshals the interface referred to by riid on the object whose IUnknown implementation is pointed to by pUnk. To do so, the CoMarshalInterface function performs the following tasks: The COM library in the client process calls the CoUnmarshalInterface function to extract the data and initialize the proxy. Before calling CoUnmarshalInterface, seek back to the original position in the stream. If you are implementing existing COM interfaces or defining your own interfaces using the Microsoft Interface Definition Language (MIDL), the MIDL-generated proxies and stubs call CoMarshalInterface for you. If you are writing your own proxies and stubs, your proxy code and stub code should each call CoMarshalInterface to correctly marshal interface pointers. Calling IMarshal directly from your proxy and stub code is not recommended. If you are writing your own implementation of IMarshal, and your proxy needs access to a private object, you can include an interface pointer to that object as part of the data you write to the stream. In such situations, if you want to use COM's default marshaling implementation when passing the interface pointer, you can call CoMarshalInterface on the object to do so. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoMarshalInterface",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTREAM",
        "name": "pStm",
        "description": "A pointer to the stream to be used during marshaling. See IStream."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of the interface to be marshaled. This interface must be derived from the IUnknown interface."
      },
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the interface to be marshaled. This interface must be derived from the IUnknown interface."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDestContext",
        "description": "The destination context where the specified interface is to be unmarshaled. The possible values come from the enumeration MSHCTX. Currently, unmarshaling can occur in another apartment of the current process (MSHCTX_INPROC), in another process on the same computer as the current process (MSHCTX_LOCAL), or in a process on a different computer (MSHCTX_DIFFERENTMACHINE)."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pvDestContext",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "mshlflags",
        "description": "The flags that specify whether the data to be marshaled is to be transmitted back to the client process (the typical  case) or written to a global table, where it can be retrieved by multiple clients. The possibles values come from the MSHLFLAGS enumeration."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Marshals an interface pointer from one thread to another thread in the same process.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and S_OK. ",
    "remarks": "The CoMarshalInterThreadInterfaceInStream function enables an object to easily and reliably marshal an interface pointer to another thread in the same process. The stream returned in the ppStm parameter is guaranteed to behave correctly when a client running in the receiving thread attempts to unmarshal the pointer. The client can then call the CoGetInterfaceAndReleaseStream to unmarshal the interface pointer and release the stream object. The CoMarshalInterThreadInterfaceInStream function performs the following tasks: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoMarshalInterThreadInterfaceInStream",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of the interface to be marshaled."
      },
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the interface to be marshaled, which must be derived from IUnknown. This parameter can be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "LPSTREAM*",
        "name": "ppStm",
        "description": "The address of the IStream* pointer variable that receives the interface pointer to the stream that contains the marshaled interface."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a list of the authentication services registered when the process called CoInitializeSecurity.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK. ",
    "remarks": "CoQueryAuthenticationServices retrieves a list of the authentication services currently registered. If the process calls CoInitializeSecurity, these are the services registered through that call. If the application does not call it, CoInitializeSecurity is called automatically by COM, registering the default security package, the first time an interface is marshaled or unmarshaled. This function returns only the authentication services registered with CoInitializeSecurity. It does not return all of the authentication services installed on the computer, but EnumerateSecurityPackages does. CoQueryAuthenticationServices is primarily useful for custom marshalers, to determine which principal names an application can use. Different authentication services support different levels of security. For example, NTLMSSP does not support delegation or mutual authentication while Kerberos does. The application is responsible only for registering authentication services that provide the features the application needs. This function provides a way to find out which services have been registered with CoInitializeSecurity. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoQueryAuthenticationServices",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "DWORD*",
        "name": "pcAuthSvc",
        "description": "A pointer to a variable that receives the number of entries returned in the asAuthSvc array."
      },
      {
        "in_out": "_Out_",
        "type": "SOLE_AUTHENTICATION_SERVICE**",
        "name": "asAuthSvc",
        "description": "A pointer to an array of SOLE_AUTHENTICATION_SERVICE structures. The list is allocated through a call to the CoTaskMemAlloc function. The caller must free the list when finished with it by calling the CoTaskMemFree function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Called by the server to find out about the client that invoked the method executing on the current thread. This is a helper function for IServerSecurity::QueryBlanket.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK. ",
    "remarks": "CoQueryClientBlanket is called by the server to get security information about the client that invoked the method executing on the current thread. This function encapsulates the following sequence of common calls (error handling excluded): This sequence calls CoGetCallContext to get a pointer to IServerSecurity and, with the resulting pointer, calls IServerSecurity::QueryBlanket and then releases the pointer. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoQueryClientBlanket",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pAuthnSvc",
        "description": "A pointer to a variable that receives the current authentication service. This will be a single value taken from the authentication service constants. If the caller specifies NULL, the current authentication service is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pAuthzSvc",
        "description": "A pointer to a variable that receives the current authorization service. This will be a single value taken from the authorization constants. If the caller specifies NULL, the current authorization service is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "OLECHAR**",
        "name": "pServerPrincName",
        "description": "The current principal name. The string will be allocated by the callee using CoTaskMemAlloc, and must be freed by the caller using CoTaskMemFree. By default, Schannel principal names will be in the msstd form. The fullsic form will be returned if EOAC_MAKE_FULLSIC is specified in the pCapabilities parameter. For more information about the msstd and fullsic forms, see Principal Names. If the caller specifies NULL, the current principal name is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pAuthnLevel",
        "description": "A pointer to a variable that receives the current authentication level. This will be a single value taken from the authentication level constants. If the caller specifies NULL, the current authentication level is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pImpLevel",
        "description": "This parameter must be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "RPC_AUTHZ_HANDLE*",
        "name": "pPrivs",
        "description": "A pointer to a handle that receives the privilege information for the client application. The format of the structure that the handle refers to depends on the authentication service. The application should not write or free the memory. The information is valid only for the duration of the current call. For NTLMSSP and Kerberos, this is a string identifying the client principal. For Schannel, this is a CERT_CONTEXT structure that represents the client's certificate. If the client has no certificate, NULL is returned. If the caller specifies NULL, the current privilege information is not retrieved. See RPC_AUTHZ_HANDLE."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "DWORD*",
        "name": "pCapabilities",
        "description": "A pointer to return flags indicating capabilities of the call. To request that the principal name be returned in fullsic form if Schannel is the authentication service, the caller can set the EOAC_MAKE_FULLSIC flag in this parameter. If the caller specifies NULL, the current capabilities are not retrieved."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Registers a process-wide filter to process activation requests.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "This registers one and only one process-wide filter. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterActivationFilter",
    "is_callback": 0,
    "dll": "ComBase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IActivationFilter*",
        "name": "pActivationFilter",
        "description": "Pointer to the filter to register."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Registers a channel hook.",
    "library": "Ole32.lib",
    "min_server": "",
    "header": "Objbase.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT WINOLEAPI",
    "category": "COM",
    "name": "CoRegisterChannelHook",
    "is_callback": 0,
    "dll": "Combase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFGUID",
        "name": "ExtensionUuid",
        "description": "The extension to register."
      },
      {
        "in_out": "_In_",
        "type": "IChannelHook*",
        "name": "pChannelHook",
        "description": "The channel hook to register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 8,
    "description": "Retrieves the authentication information the client uses to make calls on the specified proxy. This is a helper function for IClientSecurity::QueryBlanket.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK. ",
    "remarks": "CoQueryProxyBlanket is called by the client to retrieve the authentication information COM will use on calls made from the specified proxy. This function encapsulates the following sequence of common calls (error handling excluded): This sequence calls QueryInterface on the proxy to get a pointer to IClientSecurity, and with the resulting pointer, calls IClientSecurity::QueryBlanket and then releases the pointer. In pProxy, you can pass any proxy, such as a proxy you get through a call to CoCreateInstance or CoUnmarshalInterface, or you can pass an interface pointer. It can be any interface. You cannot pass a pointer to something that is not a proxy. Therefore, you can't pass a pointer to an interface that has the local keyword in its interface definition because no proxy is created for such an interface. IUnknown is the exception to this rule. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoQueryProxyBlanket",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IUnknown*",
        "name": "pProxy",
        "description": "A pointer indicating the proxy to query. This parameter cannot be NULL. For more information, see the Remarks section."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pwAuthnSvc",
        "description": "A pointer to a variable that receives the current authentication service. This will be a single value taken from the authentication service constants. This parameter cannot be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pAuthzSvc",
        "description": "A pointer to a variable that receives the current authorization service. This will be a single value taken from the authorization constants. If the caller specifies NULL, the current authorization service is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "OLECHAR**",
        "name": "pServerPrincName",
        "description": "The current principal name. The string will be allocated by the callee using CoTaskMemAlloc, and must be freed by the caller using CoTaskMemFree. The EOAC_MAKE_FULLSIC flag is not accepted in the pCapabilities parameter. For more information about the msstd and fullsic forms, see Principal Names. If the caller specifies NULL, the current principal name is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pAuthnLevel",
        "description": "A pointer to a variable that receives the current authentication level. This will be a single value taken from the authentication level constants. If the caller specifies NULL, the current authentication level is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pImpLevel",
        "description": "A pointer to a variable that receives the current impersonation level. This will be a single value taken from the impersonation level constants. If the caller specifies NULL, the current impersonation level is not retrieved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "RPC_AUTH_IDENTITY_HANDLE*",
        "name": "pAuthInfo",
        "description": "A pointer to a handle that receives the identity of the client that was passed to the last IClientSecurity::SetBlanket call (or the default value). Default values are only valid until the proxy is released. If the caller specifies NULL, the client identity is not retrieved. The format of the structure that the handle refers to depends on the authentication service. The application should not write or free the memory. For NTLMSSP and Kerberos, if the client specified a structure in the pAuthInfo parameter to CoInitializeSecurity, that value is returned. For Schannel, if a certificate for the client could be retrieved from the certificate manager, that value is returned here. Otherwise, NULL is returned. See RPC_AUTH_IDENTITY_HANDLE."
      },
      {
        "in_out": "_Out_opt_",
        "type": "DWORD*",
        "name": "pCapabilites",
        "description": "A pointer to a variable that receives the capabilities of the proxy. If the caller specifies NULL, the current capability flags are not retrieved."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Registers an EXE class object with OLE so other applications can connect to it.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "EXE object applications should call CoRegisterClassObject on startup. It can also be used to register internal objects for use by the same EXE or other code (such as DLLs) that the EXE uses. Only EXE object applications call CoRegisterClassObject. Object handlers or DLL object applications do not call this function \u00e2\u0080\u0094 instead, they must implement and export the DllGetClassObject function. At startup, a multiple-use EXE object application must create a class object (with the IClassFactory interface on it), and call CoRegisterClassObject to register the class object. Object applications that support several different classes (such as multiple types of embeddable objects) must allocate and register a different class object for each. Multiple registrations of the same class object are independent and do not produce an error. Each subsequent registration yields a unique key in lpdwRegister. Multiple document interface (MDI) applications must register their class objects. Single document interface (SDI) applications must register their class objects only if they can be started by means of the /Embedding switch. The server for a class object should call CoRevokeClassObject to revoke the class object (remove its registration) when all of the following are true: After the class object is revoked, when its reference count reaches zero, the class object can be released, allowing the application to exit. Note that CoRegisterClassObject calls IUnknown::AddRef and CoRevokeClassObject calls IUnknown::Release, so the two functions form an AddRef/Release pair. As of Windows Server 2003, if a COM object application is registered as a service, COM verifies the registration. COM makes sure the process ID of the service, in the service control manager (SCM), matches the process ID of the registering process. If not, COM fails the registration. If the COM object application runs in the system account with no registry key, COM treats the objects application identity as Launching User. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterClassObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID to be registered."
      },
      {
        "in_out": "_In_",
        "type": "LPUNKNOWN",
        "name": "pUnk",
        "description": "A pointer to the IUnknown interface on the class object whose availability is being published."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwClsContext",
        "description": "The context in which the executable code is to be run. For information on these context values, see the CLSCTX enumeration."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "flags",
        "description": "Indicates how connections are made to the class object. For information on these flags, see the REGCLS enumeration."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwRegister",
        "description": "A pointer to a value that identifies the class object registered; later used by the CoRevokeClassObject function to revoke the registration."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Registers an implementation of the IInitializeSpy interface. The IInitializeSpy interface is defied to allow developers to perform initialization and cleanup on COM apartments.",
    "library": "Ole32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "The CoRegisterInitializeSpy function registers an implementation of the IInitializeSpy interface, which defines methods to be called when CoInitializeEx (or CoInitialize) or CoUninitialize is invoked. CoRegisterInitializeSpy calls QueryInterface for IID_InitializeSpy on pSpy. It stores the address of the returned interface pointer in thread-specific storage that is independent of the COM initialization state for this thread. On success, it stores in puliCookie a ULARGE_INTEGER cookie that represents this registration. Pass this cookie to CoRevokeInitializeSpy to revoke the registration. IInitializeSpy implementations must deal with nesting issues caused by calling CoInitializeEx or CoUninitialize from within a notification method. Notifications occur only after the registration happens on this thread. For example, if CoInitializeEx is called before CoRegisterInitializeSpy, then the PreInitialize and PostInitialize notification methods will not be called. Notification methods must not cause the failure of CoInitializeEx or CoUninitialize by throwing exceptions. Implementations of IInitializeSpy must not propagate exceptions to code that calls CoInitializeEx or CoUninitialize. It is unpredictable whether a call to CoRegisterInitializeSpy from within an IInitializeSpy method call will be effective during the current top-level (non-nested) call to CoInitializeEx or CoUninitialize. A registered implementation of IInitializeSpy will always be effective for future top-level calls to CoInitializeEx or CoUninitialize. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterInitializeSpy",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPINITIALIZESPY",
        "name": "pSpy",
        "description": "A pointer to an instance of the IInitializeSpy implementation."
      },
      {
        "in_out": "_Out_",
        "type": "ULARGE_INTEGER*",
        "name": "puliCookie",
        "description": "The address at which to store a cookie that identifies this registration."
      }
    ],
    "min_client": "Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Registers an implementation of the IMallocSpy interface, thereafter requiring OLE to call its wrapper methods around every call to the corresponding IMalloc method.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as the following values.  ",
    "remarks": "The CoRegisterMallocSpy function registers the IMallocSpy object, which is used to debug calls to IMalloc methods. The function calls QueryInterface on the pointer pMallocSpy for the interface IID_IMallocSpy. This is to ensure that pMallocSpy really points to an implementation of IMallocSpy. By the rules of OLE, it is expected that a successful call to QueryInterface has added a reference (through the AddRef method) to the IMallocSpy object. That is, CoRegisterMallocSpy does not directly call AddRef on pMallocSpy, but fully expects that the QueryInterface call will. When the IMallocSpy object is registered, whenever there is a call to one of the IMalloc methods, OLE first calls the corresponding IMallocSpy pre-method. Then, after executing the IMalloc method, OLE calls the corresponding IMallocSpy post-method. For example, whenever there is a call to IMalloc::Alloc, from whatever source, OLE calls IMallocSpy::PreAlloc, calls Alloc, and after that allocation is completed, calls IMallocSpy::PostAlloc. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterMallocSpy",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPMALLOCSPY",
        "name": "pMallocSpy",
        "description": "A pointer to an instance of the IMallocSpy implementation."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Registers with OLE the instance of an IMessageFilter interface, which is to be used for handling concurrency issues on the current thread. Only one message filter can be registered for each thread. Threads in multithreaded apartments cannot have message filters.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the instance was registered or revoked successfully, the return value is S_OK; otherwise, it is S_FALSE. ",
    "remarks": "To revoke the registered message filter, pass the previous message filter (possibly NULL) as the lpMessageFilter parameter to CoRegisterMessageFilter. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterMessageFilter",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPMESSAGEFILTER",
        "name": "lpMessageFilter",
        "description": "A pointer to the IMessageFilter interface on the message filter. This message filter should be registered on the current thread, replacing the previous message filter (if any). This parameter can be NULL, indicating that no message filter should be registered on the current thread. Note that this function calls AddRef on the interface pointer to the message filter."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPMESSAGEFILTER*",
        "name": "lplpMessageFilter",
        "description": "Address of the IMessageFilter* pointer variable that receives the interface pointer to the previously registered message filter. If there was no previously registered message filter for the current thread, the value of *lplpMessageFilter is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Enables a downloaded DLL to register its custom interfaces within its running process so that the marshaling code will be able to marshal those interfaces.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK. ",
    "remarks": "Typically, the code responsible for marshaling an interface pointer into the current running process reads the HKEY_CLASSES_ROOT\\Interfaces section of the registry to obtain the CLSID of the DLL containing the ProxyStub code to be loaded. To obtain the ProxyStub CLSIDs for an existing interface, the code calls the CoGetPSClsid function. In some cases, however, it may be desirable or necessary for an in-process handler or in-process server to make its custom interfaces available without writing to the registry. A DLL downloaded across a network may not even have permission to access the local registry, and because the code originated on another computer, the user, for security purposes, may want to run it in a restricted environment. Or a DLL may have custom interfaces that it uses to talk to a remote server and may also include the ProxyStub code for those interfaces. In such cases, a DLL needs an alternative way to register its interfaces. CoRegisterPSClsid, used in conjunction with CoRegisterClassObject, provides that alternative. A DLL would typically call CoRegisterPSClsid as shown in the following code fragment. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterPSClsid",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A pointer to the IID of the interface to be registered."
      },
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "A pointer to the CLSID of the DLL that contains the proxy/stub code for the custom interface specified by riid."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Registers the surrogate process through its ISurrogate interface pointer.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function returns S_OK to indicate that the surrogate process was registered successfully. ",
    "remarks": "The CoRegisterSurrogate function sets a global interface pointer to the ISurrogate interface implemented on the surrogate process. This pointer is set in the ole32 DLL loaded in the surrogate process. COM uses this global pointer in ole32 to call the methods of ISurrogate. This function is usually called by the surrogate implementation when it is launched. As of Windows Server 2003, if a COM object application is registered as a service, COM verifies the registration. COM makes sure the process ID of the service, in the service control manager (SCM), matches the process ID of the registering process. If not, COM fails the registration. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRegisterSurrogate",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSURROGATE",
        "name": "pSurrogate",
        "description": "A pointer to the ISurrogate interface on the surrogate process to be registered."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Destroys a previously marshaled data packet.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "The CoReleaseMarshalData function performs the following tasks: You typically do not call this function. The only situation in which you might need to call this function is if you use custom marshaling (write and use your own implementation of IMarshal). Examples of when CoReleaseMarshalData should be called include the following situations: As an analogy, the data packet can be thought of as a reference to the original object, just as if it were another interface pointer being held on the object. Like a real interface pointer, that data packet must be released at some point. The use of IMarshal::ReleaseMarshalData to release data packets is analogous to the use of IUnknown::Release to release interface pointers. Note that you do not need to call CoReleaseMarshalData after a successful call of the CoUnmarshalInterface function; that function releases the marshal data as part of the processing that it does.   ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoReleaseMarshalData",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTREAM",
        "name": "pStm",
        "description": "A  pointer to the stream that contains the data packet to be destroyed. See IStream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Decrements the global per-process reference count.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "If the server application should initiate its cleanup, the function returns 0; otherwise, the function returns a nonzero value. ",
    "remarks": "Servers can call CoReleaseServerProcess to decrement a global per-process reference count incremented through a call to CoAddRefServerProcess. When that count reaches zero, OLE automatically calls CoSuspendClassObjects, which prevents new activation requests from coming in. This permits the server to deregister its class objects from its various threads without worry that another activation request may come in. New activation requests result in launching a new instance of the local server process. The simplest way for a local server application to make use of these functions is to call CoAddRefServerProcess in the constructor for each of its instance objects, and in each of its IClassFactory::LockServer methods when the fLock parameter is TRUE. The server application should also call CoReleaseServerProcess in the destructor of each of its instance objects, and in each of its IClassFactory::LockServer methods when the fLock parameter is FALSE. Finally, the server application must check the return code from CoReleaseServerProcess; if it returns 0, the server application should initiate its cleanup. This typically means that a server with multiple threads should signal its various threads to exit their message loops and call CoRevokeClassObject and CoUninitialize. If these APIs are used at all, they must be called in both the object instances and the LockServer method, otherwise the server application may be shutdown prematurely. In-process Servers typically should not call CoAddRefServerProcess or CoReleaseServerProcess. ",
    "return_type": "ULONG",
    "category": "COM",
    "name": "CoReleaseServerProcess",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Called by a server that can register multiple class objects to inform the SCM about all registered classes, and permits activation requests for those class objects.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function returns S_OK to indicate that the CLSID was retrieved successfully. ",
    "remarks": "Servers that can register multiple class objects call CoResumeClassObjects once, after having first called CoRegisterClassObject, specifying REGCLS_LOCAL_SERVER | REGCLS_SUSPENDED for each CLSID the server supports. This function causes OLE to inform the SCM about all the registered classes, and begins letting activation requests into the server process. This reduces the overall registration time, and thus the server application startup time, by making a single call to the SCM, no matter how many CLSIDs are registered for the server. Another advantage is that if the server has multiple apartments with different CLSIDs registered in different apartments, or is a free-threaded server, no activation requests will come in until the server calls CoResumeClassObjects. This gives the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests, and possibly shutdown requests. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoResumeClassObjects",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Restores the authentication information on a thread of execution.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function supports the standard return values, including S_OK to indicate success. ",
    "remarks": "CoRevertToSelf, which is a helper function that calls IServerSecurity::RevertToSelf, restores the authentication information on a thread to the authentication information on the thread before impersonation began. CoRevertToSelf encapsulates the following common sequence of calls (error handling excluded): ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRevertToSelf",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Informs OLE that a class object, previously registered with the CoRegisterClassObject function, is no longer available for use.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "A successful call to CoRevokeClassObject means that the class object has been removed from the global class object table (although it does not release the class object). If other clients still have pointers to the class object and have caused the reference count to be incremented by calls to IUnknown::AddRef, the reference count will not be zero. When this occurs, applications may benefit if subsequent calls (with the obvious exceptions of AddRef and IUnknown::Release) to the class object fail. Note that CoRegisterClassObject calls AddRef and CoRevokeClassObject calls Release, so the two functions form an AddRef/Release pair. An object application must call CoRevokeClassObject to revoke registered class objects before exiting the program. Class object implementers should call CoRevokeClassObject as part of the release sequence. You must specifically revoke the class object even when you have specified the flags value REGCLS_SINGLEUSE in a call to CoRegisterClassObject, indicating that only one application can connect to the class object. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRevokeClassObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRegister",
        "description": "A token previously returned from the CoRegisterClassObject function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Revokes a registered implementation of the IInitializeSpy interface.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_INVALIDARG, as well as S_OK to indicate success. ",
    "remarks": "CoRevokeInitializeSpy can only revoke cookies issued by previous calls to CoRegisterInitializeSpy that were executed on the current thread. Using a cookie from another thread, or one that corresponds to an already revoked registration, will return E_INVALIDARG. It is unpredictable whether a call to CoRevokeInitializeSpy from within an IInitializeSpy method call will have an effect during the current top-level (non-nested) call to CoInitializeEx or CoUninitialize. The revocation will always have an effect after the current top-level call to CoInitializeEx or CoUninitialize returns. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRevokeInitializeSpy",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULARGE_INTEGER",
        "name": "uliCookie",
        "description": "A ULARGE_INTEGER cookie identifying the registration."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Revokes a registered IMallocSpy object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "The IMallocSpy object is released when it is revoked. This release corresponds to the call to IUnknown::AddRef in the implementation of the QueryInterface function by the CoRegisterMallocSpy function. The implementation of the IMallocSpy interface should then do any appropriate cleanup. If the return code is E_ACCESSDENIED, there are still outstanding allocations that were made while the spy was active. In this case, the registered spy cannot be revoked at this time because it may have attached arbitrary headers and/or trailers to these allocations that only the spy knows about. Only the spy's PreFree (or PreRealloc) method knows how to account for these headers and trailers. Before returning E_ACCESSDENIED, CoRevokeMallocSpy notes internally that a revoke is pending. When the outstanding allocations have been freed, the revoke proceeds automatically, releasing the IMallocSpy object. Thus, it is necessary to call CoRevokeMallocSpy only once for each call to CoRegisterMallocSpy, even if E_ACCESSDENIED is returned. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoRevokeMallocSpy",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets (registers) or resets (unregisters) a cancel object for use during subsequent cancel operations on the current thread.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "For objects that support standard marshaling, the proxy object begins marshaling a method call by calling CoSetCancelObject to register a cancel object for the current thread. CoSetCancelObject calls QueryInterface for ICancelMethodCalls on the cancel object. If the cancel object does not implement ICancelMethodCalls, CoSetCancelObject fails with E_NOINTERFACE. To disable cancel operations on a custom-marshaled interface, the implementation of ICancelMethodCalls::Cancel should do nothing but return E_NOTIMPL, E_FAIL, or some other appropriate value. CoSetCancelObject calls AddRef on objects that it registers and Release on objects that it unregisters. CoSetCancelObject does not set or reset cancel objects for asynchronous methods. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoSetCancelObject",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "IUnknown*",
        "name": "pUnk",
        "description": "Pointer to the IUnknown interface on the cancel object to be set or reset on the current thread. If this parameter is NULL, the topmost cancel object is reset."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Registers or unregisters the per-thread message dispatcher that is to be invoked when there are window messages available to dispatch within COM wait APIs on an ASTA thread. This function is usually called by CoreWindow, but in certain circumstances other components that need to specialize how messages are dispatched on an ASTA thread can also call this function.",
    "library": "",
    "min_server": "",
    "header": "",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "This function is supported only in ASTA threads. An attempt to set the message dispatcher on a non-ASTA thread silently fails with no side effects. An attempt to set an object that does not implement IWeakReferenceSource silently fails with no side effects. A call to this function with a valid and non-null pMessageDispatcher parameter registers this object to receive a PumpMessages callback whenever there are window messages available to dispatch with COM wait APIs on that ASTA thread. A Windows Runtime weak reference to this object is held, and the object receives callbacks, until the registration is replaced or the ASTA uninitialized. Each call to this function replaces the previously registered message dispatcher, if any. There is no way to check if a message dispatcher is registered on an ASTA thread or to retrieve a previously registered message dispatcher. This function should only be called under circumstances where it is known that this will not collide with another registration, specifically: The case of IAppVisibility browsers requires care to avoid CoreWindow replacing the browser's message dispatcher. It is assumed that the browser has no need for CoreWindow's dispatcher. The browser should call CoSetMessageDispatcher no sooner than its IViewProvider::Initialize, or, in the case of views that implement IInitializeWithWindowFactory, no sooner than after it has created a window on the thread.   ",
    "return_type": "HRESULT WINOLEAPI",
    "category": "COM",
    "name": "CoSetMessageDispatcher",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "_In_opt_*",
        "name": "pMessageDispatcher",
        "description": "If non-null, message dispatcher object to register. This object must also implement IWeakReferenceSource. If null, unregisters the current message dispatcher."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 8,
    "description": "Sets the authentication information that will be used to make calls on the specified proxy. This is a helper function for IClientSecurity::SetBlanket.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "CoSetProxyBlanket sets the authentication information that will be used to make calls on the specified proxy. This function encapsulates the following sequence of common calls (error handling excluded). This sequence calls QueryInterface on the proxy to get a pointer to IClientSecurity, and with the resulting pointer, calls IClientSecurity::SetBlanket and then releases the pointer. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoSetProxyBlanket",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IUnknown*",
        "name": "pProxy",
        "description": "The proxy to be set."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAuthnSvc",
        "description": "The authentication service to be used. For a list of possible values, see Authentication Service Constants. Use RPC_C_AUTHN_NONE if no authentication is required. If RPC_C_AUTHN_DEFAULT is specified, DCOM will pick an authentication service following its normal security blanket negotiation algorithm."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAuthzSvc",
        "description": "The authorization service to be used. For a list of possible values, see Authorization Constants. If RPC_C_AUTHZ_DEFAULT is specified, DCOM will pick an authorization service following its normal security blanket negotiation algorithm. RPC_C_AUTHZ_NONE should be used as the authorization service if NTLMSSP, Kerberos, or Schannel is used as the authentication service."
      },
      {
        "in_out": "_In_opt_",
        "type": "OLECHAR*",
        "name": "pServerPrincName",
        "description": "The server principal name to be used with the authentication service. If COLE_DEFAULT_PRINCIPAL is specified, DCOM will pick a principal name using its security blanket negotiation algorithm. If Kerberos is used as the authentication service, this value must not be NULL. It must be the correct principal name of the server or the call will fail. If Schannel is used as the authentication service, this value must be one of the msstd or fullsic forms described in Principal Names, or NULL if you do not want mutual authentication. Generally, specifying NULL will not reset the server principal name on the proxy; rather, the previous setting will be retained. You must be careful when using NULL as pServerPrincName when selecting a different authentication service for the proxy, because there is no guarantee that the previously set principal name would be valid for the newly selected authentication service."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAuthnLevel",
        "description": "The authentication level to be used. For a list of possible values, see Authentication Level Constants. If RPC_C_AUTHN_LEVEL_DEFAULT is specified, DCOM will pick an authentication level following its normal security blanket negotiation algorithm. If this value is none, the authentication service must also be none."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwImpLevel",
        "description": "The impersonation level to be used. For a list of possible values, see Impersonation Level Constants. If RPC_C_IMP_LEVEL_DEFAULT is specified, DCOM will pick an impersonation level following its normal security blanket negotiation algorithm. If NTLMSSP is the authentication service, this value must be RPC_C_IMP_LEVEL_IMPERSONATE or RPC_C_IMP_LEVEL_IDENTIFY. NTLMSSP also supports delegate-level impersonation (RPC_C_IMP_LEVEL_DELEGATE) on the same computer. If Schannel is the authentication service, this parameter must be RPC_C_IMP_LEVEL_IMPERSONATE."
      },
      {
        "in_out": "_In_opt_",
        "type": "RPC_AUTH_IDENTITY_HANDLE",
        "name": "pAuthInfo",
        "description": "A pointer to an RPC_AUTH_IDENTITY_HANDLE value that establishes the identity of the client. The format of the structure referred to by the handle depends on the provider of the authentication service. For calls on the same computer, RPC logs on the user with the supplied credentials and uses the resulting token for the method call.  For NTLMSSP or Kerberos, the structure is a SEC_WINNT_AUTH_IDENTITY or SEC_WINNT_AUTH_IDENTITY_EX structure.  The client can discard  pAuthInfo after calling the API. RPC does not keep a copy of the pAuthInfo pointer, and the client cannot retrieve it later in the CoQueryProxyBlanket method.  If this parameter is NULL, DCOM uses the current proxy identity (which is either the process token or the impersonation token). If the handle refers to a structure, that identity is used. For Schannel, this parameter must be either a pointer to a CERT_CONTEXT structure that contains the client's X.509 certificate or is NULL if the client wishes to make an anonymous connection to the server. If a certificate is specified, the caller must not free it as long as any proxy to the object exists in the current apartment. For Snego, this member is either NULL, points to a SEC_WINNT_AUTH_IDENTITY structure, or points to a SEC_WINNT_AUTH_IDENTITY_EX structure. If it is NULL, Snego will pick a list of authentication services based on those available on the client computer. If it points to a SEC_WINNT_AUTH_IDENTITY_EX structure, the structure's PackageList member must point to a string containing a comma-separated list of authentication service names and the PackageListLength member must give the number of bytes in the PackageList string. If PackageList is NULL, all calls using Snego will fail. If COLE_DEFAULT_AUTHINFO is specified for this parameter, DCOM will pick the authentication information following its normal security blanket negotiation algorithm. CoSetProxyBlanket will fail if pAuthInfo is set and one of the cloaking flags is set in the dwCapabilities parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCapabilities",
        "description": "The capabilities of this proxy. For a list of possible values, see the EOLE_AUTHENTICATION_CAPABILITIES enumeration. The only flags that can be set through this function are EOAC_MUTUAL_AUTH, EOAC_STATIC_CLOAKING, EOAC_DYNAMIC_CLOAKING, EOAC_ANY_AUTHORITY (this flag is deprecated), EOAC_MAKE_FULLSIC, and EOAC_DEFAULT. Either EOAC_STATIC_CLOAKING or EOAC_DYNAMIC_CLOAKING can be set if pAuthInfo is not set and Schannel is not the authentication service. (See Cloaking for more information.) If any capability flags other than those mentioned here are set, CoSetProxyBlanket will fail."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Prevents any new activation requests from the SCM on all class objects registered within the process.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function returns S_OK to indicate that the activation of class objects was successfully suspended. ",
    "remarks": "CoSuspendClassObjects prevents any new activation requests from the SCM on all class objects registered within the process. Even though a process may call this function, the process still must call the CoRevokeClassObject function for each CLSID it has registered, in the apartment it registered in. Applications typically do not need to call this function, which is generally only called internally by OLE when used in conjunction with the CoReleaseServerProcess function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoSuspendClassObjects",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Switches the call context object used by CoGetCallContext.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "Custom marshallers call CoSwitchCallContext to change the call context object used by the CoGetCallContext function. Before dispatching an arriving call, custom marshallers call CoSwitchCallContext, specifying the new context object. After sending a reply, they must restore the original call context by calling CoSwitchCallContext again, this time passing a pointer to the original context object. CoSwitchCallContext does not add a reference to the new context object. Custom marshallers must ensure that the lifetime of their context object continues throughout their call and until the call to restore the original context.  Custom marshallers should not release the value that they placed into the ppOldObject parameter when they set their context. Call context objects provided by custom marshallers should support the IServerSecurity interface. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoSwitchCallContext",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "IUnknown*",
        "name": "pNewObject",
        "description": "A pointer to an interface on the new call context object. COM stores this pointer without adding a reference to the pointer until CoSwitchCallContext is called with another object. This parameter may be NULL if you are calling CoSwitchCallContext to switch back to the original call context but there was no original call context."
      },
      {
        "in_out": "_Out_",
        "type": "IUnknown**",
        "name": "ppOldObject",
        "description": "The address of pointer variable that receives a pointer to the call context object of the call currently in progress. This value is returned so that the original call context can be restored by the custom marshaller. The returned pointer will be NULL if there was no call in progress."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Allocates a block of task memory in the same way that IMalloc::Alloc does.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "If the function succeeds, it returns the allocated memory block. Otherwise, it returns NULL. ",
    "remarks": "CoTaskMemAlloc uses the default allocator to allocate a memory block in the same way that IMalloc::Alloc does. It is not necessary to call the CoGetMalloc function before calling CoTaskMemAlloc. The initial contents of the returned memory block are undefined \u00e2\u0080\u0093 there is no guarantee that the block has been initialized. The allocated block may be larger than cb bytes because of the space required for alignment and for maintenance information. If cb is 0, CoTaskMemAlloc allocates a zero-length item and returns a valid pointer to that item. If there is insufficient memory available, CoTaskMemAlloc returns NULL. Applications should always check the return value from this function, even when requesting small amounts of memory, because there is no guarantee that the memory will be allocated. ",
    "return_type": "LPVOID",
    "category": "COM",
    "name": "CoTaskMemAlloc",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "cb",
        "description": "The size of the memory block to be allocated, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Frees a block of task memory previously allocated through a call to the CoTaskMemAlloc or CoTaskMemRealloc function.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The CoTaskMemFree function uses the default OLE allocator. The number of bytes freed equals the number of bytes that were originally allocated or reallocated. After the call, the memory block pointed to by pv is invalid and can no longer be used. ",
    "return_type": "void",
    "category": "COM",
    "name": "CoTaskMemFree",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pv",
        "description": "A pointer to the memory block to be freed. If this parameter is NULL, the function has no effect."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Changes the size of a previously allocated block of task memory.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "If the function succeeds, it returns the reallocated memory block. Otherwise, it returns NULL. ",
    "remarks": "This function changes the size of a previously allocated memory block in the same way that IMalloc::Realloc does. It is not necessary to call the CoGetMalloc function to get a pointer to the OLE allocator before calling CoTaskMemRealloc. The pv parameter points to the beginning of the memory block. If pv is NULL, CoTaskMemRealloc allocates a new memory block in the same way as the CoTaskMemAlloc function. If pv is not NULL, it should be a pointer returned by a prior call to CoTaskMemAlloc. The cb parameter specifies the size of the new block. The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. Because the new block can be in a different memory location, the pointer returned by CoTaskMemRealloc is not guaranteed to be the pointer passed through the pv argument. If pv is not NULL and cb is 0, then the memory pointed to by pv is freed. CoTaskMemRealloc returns a void pointer to the reallocated (and possibly moved) memory block. The return value is NULL if the size is 0 and the buffer argument is not NULL, or if there is not enough memory available to expand the block to the specified size. In the first case, the original block is freed; in the second case, the original block is unchanged. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. To get a pointer to a type other than void, use a type cast on the return value. ",
    "return_type": "LPVOID",
    "category": "COM",
    "name": "CoTaskMemRealloc",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "pv",
        "description": "A pointer to the memory block to be reallocated. This parameter can be NULL, as discussed in Remarks."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "cb",
        "description": "The size of the memory block to be reallocated, in bytes. This parameter can be 0, as discussed in Remarks."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Determines whether the call being executed on the server has been canceled by the client.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "Server objects should call CoTestCancel at least once before returning to detect client cancellation requests. Doing so can save the server unnecessary work if the client has issued a cancellation request, and it can reduce the client's wait time if it has set the cancel timeout as RPC_C_CANCEL_INFINITE_TIMEOUT. Furthermore, if the server object detects a cancellation request before returning from a pending call, it can clean up any memory, marshaled interfaces, or handles it has created or obtained. CoTestCancel calls CoGetCallContext to obtain the ICancelMethodCalls interface on the current cancel object and then calls ICancelMethodCalls::TestCancel. Objects that implement custom marshaling should first call CoSwitchCallContext to install the appropriate call context object. This function does not test cancellation for asynchronous calls. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoTestCancel",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Establishes or removes an emulation, in which objects of one class are treated as objects of a different class.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, as well as the following values.  ",
    "remarks": "This function sets the TreatAs entry in the registry for the specified object, allowing the object to be emulated by another application. Emulation allows an application to open and edit an object of a different format, while retaining the original format of the object. After this entry is set, whenever any function such as CoGetClassObject specifies the object's original CLSID (clsidOld), it is transparently forwarded to the new CLSID (clsidNew), thus launching the application associated with the TreatAs CLSID. When the object is saved, it can be saved in its native format, which may result in loss of edits not supported by the original format. If your application supports emulation, call CoTreatAsClass in the following situations: An example of the first case is that an end user might wish to edit a spreadsheet created by one application using a different application that can read and write the spreadsheet format of the original application. For an application that supports emulation, CoTreatAsClass can be called to implement a Treat As option in a conversion dialog box. An example of the use of CoTreatAsClass in a setup program would be in an updated version of an application. When the application is updated, the objects created with the earlier version can be activated and treated as objects of the new version, while retaining the previous format information. This would allow you to give the user the option to convert when they save, or to save it in the previous format, possibly losing format information not available in the older version. One result of setting an emulation is that when you enumerate verbs, as in the IOleObject::EnumVerbs method implementation in the default handler, this would enumerate the verbs from clsidNew instead of clsidOld. To ensure that existing emulation information is removed when you install an application, your setup programs should call CoTreatAsClass, setting the clsidNew parameter to CLSID_NULL to remove any existing emulation for the classes they install. If there is no CLSID assigned to the AutoTreatAs key in the registry, setting clsidNew and clsidOld to the same value removes the TreatAs entry, so there is no emulation. If there is a CLSID assigned to the AutoTreatAs key, that CLSID is assigned to the TreatAs key. CoTreatAsClass does not validate whether an appropriate registry entry for clsidNew currently exists. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoTreatAsClass",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsidOld",
        "description": "The CLSID of the object to be emulated."
      },
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsidNew",
        "description": "The CLSID of the object that should emulate the original object. This replaces any existing emulation for clsidOld. This parameter can be CLSID_NULL, in which case any existing emulation for clsidOld is removed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Closes the COM library on the current thread, unloads all DLLs loaded by the thread, frees any other resources that the thread maintains, and forces all RPC connections on the thread to close.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function does not return a value. ",
    "remarks": "A thread must call CoUninitialize once for each successful call it has made to the CoInitialize or CoInitializeEx function, including any call that returns S_FALSE. Only the CoUninitialize call corresponding to the CoInitialize or CoInitializeEx call that initialized the library can close it. Calls to OleInitialize must be balanced by calls to OleUninitialize. The OleUninitialize function calls CoUninitialize internally, so applications that call OleUninitialize do not also need to call CoUninitialize. CoUninitialize should be called on application shutdown, as the last call made to the COM library after the application hides its main windows and falls through its main message loop. If there are open conversations remaining, CoUninitialize starts a modal message loop and dispatches any pending messages from the containers or server for this COM application. By dispatching the messages, CoUninitialize ensures that the application does not quit before receiving all of its pending messages. Non-COM messages are discarded. Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call CoInitialize, CoInitializeEx, or CoUninitialize from the DllMain function. ",
    "return_type": "void",
    "category": "COM",
    "name": "CoUninitialize",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Initializes a newly created proxy using data written into the stream by a previous call to the CoMarshalInterface function, and returns an interface pointer to that proxy.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_FAIL, errors returned by CoCreateInstance, and the following values.  ",
    "remarks": "The CoUnmarshalInterface function performs the following tasks: The primary caller of this function is COM itself, from within interface proxies or stubs that unmarshal an interface pointer. There are, however, some situations in which you might call CoUnmarshalInterface. For example, if you are implementing a stub, your implementation would call CoUnmarshalInterface when the stub receives an interface pointer as a parameter in a method call. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoUnmarshalInterface",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTREAM",
        "name": "pStm",
        "description": "A pointer to the stream from which the interface is to be unmarshaled."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "A reference to the identifier of the interface to be unmarshaled. For IID_NULL, the returned interface is the one defined by the stream, objref.iid."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID*",
        "name": "ppv",
        "description": "The address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the requested interface pointer for the unmarshaled interface."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Waits for specified handles to be signaled or for a specified timeout period to elapse.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "Depending on which flags are set in the dwFlags parameter, CoWaitForMultipleHandles blocks the calling thread until one of the following events occurs: The following flags are required when you call CoWaitForMultipleHandles within a Windows Store app: COWAIT_DISPATCH_CALLS | COWAIT_DISPATCH_WINDOW_MESSAGES. Without these flags, deadlocks may occur. If the caller resides in a single-thread apartment, CoWaitForMultipleHandles enters the COM modal loop, and the thread's message loop will continue to dispatch messages using the thread's message filter. If no message filter is registered for the thread, the default COM message processing is used. If the calling thread resides in a multithread apartment (MTA), CoWaitForMultipleHandles calls the  WaitForMultipleObjectsEx function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CoWaitForMultipleHandles",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The wait options. Possible values are taken from the COWAIT_FLAGS enumeration."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimeout",
        "description": "The timeout period, in milliseconds."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "cHandles",
        "description": "The number of elements in the pHandles array."
      },
      {
        "in_out": "_In_",
        "type": "LPHANDLE",
        "name": "pHandles",
        "description": "An array of handles."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwindex",
        "description": "A pointer to a variable that, when the returned status is S_OK, receives a value indicating the event that caused the function to return. ..."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "A replacement for CoWaitForMultipleHandles. This replacement API hides the options for CoWaitForMultipleHandles that are not supported in ASTA.",
    "library": "",
    "min_server": "",
    "header": "Combaseapi.h",
    "return_value": "Same return values as CoWaitForMultipleHandles, except the ASTA-specific CO_E_NOTSUPPORTED cases instead return E_INVALIDARG from all apartment types. ",
    "remarks": "",
    "return_type": "HRESULT WINOLEAPI",
    "category": "COM",
    "name": "CoWaitForMultipleObjects",
    "is_callback": 0,
    "dll": "Combase.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "CWMO_FLAGS flag controlling whether call/window message reentrancy is enabled from this wait. By default, neither COM calls nor window messages are dispatched from CoWaitForMultipleObjects in ASTA."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimeout",
        "description": "The timeout in milliseconds of the wait."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "cHandles",
        "description": "The length of the pHandles array. Must be <= 56."
      },
      {
        "in_out": "_In_",
        "type": "LPHANDLE",
        "name": "pHandles",
        "description": "An array of handles to waitable kernel objects."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwIndex",
        "description": "Receives the index of the handle that satisfied the wait."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Creates and returns a new anti-moniker.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and S_OK. ",
    "remarks": "You would call this function only if you are writing your own moniker class (implementing the IMoniker interface). If you are writing a new moniker class that has no internal structure, you can use CreateAntiMoniker in your implementation of the IMoniker::Inverse method, and then check for an anti-moniker in your implementation of IMoniker::ComposeWith. Like the \"..\" directory, which acts as the inverse to any directory name just preceding it in a path, an anti-moniker acts as the inverse of a simple moniker that precedes it in a composite moniker. An anti-moniker is used as the inverse of simple monikers with no internal structure. For example, the system-provided implementations of file monikers, item monikers, and pointer monikers all use anti-monikers as their inverse; consequently, an anti-moniker composed to the right of one of these monikers composes to nothing. A moniker client (an object that is using a moniker to bind to another object) typically does not know the class of a given moniker, so the client cannot be sure that an anti-moniker is the inverse. Therefore, to get the inverse of a moniker, you would call IMoniker::Inverse rather than CreateAntiMoniker. To remove the last piece of a composite moniker, you would do the following: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateAntiMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the new anti-moniker. When successful, the function has called AddRef on the anti-moniker and the caller is responsible for calling Release. When an error occurs, the anti-moniker pointer is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Creates an asynchronous bind context for use with asynchronous monikers.",
    "library": "Urlmon.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Urlmon.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "This function automatically registers the IBindStatusCallback and IEnumFORMATETC interfaces with the bind context. The client can specify flags from BSCO_OPTION to indicate which callback notifications the client is capable of receiving. If the client does not wish to receive certain notification, it can choose to implement those callback methods as empty function stubs (returning E_NOTIMPL), and they should not be called. The RegisterBindStatusCallback function can also be used to register callback interfaces in the bind context. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateAsyncBindCtx",
    "is_callback": 0,
    "dll": "Urlmon.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "reserved",
        "description": "This parameter is reserved and must be 0."
      },
      {
        "in_out": "_In_",
        "type": "IBindStatusCallback*",
        "name": "pBSCb",
        "description": "A pointer to the IBindStatusCallback interface used for receiving data availability and progress notification."
      },
      {
        "in_out": "_In_",
        "type": "IEnumFORMATETC*",
        "name": "pEFetc",
        "description": "A pointer to the IEnumFORMATETC interface that can be used to enumerate formats for format negotiation during binding. This parameter can be NULL, in which case the caller is not interested in format negotiation during binding, and the default format of the object will be bound to."
      },
      {
        "in_out": "_Out_",
        "type": "IBindCtx**",
        "name": "ppBC",
        "description": "Address of an IBindCtx* pointer variable that receives the interface pointer to the new bind context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Returns a pointer to an implementation of IBindCtx (a bind context object). This object stores information about a particular moniker-binding operation.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and S_OK. ",
    "remarks": "CreateBindCtx is most commonly used in the process of binding a moniker (locating and getting a pointer to an interface by identifying it through a moniker), as in the following steps: The following code fragment illustrates these steps. Bind contexts are also used in other methods of the IMoniker interface besides IMoniker::BindToObject and in the MkParseDisplayName function. A bind context retains references to the objects that are bound during the binding operation, causing the bound objects to remain active (keeping the object's server running) until the bind context is released. Reusing a bind context when subsequent operations bind to the same object can improve performance. You should, however, release the bind context as soon as possible, because you could be keeping the objects activated unnecessarily. A bind context contains a BIND_OPTS structure, which contains parameters that apply to all steps in a binding operation. When you create a bind context using CreateBindCtx, the fields of the BIND_OPTS structure are initialized as follows. You can call the IBindCtx::SetBindOptions method to modify these default values. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateBindCtx",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "reserved",
        "description": "This parameter is reserved and must be 0."
      },
      {
        "in_out": "_Out_",
        "type": "LPBC*",
        "name": "ppbc",
        "description": "Address of an IBindCtx* pointer variable that receives the interface pointer to the new bind context object. When the function is successful, the caller is responsible for calling Release on the bind context. A NULL value for the bind context indicates that an error occurred."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Creates a class moniker that refers to the specified class.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "The class moniker will support the binding to a fresh instance of the class identified by the CLSID in rclsid. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateClassMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "A reference to the CLSID of the object type to which this moniker binds."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the new class moniker. On successful return, the function has called AddRef on the moniker and the caller is responsible for calling Release. When an error occurs, the value of the moniker pointer is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Creates a file moniker based on the specified path.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_OUTOFMEMORY, as well as the following values.  ",
    "remarks": "CreateFileMoniker creates a moniker for an object that is stored in a file. A moniker provider (an object that provides monikers to other objects) can call this function to create a moniker to identify a file-based object that it controls, and can then make the pointer to this moniker available to other objects. An object identified by a file moniker must also implement the IPersistFile interface so it can be loaded when a file moniker is bound. When each object resides in its own file, as in an OLE server application that supports linking only to file-based documents in their entirety, file monikers are the only type of moniker necessary. To identify objects smaller than a file, the moniker provider must use another type of moniker (such as an item moniker) in addition to file monikers, creating a composite moniker. Composite monikers would be needed in an OLE server application that supports linking to objects smaller than a document (such as sections of a document or embedded objects). A file moniker can be composed to the right only of another file moniker when the first moniker is based on an absolute path and the other is a relative path, resulting in a single file moniker based on the combination of the two paths. A moniker composed to the right of another moniker must be a refinement of that moniker, and the file moniker represents the largest unit of storage. To identify objects stored within a file, you would compose other types of monikers (usually item monikers) to the right of a file moniker. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateFileMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpszPathName",
        "description": "The path on which this moniker is to be based. This parameter can specify a relative path, a UNC path, or a drive-letter-based path. If based on a relative path, the resulting moniker must be composed onto another file moniker before it can be bound."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the new file moniker. When successful, the function has called AddRef on the file moniker and the caller is responsible for calling Release. When an error occurs, the value of the interface pointer is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Performs a generic composition of two monikers and supplies a pointer to the resulting composite moniker.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_OUTOFMEMORY, as well as the following values.  ",
    "remarks": "CreateGenericComposite joins two monikers into one. The moniker classes being joined can be different, subject only to the rules of composition. Call this function only if you are writing a new moniker class by implementing the IMoniker interface, within an implementation of IMoniker::ComposeWith that includes generic composition capability. Moniker providers should call ComposeWith to compose two monikers together. Implementations of ComposeWith should (as do OLE implementations) attempt, when reasonable for the class, to perform non-generic compositions first, in which two monikers of the same class are combined. If this is not possible, the implementation can call CreateGenericComposite to do a generic composition, which combines two monikers of different classes, within the rules of composition. You can define new types of non-generic compositions if you write a new moniker class. During the process of composing the two monikers, CreateGenericComposite makes all possible simplifications. Consider the example where pmkFirst is the generic composite moniker, A + B + C, and pmkRest is the generic composite moniker, C -1 + B -1 + Z (where C -1 is the inverse of C). The function first composes C to C -1, which composes to nothing. Then it composes B and B -1 to nothing. Finally, it composes A to Z, and supplies a pointer to the generic composite moniker, A + Z. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateGenericComposite",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPMONIKER",
        "name": "pmkFirst",
        "description": "A pointer to the moniker to be composed to the left of the moniker that pmkRest points to. Can point to any kind of moniker, including a generic composite."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPMONIKER",
        "name": "pmkRest",
        "description": "A pointer to the moniker to be composed to the right of the moniker to which pmkFirst points. Can point to any kind of moniker compatible with the type of the pmkRest moniker, including a generic composite."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmkComposite",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the composite moniker object that is the result of composing pmkFirst and pmkRest. This object supports the OLE composite moniker implementation of IMoniker. When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. If either pmkFirst or pmkRest are NULL, the supplied pointer is the one that is non-NULL. If both pmkFirst and pmkRest are NULL, or if an error occurs, the returned pointer is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates an item moniker that identifies an object within a containing object (typically a compound document).",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and S_OK. ",
    "remarks": "A moniker provider, which hands out monikers to identify its objects so they are accessible to other parties, would call CreateItemMoniker to identify its objects with item monikers. Item monikers are based on a string, and identify objects that are contained within another object and can be individually identified using a string. The containing object must also implement the IOleContainer interface. Most moniker providers are OLE applications that support linking. Applications that support linking to objects smaller than file-based documents, such as a server application that allows linking to a selection within a document, should use item monikers to identify the objects. Container applications that allow linking to embedded objects use item monikers to identify the embedded objects. The lpszItem parameter is the name used by the document to uniquely identify the object. For example, if the object being identified is a cell range in a spreadsheet, an appropriate name might be something like \"A1:E7.\" An appropriate name when the object being identified is an embedded object might be something like \"embedobj1.\" The containing object must provide an implementation of the IOleItemContainer interface that can interpret this name and locate the corresponding object. This allows the item moniker to be bound to the object it identifies. Item monikers are not used in isolation. They must be composed with a moniker that identifies the containing object as well. For example, if the object being identified is a cell range contained in a file-based document, the item moniker identifying that object must be composed with the file moniker identifying that document, resulting in a composite moniker that is the equivalent of \"C:\\work\\sales.xls!A1:E7.\" Nested containers are allowed also, as in the case where an object is contained within an embedded object inside another document. The complete moniker of such an object would be the equivalent of \"C:\\work\\report.doc!embedobj1!A1:E7.\" In this case, each containing object must call CreateItemMoniker and provide its own implementation of the IOleItemContainer interface. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateItemMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpszDelim",
        "description": "A pointer to a wide character string (two bytes per character) zero-terminated string containing the delimiter (typically \"!\") used to separate this item's display name from the display name of its containing object."
      },
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpszItem",
        "description": "A pointer to a zero-terminated string indicating the containing object's name for the object being identified. This name can later be used to retrieve a pointer to the object in a call to IOleItemContainer::GetObject."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the item moniker. When successful, the function has called AddRef on the item moniker and the caller is responsible for calling Release. If an error occurs, the supplied interface pointer has a NULL value."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Creates an OBJREF moniker based on a pointer to an object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK. ",
    "remarks": "Clients use OBJREF monikers to obtain a marshaled pointer to a running object in the servers address space. The server typically calls CreateObjrefMoniker to create an OBJREF moniker and then calls IMoniker::GetDisplayName, and finally releases the moniker. The display name for an OBJREF moniker is of the form: OBJREF:nnnnnnnn Where nnnnnnnn is an arbitrarily long base-64 encoding that encapsulates the computer location, process endpoint, and interface pointer ID (IPID) of the running object The display name can then be transferred to the client as text. For example, the display name can reside on an HTML page that the client downloads. The client can pass the display name to MkParseDisplayName, which creates an OBJREF moniker based on the display name. A call to the monikers IMoniker::BindToObject method then obtains a marshaled pointer to the running instance on the server. For example, a server-side COM component contained in an Active Server Page can create an OBJREF moniker, obtain its display name, and write the display name to the HTML output that is sent to the client browser. A script that runs on the client side can use the display name to get access to the running object itself. A client-side Visual Basic script, for instance, could store the display name in a variable called strMyName and include this line: objMyInstance = GetObject(strMyName) The script engine internally makes the calls to MkParseDisplayName and IMoniker::BindToObject, and the script can then use objMyInstance to refer directly to the running object. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreateObjrefMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPUNKNOWN",
        "name": "punk",
        "description": "A pointer to the IUnknown interface on the object that the moniker is to represent."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "Address of a pointer to the IMoniker interface on the OBJREF moniker that was created."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Creates a pointer moniker based on a pointer to an object.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK. ",
    "remarks": "A pointer moniker wraps an existing interface pointer in a moniker that can be passed to those interfaces that require monikers. Pointer monikers allow an object that has no persistent representation to participate in a moniker-binding operation. Pointer monikers are not commonly used, so this function is not often called. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "CreatePointerMoniker",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPUNKNOWN",
        "name": "punk",
        "description": "A pointer to an IUnknown interface on the object to be identified by the resulting moniker."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the new pointer moniker. When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. When an error occurs, the returned interface pointer has a NULL value."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Exported by COM DLLs to enable remote debugging.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "N/A",
    "return_value": "TRUE if successful, FALSE otherwise ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "COM",
    "name": "DllDebugObjectRPCHook",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "BOOL",
        "name": "fTrace",
        "description": "If TRUE, remote debugging is enabled. If FALSE, remote debugging is not enabled."
      },
      {
        "in_out": "",
        "type": "LPORPC_INIT_ARGS",
        "name": "lpOrpcInitArgs",
        "description": "A pointer to an ORPC_INIT_ARGS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Returns the CLSID associated with the specified file name.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return any of the file system errors, as well as the following values.  ",
    "remarks": "When given a file name, GetClassFile finds the CLSID associated with that file. Examples of its use are in the OleCreateFromFile function, which is passed a file name and requires an associated CLSID, and in the OLE implementation of IMoniker::BindToObject, which, when a link to a file-based document is activated, calls GetClassFile to locate the object application that can open the file. GetClassFile uses the following strategies to determine an appropriate CLSID: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "GetClassFile",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "szFilename",
        "description": "A pointer to the filename for which you are requesting the associated CLSID."
      },
      {
        "in_out": "_Out_",
        "type": "CLSID*",
        "name": "pclsid",
        "description": "A pointer to the location where the associated CLSID is written on return."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Returns a pointer to the IRunningObjectTable interface on the local running object table (ROT).",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_UNEXPECTED and S_OK. ",
    "remarks": "Each workstation has a local ROT that maintains a table of the objects that have been registered as running on that computer. This function returns an IRunningObjectTable interface pointer, which provides access to that table. Moniker providers, which hand out monikers that identify objects so they are accessible to others, should call GetRunningObjectTable. Use the interface pointer returned by this function to register your objects when they begin running, to record the times that those objects are modified, and to revoke their registrations when they stop running. See the IRunningObjectTable interface for more information. Compound-document link sources are the most common example of moniker providers. These include server applications that support linking to their documents (or portions of a document) and container applications that support linking to embeddings within their documents. Server applications that do not support linking can also use the ROT to cooperate with container applications that support linking to embeddings. If you are implementing the IMoniker interface to write a new moniker class, and you need an interface pointer to the ROT, call IBindCtx::GetRunningObjectTable rather than the GetRunningObjectTable function. This allows future implementations of the IBindCtx interface to modify binding behavior. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "GetRunningObjectTable",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "reserved",
        "description": "This parameter is reserved and must be 0."
      },
      {
        "in_out": "_Out_",
        "type": "LPRUNNINGOBJECTTABLE*",
        "name": "pprot",
        "description": "The address of an IRunningObjectTable* pointer variable that receives the interface pointer to the local ROT. When the function is successful, the caller is responsible for calling Release on the interface pointer. If an error occurs, *pprot is undefined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Converts a string generated by the StringFromIID function back into the original interface identifier (IID).",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK. ",
    "remarks": "The function converts the interface identifier in a way that guarantees different interface identifiers will always be converted to different strings. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "IIDFromString",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "lpsz",
        "description": "A pointer to the string representation of the IID."
      },
      {
        "in_out": "_Out_",
        "type": "LPIID",
        "name": "lpiid",
        "description": "A pointer to the requested IID on return."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Initializes a thread to use Windows Runtime APIs.",
    "library": "",
    "min_server": "",
    "header": "ROApi.h",
    "return_value": "",
    "remarks": "Windows::Foundation::Initialize is changed to create      ASTAs instead of classic STAs for the RO_INIT_TYPE      value RO_INIT_SINGLETHREADED.      Windows::Foundation::Initialize(RO_INIT_SINGLETHREADED)      is not supported for desktop applications and will return CO_E_NOTSUPPORTED if called      from a process other than a Windows Store app. For Microsoft DirectX applications, you must initialize the initial thread by using      Windows::Foundation::Initialize(RO_INIT_MULTITHREADED). For an out-of-process EXE server,  you must initialize the initial thread of the server by using      Windows::Foundation::Initialize(RO_INIT_MULTITHREADED). ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "Initialize",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "RO_INIT_TYPE",
        "name": "initType",
        "description": "Specifies the apartment type of the thread to be initialized."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Determines whether the specified keystroke maps to an accelerator in the specified accelerator table.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "If the message is for the object application, the return value is TRUE. If the message is not for the object and should be forwarded to the container, the return value is FALSE. ",
    "remarks": "While an object is active in-place, the object always has first chance to translate the keystrokes into accelerators. If the keystroke corresponds to one of its accelerators, the object must not call the OleTranslateAccelerator function \u00c3\u00a2\u00e2\u0082\u00ac\u00e2\u0080\u009d even if its call to the TranslateAccelerator function fails. Failure to process keystrokes in this manner can lead to inconsistent behavior. If the keystroke is not one of the object's accelerators, then the object must call OleTranslateAccelerator to let the container try its accelerator translation. The object's server can call IsAccelerator to determine if the accelerator message belongs to it. Some servers do accelerator translation on their own and do not call TranslateAccelerator. Those applications will not call IsAccelerator, because they already have the information. ",
    "return_type": "BOOL",
    "category": "COM",
    "name": "IsAccelerator",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HACCEL",
        "name": "hAccel",
        "description": "A handle to the accelerator table."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cAccelEntries",
        "description": "The number of entries in the accelerator table."
      },
      {
        "in_out": "_In_",
        "type": "LPMSG",
        "name": "lpMsg",
        "description": "A pointer to the keystroke message to be translated."
      },
      {
        "in_out": "_Out_",
        "type": "WORD*",
        "name": "lpwCmd",
        "description": "A pointer to a variable  to receive the corresponding command identifier if there is an accelerator for the keystroke. This parameter may be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether two CLSIDs are equal.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "GuidDef.h",
    "return_value": "If the values are equal, the return value is TRUE. Otherwise, the return value is FALSE. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "COM",
    "name": "IsEqualCLSID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid1",
        "description": "The first CLSID."
      },
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid2",
        "description": "The second CLSID."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether two GUIDs are equal.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "GuidDef.h",
    "return_value": "If the values are equal, the return value is TRUE. Otherwise, the return value is FALSE. ",
    "remarks": "IsEqualGUID is used by the IsEqualCLSID and IsEqualIID functions. ",
    "return_type": "BOOL",
    "category": "COM",
    "name": "IsEqualGUID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFGUID",
        "name": "rguid1",
        "description": "The first GUID."
      },
      {
        "in_out": "_In_",
        "type": "REFGUID",
        "name": "rguid2",
        "description": "The second GUID."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether two interface identifiers are equal.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "GuidDef.h",
    "return_value": "If the values are equal, the return value is TRUE. Otherwise, the return value is FALSE. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "COM",
    "name": "IsEqualIID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFGUID",
        "name": "riid1",
        "description": "The first interface identifier."
      },
      {
        "in_out": "_In_",
        "type": "REFGUID",
        "name": "riid2",
        "description": "The second interface identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Converts a string into a moniker that identifies the object named by the string.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return value E_OUTOFMEMORY, as well as the following values.  This function can also return any of the error values returned by IMoniker::BindToObject, IOleItemContainer::GetObject, or IParseDisplayName::ParseDisplayName. ",
    "remarks": "The MkParseDisplayName function parses a human-readable name into a moniker that can be used to identify a link source. The resulting moniker can be a simple moniker (such as a file moniker), or it can be a generic composite made up of the component moniker pieces. For example, the display name \"c:\\mydir\\somefile!item 1\"   could be parsed into the following generic composite moniker: FileMoniker based on \"c:\\mydir\\somefile\") + (ItemMoniker based on \"item 1\"). The most common use of MkParseDisplayName is in the implementation of the standard Links dialog box, which allows an end user to specify the source of a linked object by typing in a string. You may also need to call MkParseDisplayName if your application supports a macro language that permits remote references (reference to elements outside of the document). Parsing a display name often requires activating the same objects that would be activated during a binding operation, so it can be just as expensive (in terms of performance) as binding. Objects that are bound during the parsing operation are cached in the bind context passed to the function. If you plan to bind the moniker returned by MkParseDisplayName, it is best to do so immediately after the function returns, using the same bind context, which removes the need to activate objects a second time. MkParseDisplayName parses as much of the display name as it understands into a moniker. The function then calls IMoniker::ParseDisplayName on the newly created moniker, passing the remainder of the display name. The moniker returned by ParseDisplayName is composed onto the end of the existing moniker and, if any of the display name remains unparsed, ParseDisplayName is called on the result of the composition. This process is repeated until the entire display name has been parsed. MkParseDisplayName attempts the following strategies to parse the beginning of the display name, using the first one that succeeds: ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "MkParseDisplayName",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPBC",
        "name": "pbc",
        "description": "A pointer to the IBindCtx interface on the bind context object to be used in this binding operation."
      },
      {
        "in_out": "_In_",
        "type": "LPCOLESTR",
        "name": "szUserName",
        "description": "A pointer to the display name to be parsed."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pchEaten",
        "description": "A pointer to the number of characters of szUserName that were consumed. If the function is successful, *pchEaten is the length of szUserName; otherwise, it is the number of characters successfully parsed."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmk",
        "description": "The address of the IMoniker* pointer variable that receives the interface pointer to the moniker that was built from szUserName. When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. If an error occurs, the specified interface pointer will contain as much of the moniker that the method was able to create before the error occurred."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a new moniker based on the common prefix that this moniker (the one comprising the data of this moniker object) shares with another moniker.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "Your implementation of IMoniker::CommonPrefixWith should first check whether the other moniker is of a type that you recognize and handle in a special way. If not, you should call MonikerCommonPrefixWith, passing itself as pmkThis and the other moniker as pmkOther. MonikerCommonPrefixWith correctly handles the cases where either moniker is a generic composite. You should call this function only if pmkThis and pmkOther are both absolute monikers (where an absolute moniker is either a file moniker or a generic composite whose leftmost component is a file moniker, and where the file moniker represents an absolute path). Do not call this function on relative monikers. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "MonikerCommonPrefixWith",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPMONIKER",
        "name": "pmkThis",
        "description": "A pointer to the IMoniker interface on one of the monikers for which a common prefix is sought; usually the moniker in which this call is used to implement IMoniker::CommonPrefixWith."
      },
      {
        "in_out": "_In_",
        "type": "LPMONIKER",
        "name": "pmkOther",
        "description": "A pointer to the IMoniker interface on the moniker to be compared with the first moniker."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmkCommon",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the moniker based on the common prefix of pmkThis and pmkOther. When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. If an error occurs, the supplied interface pointer value is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Provides a moniker that, when composed onto the end of the first specified moniker (or one with a similar structure), yields the second specified moniker.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "Your implementation of IMoniker::RelativePathTo should first check whether the other moniker is of a type you recognize and handle in a special way. If not, you should call MonikerRelativePathTo, passing itself as pmkThis and the other moniker as pmkOther. MonikerRelativePathTo correctly handles the cases where either moniker is a generic composite. You should call this function only if pmkSrc and pmkDest are both absolute monikers, where an absolute moniker is either a file moniker or a generic composite whose leftmost component is a file moniker, and where the file moniker represents an absolute path. Do not call this function on relative monikers. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "MonikerRelativePathTo",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPMONIKER",
        "name": "pmkSrc",
        "description": "A pointer to the IMoniker interface on the moniker that, when composed with the relative moniker to be created, produces pmkDest. This moniker identifies the \"source\" of the relative moniker to be created."
      },
      {
        "in_out": "_In_",
        "type": "LPMONIKER",
        "name": "pmkDest",
        "description": "A pointer to the IMoniker interface on the moniker to be expressed relative to pmkSrc. This moniker identifies the destination of the relative moniker to be created."
      },
      {
        "in_out": "_Out_",
        "type": "LPMONIKER*",
        "name": "ppmkRelPath",
        "description": "The address of an IMoniker* pointer variable that receives the interface pointer to the new relative moniker. When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. If an error occurs, the interface pointer value is NULL."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "dwReserved",
        "description": "This parameter is reserved and must be nonzero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Automatically converts an object to a new class if automatic conversion for that object class is set in the registry.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  This function can also return any of the error values returned by the OleGetAutoConvert function. When accessing storage and stream objects, see the IStorage::OpenStorage and IStorage::OpenStream methods for possible errors. When it is not possible to determine the existing CLSID or when it is not possible to update the storage object with new information, see the IStream interface for other error return values. ",
    "remarks": "OleDoAutoConvert automatically converts an object if automatic conversion has previously been specified in the registry by the OleSetAutoConvert function. Object conversion means that the object is permanently associated with a new CLSID. Automatic conversion is typically specified by the setup program for a new version of an object application, so that objects created by its older versions can be automatically updated. The storage object must be in the unloaded state when OleDoAutoConvert is called. A container application that supports object conversion should call OleDoAutoConvert each time it loads an object. If the container uses the OleLoad helper function, it need not call OleDoAutoConvert explicitly because OleLoad calls it internally. OleDoAutoConvert first determines whether any conversion is required by calling the OleGetAutoConvert function, which, if no conversion is required, returns S_OK. If the object requires conversion, OleDoAutoConvert modifies and converts the storage object by activating the new object application. The new object application reads the existing data format, but saves the object in the new native format for the object application. If the object to be automatically converted is an OLE 1 object, the ItemName string is stored in a stream called \"\\1Ole10ItemName.\" If this stream does not exist, the object's item name is NULL. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "OleDoAutoConvert",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTORAGE",
        "name": "pStg",
        "description": "A pointer to the IStorage interface on the storage object to be converted."
      },
      {
        "in_out": "_Out_",
        "type": "LPCLSID",
        "name": "pClsidNew",
        "description": "A pointer to the new CLSID for the object being converted. If there was no automatic conversion, this may be the same as the original class."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether the registry is set for objects of a specified CLSID to be automatically converted to another CLSID, and if so, retrieves the new CLSID.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "OleGetAutoConvert returns the AutoConvertTo entry in the registry for the specified object. The AutoConvertTo subkey specifies whether objects of a given CLSID are to be automatically converted to a new CLSID. This is usually used to convert files created by older versions of an application to the current version. If there is no AutoConvertTo entry, this function returns the value of clsidOld. The OleDoAutoConvert function calls OleGetAutoConvert to determine whether the object specified is to be converted. A container application that supports object conversion should call OleDoAutoConvert each time it loads an object. If the container uses the OleLoad helper function, it need not call OleDoAutoConvert explicitly because OleLoad calls it internally. To set up automatic conversion of a given class, you can call the OleSetAutoConvert function (typically in the setup program of an application installation). This function uses the AutoConvertTo subkey to tag a class of objects for automatic conversion to a different class of objects. This is a subkey of the CLSID key. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "OleGetAutoConvert",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsidOld",
        "description": "The CLSID for the object."
      },
      {
        "in_out": "_Out_",
        "type": "LPCLSID",
        "name": "pClsidNew",
        "description": "A pointer to a variable to receive the new CLSID, if any. If auto-conversion for clsidOld is not set in the registry, clsidOld is returned. The pClsidNew parameter is never NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Returns a handle to a metafile containing an icon and a string label for the specified CLSID.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "If the function succeeds, the return value is a handle to a metafile that contains and icon and label for the specified CLSID. Otherwise, the function returns NULL. ",
    "remarks": "",
    "return_type": "HGLOBAL",
    "category": "COM",
    "name": "OleGetIconOfClass",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "rclsid",
        "description": "The CLSID for which the icon and string are to be requested."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPOLESTR",
        "name": "lpszLabel",
        "description": "A pointer to the label for the icon."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fUseTypeAsLabel",
        "description": "Indicates whether to use the user type string in the CLSID as the icon label."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Returns a handle to a metafile containing an icon and string label for the specified file name.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "If the function succeeds, the return value is a handle to a metafile that contains and icon and label for the specified file. If there is no CLSID in the registration database for the file, then the function returns the string \"Document\". If lpszPath is NULL, the function returns NULL. ",
    "remarks": "",
    "return_type": "HGLOBAL",
    "category": "COM",
    "name": "OleGetIconOfFile",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpszPath",
        "description": "A pointer to a file for which the icon and string are to be requested."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fUseFileAsLabel",
        "description": "Indicates whether to use the file name as the icon label."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Converts an icon to a cursor.",
    "library": "Oleaut32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Olectl.h",
    "return_value": "The function returns a handle to the new cursor object. The caller is responsible for deleting this cursor with the DestroyCursor function. If the conversion could not be completed, the return value is NULL. ",
    "remarks": "This function calls the CopyCursor function. ",
    "return_type": "HCURSOR",
    "category": "COM",
    "name": "OleIconToCursor",
    "is_callback": 0,
    "dll": "Oleaut32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HINSTANCE",
        "name": "hinstExe",
        "description": "This parameter is ignored."
      },
      {
        "in_out": "_In_",
        "type": "HICON",
        "name": "hIcon",
        "description": "A handle to the icon to be converted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Returns miscellaneous information about the presentation and behaviors supported by the specified CLSID from the registry.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "This function can return the standard return value E_OUTOFMEMORY, as well as the following values.  ",
    "remarks": "Object applications can ask OLE to get miscellaneous status information in one of two ways. One way is to call OleRegGetMiscStatus. The other is to return OLE_S_USEREG in response to calls by the default object handler to IOleObject::GetMiscStatus. OLE_S_USEREG instructs the default handler to call OleRegGetMiscStatus. Because DLL object applications cannot return OLE_S_USEREG, they must call OleRegGetMiscStatus rather than delegating the job to the object handler. OleRegGetMiscStatus and its sibling functions, OleRegGetUserType, OleRegEnumFormatEtc, and OleRegEnumVerbs, provide a way for developers of custom DLL object applications to emulate the behavior of OLE's default object handler in getting information about objects from the registry. By using these functions, you avoid the considerable work of writing your own, and the pitfalls inherent in working directly in the registry. In addition, you get future enhancements and optimizations of these functions without having to code them yourself. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "OleRegGetMiscStatus",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsid",
        "description": "The CLSID of the class for which status information is to be requested."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAspect",
        "description": "The presentation aspect of the class for which information is requested. Possible values are taken from the DVASPECT enumeration."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD*",
        "name": "pdwStatus",
        "description": "A pointer to the variable that receives the status information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Gets the user type of the specified class from the registry.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "This function can return the standard return value E_OUTOFMEMORY, as well as the following values.  ",
    "remarks": "Object applications can ask OLE to get the user type name of a specified class in one of two ways. One way is to call OleRegGetUserType. The other is to return OLE_S_USEREG in response to calls by the default object handler to IOleObject::GetUserType. OLE_S_USEREG instructs the default handler to call OleRegGetUserType. Because DLL object applications cannot return OLE_S_USEREG, they must call OleRegGetUserType, rather than delegating the job to the object handler. The OleRegGetUserType function and its sibling functions, OleRegGetMiscStatus, OleRegEnumFormatEtc, and OleRegEnumVerbs, provide a way for developers of custom DLL object applications to emulate the behavior of OLE's default object handler in getting information about objects from the registry. By using these functions, you avoid the considerable work of writing your own, and the pitfalls inherent in working directly in the registry. In addition, you get future enhancements and optimizations of these functions without having to code them yourself. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "OleRegGetUserType",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsid",
        "description": "The CLSID of the class for which the user type is to be requested."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFormOfType",
        "description": "The form of the user-presentable string. Possible values are taken from the enumeration USERCLASSTYPE."
      },
      {
        "in_out": "_Out_",
        "type": "LPOLESTR*",
        "name": "pszUserType",
        "description": "A pointer to a string that receives the user type."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Specifies a CLSID for automatic conversion to a different class when an object of that class is loaded.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ole2.h",
    "return_value": "This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "OleSetAutoConvert goes to the system registry, finds the AutoConvertTo subkey under the CLSID specified by clsidOld, and sets it to clsidNew. This function does not validate whether an appropriate registry entry for clsidNew currently exists. These entries appear in the registry as subkeys of the CLSID key. Object conversion means that the object's data is permanently associated with a new CLSID. Automatic conversion is typically specified in the setup program of a new version of an object application, so objects created by its older versions can be automatically updated to the new version. For example, it may be necessary to convert spreadsheets that were created with earlier versions of a spreadsheet application to the new version. The spreadsheet objects from earlier versions have different CLSIDs than the new version. For each earlier version that you want automatically updated, you would call OleSetAutoConvert in the setup program, specifying the CLSID of the old version, and that of the new one. Then, whenever a user loads an object from a previous version, it would be automatically updated. To support automatic conversion of objects, a server that supports conversion must be prepared to manually convert objects that have the format of an earlier version of the server. Automatic conversion relies internally on this manual-conversion support. Before setting the desired AutoConvertTo value, setup programs should also call OleSetAutoConvert to remove any existing conversion for the new class, by specifying the new class as the clsidOld parameter, and setting the clsidNew parameter to CLSID_NULL. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "OleSetAutoConvert",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsidOld",
        "description": "The CLSID of the object class to be converted."
      },
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsidNew",
        "description": "The CLSID of the object class that should replace clsidOld. This new CLSID replaces any existing auto-conversion information in the registry for clsidOld. If this value is CLSID_NULL, any existing auto-conversion information for clsidOld is removed from the registry."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the ProgID for a given CLSID.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "This function can return the following values.  ",
    "remarks": "Every OLE object class listed in the Insert Object dialog box must have a programmatic identifier (ProgID), a string that uniquely identifies a given class, stored in the registry. In addition to determining the eligibility for the Insert Object dialog box, the ProgID can be used as an identifier in a macro programming language to identify a class. Finally, the ProgID is also the class name used for an object of an OLE class that is placed in an OLE 1 container. ProgIDFromCLSID uses entries in the registry to do the conversion. OLE application authors are responsible for ensuring that the registry is configured correctly in the application's setup program. The ProgID string must be different than the class name of any OLE 1 application, including the OLE 1 version of the same application, if there is one. In addition, a ProgID string must not contain more than 39 characters, start with a digit, or, except for a single period, contain any punctuation (including underscores). The ProgID must never be shown to the user in the user interface. If you need a short displayable string for an object, call IOleObject::GetUserType. Call the CLSIDFromProgID function to find the CLSID associated with a given ProgID. Be sure to free the returned ProgID  when you are finished with it by calling the CoTaskMemFree function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "ProgIDFromCLSID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFCLSID",
        "name": "clsid",
        "description": "The CLSID for which the ProgID is to be requested."
      },
      {
        "in_out": "_Out_",
        "type": "LPOLESTR*",
        "name": "lplpszProgID",
        "description": "The address of a pointer variable that receives the ProgID string. The string that represents clsid includes enclosing braces."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Converts a globally unique identifier (GUID) into a string of printable characters.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "If the function succeeds, the return value is the number of characters in the returned string, including the null terminator. If the buffer is too small to contain the string, the return value is 0. ",
    "remarks": "",
    "return_type": "int",
    "category": "COM",
    "name": "StringFromGUID2",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFGUID",
        "name": "rguid",
        "description": "The GUID to be converted."
      },
      {
        "in_out": "_Out_",
        "type": "LPOLESTR",
        "name": "lpsz",
        "description": "A pointer to a caller-allocated string variable to receive the resulting string. The string that represents rguid includes enclosing braces."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchMax",
        "description": "The number of characters available in the lpsz buffer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Converts an interface identifier into a string of printable characters.",
    "library": "Ole32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Objbase.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and S_OK. ",
    "remarks": "The caller is responsible for freeing the memory allocated for the string by calling the CoTaskMemFree function. ",
    "return_type": "HRESULT",
    "category": "COM",
    "name": "StringFromIID",
    "is_callback": 0,
    "dll": "Ole32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "rclsid",
        "description": "The interface identifier to be converted."
      },
      {
        "in_out": "_Out_",
        "type": "LPOLESTR*",
        "name": "lplpsz",
        "description": "The address of a pointer variable that receives a pointer to the resulting string. The string that represents rclsid includes enclosing braces."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Instructs an in-process server to remove only those entries created through DllRegisterServer.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Olectl.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "The server must not disturb any entries that it did not create which currently exist for its object classes. For example, between registration and unregistration, the user may have specified a Treat As relationship between this class and another. In that case, unregistration can remove all entries except the TreatAs key and any others that were not explicitly created in DllRegisterServer. The registry functions specifically disallow the deletion of an entire populated tree in the registry. The server can attempt, as the last step, to remove the CLSID key, but if other entries still exist, the key will remain. ",
    "return_type": "HRESULT __stdcall",
    "category": "COM",
    "name": "DllUnregisterServer",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Instructs an in-process server to create its registry entries for all classes supported in this server module.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Olectl.h",
    "return_value": "This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.  ",
    "remarks": "E_NOTIMPL is not a valid return code. If this function fails, the state of the registry for all its classes is undefined. ",
    "return_type": "HRESULT __stdcall",
    "category": "COM",
    "name": "DllRegisterServer",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]