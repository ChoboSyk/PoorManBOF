[
  {
    "n_arguments": 3,
    "description": "Deprecated. Adjusts a date by a specified number of years, months, weeks, or days.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns TRUE if successful or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with the module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "AdjustCalendarDate",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCALDATETIME",
        "name": "lpCalDateTime",
        "description": "Pointer to a CALDATETIME structure that contains the date and calendar information to adjust."
      },
      {
        "in_out": "_In_",
        "type": "CALDATETIME_DATEUNIT",
        "name": "calUnit",
        "description": "The CALDATETIME_DATEUNIT enumeration value indicating the date unit, for example, DayUnit."
      },
      {
        "in_out": "_Out_",
        "type": "INT",
        "name": "amount",
        "description": "The amount by which to adjust the specified date."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Compares two character strings, for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (see Remarks) (include Windows.h);  Stringapiset.h (see Remarks) (include Windows.h)",
    "return_value": "Returns the values described for CompareStringEx. ",
    "remarks": "See Remarks for CompareStringEx. If your application is calling the ANSI version of CompareString, the function converts parameters via the default code page of the supplied locale. Thus, an application can never use CompareString to handle UTF-8 text. Normally, for case-insensitive comparisons, CompareString maps the lowercase \"i\" to the uppercase \"I\", even when the locale is Turkish or Azerbaijani. The  NORM_LINGUISTIC_CASING flag overrides this behavior for Turkish or Azerbaijani. If this flag is specified in conjunction with Turkish or Azerbaijani, LATIN SMALL LETTER DOTLESS I (U+0131) is the lowercase form of LATIN CAPITAL LETTER I (U+0049) and LATIN SMALL LETTER I (U+0069) is the lowercase form of LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130). Starting with Windows 8: The ANSI version of the function is declared in Winnls.h, and the Unicode version is declared in Stringapiset.h. Before Windows 8, both versions were declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "CompareString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier of the locale used for the comparison. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCmpFlags",
        "description": "Flags that indicate how the function compares the two strings. For detailed definitions, see the dwCmpFlags parameter of CompareStringEx."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString1",
        "description": "Pointer to the first string to compare."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCount1",
        "description": "Length of the string indicated by lpString1, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString2",
        "description": "Pointer to the second string to compare."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCount2",
        "description": "Length of the string indicated by lpString2, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "Compares two Unicode (wide character) strings, for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Stringapiset.h (include Windows.h)",
    "return_value": "Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of <0, ==0, and >0 is consistent with the C runtime. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Both CompareString and CompareStringEx are optimized to run at the highest speed when dwCmpFlags is set to 0 or NORM_IGNORECASE, cchCount1 and cchCount2 are set to -1, and the locale does not support any linguistic compressions, as when traditional Spanish sorting treats \"ch\" as a single character. Both CompareString and CompareStringEx ignore Arabic kashidas during the comparison. Thus, if two strings are identical except for the presence of kashidas, the function returns CSTR_EQUAL. When the application uses the NORM_IGNORENONSPACE and NORM_IGNORECASE flags with the sorting function, the flags can sometimes interfere with string comparisons. This situation might result for a locale that does not support non-spacing characters or case, but uses equivalent weight levels to handle other important operations. In such cases, your application should use the LINGUISTIC_IGNOREDIACRITIC and LINGUISTIC_IGNORECASE flags. These flags provide linguistically appropriate results for sorting code points that use case and diacritic marks, and have no impact on other code points. Beginning in Windows Vista:  Both CompareString and CompareStringEx can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. Beginning in Windows 8: CompareStringEx  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h. An example showing the use of this function can be found in NLS: Name-based APIs Sample. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "CompareStringEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCmpFlags",
        "description": "Flags that indicate how the function compares the two strings. By default, these flags are not set. This parameter can specify a combination of any of the following values, or it can be set to 0 to obtain the default behavior.  FlagMeaning  LINGUISTIC_IGNORECASE   Ignore case, as linguistically appropriate.   LINGUISTIC_IGNOREDIACRITIC   Ignore nonspacing characters, as linguistically appropriate. Note  This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.     NORM_IGNORECASE   Ignore case. For many scripts (notably Latin scripts), NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE. Note  NORM_IGNORECASE ignores any tertiary distinction, whether it is actually linguistic case or not. For example, in Arabic and Indic scripts, this distinguishes alternate forms of a character, but the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE causes the function to ignore only actual linguistic casing, instead of ignoring the third sorting weight.   Note  With this flag set, the function ignores the distinction between the wide and narrow forms of the CJK compatibility characters.     NORM_IGNOREKANATYPE   Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.   NORM_IGNORENONSPACE   Ignore nonspacing characters. For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC. Note  NORM_IGNORENONSPACE ignores any secondary distinction, whether it is a diacritic or not. Scripts for Korean, Japanese, Chinese, and Indic languages, among others, use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC causes the function to ignore only actual diacritics, instead of ignoring the second sorting weight.   Note  NORM_IGNORENONSPACE only has an effect for locales in which accented characters are sorted in a second pass from main characters. Normally all characters in the string are first compared without regard to accents and, if the strings are equal, a second pass over the strings is performed to compare accents. This flag causes the second pass to not be performed. For locales that sort accented characters in the first pass, this flag has no effect.     NORM_IGNORESYMBOLS   Ignore symbols and punctuation.   NORM_IGNOREWIDTH   Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.   NORM_LINGUISTIC_CASING   Use linguistic rules for casing, instead of file system rules (default).   SORT_DIGITSASNUMBERS   Windows 7: Treat digits as numbers during sorting, for example, sort \"2\" before \"10\".   SORT_STRINGSORT   Treat punctuation the same as symbols."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString1",
        "description": "Pointer to the first string to compare."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCount1",
        "description": "Length of the string indicated by lpString1, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString2",
        "description": "Pointer to the second string to compare."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCount2",
        "description": "Length of the string indicated by lpString2, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPNLSVERSIONINFO",
        "name": "lpVersionInformation",
        "description": "Reserved; must set to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpReserved",
        "description": "Reserved; must set to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Reserved; must be set to 0."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Compares two Unicode strings to test binary equivalence.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Stringapiset.h (include Windows.h)",
    "return_value": "Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of <0, ==0, and >0 is consistent with the C runtime. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function tests for binary equality, not linguistic equality. For information about the use of the function for ordinal sorting, see Handling Sorting in Your Applications. Applications that are concerned with linguistic equality should use CompareString, CompareStringEx, lstrcmp, or lstrcmpi. For more information about linguistic sorting, see Handling Sorting in Your Applications Starting with Windows 8: CompareStringOrdinal  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "CompareStringOrdinal",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString1",
        "description": "Pointer to the first string to compare."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCount1",
        "description": "Length of the string indicated by lpString1. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString2",
        "description": "Pointer to the second string to compare."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCount2",
        "description": "Length of the string indicated by lpString2. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bIgnoreCase",
        "description": "TRUE if the function is to perform a case-insensitive comparison, using the operating system uppercase table information. The application sets this parameter to FALSE if the function is to compare the strings exactly as they are passed in."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Deprecated. Converts a specified CALDATETIME structure to a SYSTEMTIME structure.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns TRUE if successful or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with the module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "ConvertCalDateTimeToSystemTime",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LPCALDATETIME",
        "name": "lpCalDateTime",
        "description": "Pointer to the CALDATETIME structure to convert."
      },
      {
        "in_out": "_Out_",
        "type": "SYSTEMTIME*",
        "name": "lpSysTime",
        "description": "Pointer to the equivalent SYSTEMTIME structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Converts a default locale value to an actual locale identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the appropriate locale identifier if successful. This function returns the value of the Locale parameter if it does not succeed. The function fails when the Locale value is not one of the default values listed above. ",
    "remarks": "A call to ConvertDefaultLocale specifying LOCALE_SYSTEM_DEFAULT is equivalent to a call to GetSystemDefaultLCID. A call to ConvertDefaultLocale specifying LOCALE_USER_DEFAULT is equivalent to a call to GetUserDefaultLCID. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "ConvertDefaultLocale",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Default locale identifier value to convert. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deprecated. Converts a specified SYSTEMTIME structure to a CALDATETIME structure.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns TRUE if successful or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The earliest date supported by this function is January 1, 1601. This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with the module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "ConvertSystemTimeToCalDateTime",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const SYSTEMTIME",
        "name": "lpSysTime",
        "description": "Pointer to the SYSTEMTIME structure to convert."
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "calId",
        "description": "The system calendar identifier to use in the conversion."
      },
      {
        "in_out": "_Out_",
        "type": "LPCALDATETIME",
        "name": "lpCalDateTime",
        "description": "Pointer to the equivalent CALDATETIME structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Provides a list of scripts for the specified locale.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Idndl.h",
    "return_value": "Returns the number of characters retrieved in the script buffer, including the terminating null character. If the function succeeds and the value of cchScripts is 0, the return value is the required size, in characters including a terminating null character, for the script buffer. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function is useful as part of a strategy to mitigate security issues related to internationalized domain names (IDNs). Here are some examples of inputs and outputs for this function, assuming a sufficient buffer size:  The list does not contain the Latin script unless it is an essential part of the writing system used for a locale. However, Latin characters are often used in the context of locales for which they are not native, as for a foreign business name. In the example above for Hindi in India, the only script retrieved is \"Deva\" (for Devanagari), although Latin characters can also appear in Hindi text. The DownlevelVerifyScripts function has a special flag to address that case. The required header file and DLL are part of the  \"Microsoft Internationalized Domain Name (IDN) Mitigation APIs\" download, available at the MSDN Download Center. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "DownlevelGetLocaleScripts",
    "is_callback": 0,
    "dll": "Idndl.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a null-terminated locale name."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpScripts",
        "description": "Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in ISO 15924. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each of them, including the last, is followed by a semicolon. Alternatively, this parameter can contain NULL if cchScripts is set to 0. In this case, the function returns the required size for the script buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchScripts",
        "description": "Size, in characters, for the script buffer indicated by lpScripts. Alternatively, the application can set this parameter to 0. In this case, the function retrieves NULL in lpScripts and returns the required size for the script buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the locale identifier for the parent of the supplied locale.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Nlsdl.h",
    "return_value": "Returns the parent locale identifier if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The required header file and DLL are part of the \"Microsoft NLS Downlevel Data Mapping APIs\"  download, available at the Microsoft Download Center. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "DownlevelGetParentLocaleLCID",
    "is_callback": 0,
    "dll": "NlsMap.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier of the locale for which to retrieve the parent locale identifier. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the locale name for the parent of the supplied locale.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Nlsdl.h",
    "return_value": "Returns the count of UTF-16 code points in the locale name, including the terminating null character, if successful. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The required header file and DLL are part of the \"Microsoft NLS Downlevel Data Mapping APIs\"  download, available at the Microsoft Download Center. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "DownlevelGetParentLocaleName",
    "is_callback": 0,
    "dll": "NlsMap.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier of the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpName",
        "description": "Pointer to a buffer in which the function retrieves the parent locale name, or one of the following predefined values. This parameter is set to NULL if cchName is set to 0.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchName",
        "description": "Size of the buffer indicated by lpName, in UTF-16 code points. A value of 0 for this parameter causes the function to ignore the lpName buffer and return the size of the buffer, in characters (null characters included), required to contain the parent locale name."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Provides a list of scripts used in the specified Unicode string.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Idndl.h",
    "return_value": "Returns the number of characters retrieved in the output buffer, including a terminating null character, if successful and cchScripts is set to a nonzero value. The function returns 1 to indicate that no script has been found, for example, when the input string only contains COMMON or INHERITED characters and GSS_ALLOW_INHERITED_COMMON is not set. Given that each found script adds five characters (four characters + delimiter), a simple mathematical operation provides the script count as (return_code - 1) / 5. If the function succeeds and the value of cchScripts is 0, the return value is the required size, in characters including a terminating null character, for the script buffer. The script count is as described above. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function is useful as part of a strategy to mitigate security issues related to internationalized domain names (IDNs). The script determination is based on the script values published by the Unicode Consortium in http://www.unicode.org/Public/4.1.0/ucd/Scripts.txt, except that the unassigned characters have the value \"Zzzz\" (UNASSIGNED) instead of \"Zyyy\" (COMMON). Here are some examples of the behavior of this function:  The required header file and DLL are part of the  \"Microsoft Internationalized Domain Name (IDN) Mitigation APIs\" download, available at the MSDN Download Center. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "DownlevelGetStringScripts",
    "is_callback": 0,
    "dll": "Idndl.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying options for script retrieval.  ValueMeaning  GSS_ALLOW_INHERITED_COMMON   Retrieve \"Qaii\" (INHERITED) and \"Zyyy\" (COMMON) script information. This value does not affect the processing of unassigned characters. These characters in the input string always cause a \"Zzzz\" (UNASSIGNED script) to appear in the script string.     Note  By default, this function ignores any inherited or common characters in the input Unicode string. If GSS_ALLOW_INHERITED_COMMON is not set, neither \"Qaii\" nor \"Zyyy\" will appear in the script string, even if the input string contains such characters. If GSS_ALLOW_INHERITED_COMMON is set, and if the input string contains inherited and/or common characters, \"Qaii\" and/or \"Zyyy\" appear in the script string. See the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString",
        "description": "Pointer to the Unicode string to analyze."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchString",
        "description": "Size, in characters, of the Unicode string indicated by lpString. The application sets this parameter to -1 if the string is null-terminated. If the application sets this parameter to 0, the function retrieves a null Unicode string (L\"\\0\") in lpScripts and returns 1."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpScripts",
        "description": "Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in ISO 15924. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each name, including the last, is followed by a semicolon. Alternatively, this parameter can contain NULL if cchScripts set to 0. In this case, the function returns the required size for the script buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchScripts",
        "description": "Size, in characters, for the script buffer indicated by lpScripts. Alternatively, the application can set this parameter to 0. In this case, the function retrieves NULL in lpScripts and returns the required size for the script buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Converts a locale identifier to a locale name.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Nlsdl.h",
    "return_value": "Returns the count of UTF-16 code points in the locale name, including the terminating null character, if successful. If the function succeeds and the value of cchName is 0, the return value is the required size, in characters (including null characters), for the locale name buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The required header file and DLL are part of the \"Microsoft NLS Downlevel Data Mapping APIs\"  download, available at the Microsoft Download Center. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "DownlevelLCIDToLocaleName",
    "is_callback": 0,
    "dll": "NlsMap.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "The locale identifier to translate. You can use the MAKELCID macro to create a locale identifier. This function does not support neutral locales or the following specific locale identifier values.    LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpName",
        "description": "Pointer to a buffer in which this function retrieves the locale name. The function retrieves NULL if cchName is set to 0."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchName",
        "description": "Size, in UTF-16 code points, of the locale name buffer. The application sets this parameter to 0 to return the required size of the locale name buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying the type of name to retrieve. The default value is DOWNLEVEL_LOCALE_NAME."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Converts a locale name to a locale identifier that can be used to get information from the operating system.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Nlsdl.h",
    "return_value": "Returns the locale identifier that corresponds to the locale name if successful. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The required header file and DLL are part of the \"Microsoft NLS Downlevel Data Mapping APIs\"  download, available at the Microsoft Download Center. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "DownlevelLocaleNameToLCID",
    "is_callback": 0,
    "dll": "NlsMap.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpName",
        "description": "Pointer to a null-terminated string representing a locale name."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying the type of name. The default is DOWNLEVEL_LOCALE_NAME."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Compares two enumerated lists of scripts.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Idndl.h",
    "return_value": "Returns TRUE if the test list is non-empty and all items in the list are also included in the locale list. Otherwise, the function returns FALSE. A return value of FALSE can indicate that the test list contains an item that is not in the locale list, or it can indicate an error. To distinguish between these two cases, the application can call GetLastError. If DownlevelVerifyScripts has successfully determined that there is an item in the test list that is not in the locale list, GetLastError returns ERROR_SUCCESS. Otherwise, GetLastError can return one of the following error codes: ",
    "remarks": "This function compares strings, such as \"Latn;Cyrl;\", that consist of a series of 4-character script names, with each script name followed by a semicolon. It also has a special case to account for the fact that the Latin script is often used in languages and locales for which it is not native. This function is useful as part of a strategy to mitigate security issues related to internationalized domain names (IDNs). The following are examples of the return of this function and a subsequent call to GetLastError in various scenarios. The last two examples illustrate, respectively, a case in which the test list lacks a terminating semicolon (malformed string) and a case in which the test list is empty.  The required header file and DLL are part of the  \"Microsoft Internationalized Domain Name (IDN) Mitigation APIs\" download, available at the MSDN Download Center. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "DownlevelVerifyScripts",
    "is_callback": 0,
    "dll": "Idndl.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying script verification options.  ValueMeaning  VS_ALLOW_LATIN   Allow \"Latn\" (Latin script) in the test list, even if it is not in the locale list."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpLocaleScripts",
        "description": "Pointer to the locale list, the enumerated list of scripts for a given locale. This list is typically populated by calling DownlevelGetLocaleScripts."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchLocaleScripts",
        "description": "Size, in characters, of the string indicated by lpLocaleScripts. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpTestScripts",
        "description": "Pointer to the test list, a second enumerated list of scripts. This list is typically populated by calling DownlevelGetStringScripts."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchTestScripts",
        "description": "Size, in characters, of the string indicated by lpTestScripts. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates calendar information for a specified locale.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for EnumCalendarInfoEx. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumCalendarInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CALINFO_ENUMPROC",
        "name": "pCalInfoEnumProc",
        "description": "Pointer to an application-defined callback function. For more information, see EnumCalendarInfoProc."
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which to retrieve calendar information. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale."
      },
      {
        "in_out": "_In_",
        "type": "CALTYPE",
        "name": "CalType",
        "description": "Type of calendar information. For more information, see Calendar Type Information. Only one calendar type can be specified per call to this function, except where noted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates calendar information for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the Calendar parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information. This process continues until EnumCalendarInfoEx finds the last applicable calendar or the callback function returns FALSE. This function can enumerate data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumCalendarInfoEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CALINFO_ENUMPROCEX",
        "name": "pCalInfoEnumProcEx",
        "description": "Pointer to an application-defined callback function. For more information, see EnumCalendarInfoProcEx."
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which to retrieve calendar information. You can use the MAKELCID macro to create an identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale."
      },
      {
        "in_out": "_In_",
        "type": "CALTYPE",
        "name": "CalType",
        "description": "Type of calendar information. For more information, see Calendar Type Information. Only one calendar type can be specified per call to this function, except where noted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Enumerates calendar information for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the Calendar parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information, a calendar identifier, and an application-defined parameter that is useful for multi-threaded applications. This process continues until EnumCalendarInfoExEx finds the last applicable calendar or the callback function returns FALSE. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumCalendarInfoExEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CALINFO_ENUMPROCEXEX",
        "name": "pCalInfoEnumProcExEx",
        "description": "Pointer to an application-defined callback function. For more information, see EnumCalendarInfoProcExEx."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpReserved",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "CALTYPE",
        "name": "CalType",
        "description": "Type of calendar information. For more information, see Calendar Type Information. Only one calendar type can be specified per call to this function, except where noted."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined callback function that processes enumerated calendar information provided by the EnumCalendarInfo function. The CALINFO_ENUMPROC type defines a pointer to this callback function. EnumCalendarInfoProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumCalendarInfoProc function can carry out any desired task. The application registers this function by passing its address to the EnumCalendarInfo function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumCalendarInfoProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpCalendarInfoString",
        "description": "Pointer to a buffer containing a null-terminated calendar information string. This string is formatted according to the calendar type passed to EnumCalendarInfo."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "An application-defined callback function that processes enumerated calendar information provided by the EnumCalendarInfoEx function. The CALINFO_ENUMPROCEX type defines a pointer to this callback function. EnumCalendarInfoProcEx is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumCalendarInfoProcEx function can carry out any desired task. The application registers this function by passing its address to the EnumCalendarInfoEx function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumCalendarInfoProcEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpCalendarInfoString",
        "description": "Pointer to a buffer containing a null-terminated calendar information string. This string is formatted according to the calendar type passed to EnumCalendarInfoEx."
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier that specifies the calendar associated with the supplied information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "An application-defined callback function that processes enumerated calendar information provided by the EnumCalendarInfoExEx function. The CALINFO_ENUMPROCEXEX type defines a pointer to this callback function. EnumCalendarInfoProcExEx is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumCalendarInfoProcExEx function can carry out any desired task. The application registers this function by passing its address to the EnumCalendarInfoExEx function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumCalendarInfoProcExEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpCalendarInfoString",
        "description": "Pointer to a buffer containing a null-terminated calendar information string. This string is formatted according to the calendar type passed to EnumCalendarInfoExEx."
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier that specifies the calendar associated with the specified information."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpReserved",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided input parameter of EnumCalendarInfoExEx. This value is especially useful for multi-threaded applications, since it can be used to pass thread-specific data to this callback function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined callback function that processes enumerated code page information provided by the EnumSystemCodePages function. The CODEPAGE_ENUMPROC type defines a pointer to this callback function. EnumCodePagesProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumCodePagesProc function can carry out any desired task. The application registers this function by passing its address to the EnumSystemCodePages function. When an application is using this function to determine an appropriate code page for saving data, it should use Unicode when possible. Other code pages are not as portable as Unicode between vendors or operating systems, due to different implementations of the associated standards. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumCodePagesProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpCodePageString",
        "description": "Pointer to a buffer containing a null-terminated code page identifier string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Enumerates the code pages that are either installed on or supported by an operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates the code pages by passing code page identifiers, one at a time, to the specified application-defined callback function. This process continues until all installed or supported code page identifiers have been passed to the callback function, or the callback function returns FALSE. When an application is using this function to determine an appropriate code page for saving data, it should use Unicode when possible. Other code pages are not as portable as Unicode between vendors or operating systems, due to different implementations of the associated standards. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumSystemCodePages",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CODEPAGE_ENUMPROC",
        "name": "lpCodePageEnumProc",
        "description": "Pointer to an application-defined callback function. The EnumSystemCodePages function enumerates code pages by making repeated calls to this callback function. For more information, see EnumCodePagesProc."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying the code pages to enumerate. This parameter can have one of the following values, which are mutually exclusive.  ValueMeaning  CP_INSTALLED   Enumerate only installed code pages.   CP_SUPPORTED   Enumerate all supported code pages."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Enumerates the long date, short date, or year/month formats that are available for a specified locale.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "For details of operation of this function, see Remarks in EnumDateFormatsEx. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumDateFormats",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DATEFMT_ENUMPROC",
        "name": "lpDateFmtEnumProc",
        "description": "Pointer to an application-defined callback function. For more information, see EnumDateFormatsProc."
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which to retrieve date format information. You can use the MAKELCID macro to create an identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying date formats. For detailed definitions, see the dwFlags parameter of EnumDateFormatsExEx."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Enumerates the long date, short date, or year/month formats that are available for a specified locale.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function. This process continues until EnumDateFormatsEx finds the last date format or the callback function returns FALSE. This function enumerates all date formats for the specified locale, including alternate calendars, if any. However, the calendar identifier is not enumerated along with the date format, making formats for locales with alternate calendars difficult to use. This function can enumerate data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). The application should use EnumDateFormatsEx (instead of EnumDateFormats) to enumerate date formats for locales with alternate calendars. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumDateFormatsEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DATEFMT_ENUMPROCEX",
        "name": "lpDateFmtEnumProcEx",
        "description": "Pointer to an application-defined callback function. For more information, see EnumDateFormatsProcEx."
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which to retrieve date format information. You can use the MAKELCID macro to create an identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying date formats. For detailed definitions, see the dwFlags parameter of EnumDateFormatsExEx."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the long date, short date, or year/month formats that are available for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function, along with an application-defined constant that is useful for multi-threaded applications. This process continues until EnumDateFormatsExEx finds the last date format or the callback function returns FALSE. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumDateFormatsExEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DATEFMT_ENUMPROCEXEX",
        "name": "lpDateFmtEnumProcExEx",
        "description": "Pointer to an application-defined callback function. For more information, see EnumDateFormatsProcExEx."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying date formats. The application can supply one of the following values or the LOCALE_USE_CP_ACP constant.  ValueMeaning  DATE_SHORTDATE   Use short date formats. This value cannot be used with any of the other flag values.   DATE_LONGDATE   Use long date formats. This value cannot be used with any of the other flag values.   DATE_YEARMONTH   Use year/month formats. This value cannot be used with any of the other flag values.   DATE_MONTHDAY   Use month/day formats. This value cannot be used with any of the other flag values."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined callback function that processes date format information provided by the EnumDateFormats function. The DATEFMT_ENUMPROC type defines a pointer to this callback function. EnumDateFormatsProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumDateFormatsProc function can carry out any desired task. The application registers this function by passing its address to the EnumDateFormats function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumDateFormatsProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpDateFormatString",
        "description": "Pointer to a buffer containing a null-terminated date format string. This string is a long or short date format, depending on the value of the dwFlags parameter of EnumDateFormats."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "An application-defined callback function that processes enumerated date format information provided by the EnumDateFormatsEx function. The DATEFMT_ENUMPROCEX type defines a pointer to this callback function. EnumDateFormatsProcEx is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumDateFormatsProcEx function can carry out any desired task. The application registers this function by passing its address to the EnumDateFormatsEx function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumDateFormatsProcEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpDateFormatString",
        "description": "Pointer to a buffer containing a null-terminated date format string. This string is a long or short date format, depending on the value of the dwFlags parameter of EnumDateFormatsEx."
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "CalendarID",
        "description": "Calendar identifier associated with the date format string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "An application-defined function that processes enumerated date format information provided by the EnumDateFormatsExEx function. The DATEFMT_ENUMPROCEXEX type defines a pointer to this callback function. EnumDateFormatsProcExEx is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumDateFormatsProcExEx function can carry out any desired task. An application registers this function by passing its address to the EnumDateFormatsExEx function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumDateFormatsProcExEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpDateFormatString",
        "description": "Pointer to a buffer containing a null-terminated date format string. This string is a long or short date format, depending on the value of the dwFlags parameter passed to EnumDateFormatsExEx."
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "CalendarID",
        "description": "Calendar identifier associated with the specified date format string."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided input parameter of EnumDateFormatsExEx. This parameter is especially useful for multi-threaded applications, since it can be used to pass thread-specific data to this callback function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined callback function that processes enumerated geographical location information provided by the EnumSystemGeoID function. The GEO_ENUMPROC type defines a pointer to this callback function. EnumGeoInfoProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumGeoInfoProc function can carry out any desired task. The application registers this function by passing its address to the EnumSystemGeoID function. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumGeoInfoProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GEOID",
        "name": "GeoId",
        "description": "Identifier of the geographical location to check."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Enumerates the geographical location identifiers (type GEOID) that are available on the operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumSystemGeoID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GEOCLASS",
        "name": "GeoClass",
        "description": "Geographical location class for which to enumerate the identifiers. At present, only GEOCLASS_NATION is supported. This type causes the function to enumerate all geographical identifiers for nations on the operating system."
      },
      {
        "in_out": "_In_",
        "type": "GEOID",
        "name": "ParentGeoId",
        "description": "Reserved. This parameter must be 0."
      },
      {
        "in_out": "_In_",
        "type": "GEO_ENUMPROC",
        "name": "lpGeoEnumProc",
        "description": "Pointer to the application-defined callback function EnumGeoInfoProc. The EnumSystemGeoID function makes repeated calls to this callback function until it returns FALSE."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the locales in a specified language group.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates locales in the specified language group by passing locale identifiers, one at a time, to the application-defined callback function. This process continues until EnumLanguageGroupLocales finds the last locale identifier or the callback function returns FALSE. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumLanguageGroupLocales",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LANGGROUPLOCALE_ENUMPROC",
        "name": "lpLangGroupLocaleEnumProc",
        "description": "Pointer to an application-defined callback function. For more information, see EnumLanguageGroupLocalesProc."
      },
      {
        "in_out": "_In_",
        "type": "LGRPID",
        "name": "LanguageGroup",
        "description": "Identifier of the language group for which to enumerate locales. This parameter can have one of the following values:  LGRPID_ARABIC  LGRPID_ARMENIAN  LGRPID_BALTIC  LGRPID_CENTRAL_EUROPE  LGRPID_CYRILLIC  LGRPID_GEORGIAN  LGRPID_GREEK  LGRPID_HEBREW  LGRPID_INDIC  LGRPID_JAPANESE  LGRPID_KOREAN  LGRPID_SIMPLIFIED_CHINESE  LGRPID_TRADITIONAL_CHINESE  LGRPID_THAI  LGRPID_TURKIC  LGRPID_TURKISH  LGRPID_VIETNAMESE  LGRPID_WESTERN_EUROPE"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved; must be 0."
      },
      {
        "in_out": "_In_",
        "type": "LONG_PTR",
        "name": "lParam",
        "description": "An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "An application-defined callback function that processes enumerated language group locale information provided by the EnumLanguageGroupLocales function. The LANGGROUPLOCALE_ENUMPROC type defines a pointer to this callback function. EnumLanguageGroupLocalesProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumLanguageGroupLocalesProc function can carry out any desired task. The application registers this function by passing its address to the EnumLanguageGroupLocales function. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumLanguageGroupLocalesProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LGRPID",
        "name": "LanguageGroup",
        "description": "Identifier of the language group. This parameter can have one of the following values:  LGRPID_ARABIC LGRPID_ARMENIAN LGRPID_BALTIC LGRPID_CENTRAL_EUROPE LGRPID_CYRILLIC LGRPID_GEORGIAN LGRPID_GREEK LGRPID_HEBREW LGRPID_INDIC LGRPID_JAPANESE LGRPID_KOREAN  LGRPID_SIMPLIFIED_CHINESE LGRPID_TRADITIONAL_CHINESE LGRPID_THAI LGRPID_TURKIC LGRPID_TURKISH LGRPID_VIETNAMESE LGRPID_WESTERN_EUROPE"
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpLocaleString",
        "description": "Pointer to a buffer containing a null-terminated locale identifier string."
      },
      {
        "in_out": "_In_",
        "type": "LONG_PTR",
        "name": "lParam",
        "description": "Application-defined value passed to the EnumLanguageGroupLocales function. This parameter can be used for error checking."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "An application-defined callback function that processes enumerated language group information provided by the EnumSystemLanguageGroups function. The LANGUAGEGROUP_ENUMPROC type defines a pointer to this callback function. EnumLanguageGroupsProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumLanguageGroupsProc function can carry out any desired task. The application registers this function by passing its address to the EnumSystemLanguageGroups function. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumLanguageGroupsProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LGRPID",
        "name": "LanguageGroup",
        "description": "Language group identifier. This parameter can have one of the following values:  LGRPID_ARABIC LGRPID_ARMENIAN LGRPID_BALTIC LGRPID_CENTRAL_EUROPE LGRPID_CYRILLIC LGRPID_GEORGIAN LGRPID_GREEK LGRPID_HEBREW LGRPID_INDIC LGRPID_JAPANESE LGRPID_KOREAN  LGRPID_SIMPLIFIED_CHINESE LGRPID_TRADITIONAL_CHINESE LGRPID_THAI LGRPID_TURKIC LGRPID_TURKISH LGRPID_VIETNAMESE LGRPID_WESTERN_EUROPE"
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpLanguageGroupString",
        "description": "Pointer to a buffer containing a null-terminated language group identifier string."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpLanguageGroupNameString",
        "description": "Pointer to a buffer containing a null-terminated language group name string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying whether the language group identifier is supported or installed. This parameter can have one of the following values.   ValueMeaning      LGRPID_INSTALLED   Language group identifier is installed.   LGRPID_SUPPORTED   Language group identifier is both supported and installed."
      },
      {
        "in_out": "_In_",
        "type": "LONG_PTR",
        "name": "lParam",
        "description": "Application-defined parameter. This parameter can be used for error checking."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Enumerates the language groups that are either installed on or supported by an operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates language groups by passing language group identifiers, one at a time, to the specified application-defined callback function. This process continues until the last language group identifier is found or the callback function returns FALSE. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumSystemLanguageGroups",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LANGUAGEGROUP_ENUMPROC",
        "name": "lpLanguageGroupEnumProc",
        "description": "Pointer to an application-defined callback function. For more information, see EnumLanguageGroupsProc."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying the language group identifiers to enumerate. This parameter can have one of the following values.  ValueMeaning  LGRPID_INSTALLED   Enumerate only installed language group identifiers.   LGRPID_SUPPORTED   Enumerate all supported language group identifiers."
      },
      {
        "in_out": "_In_",
        "type": "LONG_PTR",
        "name": "lParam",
        "description": "Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined callback function that processes enumerated locale information provided by the EnumSystemLocales function. The LOCALE_ENUMPROC type defines a pointer to this callback function. EnumLocalesProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumLocalesProc function can carry out any desired task. The application registers this function by passing its address to the EnumSystemLocales function. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumLocalesProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpLocaleString",
        "description": "Pointer to a buffer containing a null-terminated locale identifier string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Enumerates the locales that are either installed on or supported by an operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The function enumerates locales by passing locale identifiers, one at a time, to the specified application-defined callback function. This continues until all of the installed or supported locale identifiers have been passed to the callback function or the callback function returns FALSE. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumSystemLocales",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LOCALE_ENUMPROC",
        "name": "lpLocaleEnumProc",
        "description": "Pointer to an application-defined callback function. For more information, see EnumLocalesProc."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.  ValueMeaning  LCID_INSTALLED   Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.   LCID_SUPPORTED   Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.   LCID_ALTERNATE_SORTS   Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "An application-defined callback function that processes enumerated locale information provided by the EnumSystemLocalesEx function. The LOCALE_ENUMPROCEX type defines a pointer to this callback function. EnumLocalesProcEx is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumLocalesProcEx function can carry out any desired task. The application registers this function by passing its address to the EnumSystemLocalesEx function. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumLocalesProcEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpLocaleString",
        "description": "Pointer to a buffer containing a null-terminated locale name string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags defining locale information. Values for this parameter can include a binary OR of flags, but some flag combinations never occur. If the application specifies LOCALE_WINDOWS or LOCALE_ALTERNATE_SORTS, it can also specify LOCALE_REPLACEMENT so that the EnumSystemLocalesEx function can test to see if the locale is a replacement.    LOCALE_ALL   LOCALE_ALTERNATE_SORTS; for more information, see EnumSystemLocalesEx   LOCALE_NEUTRALDATA   LOCALE_REPLACEMENT Note  This constant is not a valid input to the dwFlags parameter of EnumSystemLocalesEx. To enumerate replacement locales, the application should call this function with the dwFlags parameter specified as LOCALE_WINDOWS or LOCALE_ALL, then check for this constant in the callback function.     LOCALE_SUPPLEMENTAL   LOCALE_WINDOWS"
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided input parameter of EnumSystemLocalesEx. This value is especially useful for multi-threaded applications, since it can be used to pass thread-specific data to this callback function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the locales that are either installed on or supported by an operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates locales by passing locale names, one at a time, to the application-defined callback function specified by lpLocaleEnumProcEx. Enumeration continues until all installed or supported names have been passed to the callback function or the callback function returns FALSE. The choices for the dwFlags parameter are different from those for EnumSystemLocales, which must distinguish between installed and supported locales. If dwFlags specifies LOCALE_ALTERNATE_SORTS, the callback function is called for every locale that represents an alternate sort order. For example, Spanish (Spain) defaults to international sort order, but traditional sort order is available for an alternate sort. German (Germany) defaults to dictionary sort order, but there is an alternate phone book sort order available. An example showing the use of this function can be found in NLS: Name-based APIs Sample. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumSystemLocalesEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LOCALE_ENUMPROCEX",
        "name": "lpLocaleEnumProcEx",
        "description": "Pointer to an application-defined callback function. The EnumSystemLocalesEx function enumerates locales by making repeated calls to this callback function. For more information, see EnumLocalesProcEx."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags identifying the locales to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LOCALE_ALL.    LOCALE_ALL   LOCALE_ALTERNATE_SORTS; see Remarks  LOCALE_NEUTRALDATA   LOCALE_SUPPLEMENTAL   LOCALE_WINDOWS"
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpReserved",
        "description": "Reserved; must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Enumerates the time formats that are available for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The function enumerates the time formats by passing a pointer to a buffer containing a time format to an application-defined callback function. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns FALSE. This function can enumerate data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (\"?\").  Note that any new values for dwFlags introduced in the future will not work with the ANSI version. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumTimeFormats",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TIMEFMT_ENUMPROC",
        "name": "lpTimeFmtEnumProc",
        "description": "Pointer to an application-defined callback function. For more information, see EnumTimeFormatsProc."
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which to retrieve time format information. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The time format. This parameter can specify a combination of any of the following values.  FlagMeaning  0   Use the current user's long time format.   TIME_NOSECONDS   Windows 7 and later: Use the current user's short time format. Note  This value will not work with the ANSI version of this function, EnumTimeFormatsA.     LOCAL_USE_CP_ACP   Specified with the ANSI version of this function, EnumTimeFormatsA (not recommended), to use the system default Windows ANSI code page (ACP) instead of the locale code page."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the time formats that are available for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function enumerates the time formats by passing time format string pointers, one at a time, to the specified application-defined callback function, along with an application-defined constant that is useful for multi-threaded applications. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns FALSE. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "EnumTimeFormatsEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "TIMEFMT_ENUMPROCEX",
        "name": "lpTimeFmtEnumProcEx",
        "description": "Pointer to an application-defined callback function. For more information, see EnumTimeFormatsProcEx."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The time format. Set to 0 to use the current user's long time format, or TIME_NOSECONDS (starting with Windows 7) to use the short time format."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "An application-defined callback function that processes enumerated time format information provided by the EnumTimeFormats function. The TIMEFMT_ENUMPROC type defines a pointer to this callback function. EnumTimeFormatsProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumTimeFormatsProc function can carry out any desired task. The application registers this function by passing its address to the EnumTimeFormats function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumTimeFormatsProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpTimeFormatString",
        "description": "Pointer to a buffer containing a null-terminated time format string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "An application-defined callback function that processes enumerated time format information provided by the EnumTimeFormatsEx function. The TIMEFMT_ENUMPROCEX type defines a pointer to this callback function. EnumTimeFormatsProcEx is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE to continue enumeration or FALSE otherwise. ",
    "remarks": "An EnumTimeFormatsProcEx function can carry out any desired task. The application registers this function by passing its address to the EnumTimeFormatsEx function. This callback function can process enumerated data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL CALLBACK",
    "category": "National Language Support (NLS)",
    "name": "EnumTimeFormatsProcEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpTimeFormatString",
        "description": "Pointer to a buffer containing a null-terminated time format string."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application-provided input parameter of EnumTimeFormatsEx. This value is especially useful for multi-threaded applications, since it can be used to pass thread-specific data to this callback function."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a 0-based index into the source string indicated by lpStringSource if successful. In combination with the value in pcchFound, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0. The function returns -1 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for FindNLSStringEx. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "FindNLSString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create an identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFindNLSStringFlags",
        "description": "Flags specifying details of the find operation. For detailed definitions, see the dwFindNLSStringFlags parameter of FindNLSStringEx."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpStringSource",
        "description": "Pointer to the source string, in which the function searches for the string specified by lpStringValue."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSource",
        "description": "Size, in characters excluding the terminating null character, of the string indicated by lpStringSource. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpStringValue",
        "description": "Pointer to the search string, for which the function searches in the source string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchValue",
        "description": "Size, in characters excluding the terminating null character, of the string indicated by lpStringValue. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPINT",
        "name": "pcchFound",
        "description": "Pointer to a buffer containing the length of the string that the function finds. For details, see the pcchFound parameter of FindNLSStringEx."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 10,
    "description": "Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a 0-based index into the source string indicated by lpStringSource if successful. In combination with the value in pcchFound, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0. The function returns -1 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function provides a variety of search options, including search direction, character equivalence filtering, and locale-specific filtering. Note that equivalence depends on the locale and flags specified in the call to the function. The filtering flags can alter the results of the search. For example, the potential matches increase when the function ignores case or diacritic marks when performing the search. By default, this function maps the lowercase \"i\" to the uppercase \"I\", even when the Locale parameter specifies Turkish (Turkey) or Azerbaijani (Azerbaijan). To override this behavior for Turkish or Azerbaijani, the application should specify NORM_LINGUISTIC_CASING. If this flag is specified for the correct locale, \"\u00c4\u00b1\" (lowercase dotless I) is the lowercase form of \"I\" (uppercase dotless I) and \"i\" (lowercase dotted I) is the lowercase form of \"\u00c4\u00b1\" (uppercase dotted I). For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC and NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE, with the following exceptions: In contrast to other NLS API functions, which return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns. This function is one of the few NLS functions that calls SetLastError even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by GetLastError. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "FindNLSStringEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFindNLSStringFlags",
        "description": "Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags with any of the filtering flags defined in the next table. If the application does not specify a flag, the function uses the default comparison for the specified locale. As discussed in Handling Sorting in Your Applications, there is no binary comparison mode.  ValueMeaning  FIND_FROMSTART   Search the string, starting with the first character of the string.   FIND_FROMEND   Search the string in the reverse direction, starting with the last character of the string.   FIND_STARTSWITH   Test to find out if the value specified by lpStringValue is the first value in the source string indicated by lpStringSource.   FIND_ENDSWITH   Test to find out if the value specified by lpStringValue is the last value in the source string indicated by lpStringSource.     The application can use the filtering flags defined below in combination with a find flag.  ValueMeaning  LINGUISTIC_IGNORECASE   Ignore case in the search, as linguistically appropriate. For more information, see the Remarks section.   LINGUISTIC_IGNOREDIACRITIC   Ignore diacritics, as linguistically appropriate. For more information, see the Remarks section. Note  This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.     NORM_IGNORECASE   Ignore case in the search. For more information, see the Remarks section.   NORM_IGNOREKANATYPE   Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.   NORM_IGNORENONSPACE   Ignore nonspacing characters. For more information, see the Remarks section.   NORM_IGNORESYMBOLS   Ignore symbols and punctuation.   NORM_IGNOREWIDTH   Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.   NORM_LINGUISTIC_CASING   Use linguistic rules for casing, instead of file system rules (default). For more information, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpStringSource",
        "description": "Pointer to the source string, in which the function searches for the string specified by lpStringValue."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSource",
        "description": "Size, in characters excluding the terminating null character, of the string indicated by lpStringSource. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpStringValue",
        "description": "Pointer to the search string, for which the function searches in the source string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchValue",
        "description": "Size, in characters excluding the terminating null character, of the string indicated by lpStringValue. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPINT",
        "name": "pcchFound",
        "description": "Pointer to a buffer containing the length of the string that the function finds. The string can be either longer or shorter than the search string. If the function fails to find the search string, this parameter is not modified. The function can retrieve NULL in this parameter. In this case, the function makes no indication if the length of the found string differs from the length of the source string.  Note that the value of pcchFound is often identical to the value provided in cchValue, but can differ in the following cases:  The value provided in cchValue is negative. The strings are equivalent, but have different lengths. For example, \"A\" plus \"Combining Ring\" (U+0041 U+030A) is equivalent to the \"A Ring\" (U+00c5)."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPNLSVERSIONINFO",
        "name": "lpVersionInformation",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpReserved",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPARAM",
        "name": "sortHandle",
        "description": "Reserved; must be 0."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Locates a Unicode string (wide characters) in another Unicode string for a non-linguistic comparison.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Libloaderapi.h (include Windows.h)",
    "return_value": "Returns a 0-based index into the source string indicated by lpStringSource if successful. If the function succeeds, the found string is the same size as the value of lpStringValue. A return value of 0 indicates that the function found a match at the beginning of the source string. The function returns -1 if it does not succeed or if it does not find the search string. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Since FindStringOrdinal provides a binary comparison, it does not return linguistically appropriate results. The ordinal comparison might be mistaken for English sorting behavior. However, it does not find matches when characters vary by linguistically insignificant amounts. See Sorting for information about choosing an appropriate sorting function. In contrast to NLS functions that return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns. This function is one of the few NLS functions that calls SetLastError even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by GetLastError. Starting with Windows 8: FindStringOrdinal  is declared in Libloaderapi.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "FindStringOrdinal",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFindStringOrdinalFlags",
        "description": "Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags.  ValueMeaning  FIND_FROMSTART   Search the string, starting with the first character of the string.   FIND_FROMEND   Search the string in the reverse direction, starting with the last character of the string.   FIND_STARTSWITH   Test to find out if the value specified by lpStringValue is the first value in the source string indicated by lpStringSource.   FIND_ENDSWITH   Test to find out if the value specified by lpStringValue is the last value in the source string indicated by lpStringSource."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpStringSource",
        "description": "Pointer to the source string, in which the function searches for the string specified by lpStringValue."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSource",
        "description": "Size, in characters excluding the terminating null character, of the string indicated by lpStringSource. The application must normally specify a positive number, or 0. The application can specify -1 if the source string is null-terminated and the function should calculate the size automatically."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpStringValue",
        "description": "Pointer to the search string for which the function searches in the source string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchValue",
        "description": "Size, in characters excluding the terminating null character, of the string indicated by lpStringValue. The application must normally specify a positive number, or 0. The application can specify -1 if the string is null-terminated and the function should calculate the size automatically."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bIgnoreCase",
        "description": "TRUE if the function is to perform a case-insensitive comparison, and FALSE otherwise. The comparison is not a linguistic operation and is not appropriate for all locales and languages. Its behavior is similar to that for English."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Maps one Unicode string to another, performing the specified transformation. For an overview of the use of the string functions, see Strings.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (see Remarks) (include Windows.h);  Stringapiset.h (see Remarks) (include Windows.h)",
    "return_value": "Returns the number of characters in the translated string, including a terminating null character, if successful. If the function succeeds and the value of cchDest is 0, the return value is the size of the buffer required to hold the translated string, including a terminating null character. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The values of the lpSrcStr and  and lpDestStr parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER. The compatibility zone in Unicode consists of characters in the range 0xF900 through 0xFFEF that are assigned to characters from other encoding standards for characters but are actually variants of characters already in Unicode. The compatibility zone is used to support round-trip mapping to these standards. Applications can use the MAP_FOLDCZONE flag to avoid supporting the duplication of characters in the compatibility zone. Startng with Windows Vista: This function supports Unicode normalization. All Unicode compatibility characters are mapped. Startng with Windows Vista: The transformations indicated by the MAP_FOLDCZONE, MAP_PRECOMPOSED, and MAP_COMPOSITE flags use Unicode normalization forms KC, C, and D (through the NormalizeString function) to do the mappings. Starting with Windows 8: The ANSI version of the function is declared in Winnls.h and the Unicode version is declared in Stringapiset.h. Before Windows 8, both versions were declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "FoldString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMapFlags",
        "description": "Flags specifying the type of transformation to use during string mapping. ..."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSrcStr",
        "description": "Pointer to a source string that the function maps."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSrc",
        "description": "Size, in characters, of the source string indicated by lpSrcStr, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by lpDestStr."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpDestStr",
        "description": "Pointer to a buffer in which this function retrieves the mapped string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDest",
        "description": "Size, in characters, of the destination string indicated by lpDestStr. If space for a terminating null character is included in cchSrc, cchDest must also include space for a terminating null character. The application can set cchDest to 0. In this case, the function does not use the lpDestStr parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the current Windows ANSI code page identifier for the operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the current Windows ANSI code page (ACP) identifier for the operating system. See Code Page Identifiers for a list of identifiers for Windows ANSI code pages and other code pages. ",
    "remarks": "The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, applications should use UTF-8 or UTF-16 when possible. ",
    "return_type": "UINT",
    "category": "National Language Support (NLS)",
    "name": "GetACP",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Deprecated. Retrieves a properly formatted date string for the specified locale using the specified date and calendar. The user can specify the short date format, the long date format, the year month format, or a custom format pattern.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns the number of characters written to the lpDateStr buffer if successful. If the cchDate parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character. This function returns 0 if it does not succeed.  To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The earliest date supported by this function is January 1, 1601. This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with that module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetCalendarDateFormatEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpszLocale",
        "description": "Pointer to a locale name, or one of the following predefined values.   LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying date format options. If lpFormat is not set to NULL, this parameter must be set to 0. If lpFormat is set to NULL, the application can specify a combination of the following values and LOCALE_NOUSEROVERRIDE.  ValueMeaning  DATE_SHORTDATE   Use the short date format. This is the default. This value cannot be used with DATE_LONGDATE or DATE_YEARMONTH.    DATE_LONGDATE   Use the long date format. This value cannot be used with DATE_SHORTDATE or DATE_YEARMONTH.    DATE_YEARMONTH   Use the year/month format. This value cannot be used with DATE_SHORTDATE or DATE_LONGDATE.   DATE_LTRREADING   Add marks for left-to-right reading layout. This value cannot be used with DATE_RTLREADING.   DATE_RTLREADING   Add marks for right-to-left reading layout. This value cannot be used with DATE_LTRREADING"
      },
      {
        "in_out": "_In_",
        "type": "const LPCALDATETIME",
        "name": "lpCalDateTime",
        "description": "Pointer to a CALDATETIME structure that contains the date and calendar information to format."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFormat",
        "description": "Pointer to a format picture string that is used to form the date string. Possible values for the format picture string are defined in Day, Month, Year, and Era Format Pictures. The format picture string must be null-terminated. The function uses the locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application sets this parameter to NULL if the function is to use the date format of the specified locale."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpDateStr",
        "description": "Pointer to a buffer in which this function receives the formatted date string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDate",
        "description": "Size, in characters, of the lpDateStr buffer. Alternatively, the application can set this parameter to 0. In this case, the function returns the number of characters required to hold the formatted date string, and the lpDateStr parameter is not used."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves information about a calendar for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the lpCalData buffer, with cchData set to a nonzero value, if successful. If the function succeeds, cchData is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the calendar information. If the function succeeds, cchData is set 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value retrieved in lpValue, that is, 2 for the Unicode version of the function or 4 for the ANSI version. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetCalendarInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which to retrieve calendar information. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier."
      },
      {
        "in_out": "_In_",
        "type": "CALTYPE",
        "name": "CalType",
        "description": "Type of information to retrieve. For more information, see Calendar Type Information.  Note  GetCalendarInfo returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.   CAL_USE_CP_ACP is relevant only for the ANSI version of this function. For CAL_NOUSEROVERRIDE, the function ignores any value set by SetCalendarInfo and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by SetCalendarInfo."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpCalData",
        "description": "Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in CalType, this parameter must retrieve NULL."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchData",
        "description": "Size, in characters, of the lpCalData buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the lpCalData parameter is not used. If CAL_RETURN_NUMBER is specified for CalType, the value of cchData must be 0."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpValue",
        "description": "Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in CalType, then lpValue must not be NULL. If CAL_RETURN_NUMBER is not specified in CalType, then lpValue must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Retrieves information about a calendar for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the lpCalData buffer if successful. If the function succeeds, cchData is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the locale information. If the function succeeds, cchData is set to 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value written to the lpValue parameter. This size is always 2. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetCalendarInfoEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpReserved",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "CALTYPE",
        "name": "CalType",
        "description": "Type of information to retrieve. For more information, see Calendar Type Information.  \t\t\t  Note  GetCalendarInfoEx returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.   For CAL_NOUSEROVERRIDE, the function ignores any value set by SetCalendarInfo and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by SetCalendarInfo."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpCalData",
        "description": "Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in CalType, this parameter must retrieve NULL."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchData",
        "description": "Size, in characters, of the lpCalData buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the lpCalData parameter is not used. If CAL_RETURN_NUMBER is specified for CalType, the value of cchData must be 0."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpValue",
        "description": "Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in CalType, then lpValue must not be NULL. If CAL_RETURN_NUMBER is not specified in CalType, then lpValue must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Deprecated. Gets the supported date range for a specified calendar.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns TRUE if successful or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The earliest date supported by this function is January 1, 1601. This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with the module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetCalendarSupportedDateRange",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier for which to get the supported date range."
      },
      {
        "in_out": "_Out_",
        "type": "LPCALDATETIME",
        "name": "lpCalMinDateTime",
        "description": "Pointer to a CALDATETIME structure defining the minimum supported date."
      },
      {
        "in_out": "_Out_",
        "type": "LPCALDATETIME",
        "name": "lpCalMaxDateTime",
        "description": "Pointer to a CALDATETIME structure defining the maximum supported date."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves information about any valid installed or available code page.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns 1 if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for GetCPInfoEx. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetCPInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "CodePage",
        "description": "Identifier for the code page for which to retrieve information. For details, see the CodePage parameter of GetCPInfoEx."
      },
      {
        "in_out": "_Out_",
        "type": "LPCPINFO",
        "name": "lpCPInfo",
        "description": "Pointer to a CPINFO structure that receives information about the code page. See the Remarks section."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves information about any valid installed or available code page.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The information retrieved in the CPINFOEX structure is not always useful for all code pages. To determine buffer sizes, for example, the application should call MultiByteToWideChar or WideCharToMultiByte to request an accurate buffer size. If CPINFOEX settings indicate that a lead byte exists, the conversion function does not necessarily handle lead bytes differently, for example, in the case of a missing or illegal trail byte. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetCPInfoEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "CodePage",
        "description": "Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See Code Page Identifiers for a list of identifiers for ANSI and other code pages.  ValueMeaning  CP_ACP   Use the system default Windows ANSI code page.   CP_MACCP   Use the system default Macintosh code page.   CP_OEMCP   Use the system default OEM code page.   CP_THREAD_ACP                    Use the current thread's ANSI code page."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved; must be 0."
      },
      {
        "in_out": "_Out_",
        "type": "LPCPINFOEX",
        "name": "lpCPInfoEx",
        "description": "Pointer to a CPINFOEX structure that receives information about the code page."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Formats a number string as a currency string for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the buffer indicated by lpCurrencyStr if successful. If the cchCurrency parameter is set to 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetCurrencyFormat",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which this function formats the currency string. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags controlling currency format. The application must set this parameter to 0 if lpFormat is not set to NULL. In this case, the function formats the string using user overrides to the default currency format for the locale. If lpFormat is set to NULL, the application can specify LOCALE_NOUSEROVERRIDE to format the string using the system default currency format for the specified locale. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpValue",
        "description": "For details, see the lpValue parameter of GetCurrencyFormatEx."
      },
      {
        "in_out": "_In_opt_",
        "type": "const CURRENCYFMT*",
        "name": "lpFormat",
        "description": "Pointer to a CURRENCYFMT structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to NULL if function is to use the currency format of the specified locale. If this parameter is not set to NULL, the function uses the specified locale only for formatting information not specified in the CURRENCYFMT structure, for example, the string value for the negative sign used by the locale."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpCurrencyStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted currency string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCurrency",
        "description": "Size, in characters, of the lpCurrencyStr buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the lpCurrencyStr parameter is not used."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Formats a number string as a currency string for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the buffer indicated by lpCurrencyStr if successful. If the cchCurrency parameter is 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetCurrencyFormatEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags controlling the operation of the function. The application must set this parameter to 0 if lpFormat is not set to NULL. In this case, the function formats the string using user overrides to the default currency format for the locale. If lpFormat is set to NULL, the application can specify LOCALE_NOUSEROVERRIDE to format the string using the system default currency format for the specified locale. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpValue",
        "description": "Pointer to a null-terminated string containing the number string to format. This string can contain only the following characters. All other characters are invalid. The function returns an error if the string deviates from these rules.  Characters \"0\" through \"9\" One decimal point (dot) if the number is a floating-point value A minus sign in the first character position if the number is a negative value"
      },
      {
        "in_out": "_In_opt_",
        "type": "const CURRENCYFMT*",
        "name": "lpFormat",
        "description": "Pointer to a CURRENCYFMT structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to NULL if function is to use the currency format of the specified locale. If this parameter is not set to NULL, the function uses the specified locale only for formatting information not specified in the CURRENCYFMT structure, for example, the string value for the negative sign used by the locale."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpCurrencyStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted currency string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchCurrency",
        "description": "Size, in characters, of the lpCurrencyStr buffer. The application can set this parameter to 0 to return the size of the buffer required to hold the formatted currency string. In this case, the buffer indicated by lpCurrencyStr is not used."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Formats a date as a date string for a locale specified by the locale identifier. The function formats either a specified date or the local system date.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Datetimeapi.h (include Windows.h)",
    "return_value": "Returns the number of characters written to the lpDateStr buffer if successful. If the cchDate parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for GetDateFormatEx. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (\"?\"). Starting with Windows 8: GetDateFormat  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetDateFormat",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale this function formats the date string for. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying date format options. For detailed definitions, see the dwFlags parameter of GetDateFormatEx."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SYSTEMTIME*",
        "name": "lpDate",
        "description": "Pointer to a SYSTEMTIME structure that contains the date information to format. The application sets this parameter to NULL if the function is to use the current local system date."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpFormat",
        "description": "Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in Day, Month, Year, and Era Format Pictures. The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to NULL to format the string according to the date format for the specified locale."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpDateStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted date string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDate",
        "description": "Size, in characters, of the lpDateStr buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by lpDateStr is not used."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Formats a date as a date string for a locale specified by name. The function formats either a specified date or the local system date.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Datetimeapi.h (include Windows.h)",
    "return_value": "Returns the number of characters written to the lpDateStr buffer if successful. If the cchDate parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The earliest date supported by this function is January 1, 1601. The day name, abbreviated day name, month name, and abbreviated month name are all localized based on the locale identifier. The date values in the structure indicated by lpDate must be valid. The function checks each of the date values: year, month, day, and day of week. If the day of the week is incorrect, the function uses the correct value, and returns no error. If any of the other date values are outside the correct range, the function fails, and sets the last error to ERROR_INVALID_PARAMETER. The function ignores the time members of the SYSTEMTIME structure indicated by lpDate. These include wHour, wMinute, wSecond, and wMilliseconds. If the lpFormat parameter contains a bad format string, the function returns no errors, but just forms the best possible date string. For example, the only year pictures that are valid are L\"yyyy\" and L\"yy\", where the \"L\" indicates a Unicode (16-bit characters) string. If L\"y\" is passed in, the function assumes L\"yy\". If L\"yyy\" is passed in, the function assumes L\"yyyy\". If more than four date (L\"dddd\") or four month (L\"MMMM\") pictures are passed in, the function defaults to L\"dddd\" or L\"MMMM\". The application should enclose any text that should remain in its exact form in the date string within single quotation marks in the date format picture. The single quotation mark can also be used as an escape character to allow the single quotation mark itself to be displayed in the date string. However, the escape sequence must be enclosed within two single quotation marks. For example, to display the date as \"May '93\", the format string is: L\"MMMM ''''yy\". The first and last single quotation marks are the enclosing quotation marks. The second and third single quotation marks are the escape sequence to allow the single quotation mark to be displayed before the century. When the date picture contains both a numeric form of the day (either d or dd) and the full month name (MMMM), the genitive form of the month name is retrieved in the date string. To obtain the default short and long date format without performing any actual formatting, the application should use GetLocaleInfoEx with the LOCALE_SSHORTDATE or LOCALE_SLONGDATE constant. To get the date format for an alternate calendar, the application uses GetLocaleInfoEx with the LOCALE_IOPTIONALCALENDAR constant. To get the date format for a particular calendar, the application uses GetCalendarInfoEx, passing the appropriate Calendar Identifier. It can call EnumCalendarInfoEx or EnumDateFormatsEx to retrieve date formats for a particular calendar. This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. The DATE_LONGDATE format includes two kinds of date patterns: patterns that include the day of the week and patterns that do not include the day of the week. For example, \"Tuesday, October 18, 2016\" or \"October 18, 2016\".  If your application needs to ensure that dates use one of these kinds of patterns and not the other kind, your application should perform the following actions: If the presence or absence of the day of the week in the long date format does not matter to your application, your application can call GetDateFormatEx directly without first enumerating all of the long date formats by calling EnumDateFormatsExEx. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. Beginning in Windows 8: GetDateFormatEx  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetDateFormatEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying various function options that can be set if lpFormat is set to NULL. The application can specify a combination of the following values and LOCALE_USE_CP_ACP or LOCALE_NOUSEROVERRIDE. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.    ValueMeaning  DATE_AUTOLAYOUT   Windows 7 and later: Detect the need for right-to-left and left-to-right reading layout using the locale and calendar information, and add marks accordingly. This value cannot be used with DATE_LTRREADING or DATE_RTLREADING. DATE_AUTOLAYOUT is preferred over DATE_LTRREADING and DATE_RTLREADING because it uses the locales and calendars to determine the correct addition of marks.   DATE_LONGDATE   Use the long date format. This value cannot be used with DATE_MONTHDAY, DATE_SHORTDATE, or DATE_YEARMONTH.   DATE_LTRREADING                    Add marks for left-to-right reading layout. This value cannot be used with DATE_RTLREADING.   DATE_RTLREADING                    Add marks for right-to-left reading layout. This value cannot be used with DATE_LTRREADING   DATE_SHORTDATE   Use the short date format. This is the default. This value cannot be used with DATE_MONTHDAY, DATE_LONGDATE, or DATE_YEARMONTH.   DATE_USE_ALT_CALENDAR   Use the alternate calendar, if one exists, to format the date string. If this flag is set, the function uses the default format for that alternate calendar, rather than using any user overrides. The user overrides will be used only in the event that there is no default format for the specified alternate calendar.   DATE_YEARMONTH   Windows Vista: Use the year/month format. This value cannot be used with DATE_MONTHDAY, DATE_SHORTDATE, or DATE_LONGDATE.   DATE_MONTHDAY   Windows 10: Use the combination of month and day formats appropriate for the specified locale. This value cannot be used with DATE_YEARMONTH, DATE_SHORTDATE, or DATE_LONGDATE.     If  the application does not specify DATE_YEARMONTH, DATE_MONTHDAY, DATE_SHORTDATE, or DATE_LONGDATE, and lpFormat is set to NULL, DATE_SHORTDATE is the default."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SYSTEMTIME*",
        "name": "lpDate",
        "description": "Pointer to a SYSTEMTIME structure that contains the date information to format. The application can set this parameter to NULL if the function is to use the current local system date."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpFormat",
        "description": "Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in Day, Month, Year, and Era Format Pictures. For example, to get the date string \"Wed, Aug 31 94\", the application uses the picture string \"ddd',' MMM dd yy\". The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to NULL to format the string according to the date format for the specified locale."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpDateStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted date string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDate",
        "description": "Size, in characters, of the lpDateStr buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by lpDateStr is not used."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpCalendar",
        "description": "Reserved; must set to NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "Formats a duration of time as a time string for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the buffer indicated by lpDurationStr if successful. If lpDurationStr is set to NULL and cchDuration is set to 0, the function returns the required size for the duration string buffer, including the null terminating character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for GetDurationFormatEx. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetDurationFormat",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale for which this function formats the duration. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying function options. If lpFormat is not set to NULL, this parameter must be set to 0. If lpFormat is set to NULL, your application can specify LOCALE_NOUSEROVERRIDE to format the string using the system default duration format for the specified locale. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SYSTEMTIME*",
        "name": "lpDuration",
        "description": "Pointer to a SYSTEMTIME structure that contains the time duration information to format. If this pointer is NULL, the function ignores this parameter and uses ullDuration."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "ullDuration",
        "description": "64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both lpDuration and ullDuration are present, lpDuration takes precedence. If lpDuration is set to NULL and ullDuration is set to 0, the duration is zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpFormat",
        "description": "Pointer to the format string. For details, see the lpFormat parameter of GetDurationFormatEx."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpDurationStr",
        "description": "Pointer to the buffer in which the function retrieves the duration string. Alternatively, this parameter can contain NULL if cchDuration is set to 0. In this case, the function returns the required size for the duration string buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDuration",
        "description": "Size, in characters, of the buffer indicated by lpDurationStr. Alternatively, the application can set this parameter to 0. In this case, the function retrieves NULL in lpDurationStr and returns the required size for the duration string buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Formats a duration of time as a time string for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the buffer indicated by lpDurationStr if successful. If lpDurationStr is set to NULL and cchDuration is set to 0, the function returns the required size for the duration string buffer, including the terminating null character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function can be used with multimedia applications that display file time and sporting event applications that display finish times. This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. The following are characteristics of duration format strings: Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. Examples Following are examples of duration formats and corresponding outputs for specified time durations. SYSTEMTIME = 14 days, 2 hours, 45 minutes, 12 seconds, and 247 milliseconds  SYSTEMTIME = 345 seconds  uulDuration = 51234567 (5.1234567 seconds)  ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetDurationFormatEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.   LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying function options. If lpFormat is not set to NULL, this parameter must be set to 0. If lpFormat is set to NULL, your application can specify LOCALE_NOUSEROVERRIDE to format the string using the system default duration format for the specified locale. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SYSTEMTIME*",
        "name": "lpDuration",
        "description": "Pointer to a SYSTEMTIME structure that contains the time duration information to format. The application sets this parameter to NULL if the function is to ignore it and use ullDuration."
      },
      {
        "in_out": "_In_",
        "type": "ULONGLONG",
        "name": "ullDuration",
        "description": "64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both lpDuration and ullDuration are set, the lpDuration parameter takes precedence. If lpDuration is set to NULL and ullDuration is set to 0, the duration is 0."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpFormat",
        "description": "Pointer to the format string with characters as shown below. The application can set this parameter to NULL if the function is to format the string according to the duration format for the specified locale. If lpFormat is not set to NULL, the function uses the locale only for information not specified in the format picture string.  ValueMeaning  d   days   h or H   hours   hh or HH   hours; if less than ten,  prepend a leading zero   m   minutes   mm   minutes; if less than ten, prepend a leading zero   s   seconds   ss   seconds; if less than ten, prepend a leading zero   f   fractions of a second  Note  The character \"f\" can occur up to nine consecutive times (fffffffff), although support for frequency timers is limited to 100 nanoseconds. Thus, if nine characters are present, the last two digits are always 0."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpDurationStr",
        "description": "Pointer to the buffer in which the function retrieves the duration string. Alternatively, this parameter retrieves NULL if cchDuration is set to 0. In this case, the function returns the required size for the duration string buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDuration",
        "description": "Size, in characters, of the buffer indicated by lpDurationStr. Alternatively, the application can set this parameter to 0. In this case, the function retrieves NULL in lpDurationStr and returns the required size for the duration string buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information about a specified geographical location.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of bytes (ANSI) or words (Unicode) of geographical location information retrieved in the output buffer. If cchData is set to 0, the function returns the required size for the buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "If the application specifies GEO_RFC1766 for GeoType, it should specify a language identifier for LangId that is appropriate to the specified geographical location identifier. The appropriate language is either a locale-neutral language or one with a locale corresponding to the specified identifier. The resulting string, compliant with RFC 4646 (Windows Vista), constitutes a locale name. For example, if Location is specified as 0xF4 for United States, GeoType is specified as GEO_RFC1766, and LangId is specified as either 0x09 for locale-neutral English or 0x409 for English (United States), the function retrieves \"en-US\" on successful return. In fact, the function ignores the locale-specific portion of the language. Thus, if the application specifies LangId as 0x809 for English (United Kingdom), the function also writes \"en-US\" to lpGeoData. Consider another example. If Location is specified as 0xF4 for United States, GeoType is specified as GEO_RFC1766, and LangId is specified as 0x04 for Chinese, the function retrieves \"zh-US\" on successful return. This is not the name of a supported locale. If the application specifies GEO_LCID for GeoType, the function treats the language identifier as a locale identifier (LCID). It attempts to return the locale identifier if it is associated with the provided geographical identifier in some way. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetGeoInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GEOID",
        "name": "Location",
        "description": "Identifier for the geographical location for which to get information. For more information, see Table of Geographical Locations. You can obtain the available values by calling EnumSystemGeoID."
      },
      {
        "in_out": "_In_",
        "type": "GEOTYPE",
        "name": "GeoType",
        "description": "Type of information to retrieve. Possible values are defined by the SYSGEOTYPE enumeration. If the value of GeoType is GEO_LCID, the function retrieves a locale identifier. If the value of GeoType is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (Windows Vista). For more information, see the Remarks section. Windows XP: When GeoType is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value. Windows Me: When GeoType is set to GEO_LCID, the retrieved string is a decimal value."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpGeoData",
        "description": "Pointer to the buffer in which this function retrieves the information."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchData",
        "description": "Size of the buffer indicated by lpGeoData. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "LANGID",
        "name": "LangId",
        "description": "Identifier for the language, used with the value of Location. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for GeoType. This setting causes the function to retrieve the language identifier by calling GetUserDefaultLangID. Note   The application must set this parameter to 0 if GeoType has any value other than GEO_RFC1766 or GEO_LCID."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves information about a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the locale data buffer if successful and cchData is a nonzero value. If the function succeeds, cchData is nonzero, and LOCALE_RETURN_NUMBER is specified, the return value is the size of the integer retrieved in the data buffer; that is, 2 for the Unicode version of the function or 4 for the ANSI version. If the function succeeds and the value of cchData is 0, the return value is the required size, in characters including a null character, for the locale data buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "For the operation of this function, see Remarks for GetLocaleInfoEx. The following examples deal correctly with the buffer size for non-text values: The ANSI string retrieved by the ANSI version of this function is translated from Unicode to ANSI based on the default ANSI code page for the locale identifier. However, if LOCALE_USE_CP_ACP is specified, the translation is based on the system default ANSI code page. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetLocaleInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier for which to retrieve information. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "LCTYPE",
        "name": "LCType",
        "description": "The locale information to retrieve. For detailed definitions, see the LCType parameter of GetLocaleInfoEx. Note  For GetLocaleInfo, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpLCData",
        "description": "Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if cchData is set to 0. For more information, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchData",
        "description": "Size, in TCHAR values, of the data buffer indicated by lpLCData. Alternatively, the application can set this parameter to 0. In this case, the function does not use the lpLCData parameter and returns the required buffer size, including the terminating null character."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves information about a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the locale data buffer if successful and cchData is a nonzero value. If the function succeeds, cchData is nonzero, and LOCALE_RETURN_NUMBER is specified, the return value is the size of the integer retrieved in the data buffer, that is, 2. If the function succeeds and the value of cchData is 0, the return value is the required size, in characters including a null character, for the locale data buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function normally retrieves information in text format. If the information is a numeric value and the value of LCType is LOCALE_ILANGUAGE or LOCALE_IDEFAULTLANGUAGE, this function retrieves strings containing hexadecimal numbers. Otherwise, the retrieved text for numeric information is a decimal number. There are two exceptions to this rule. First, the application can retrieve numeric values as integers by specifying LOCALE_RETURN_NUMBER in the LCType parameter. The second exception is that LOCALE_FONTSIGNATURE behaves differently from all other locale information constants. The application must provide a data buffer of at least sizeof(LOCALESIGNATURE) bytes. On successful return from the function, the buffer is filled in as a LOCALESIGNATURE structure. The following examples deal correctly with the buffer size for non-text values: This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. Examples showing the use of this function can be found in NLS: Name-based APIs Sample and NLS: Internationalized Domain Name (IDN) Mitigation Sample. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetLocaleInfoEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "LCTYPE",
        "name": "LCType",
        "description": "The locale information to retrieve. For possible values, see the \"Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo\" section in Locale Information Constants. Note that only one piece of locale information can be specified per call.  The application can use the binary OR operator to combine LOCALE_RETURN_NUMBER with any other allowed constant. In this case, the function retrieves the value as a number instead of a string. The buffer that receives the value must be at least the length of a DWORD value, which is 2. Caution  It is also possible to combine LOCALE_NOUSEROVERRIDE with any other constant. However, use of this constant is strongly discouraged. (Even without using the current user override, the data can differ from computer to computer, and custom locales can change the data. For example, even month or day names are subject to spelling reforms.)   If LCType is set to LOCALE_IOPTIONALCALENDAR, the function retrieves only the first alternate calendar.  Note  To get all alternate calendars, the application should use EnumCalendarInfoEx.                Starting with Windows Vista, your applications should not use LOCALE_ILANGUAGE in the LCType parameter to avoid failure or retrieval of unexpected data. Instead, it is recommended for your applications to call GetLocaleInfoEx."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpLCData",
        "description": "Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if cchData is set to 0."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchData",
        "description": "Size, in characters, of the data buffer indicated by lpLCData. Alternatively, the application can set this parameter to 0. In this case, the function does not use the lpLCData parameter and returns the required buffer size, including the terminating null character."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves information about the current version of a specified NLS capability for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if and only if the application has supplied valid values in lpVersionInformation, or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function allows an application such as Active Directory to determine if an NLS change affects the locale identifier used for a particular index table. If it does not, there is no need to re-index the table. For more information, see Handling Sorting in Your Applications. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetNLSVersion",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NLS_FUNCTION",
        "name": "Function",
        "description": "The NLS capability to query. This value must be COMPARE_STRING. See the SYSNLS_FUNCTION enumeration."
      },
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create an identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_Inout_",
        "type": "LPNLSVERSIONINFO",
        "name": "lpVersionInformation",
        "description": "Pointer to an NLSVERSIONINFO structure. The application must initialize the dwNLSVersionInfoSize member to sizeof(NLSVERSIONINFO). Note  On Windows Vista and later, the function can alternatively provide version information in an NLSVERSIONINFOEX structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves information about the current version of a specified NLS capability for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if and only if the application has supplied valid values in lpVersionInformation, or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function allows an application such as Active Directory to determine if an NLS change affects the locale used for a particular index table. If it does not, there is no need to re-index the table. For more information, see Handling Sorting in Your Applications. In particular, to tell if a sort version changed and you need to reindex: This is covered in more detail in the blog entry \"How to tell if the collation version changed\" (http://blogs.msdn.com/shawnste/archive/2007/06/01/how-to-tell-if-the-collation-version-changed.aspx). This function supports custom locales. If lpLocaleName specifies a supplemental locale, the data retrieved is the correct data for the sort order associated with that supplemental locale. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetNLSVersionEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NLS_FUNCTION",
        "name": "function",
        "description": "The NLS capability to query. This value must be COMPARE_STRING. See the SYSNLS_FUNCTION enumeration."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_Inout_",
        "type": "LPNLSVERSIONINFOEX",
        "name": "lpVersionInformation",
        "description": "Pointer to an NLSVERSIONINFOEX structure. The application must initialize the dwNLSVersionInfoSize member to  sizeof(NLSVERSIONINFOEX).  Note  On Windows Vista and later, the function can alternatively provide version information in an NLSVERSIONINFO structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Formats a number string as a number string customized for a locale specified by identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of TCHAR values retrieved in the buffer indicated by lpNumberStr if successful. If the cchNumber parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetNumberFormat",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags controlling the operation of the function. The application must set this parameter to 0 if lpFormat is not set to NULL. In this case, the function formats the string using user overrides to the default number format for the locale. If lpFormat is set to NULL, the application can specify LOCALE_NOUSEROVERRIDE to format the string using the system default number format for the specified locale. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpValue",
        "description": "Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by lpValue deviates from these rules.  Characters \"0\" through \"9\". One decimal point (dot) if the number is a floating-point value. A minus sign in the first character position if the number is a negative value."
      },
      {
        "in_out": "_In_opt_",
        "type": "const NUMBERFMT*",
        "name": "lpFormat",
        "description": "Pointer to a NUMBERFMT structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to NULL, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpNumberStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted number string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchNumber",
        "description": "Size, in TCHAR values, for the number string buffer indicated by lpNumberStr. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the lpNumberStr parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Formats a number string as a number string customized for a locale specified by name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the buffer indicated by lpNumberStr if successful. If the cchNumber parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetNumberFormatEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags controlling the operation of the function. The application must set this parameter to 0 if lpFormat is not set to NULL. In this case, the function formats the string using user overrides to the default number format for the locale. If lpFormat is set to NULL, the application can specify LOCALE_NOUSEROVERRIDE to format the string using the system default number format for the specified locale. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpValue",
        "description": "Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by lpValue deviates from these rules.  Characters \"0\" through \"9\". One decimal point (dot) if the number is a floating-point value. A minus sign in the first character position if the number is a negative value."
      },
      {
        "in_out": "_In_opt_",
        "type": "const NUMBERFMT*",
        "name": "lpFormat",
        "description": "Pointer to a NUMBERFMT structure that contains number formatting information, with all members set to appropriate values. If the application does not set this parameter to NULL, the function uses the locale only for formatting information not specified in the structure, for example, the locale string value for the negative sign."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpNumberStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted number string. Alternatively, this parameter contains NULL if cchNumber is set to 0. In this case, the function returns the required size for the number string buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchNumber",
        "description": "Size, in characters, for the number string buffer indicated by lpNumberStr. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer and does not use the lpNumberStr parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the current original equipment manufacturer (OEM) code page identifier for the operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the current OEM code page identifier for the operating system. ",
    "remarks": "See Code Page Identifiers for a list of OEM and other code pages. ",
    "return_type": "UINT",
    "category": "National Language Support (NLS)",
    "name": "GetOEMCP",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Provides a list of scripts used in the specified Unicode string.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the output buffer, including a terminating null character, if successful and cchScripts is set to a nonzero value. The function returns 1 to indicate that no script has been found, for example, when the input string only contains COMMON or INHERITED characters and GSS_ALLOW_INHERITED_COMMON is not set. Given that each found script adds five characters (four characters + delimiter), a simple mathematical operation provides the script count as (return_code - 1) / 5. If the function succeeds and the value of cchScripts is 0, the function returns the required size, in characters including a terminating null character, for the script buffer. The script count is as described above. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function is useful as part of a strategy to mitigate security issues related to internationalized domain names (IDNs). The script determination is based on the script values published by the Unicode Consortium in http://www.unicode.org/Public/4.1.0/ucd/Scripts.txt, except that the unassigned characters have the value \"Zzzz\" (UNASSIGNED) instead of \"Zyyy\" (COMMON). Here are some examples of the behavior of this function:  ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetStringScripts",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying options for script retrieval.  ValueMeaning  GSS_ALLOW_INHERITED_COMMON   Retrieve \"Qaii\" (INHERITED) and \"Zyyy\" (COMMON) script information. This flag does not affect the processing of unassigned characters. These characters in the input string always cause a \"Zzzz\" (UNASSIGNED script) to appear in the script string.     Note   By default, GetStringScripts ignores any inherited or common characters in the input string indicated by lpString. If GSS_ALLOW_INHERITED_COMMON is not set, neither \"Qaii\" nor \"Zyyy\" appears in the script string, even if the input string contains such characters. If GSS_ALLOW_INHERITED_COMMON is set, and if the input string contains inherited and/or common characters, \"Qaii\" and/or \"Zyyy\", respectively, appear in the script string. See the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString",
        "description": "Pointer to the Unicode string to analyze."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchString",
        "description": "Size, in characters, of the Unicode string indicated by lpString. The application sets this parameter to -1 if the Unicode string is null-terminated. If the application sets this parameter to 0, the function retrieves a null Unicode string (L\"\\0\") in lpScripts and returns 1."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpScripts",
        "description": "Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in ISO 15924. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each name, including the last, is followed by a semicolon. Alternatively, this parameter contains NULL if cchScripts is set to 0. In this case, the function returns the required size for the script buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchScripts",
        "description": "Size, in characters, of the script buffer indicated by lpScripts. Alternatively, the application can set this parameter to 0. In this case, the function retrieves NULL in lpScripts and returns the required size for the script buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Deprecated. Retrieves character type information for the characters in the specified source string. For each character in the string, the function sets one or more bits in the corresponding 16-bit element of the output array. Each bit identifies a given character type, for example, letter, digit, or neither.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "For an overview of the use of the string functions, see Strings. This function converts the source string to Unicode and calls the  corresponding GetStringTypeW function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single  Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus GetStringTypeA is of limited use for multi-character strings. GetStringTypeW and GetStringTypeEx are recommended instead. When this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). The values of the lpSrcStr and lpCharType parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER. The Locale parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of Locale. The Locale parameter is not used by the corresponding GetStringTypeW function. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a GetStringType* function through the use of the #define UNICODE switch. An application can circumvent this limitation by using GetStringTypeEx, which is the recommended function. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetStringTypeA",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoType",
        "description": "Flags specifying the character type information to retrieve. For possible flag values, see the dwInfoType parameter of GetStringTypeW. For detailed information about the character type bits, see Remarks for GetStringTypeW."
      },
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "lpSrcStr",
        "description": "Pointer to the ANSI string for which to retrieve the character types. The string can be a double-byte character set (DBCS) string if the supplied locale is appropriate for DBCS. The string is assumed to be null-terminated if cchSrc is set to any negative value."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSrc",
        "description": "Size, in characters, of the string indicated by lpSrcStr. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination."
      },
      {
        "in_out": "_Out_",
        "type": "LPWORD",
        "name": "lpCharType",
        "description": "Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If cchSrc is not a negative number, lpCharType should be an array of words with cchSrc elements. If cchSrc is set to a negative number, lpCharType is an array of words with lpSrcStr + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves character type information for the characters in the specified source string. For each character in the string, the function sets one or more bits in the corresponding 16-bit element of the output array. Each bit identifies a given character type, for example, letter, digit, or neither.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "For an overview of the use of the string functions, see Strings. Using the ANSI code page for the supplied locale, this function translates the source string from ANSI to Unicode. It then analyzes each Unicode character for character type information. The ANSI version of this function converts the source string to Unicode and calls the  corresponding GetStringTypeW function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single  Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus, the ANSI version of this function is of limited use for multi-character strings. The Unicode version of the function is recommended instead. This function circumvents a limitation caused by the difference in parameters between GetStringTypeA and GetStringTypeW. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a GetStringType* function through the use of the #define UNICODE switch. On the other hand, GetStringTypeEx, behaves properly with regard to that switch. Thus it is the recommended function. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). The values of the lpSrcStr and lpCharType parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER. The Locale parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of Locale. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetStringTypeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. This value uniquely defines the ANSI code page. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista and later: The following custom locale identifiers are also supported.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoType",
        "description": "Flags specifying the character type information to retrieve. For possible flag values, see the dwInfoType parameter of GetStringTypeW. For detailed information about the character type bits, see Remarks for GetStringTypeW."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSrcStr",
        "description": "Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if cchSrc is set to any negative value."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSrc",
        "description": "Size, in characters, of the string indicated by lpSrcStr. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination."
      },
      {
        "in_out": "_Out_",
        "type": "LPWORD",
        "name": "lpCharType",
        "description": "Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If cchSrc is not a negative number, lpCharType should be an array of words with cchSrc elements. If cchSrc is set to a negative number, lpCharType is an array of words with lpSrcStr + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves character type information for the characters in the specified Unicode source string. For each character in the string, the function sets one or more bits in the corresponding 16-bit element of the output array. Each bit identifies a given character type, for example, letter, digit, or neither.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Stringapiset.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "For an overview of the use of the string functions, see Strings. The values of the lpSrcStr and lpCharType parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER. The Locale parameter used by the corresponding GetStringTypeA function is not used by this function. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a GetStringType* function through the use of the #define UNICODE switch. An application can circumvent this limitation by using GetStringTypeEx, which is the recommended function. Supported Character Types The character type bits are divided into several levels. The information for one level can be retrieved by a single call to this function. Each level is limited to 16 bits of information so that the other mapping functions, which are limited to 16 bits of representation per character, can also return character type information. Ctype 1 These types support ANSI C and POSIX (LC_CTYPE) character typing functions. A bitwise-OR of these values is retrieved in the array in the output buffer when dwInfoType is set to CT_CTYPE1. For DBCS locales, the type attributes apply to both narrow characters and wide characters. The Japanese hiragana and katakana characters, and the kanji ideograph characters all have the C1_ALPHA attribute.   The following character types are either constant or computable from basic types and do not need to be supported by this function.   Ctype 2 These types support proper layout of Unicode text. For DBCS locales, the character type applies to both narrow and wide characters. The direction attributes are assigned so that the bidirectional layout algorithm standardized by Unicode produces accurate results. These types are mutually exclusive. For more information about the use of these attributes, see The Unicode Standard.   Ctype 3 These types are intended to be placeholders for extensions to the POSIX types required for general text processing or for the standard C library functions. A bitwise-OR of these values is retrieved when dwInfoType is set to CT_CTYPE3. For DBCS locales, the Ctype 3 attributes apply to both narrow characters and wide characters. The Japanese hiragana and katakana characters, and the kanji ideograph characters all have the C3_ALPHA attribute.   C3_HIGHSURROGATE and C3_LOWSURROGATE are listed only for completeness, and should never be provided to this function. They are relevant only for Unicode. Starting with Windows 8: GetStringTypeW  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "GetStringTypeW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoType",
        "description": "Flags specifying the character type information to retrieve. This parameter can have the following values. The character types are divided into different levels as described in the Remarks section.  FlagMeaning  CT_CTYPE1                    Retrieve character type information.   CT_CTYPE2   Retrieve bidirectional layout information.   CT_CTYPE3   Retrieve text processing information."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpSrcStr",
        "description": "Pointer to the Unicode string for which to retrieve the character types. The string is assumed to be null-terminated if cchSrc is set to any negative value."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSrc",
        "description": "Size, in characters, of the string indicated by lpSrcStr. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination."
      },
      {
        "in_out": "_Out_",
        "type": "LPWORD",
        "name": "lpCharType",
        "description": "Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If cchSrc is not a negative number, lpCharType should be an array of words with cchSrc elements. If cchSrc is set to a negative number, lpCharType is an array of words with lpSrcStr + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the language identifier for the system locale.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the language identifier for the system locale. This is  the language used when displaying text in programs that do not support Unicode. It is set by the Administrator under Control Panel > Clock, Language, and Region > Change date, time, or number formats > Administrative tab. For more information on language identifiers, see Language Identifier Constants and Strings. ",
    "remarks": "",
    "return_type": "LANGID",
    "category": "National Language Support (NLS)",
    "name": "GetSystemDefaultLangID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the locale identifier for the system locale.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the locale identifier for the system default locale, identified by LOCALE_SYSTEM_DEFAULT. ",
    "remarks": "This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "GetSystemDefaultLCID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the system default locale name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a value greater than 0 that indicates the length of the locale name, including the terminating null character, if successful. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. An example showing the use of this function can be found in NLS: Name-based APIs Sample. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetSystemDefaultLocaleName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a buffer in which this function retrieves the locale name."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchLocaleName",
        "description": "Size, in characters, of the output buffer indicated by lpLocaleName. The maximum possible character length of a locale name (including a terminating null character) is the value of LOCALE_NAME_MAX_LENGTH. This is the recommended size."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the locale identifier of the current locale for the calling thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the locale identifier of the locale associated with the current thread. Windows Vista: This function can return the identifier of a custom locale. If the current thread locale is a custom locale, the function returns LOCALE_CUSTOM_DEFAULT. If the current thread locale is a supplemental custom locale, the function can return LOCALE_CUSTOM_UNSPECIFIED. All supplemental locales share this locale identifier. ",
    "remarks": "When an application process launches, it uses the Standards and Formats variable for the locale. For more information, see NLS Terminology. When a new thread is created in a process, it inherits the locale of the creating thread. This locale can be either the default Standards and Formats locale or a different locale set for the creating thread in a call to SetThreadLocale. GetThreadLocale and SetThreadLocale can be used to modify the locale of the new thread. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "GetThreadLocale",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Datetimeapi.h (include Windows.h)",
    "return_value": "Returns the number of TCHAR values retrieved in the buffer indicated by lpTimeStr. If the cchTime parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for GetTimeFormatEx. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). Starting with Windows 8: GetTimeFormat  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetTimeFormat",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying time format options. For detailed definitions see the dwFlags parameter of GetTimeFormatEx."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SYSTEMTIME*",
        "name": "lpTime",
        "description": "Pointer to a SYSTEMTIME structure that contains the time information to format. The application can set this parameter to NULL if the function is to use the current local system time."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpFormat",
        "description": "Pointer to a format picture to use to format the time string. If the application sets this parameter to NULL, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to NULL, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpTimeStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted time string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchTime",
        "description": "Size, in TCHAR values, for the time string buffer indicated by lpTimeStr. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the lpTimeStr parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Formats time as a time string for a locale specified by name. The function formats either a specified time or the local system time.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Datetimeapi.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in the buffer indicated by lpTimeStr. If the cchTime parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "If a time marker exists and the TIME_NOTIMEMARKER flag is not set, the function localizes the time marker based on the specified locale identifier. Examples of time markers are \"AM\" and \"PM\" for English (United States). The time values in the structure indicated by lpTime must be valid. The function checks each of the time values to determine that it is within the appropriate range of values. If any of the time values are outside the correct range, the function fails, and sets the last error to ERROR_INVALID_PARAMETER. The function ignores the date members of the SYSTEMTIME structure. These include: wYear, wMonth, wDayOfWeek, and wDay. If TIME_NOMINUTESORSECONDS or TIME_NOSECONDS is specified, the function removes the separators preceding the minutes and/or seconds members. If TIME_NOTIMEMARKER is specified, the function removes the separators preceding and following the time marker. If TIME_FORCE24HOURFORMAT is specified, the function displays any existing time marker, unless the TIME_NOTIMEMARKER flag is also set. The function does not include milliseconds as part of the formatted time string. The function returns no errors for a bad format string, but just forms the best possible time string. If more than two hour, minute, second, or time marker format pictures are passed in, the function defaults to two. For example, the only time marker pictures that are valid are \"t\" and \"tt\". If \"ttt\" is passed in, the function assumes \"tt\". To obtain the time format without performing any actual formatting, the application should use the GetLocaleInfoEx function, specifying LOCALE_STIMEFORMAT. The application can use the following elements to construct a format picture string. If spaces are used to separate the elements in the format string, these spaces appear in the same location in the output string. The letters must be in uppercase or lowercase as shown, for example, \"ss\", not \"SS\". Characters in the format string that are enclosed in single quotation marks appear in the same location and unchanged in the output string.  For example, to get the time string the application should use the picture string This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. Beginning in Windows 8: GetTimeFormatEx  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetTimeFormatEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying time format options. The application can specify a combination of the following values and LOCALE_USE_CP_ACP or LOCALE_NOUSEROVERRIDE. Caution  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.    ValueMeaning  TIME_NOMINUTESORSECONDS   Do not use minutes or seconds.   TIME_NOSECONDS   Do not use seconds.   TIME_NOTIMEMARKER   Do not use a time marker.   TIME_FORCE24HOURFORMAT   Always use a 24-hour time format."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SYSTEMTIME*",
        "name": "lpTime",
        "description": "Pointer to a SYSTEMTIME structure that contains the time information to format. The application can set this parameter to NULL if the function is to use the current local system time."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpFormat",
        "description": "Pointer to a format picture to use to format the time string. If the application sets this parameter to NULL, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to NULL, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpTimeStr",
        "description": "Pointer to a buffer in which this function retrieves the formatted time string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchTime",
        "description": "Size, in characters, for the time string buffer indicated by lpTimeStr. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the lpTimeStr parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the language identifier of the Region Format setting for the current user.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the language identifier for the current user as set under Control Panel > Clock, Language, and Region > Change date, time, or number formats > Formats tab > Format dropdown. For more information on language identifiers, see Language Identifier Constants and Strings. ",
    "remarks": "The return value is not necessarily the same as that returned by GetSystemDefaultLangID, even for a single-user computer. ",
    "return_type": "LANGID",
    "category": "National Language Support (NLS)",
    "name": "GetUserDefaultLangID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Returns the locale identifier for the user default locale.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the locale identifier for the user default locale, represented as LOCALE_USER_DEFAULT. If the user default locale is a custom locale, this function always returns LOCALE_CUSTOM_DEFAULT, regardless of the custom locale that is selected. For example, whether the user locale is Hawaiian (US), haw-US, or Fijiian (Fiji), fj-FJ, the function returns the same value. ",
    "remarks": "This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "GetUserDefaultLCID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the user default locale name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the size of the buffer containing the locale name, including the terminating null character, if successful. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "GetUserDefaultLocaleName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a buffer in which this function retrieves the locale name."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchLocaleName",
        "description": "Size, in characters, of the buffer indicated by lpLocaleName. The maximum possible length of a locale name, including a terminating null character, is LOCALE_NAME_MAX_LENGTH. This is the recommended size to supply in this parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves information about the geographical location of the user. For more information, see Table of Geographical Locations.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the geographical location identifier of the user if SetUserGeoID has been called before to set the identifier. If no geographical location identifier has been set for the user, the function returns GEOID_NOT_AVAILABLE. ",
    "remarks": "",
    "return_type": "GEOID",
    "category": "National Language Support (NLS)",
    "name": "GetUserGeoID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GEOCLASS",
        "name": "GeoClass",
        "description": "Geographical location class to return. Possible values are defined by the SYSGEOCLASS enumeration."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Converts an internationalized domain name (IDN) or another internationalized label to a Unicode (wide character) representation of the ASCII string that represents the name in the Punycode transfer encoding syntax.",
    "library": "Normaliz.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in lpASCIICharStr if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated. If the function succeeds and the value of cchASCIIChar is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The function does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should supply -1 for the cchUnicodeChar parameter or explicitly count the terminating null character for the input string. Note that the function always fails if the input string contains control characters (U+0001 through U+0020) or the \"delete\" character (U+007F). Since the character U+0000 can appear only as a terminating null character, the function always fails if U+0000 appears anywhere else in the input string. Windows XP, Windows Server 2003:  The required header file and DLL are part of the  \"Microsoft Internationalized Domain Name (IDN) Mitigation APIs\" download, available at the MSDN Download Center. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "IdnToAscii",
    "is_callback": 0,
    "dll": "Normaliz.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying conversion options. The following table lists the possible values.  ValueMeaning  IDN_ALLOW_UNASSIGNED   Note  An application can set this value if it is just using a query string for normal lookup, as in a compare operation. However, the application should not set this value for a stored string, which is a string being prepared for storage.   Allow unassigned code points to be included in the input string. The default is to not allow unassigned code points, and fail with an extended error code of ERROR_INVALID_NAME. This flag allows the function to process characters that are not currently legal in IDNs, but might be legal in later versions of the IDNA standard. If your application encodes unassigned code points as Punycode, the resulting domain names should be illegal. Security can be compromised if a later version of IDNA makes these names legal or if an application filters out the illegal characters to try to create a legal domain name. For more information, see Handling Internationalized Domain Names (IDNs).   IDN_USE_STD3_ASCII_RULES   Filter out ASCII characters that are not allowed in STD3 names. The only ASCII characters allowed in the input Unicode string are letters, digits, and the hyphen-minus. The string cannot begin or end with the hyphen-minus. The function fails if the input Unicode string contains ASCII characters, such as \"[\", \"]\", or \"/\", that cannot occur in domain names.Note  Some local networks can allow some of these characters in computer names.   The function fails if the input Unicode string contains control characters (U+0001 through U+0020) or the \"delete\" character (U+007F). In either case, this flag has no effect on the non-ASCII characters that are allowed in the Unicode string.   IDN_EMAIL_ADDRESS   Starting with Windows 8: Enable EAI algorithmic fallback for the local parts of email addresses (such as <local>@microsoft.com). The default is for this function to fail when an email address has an invalid address or syntax. An application can set this flag to enable Email Address Internationalization (EAI) to return a discoverable fallback address, if possible. For more information, see the IETF Email Address Internationalization (eai) Charter.   IDN_RAW_PUNYCODE   Starting with Windows 8: Disable the validation and mapping of Punycode."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpUnicodeCharStr",
        "description": "Pointer to a Unicode string representing an IDN or another internationalized label."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchUnicodeChar",
        "description": "Count of characters in the input Unicode string indicated by lpUnicodeCharStr."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpASCIICharStr",
        "description": "Pointer to a buffer that receives a Unicode string consisting only of characters in the ASCII character set. On return from this function, the buffer contains the ASCII string equivalent of the string provided in lpUnicodeCharStr under Punycode. Alternatively, the function can retrieve NULL for this parameter, if cchASCIIChar is set to 0. In this case, the function returns the size required for this buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchASCIIChar",
        "description": "Size of the buffer indicated by lpASCIICharStr. The application can set the parameter to 0 to retrieve NULL in lpASCIICharStr."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Converts an internationalized domain name (IDN) or another internationalized label to the NamePrep form specified by Network Working Group RFC 3491, but does not perform the additional conversion to Punycode. For more information and links to related draft standards, see Handling Internationalized Domain Names (IDNs).",
    "library": "Normaliz.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in lpNameprepCharStr if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated. If the function succeeds and the value of cchNameprepChar is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for IdnToAscii. NLS: Internationalized Domain Name (IDN) Conversion Sample demonstrates the use of this function. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "IdnToNameprepUnicode",
    "is_callback": 0,
    "dll": "Normaliz.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying conversion options. For detailed definitions, see the dwFlags parameter of IdnToAscii."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpUnicodeCharStr",
        "description": "Pointer to a Unicode string representing an IDN or another internationalized label."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchUnicodeChar",
        "description": "Count of Unicode characters in the input Unicode string indicated by lpUnicodeCharStr."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpNameprepCharStr",
        "description": "Pointer to a buffer that receives a version of the input Unicode string converted through NamePrep processing. Alternatively, the function can retrieve NULL for this parameter, if cchNameprepChar is set to 0. In this case, the function returns the size required for this buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchNameprepChar",
        "description": "Size, in characters, of the buffer indicated by lpNameprepCharStr. The application can set the size to 0 to retrieve NULL in lpNameprepCharStr and have the function return the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Converts the Punycode form of an internationalized domain name (IDN) or another internationalized label to the normal Unicode UTF-16 encoding syntax.",
    "library": "Normaliz.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters retrieved in lpUnicodeCharStr if successful. The retrieved string is null-terminated only if the input string is null-terminated. If the function succeeds and the value of cchUnicodeChar is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for IdnToAscii. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "IdnToUnicode",
    "is_callback": 0,
    "dll": "Normaliz.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying conversion options. For detailed definitions, see the dwFlags parameter of IdnToAscii."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpASCIICharStr",
        "description": "Pointer to a string representing the Punycode encoding of an IDN or another internationalized label. This string must consist only of ASCII characters, and can include Punycode-encoded Unicode. The function decodes Punycode values to their UTF-16 values."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchASCIIChar",
        "description": "Count of characters in the input string indicated by lpASCIICharStr."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpUnicodeCharStr",
        "description": "Pointer to a buffer that receives a normal Unicode UTF-16 encoding equivalent to the Punycode value of the input string. Alternatively, the function can retrieve NULL for this parameter, if cchUnicodeChar set to 0. In this case, the function returns the size required for this buffer."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchUnicodeChar",
        "description": "Size, in characters, of the buffer indicated by lpUnicodeCharStr. The application can set the size to 0 to retrieve NULL in lpUnicodeCharStr and have the function return the required buffer size."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Deprecated. Identifies whether the specified year is a leap year within the given era for the specific calendar.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns TRUE if the specified year is a leap year, or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with that module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsCalendarLeapYear",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "calId",
        "description": "The calendar identifier to use for checking leap year."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "year",
        "description": "The year to check."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "era",
        "description": "The era to check."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Determines if each character in a string has a defined result for a specified NLS capability.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if successful, only if the input string is valid, or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function differentiates between defined and undefined strings, so that an application such as Active Directory can reject strings with undefined code points. Use of the function can minimize the necessity for the application to re-index its database. For more information, see Handling Sorting in Your Applications. For example, if Function is set to COMPARE_STRING, IsNLSDefinedString checks for undefined code points, surrogate pairs that represent undefined Unicode characters, or ill-formed surrogate pairs. If the function returns TRUE for a particular string, the results, as retrieved by CompareString or LCMapString with LCMAP_SORTKEY set, are guaranteed to be identical as long as the corresponding NLS version does not change. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsNLSDefinedString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NLS_FUNCTION",
        "name": "Function",
        "description": "NLS capability to query. This value must be COMPARE_STRING. See the SYSNLS_FUNCTION enumeration."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags defining the function. Must be 0."
      },
      {
        "in_out": "_In_",
        "type": "LPNLSVERSIONINFO",
        "name": "lpVersionInformation",
        "description": "Pointer to an NLSVERSIONINFO structure containing version information. Typically, the information is obtained by calling GetNLSVersion. The application sets this parameter to NULL if the function is to use the current version."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString",
        "description": "Pointer to the UTF-16 string to examine."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "cchStr",
        "description": "Number of UTF-16 characters in the string indicated by lpString. This count can include a terminating null character. If the terminating null character is included in the character count, it does not affect the checking behavior because the terminating null character is always defined. The application should supply -1 to indicate that the string is null-terminated. In this case, the function itself calculates the string length."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Verifies that a string is normalized according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if the input string is already normalized to the appropriate form, or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: If you need to reliably determine FALSE from an error condition, then it must call SetLastError(ERROR_SUCCESS). ",
    "remarks": "Windows XP, Windows Server 2003: The required header file and DLL are part of the  \"Microsoft Internationalized Domain Name (IDN) Mitigation APIs\" download, available at the MSDN Download Center. An example showing the use of this function can be found in NLS: Unicode Normalization Sample. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsNormalizedString",
    "is_callback": 0,
    "dll": "Normaliz.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NORM_FORM",
        "name": "NormForm",
        "description": "Normalization form to use. NORM_FORM specifies the standard Unicode normalization forms."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpString",
        "description": "Pointer to the string to test."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cwLength",
        "description": "Length, in characters, of the input string, including a null terminating character. If this value is -1, the function assumes the string to be null-terminated and calculates the length automatically."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Determines if a specified code page is valid.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if the code page is valid, or 0 if the code page is invalid. ",
    "remarks": "A code page is considered valid only if it is installed on the operating system. Unicode is preferred. Starting with Windows Vista, all code pages that can be installed are loaded by default. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsValidCodePage",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "CodePage",
        "description": "Code page identifier for the code page to check."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Determines if a language group is installed or supported on the operating system. For more information, see NLS Terminology.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if the language group identifier passes the specified validity test, or FALSE otherwise. ",
    "remarks": "If the LGRPID_INSTALLED flag is specified and this function returns TRUE, the language group identifier is both supported and installed on the operating system. If the LGRPID_SUPPORTED flag is specified and this function returns TRUE, the language group identifier is supported in the release, but not necessarily installed on the operating system. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsValidLanguageGroup",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LGRPID",
        "name": "LanguageGroup",
        "description": "Identifier of language group to validate. This parameter can have one of the following values:  LGRPID_ARABIC  LGRPID_ARMENIAN  LGRPID_BALTIC LGRPID_CENTRAL_EUROPE  LGRPID_CYRILLIC  LGRPID_GEORGIAN  LGRPID_GREEK  LGRPID_HEBREW  LGRPID_INDIC LGRPID_JAPANESE  LGRPID_KOREAN  LGRPID_SIMPLIFIED_CHINESE  LGRPID_TRADITIONAL_CHINESE  LGRPID_THAI LGRPID_TURKIC  LGRPID_TURKISH  LGRPID_VIETNAMESE LGRPID_WESTERN_EUROPE"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying the validity test to apply to the language group identifier. This parameter can be set to one of the following values.  ValueMeaning  LGRPID_INSTALLED   Determine if language group identifier is both supported and installed.   LGRPID_SUPPORTED   Determine if language group identifier is supported."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[IsValidLocale is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use IsValidLocaleName to determine the validity of a supplemental locale.]",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if the locale identifier passes the specified validity test. The function returns 0 if it does not succeed. ",
    "remarks": "If the LCID_INSTALLED flag is specified and this function returns a nonzero value, the locale identifier is both supported and installed on the operating system. Having an identifier installed implies that the full level of language support is available for the indicated locale. Full support includes code page translation tables, keyboard layouts, fonts, and sorting and locale data. If LCID_SUPPORTED is specified and this function returns 0, the locale identifier is supported in the release, but not necessarily installed on the operating system. This function can handle data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsValidLocale",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier of the locale to validate. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT Windows Server 2003, Windows XP and Windows 2000:  This locale identifier is not supported.   LOCALE_CUSTOM_UI_DEFAULT Windows Server 2003, Windows XP and Windows 2000:  This locale identifier is not supported.   LOCALE_CUSTOM_UNSPECIFIED Windows Server 2003, Windows XP and Windows 2000:  This locale identifier is not supported.   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag specifying the validity test to apply to the locale identifier. This parameter can have one of the following values.  ValueMeaning  LCID_INSTALLED   Determine if the locale identifier is both supported and installed.   LCID_SUPPORTED   Determine if the locale identifier is supported.    0x39   Do not use. Instead, use LCID_INSTALLED. Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP and Windows 2000:  Setting dwFlags to 0x39 is a special case that can behave like LCID_INSTALLED for some locales on some versions of Windows."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines if the specified locale name is valid for a locale that is installed or supported on the operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if the locale name is valid, or returns 0 for an invalid name. ",
    "remarks": "On Windows Vista and later, all supported locales should be installed on all operating systems. This function can handle the name of a custom locale. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. An example showing the use of this function can be found in NLS: Name-based APIs Sample. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "IsValidLocaleName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to the locale name to validate."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Determines if the NLS version is valid for a given NLS function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if the NLS version is valid, or zero if the version is invalid. ",
    "remarks": "Initialize the NLSVERSIONINFOEX structure by calling GetNLSVersionEx. See the Remarks for GetNLSVersionEx for a discussion on how the members of NLSVERSIONINFOEX can be used to determine if a sort version has changed and you need to reindex data. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "DWORD",
    "category": "National Language Support (NLS)",
    "name": "IsValidNLSVersion",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NLS_FUNCTION",
        "name": "function",
        "description": "The NLS capability to query. This value must be COMPARE_STRING. See the SYSNLS_FUNCTION enumeration."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "LPNLSVERSIONINFOEX",
        "name": "lpVersionInformation",
        "description": "Pointer to an NLSVERSIONINFOEX structure. The application must initialize the dwNLSVersionInfoSize member to  sizeof(NLSVERSIONINFOEX)."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Converts a locale identifier to a locale name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the count of characters, including the terminating null character, in the locale name if successful. If the function succeeds and the value of cchName is 0, the return value is the required size, in characters (including nulls), for the locale name buffer. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "LCIDToLocaleName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier to translate. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   Windows Vista: The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpName",
        "description": "Pointer to a buffer in which this function retrieves the locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchName",
        "description": "Size, in characters, of the locale name buffer. The maximum possible length of a locale name, including a terminating null character, is LOCALE_NAME_MAX_LENGTH. This is the recommended size to supply for this parameter. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the locale name buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Before Windows 7: Reserved; should always be 0. Starting with Windows 7: Can be set to LOCALE_ALLOW_NEUTRAL_NAMES to allow the return of a neutral name."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters or bytes in the translated string or sort key, including a terminating null character, if successful. If the function succeeds and the value of cchDest is 0, the return value is the size of the buffer required to hold the translated string or sort key, including a terminating null character. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "See Remarks for LCMapStringEx. The ANSI version of LCMapString maps strings to and from Unicode based on the default Windows (ANSI) code page associated with the specified locale. When the ANSI version of this function is used with a Unicode-only locale, the function can succeed because the operating system uses the CP_ACP value, representing the system default Windows ANSI code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "LCMapString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMapFlags",
        "description": "Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the dwMapFlags parameter of LCMapStringEx."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSrcStr",
        "description": "Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSrc",
        "description": "Size, in characters, of the source string indicated by lpSrcStr. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if LCMapString is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by lpDestStr. The application cannot set this parameter to 0."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpDestStr",
        "description": "Pointer to a buffer in which this function retrieves the mapped string or a sort key. When the application uses this function to generate a sort key, the destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed. Note  The destination string can be the same as the source string only if LCMAP_UPPERCASE or LCMAP_LOWERCASE is set. Otherwise, the strings cannot be the same. If they are, the function fails.   Note  Upon failure of the function, the destination buffer might contain either partial results or no results at all. In this case, it is recommended for your application to consider any results invalid."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDest",
        "description": "Size, in characters, of the destination string indicated by lpDestStr. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in cchSrc, cchDest must also include space for a terminating null character. If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator. The application can set cchDest to 0. In this case, the function does not use the lpDestStr parameter and returns the required buffer size for the mapped string or sort key."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "For a locale specified by name, maps an input character string to another using a specified transformation, or generates a sort key for the input string.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the number of characters or bytes in the translated string or sort key, including a terminating null character, if successful. If the function succeeds and the value of cchDest is 0, the return value is the size of the buffer required to hold the translated string or sort key, including a terminating null character if the input was null terminated. This function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The application can use LCMapString or LCMapStringEx to generate a sort key. To do this, the application specifies  LCMAP_SORTKEY for the dwMapFlags parameter. For more information, see Handling Sorting in Your Applications. Another way for your application to use LCMapString or LCMapStringEx is in mapping strings. In this case, the application does not specify LCMAP_SORTKEY for the dwMapFlags parameter, but supplies some other combination of flags. For more information, see Handling Sorting in Your Applications. Beginning in Windows Vista: This function can handle data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see Using Persistent Locale Data. Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "LCMapStringEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMapFlags",
        "description": "Flag specifying the type of transformation to use during string mapping or the type of sort key to generate. This parameter can have the following values.  FlagMeaning  LCMAP_BYTEREV                    Use byte reversal. For example, if the application passes in 0x3450 0x4822, the result is 0x5034 0x2248.   LCMAP_FULLWIDTH   Use Unicode (wide) characters where applicable. This flag and LCMAP_HALFWIDTH are mutually exclusive.   LCMAP_HALFWIDTH   Use narrow characters where applicable. This flag and LCMAP_FULLWIDTH are mutually exclusive.   LCMAP_HIRAGANA   Map all katakana characters to hiragana. This flag and LCMAP_KATAKANA are mutually exclusive.   LCMAP_KATAKANA   Map all hiragana characters to katakana. This flag and LCMAP_HIRAGANA are mutually exclusive.   LCMAP_LINGUISTIC_CASING                    Use linguistic rules for casing, instead of file system rules (default). This flag is valid with LCMAP_LOWERCASE or LCMAP_UPPERCASE only.   LCMAP_LOWERCASE   For locales and scripts capable of handling uppercase and lowercase, map all characters to lowercase.   LCMAP_SIMPLIFIED_CHINESE   Map traditional Chinese characters to simplified Chinese characters. This flag and LCMAP_TRADITIONAL_CHINESE are mutually exclusive.   LCMAP_SORTKEY   Produce a normalized sort key. If the LCMAP_SORTKEY flag is not specified, the function performs string mapping. For details of sort key generation and string mapping, see the Remarks section.   LCMAP_TITLECASE   Windows 7: Map all characters to title case, in which the first letter of each major word is capitalized.   LCMAP_TRADITIONAL_CHINESE   Map simplified Chinese characters to traditional Chinese characters. This flag and LCMAP_SIMPLIFIED_CHINESE are mutually exclusive.   LCMAP_UPPERCASE   For locales and scripts capable of handling uppercase and lowercase, map all characters to uppercase.     The following flags can be used alone, with one another, or with the LCMAP_SORTKEY and/or LCMAP_BYTEREV flags. However, they cannot be combined with the other flags listed above.  FlagMeaning  NORM_IGNORENONSPACE   Ignore nonspacing characters. For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC. Note  NORM_IGNORENONSPACE ignores any secondary distinction, whether it is a diacritic or not. Scripts for Korean, Japanese, Chinese, and Indic languages, among others, use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC causes the function to ignore only actual diacritics, instead of ignoring the second sorting weight.     NORM_IGNORESYMBOLS   Ignore symbols and punctuation.     The flags listed below are used only with the LCMAP_SORTKEY flag.  FlagMeaning  LINGUISTIC_IGNORECASE   Ignore case, as linguistically appropriate.   LINGUISTIC_IGNOREDIACRITIC   Ignore nonspacing characters, as linguistically appropriate. Note  This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.     NORM_IGNORECASE   Ignore case. For many scripts (notably Latin scripts), NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE. Note  NORM_IGNORECASE ignores any tertiary distinction, whether it is actually linguistic case or not. For example, in Arabic and Indic scripts, this flag distinguishes alternate forms of a character, but the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE causes the function to ignore only actual linguistic casing, instead of ignoring the third sorting weight.   Note  For double-byte character set (DBCS) locales, NORM_IGNORECASE has an effect on all Unicode characters as well as narrow (one-byte) characters, including Greek and Cyrillic characters.     NORM_IGNOREKANATYPE   Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.   NORM_IGNOREWIDTH   Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.   NORM_LINGUISTIC_CASING   Use linguistic rules for casing, instead of file system rules (default).   SORT_DIGITSASNUMBERS   Windows 7: Treat digits as numbers during sorting, for example, sort \"2\" before \"10\".   SORT_STRINGSORT   Treat punctuation the same as symbols."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpSrcStr",
        "description": "Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchSrc",
        "description": "Size, in characters, of the source string indicated by lpSrcStr. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself. The application can set this parameter to any negative value to specify that the source string is null-terminated. In this case, if LCMapStringEx is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by lpDestStr. The application cannot set this parameter to 0."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpDestStr",
        "description": "Pointer to a buffer in which this function retrieves the mapped string or sort key. If the application specifies LCMAP_SORTKEY, the function stores a sort key in the buffer as an opaque array of byte values that can include embedded 0 bytes. Note  If the function fails, the destination buffer might contain either partial results or no results at all. In this case, it is recommended for your application to consider any results invalid."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchDest",
        "description": "Size, in characters, of the buffer indicated by lpDestStr. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in cchSrc, cchDest must also include space for a terminating null character. If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator. The application can set cchDest to 0. In this case, the function does not use the lpDestStr parameter and returns the required buffer size for the mapped string or sort key."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPNLSVERSIONINFO",
        "name": "lpVersionInformation",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpReserved",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPARAM",
        "name": "sortHandle",
        "description": "Reserved; must be 0."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "Unsupported. LoadStringByReference may be altered or unavailable. Instead, use SHLoadIndirectString.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "A BOOL datatype. ",
    "remarks": "LoadStringByReference is not supported and may be altered or unavailable in the future. Instead, use SHLoadIndirectString. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "LoadStringByReference",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Reserved."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "Language",
        "description": "The language."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "SourceString",
        "description": "The source string reference."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PWSTR",
        "name": "Buffer",
        "description": "The buffer to receive the string."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "cchBuffer",
        "description": "The size of Buffer, in characters."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "Directory",
        "description": "The directory path to SourceString."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "pcchBufferOut",
        "description": "The number of characters written to Buffer."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins with the '@' symbol).",
    "library": "Shlwapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: HRESULT If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "An indirect string can be provided in several forms, each of which has its own interpretation: If the string is not an indirect string, then the string is directly copied without change to pszOutBuf and the function returns S_OK. ",
    "return_type": "HRESULT",
    "category": "National Language Support (NLS)",
    "name": "SHLoadIndirectString",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.5 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszSource",
        "description": "Type: PCWSTR A pointer to a buffer that contains the indirect string from which the resource will be retrieved. This string should begin with the '@' symbol and use one of the forms discussed in the Remarks section. This function will successfully accept a string that does not begin with an '@' symbol, but the string will be simply passed unchanged to pszOutBuf."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "pszOutBuf",
        "description": "Type: PWSTR A pointer to a buffer that, when this function returns successfully, receives the text resource. Both pszOutBuf and pszSource can point to the same buffer, in which case the original string will be overwritten."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cchOutBuf",
        "description": "Type: UINT The size of the buffer pointed to by pszOutBuf, in characters."
      },
      {
        "in_out": "_Reserved_",
        "type": "void**",
        "name": "ppvReserved",
        "description": "Type: void** Not used; set to NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Converts a locale name to a locale identifier.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the locale identifier corresponding to the locale name if successful. If the supplied locale name corresponds to a custom locale that is the user default, this function returns LOCALE_CUSTOM_DEFAULT. If the locale name corresponds to a custom locale that is not the user default, the function returns LOCALE_CUSTOM_UNSPECIFIED. If the locale provided is a transient locale or a CLDR (Unicode Common Locale Data Repository) locale, then the LCID returned is 0x1000. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Beginning in Windows 8: If your app passes language tags to this function from the Windows.Globalization namespace, it must first convert the tags by calling ResolveLocaleName. ",
    "return_type": "LCID",
    "category": "National Language Support (NLS)",
    "name": "LocaleNameToLCID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpName",
        "description": "Pointer to a null-terminated string representing a locale name, or one of the following predefined values.    LOCALE_NAME_INVARIANT   LOCALE_NAME_SYSTEM_DEFAULT   LOCALE_NAME_USER_DEFAULT"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Prior to Windows 7:                   Reserved; should always be 0.                Beginning in Windows 7: Can be set to LOCALE_ALLOW_NEUTRAL_NAMES to allow the return of a neutral LCID."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Normalizes characters of a text string according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the length of the normalized string in the destination buffer. If cwDstLength is set to 0, the function returns the estimated buffer length required to do the actual conversion. If the string in the input buffer is null-terminated or if cwSrcLength is -1, the string written to the destination buffer is null-terminated and the returned string length includes the terminating null character. The function returns a value that is less than or equal to 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules, as described in Using Unicode Normalization to Represent Strings. The Win32 and the .NET Framework currently support normalization forms C, D, KC, and KD, as defined in Unicode Standard Annex #15: Unicode Normalization Forms. Normalized strings are typically evaluated with an ordinal comparison. The following code demonstrates the use of the buffer length estimate: Windows XP, Windows Server 2003: The required header file and DLL are part of the  \"Microsoft Internationalized Domain Name (IDN) Mitigation APIs\" download, available at the MSDN Download Center. An example showing the use of this function can be found in NLS: Unicode Normalization Sample. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "NormalizeString",
    "is_callback": 0,
    "dll": "Normaliz.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NORM_FORM",
        "name": "NormForm",
        "description": "Normalization form to use. NORM_FORM specifies the standard Unicode normalization forms."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpSrcString",
        "description": "Pointer to the non-normalized source string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cwSrcLength",
        "description": "Length, in characters, of the buffer containing the source string. The application can set this parameter to -1 if the function should assume the string to be null-terminated and calculate the length automatically."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpDstString",
        "description": "Pointer to a buffer in which the function retrieves the destination string. Alternatively, this parameter contains NULL if cwDstLength is set to 0. Note  The function does not null-terminate the string if the input string length is explicitly specified without a terminating null character. To null-terminate the output string, the application should specify -1 or explicitly count the terminating null character for the input string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cwDstLength",
        "description": "Length, in characters, of the buffer containing the destination string. Alternatively, the application can set this parameter to 0 to request the function to return the required size for the destination buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Unsupported. NotifyUILanguageChange may be altered or unavailable.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "A BOOL datatype. ",
    "remarks": "NotifyUILanguageChange is not supported and may be altered or unavailable in the future. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "NotifyUILanguageChange",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "pcwstrNewLanguage",
        "description": "The new language."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "pcwstrPreviousLanguage",
        "description": "The previous language."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "Reserved."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PDWORD",
        "name": "pdwStatusRtrn",
        "description": "A pointer to a DWORD return status."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Finds a possible locale name match for the supplied name.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns the size of the buffer containing the locale name, including the terminating null character, if successful. The function returns 0 if it does not succeed. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "The retrieved locale name indicates a specific locale, including language and country/region, even if the input language is neutral. For example, an input of \"en\" for English (United States) causes the function to retrieve \"en-US\". This function can retrieve data from custom locales. Data is not guaranteed to be the same from computer to computer or between runs of an application, nor does the return of a valid locale guarantee that it will be valid on another computer. If your application must persist or transmit data, see Using Persistent Locale Data. Beginning in Windows 8: Language tags obtained from the Windows.Globalization namespace must be converted by  ResolveLocaleName before they can be used with any National Language Support functions. ",
    "return_type": "int",
    "category": "National Language Support (NLS)",
    "name": "ResolveLocaleName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCWSTR",
        "name": "lpNameToResolve",
        "description": "Pointer to a name to resolve, for example, \"en-FJ\" for English (Fiji)."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPWSTR",
        "name": "lpLocaleName",
        "description": "Pointer to a buffer in which this function retrieves the locale name that is the match for the input name. For example, the match for the name \"en-FJ\" is \"en-US\" for English (United States). Note  If the function fails, the state of the output buffer is not guaranteed to be accurate. In this case, the application should check the return value and error status set by the function to determine the correct course of action."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchLocaleName",
        "description": "Size, in characters, of the buffer indicated by lpLocaleName. The maximum possible length of a locale name, including a terminating null character, is the value of LOCALE_NAME_MAX_LENGTH. This is the recommended size to supply in this parameter."
      }
    ],
    "min_client": "Windows 7 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Determines if a locale specified by name is installed or supported on the operating system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. ",
    "remarks": "This function is similar to IsValidLocaleName. The only difference is that if LOCALE_ALLOW_NEUTRAL is set, RtlIsValidLocaleName returns TRUE for a name that corresponds to a neutral locale (such as \"en\"), while IsValidLocaleName returns TRUE only for a specific locale (such as \"en-US\"). Neutral locales are used as part of the resource loading strategy in Windows Vista and later. Only a small class of highly specialized applications use RtlIsValidLocaleName and set LOCALE_ALLOW_NEUTRAL, because neutral locales are of very limited use. None of the functions described in Calling the \"Locale Name\" Functions accept neutral locales as inputs. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "RtlIsValidLocaleName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "LocaleName",
        "description": "Locale name to validate. This parameter can specify the name of a custom locale."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Flags indicating if neutral locales are considered valid. Currently the only defined flag is LOCALE_ALLOW_NEUTRAL. The default value is that they are not."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets an item of locale information for a calendar. For more information, see Date and Calendar.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function only affects the user override portion of the calendar settings. It does not set the system defaults. Calendar information is always passed as a null-terminated Unicode string in the Unicode version of this function, and as a null-terminated ANSI string in the ANSI version. No integers are allowed by this function. Any numeric values must be specified as either Unicode or ANSI text. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). CAL_ITWODIGITYEARMAX can be used with any calendar, even if the calendar is not supported for the specified locale. To avoid complications, the application should call EnumCalendarInfo to ensure that the calendar is supported for the locale of interest. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "SetCalendarInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "CALID",
        "name": "Calendar",
        "description": "Calendar identifier for the calendar for which to set information."
      },
      {
        "in_out": "_In_",
        "type": "CALTYPE",
        "name": "CalType",
        "description": "Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.  CAL_USE_CP_ACP CAL_ITWODIGITYEARMAX  The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in Calendar Type Information."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpCalData",
        "description": "Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Sets an item of information in the user override portion of the current locale. This function does not set the system defaults.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function writes to the registry, where it sets values that are associated with a particular user instead of a particular application. These registry values affect the behavior of other applications run by the user. As a rule, an application should call this function only when the user has explicitly requested the changes. The registry settings should not be changed for the convenience of a single application. For the LCType parameter, the application should set LOCALE_USE_CP_ACP to use the operating system ANSI code page instead of the locale code page for string translation. When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). As of Windows Vista, the LOCALE_SDATE and LOCALE_STIME constants are obsolete. Do not use these constants. Use LOCALE_SSHORTDATE and LOCALE_STIMEFORMAT instead. A custom locale might not have a single, uniform separator character within the date or time format: for example, a format such as \"12/31, 2006\" or \"03:56'23\" might be valid. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "SetLocaleInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "For the ANSI version of the function, the locale identifier of the locale with the code page used when interpreting the lpLCData information. For the Unicode version, this parameter is ignored. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT   The following custom locale identifiers are also supported.   LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED"
      },
      {
        "in_out": "_In_",
        "type": "LCTYPE",
        "name": "LCType",
        "description": "Type of locale information to set. For valid constants see \"Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo\" section of Locale Information Constants. The application can specify only one value per call, but it can use the binary OR operator to combine LOCALE_USE_CP_ACP with any other constant."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpLCData",
        "description": "Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the current locale of the calling thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "The function should return an LCID on success. This is the LCID of the previous thread locale. ",
    "remarks": "When a thread is created, it uses the user locale. This value is returned by GetUserDefaultLCID. The user locale can be modified for future processes and thread creation using the regional and language options portion of the Control Panel. The thread locale can also be changed using SetThreadLocale. SetThreadLocale affects the selection of resources with a LANGUAGE statement. The statement affects such functions as CreateDialog, DialogBox, LoadMenu, LoadString, and FindResource. It sets the code page implied by CP_THREAD_ACP, but does not affect FindResourceEx. For more information, see Code Page Identifiers. Windows Vista and later:  Do not use SetThreadLocale to select a user interface language. The resource loader selects the resource that is defined in the .rc file with a LANGUAGE statement, or the application can use FindResourceEx. Additionally, the application can use SetThreadUILanguage. Windows 2000, Windows XP: Do not use SetThreadLocale to select a user interface language. To select the resource that is defined in the .rc file with a LANGUAGE statement, the application must use the FindResourceEx function. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "SetThreadLocale",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LCID",
        "name": "Locale",
        "description": "Locale identifier that specifies the locale. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.    LOCALE_CUSTOM_DEFAULT   LOCALE_CUSTOM_UI_DEFAULT   LOCALE_CUSTOM_UNSPECIFIED   LOCALE_INVARIANT   LOCALE_SYSTEM_DEFAULT   LOCALE_USER_DEFAULT"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the geographical location identifier for the user. This identifier should have one of the values described in Table of Geographical Locations.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE otherwise. Windows XP, Windows Server 2003: This function does not supply extended error information. Thus it is not appropriate for an application to call GetLastError after this function. If the application does call GetLastError, it can return a value set by some previously called function. If this function does not succeed, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function writes to the registry the geographical location for a particular user instead of a particular application. This action affects the behavior of other applications run by the user. As a rule, the application should call this function only when the user has explicitly requested changes, but not for purely application-specific reasons. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "SetUserGeoID",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GEOID",
        "name": "GeoId",
        "description": "Identifier for the geographical location of the user."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deprecated. Gets the day of the week that corresponds to a specified day and populates the DayOfWeek member in the specified CALDATETIME structure with that value.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "",
    "return_value": "Returns TRUE if successful or FALSE otherwise. To get extended error information, the application can call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function does not have an associated header file or library file. The application can call LoadLibrary with the DLL name (Kernel32.dll) to obtain a module handle. It can then call GetProcAddress with that module handle and the name of this function to get the function address. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "UpdateCalendarDayOfWeek",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPCALDATETIME",
        "name": "lpCalDateTime",
        "description": "Pointer to the CALDATETIME structure containing the date for which to set the day of the week."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Compares two enumerated lists of scripts.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winnls.h (include Windows.h)",
    "return_value": "Returns TRUE if the test list is non-empty and all items in the list are also included in the locale list. The function still returns TRUE if the locale list contains more scripts than the test list, but all the test list scripts must be contained in the locale list. If VS_ALLOW_LATIN is specified in dwFlags, the function behaves as if \"Latn;\" is always in the locale list. In all other cases, the function returns FALSE. This return can indicate that the test list contains an item that is not in the locale list, or it can indicate an error. To distinguish between these two cases, the application should call GetLastError, which can return one of the following error codes: ",
    "remarks": "This function compares strings, such as \"Latn;Cyrl;\", that consist of a series of 4-character script names, with each script name followed by a semicolon. It also has a special case to account for the fact that the Latin script is often used in languages and locales for which it is not native. This function is useful as part of a strategy to mitigate security issues related to internationalized domain names (IDNs). The following are examples of the return of this function and a subsequent call to GetLastError in various scenarios. The last two examples illustrate, respectively, a case in which the test list lacks a terminating semicolon (malformed string) and a case in which the test list is empty.  * Results are the same whether VS_ALLOW_LATIN is passed in the dwFlags parameter or no flags are supplied. NLS: Internationalized Domain Name (IDN) Mitigation Sample demonstrates the use of this function. ",
    "return_type": "BOOL",
    "category": "National Language Support (NLS)",
    "name": "VerifyScripts",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags specifying script verification options.  ValueMeaning  VS_ALLOW_LATIN   Allow \"Latn\" (Latin script) in the test list even if it is not in the locale list."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpLocaleScripts",
        "description": "Pointer to the locale list, the enumerated list of scripts for a given locale. This list is typically populated by calling GetLocaleInfoEx with LCType set to LOCALE_SSCRIPTS."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchLocaleScripts",
        "description": "Size, in characters, of the string indicated by lpLocaleScripts. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpTestScripts",
        "description": "Pointer to the test list, a second enumerated list of scripts. This list is typically populated by calling GetStringScripts."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchTestScripts",
        "description": "Size, in characters, of the string indicated by lpTestScripts. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  }
]