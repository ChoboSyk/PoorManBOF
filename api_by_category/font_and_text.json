[
  {
    "n_arguments": 4,
    "description": "The AddFontMemResourceEx function adds the font resource from a memory image to the system.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the handle to the font added. This handle uniquely identifies the fonts that were installed on the system. If the function fails, the return value is zero. No extended error information is available. ",
    "remarks": "This function allows an application to get a font that is embedded in a document or a webpage. A font that is added by AddFontMemResourceEx is always private to the process that made the call and is not enumerable. A memory image can contain more than one font. When this function succeeds, pcFonts is a pointer to a DWORD whose value is the number of fonts added to the system as a result of this call. For example, this number could be 2 for the vertical and horizontal faces of an Asian font. When the function succeeds, the caller of this function can free the memory pointed to by pbFont because the system has made its own copy of the memory. To remove the fonts that were installed, call RemoveFontMemResourceEx. However, when the process goes away, the system will unload the fonts even if the process did not call RemoveFontMemResource. ",
    "return_type": "HANDLE",
    "category": "Font and Text",
    "name": "AddFontMemResourceEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pbFont",
        "description": "A pointer to a font resource."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbFont",
        "description": "The number of bytes in the font resource that is pointed to by pbFont."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pdv",
        "description": "Reserved. Must be 0."
      },
      {
        "in_out": "_In_",
        "type": "DWORD*",
        "name": "pcFonts",
        "description": "A pointer to a variable that specifies the number of fonts installed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The AddFontResource function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the number of fonts added. If the function fails, the return value is zero. No extended error information is available. ",
    "remarks": "Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a WM_FONTCHANGE message to all top-level windows in the operating system. The application should send this message by calling the SendMessage function and setting the hwnd parameter to HWND_BROADCAST. When an application no longer needs a font resource that it loaded by calling the AddFontResource function, it must remove that resource by calling the RemoveFontResource function. This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry. A font listed in the registry and installed to a location other than the %windir%\\fonts\\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling RemoveFontResource, removed from the font registry (HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "AddFontResource",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFilename",
        "description": "A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.  File ExtensionMeaning  .fon   Font resource file.   .fnt   Raw bitmap font file.   .ttf   Raw TrueType file.   .ttc   East Asian Windows: TrueType font collection.   .fot   TrueType resource file.   .otf   PostScript OpenType font.   .mmm   Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.   .pfb   Type 1 font bits file. It is used with a .pfm file.   .pfm   Type 1 font metrics file. It is used with a .pfb file.     To add a font whose information comes from several resource files, have lpszFileName point to a string with the file names separated by a \"|\" --for example, abcxxxxx.pfm | abcxxxxx.pfb."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The AddFontResourceEx function adds the font resource from the specified file to the system. Fonts added with the AddFontResourceEx function can be marked as private and not enumerable.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the number of fonts added. If the function fails, the return value is zero. No extended error information is available. ",
    "remarks": "This function allows a process to use fonts without allowing other processes access to the fonts. When an application no longer needs a font resource it loaded by calling the AddFontResourceEx function, it must remove the resource by calling the RemoveFontResourceEx function. This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry. A font listed in the registry and installed to a location other than the %windir%\\fonts\\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling RemoveFontResource, removed from the font registry (HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "AddFontResourceEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFilename",
        "description": "A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.  File ExtensionMeaning  .fon   Font resource file.   .fnt   Raw bitmap font file.   .ttf   Raw TrueType file.   .ttc   East Asian Windows: TrueType font collection.   .fot   TrueType resource file.   .otf   PostScript OpenType font.   .mmm   multiple master Type1 font resource file. It must be used with .pfm and .pfb files.   .pfb   Type 1 font bits file. It is used with a .pfm file.   .pfm   Type 1 font metrics file. It is used with a .pfb file.     To add a font whose information comes from several resource files, point lpszFileName to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fl",
        "description": "The characteristics of the font to be added to the system. This parameter can be one of the following values.  ValueMeaning  FR_PRIVATE   Specifies that only the process that called the AddFontResourceEx function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the AddFontResourceEx function.   FR_NOT_ENUM   Specifies that no process, including the process that called the AddFontResourceEx function, can enumerate this font."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pdv",
        "description": "Reserved. Must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 14,
    "description": "The CreateFont function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a logical font. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the font, call the DeleteObject function to delete it. To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user. To get the appropriate font on different language versions of the OS, call EnumFontFamiliesEx with the desired font characteristics in the LOGFONT structure, then retrieve the appropriate typeface name and create the font using CreateFont or CreateFontIndirect. The font mapper for CreateFont,CreateFontIndirect, and CreateFontIndirectEx recognizes both the English and the localized typeface name, regardless of locale. The following situations do not support ClearType antialiasing: For another example, see \"Setting Fonts for Menu-Item Text Strings\" in Using Menus. ",
    "return_type": "HFONT",
    "category": "Font and Text",
    "name": "CreateFont",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in nHeight in the following manner.  ValueMeaning   > 0   The font mapper transforms this value into device units and matches it against the cell height of the available fonts.    0   The font mapper uses a default height value when it searches for a match.    < 0   The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.     For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size. This mapping occurs when the font is used for the first time. For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:   C++     Copy       nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);"
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nEscapement",
        "description": "The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text. When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters. When the graphics mode is set to GM_COMPATIBLE, nEscapement specifies both the escapement and orientation. You should set nEscapement and nOrientation to the same value."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nOrientation",
        "description": "The angle, in tenths of degrees, between each character's base line and the x-axis of the device."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnWeight",
        "description": "The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used. The following values are defined for convenience.  WeightValue  FW_DONTCARE   0   FW_THIN   100   FW_EXTRALIGHT   200   FW_ULTRALIGHT   200   FW_LIGHT   300   FW_NORMAL   400   FW_REGULAR   400   FW_MEDIUM   500   FW_SEMIBOLD   600   FW_DEMIBOLD   600   FW_BOLD   700   FW_EXTRABOLD   800   FW_ULTRABOLD   800   FW_HEAVY   900   FW_BLACK   900"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwItalic",
        "description": "Specifies an italic font if set to TRUE."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwUnderline",
        "description": "Specifies an underlined font if set to TRUE."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwStrikeOut",
        "description": "A strikeout font if set to TRUE."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwCharSet",
        "description": "The character set. The following values are predefined:  ANSI_CHARSET BALTIC_CHARSET CHINESEBIG5_CHARSET DEFAULT_CHARSET EASTEUROPE_CHARSET GB2312_CHARSET GREEK_CHARSET HANGUL_CHARSET MAC_CHARSET OEM_CHARSET RUSSIAN_CHARSET SHIFTJIS_CHARSET SYMBOL_CHARSET TURKISH_CHARSET VIETNAMESE_CHARSET               Korean language edition of Windows:               JOHAB_CHARSET               Middle East language edition of Windows:               ARABIC_CHARSET HEBREW_CHARSET               Thai language edition of Windows:               THAI_CHARSET  The OEM_CHARSET value specifies a character set that is operating-system dependent. DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET. Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font. To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the lpszFace parameter, make sure that the fdwCharSet value matches the character set of the typeface specified in lpszFace."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwOutputPrecision",
        "description": "The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.  ValueMeaning  OUT_CHARACTER_PRECIS   Not used.   OUT_DEFAULT_PRECIS   The default font mapper behavior.   OUT_DEVICE_PRECIS   Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.   OUT_OUTLINE_PRECIS   This value instructs the font mapper to choose from TrueType and other outline-based fonts.   OUT_PS_ONLY_PRECIS   Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.   OUT_RASTER_PRECIS   Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.   OUT_STRING_PRECIS   This value is not used by the font mapper, but it is returned when raster fonts are enumerated.   OUT_STROKE_PRECIS   This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.   OUT_TT_ONLY_PRECIS   Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.   OUT_TT_PRECIS   Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.     Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwClipPrecision",
        "description": "The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.  ValueMeaning  CLIP_CHARACTER_PRECIS   Not used.   CLIP_DEFAULT_PRECIS   Specifies default clipping behavior.   CLIP_DFA_DISABLE   Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.   CLIP_EMBEDDED   You must specify this flag to use an embedded read-only font.   CLIP_LH_ANGLES   When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed. If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system. For more information about the orientation of coordinate systems, see the description of the nOrientation parameter   CLIP_MASK   Not used.   CLIP_DFA_OVERRIDE   Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.   CLIP_STROKE_PRECIS   Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated. For compatibility, this value is always returned when enumerating fonts.   CLIP_TT_ALWAYS   Not used."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwQuality",
        "description": "The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.  ValueMeaning  ANTIALIASED_QUALITY   Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.   CLEARTYPE_QUALITY   If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.   DEFAULT_QUALITY   Appearance of the font does not matter.   DRAFT_QUALITY   Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.   NONANTIALIASED_QUALITY   Font is never antialiased, that is, font smoothing is not done.   PROOF_QUALITY   Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.     If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is TRUE. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of \"Smooth edges of screen fonts\".)"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwPitchAndFamily",
        "description": "The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:  DEFAULT_PITCH FIXED_PITCH VARIABLE_PITCH  The four high-order bits specify the font family and can be one of the following values.  ValueMeaning  FF_DECORATIVE   Novelty fonts. Old English is an example.   FF_DONTCARE   Use default font.   FF_MODERN   Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.   FF_ROMAN   Fonts with variable stroke width and with serifs. MS Serif is an example.   FF_SCRIPT   Fonts designed to look like handwriting. Script and Cursive are examples.   FF_SWISS   Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.     An application can specify a value for the fdwPitchAndFamily parameter by using the Boolean OR operator to join a pitch constant with a family constant. Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFace",
        "description": "A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The EnumFontFamilies function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks. If lpszFace is NULL or empty string, GDI uses the first font that matches the other specified attributes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateFontIndirect function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a logical font. If the function fails, the return value is NULL. ",
    "remarks": "The CreateFontIndirect function creates a logical font with the characteristics specified in the LOGFONT structure. When this font is selected by using the SelectObject function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible. To get the appropriate font on different language versions of the OS, call EnumFontFamiliesEx with the desired font characteristics in the LOGFONT structure, retrieve the appropriate typeface name, and create the font using CreateFont or CreateFontIndirect. When you no longer need the font, call the DeleteObject function to delete it. The fonts for many East Asian languages have two typeface names: an English name and a localized name. CreateFont and CreateFontIndirect take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that EnumFonts, EnumFontFamilies, and EnumFontFamiliesEx return the English typeface name if the system locale does not match the language of the font. The font mapper for CreateFont, CreateFontIndirect, and CreateFontIndirectEx recognizes both the English and the localized typeface name, regardless of locale. For an example, see Creating a Logical Font. ",
    "return_type": "HFONT",
    "category": "Font and Text",
    "name": "CreateFontIndirect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LOGFONT*",
        "name": "lplf",
        "description": "A pointer to a LOGFONT structure that defines the characteristics of the logical font."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateFontIndirectEx function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the new ENUMLOGFONTEXDV structure. If the function fails, the return value is zero. No extended error information is available. ",
    "remarks": "The CreateFontIndirectEx function creates a logical font with the characteristics specified in the ENUMLOGFONTEXDV structure. When this font is selected by using the SelectObject function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible. When you no longer need the font, call the DeleteObject function to delete it. The font mapper for CreateFont, CreateFontIndirect, and CreateFontIndirectEx recognizes both the English and the localized typeface name, regardless of locale. ",
    "return_type": "HFONT",
    "category": "Font and Text",
    "name": "CreateFontIndirectEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const ENUMLOGFONTEXDV*",
        "name": "penumlfex",
        "description": "Pointer to an ENUMLOGFONTEXDV structure that defines the characteristics of a multiple master font. Note, this function ignores the elfDesignVector member in ENUMLOGFONTEXDV."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lpRect->top to the bottom of the drawn text If the function fails, the return value is zero. ",
    "remarks": "The DrawText function uses the device context's selected font, text color, and background color to draw the text. Unless the DT_NOCLIP format is used, DrawText clips the text so that it does not appear outside the specified rectangle. Note that text with significant overhang may be clipped, for example, an initial \"W\" in the text string or text that is in italics. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified. If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font. The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "DrawText",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_Inout_",
        "type": "LPCTSTR",
        "name": "lpchText",
        "description": "A pointer to the string that specifies the text to be drawn. If the nCount parameter is -1, the string must be null-terminated. If uFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically."
      },
      {
        "in_out": "_Inout_",
        "type": "LPRECT",
        "name": "lpRect",
        "description": "A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFormat",
        "description": "The method of formatting the text. This parameter can be one or more of the following values.  ValueMeaning  DT_BOTTOM   Justifies the text to the bottom of the rectangle. This value is used only with the DT_SINGLELINE value.   DT_CALCRECT   Determines the width and height of the rectangle. If there are multiple lines of text, DrawText uses the width of the rectangle pointed to by the lpRect parameter and extends the base of the rectangle to bound the last line of text. If the largest word is wider than the rectangle, the width is expanded. If the text is less than the width of the rectangle, the width is reduced. If there is only one line of text, DrawText modifies the right side of the rectangle so that it bounds the last character in the line. In either case, DrawText returns the height of the formatted text but does not draw the text.   DT_CENTER   Centers text horizontally in the rectangle.   DT_EDITCONTROL   Duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average character width is calculated in the same manner as for an edit control, and the function does not display a partially visible last line.   DT_END_ELLIPSIS   For displayed text, if the end of a string does not fit in the rectangle, it is truncated and ellipses are added. If a word that is not at the end of the string goes beyond the limits of the rectangle, it is truncated without ellipses. The string is not modified unless the DT_MODIFYSTRING flag is specified. Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.   DT_EXPANDTABS   Expands tab characters. The default number of characters per tab is eight. The DT_WORD_ELLIPSIS, DT_PATH_ELLIPSIS, and DT_END_ELLIPSIS values cannot be used with the DT_EXPANDTABS value.   DT_EXTERNALLEADING   Includes the font external leading in line height. Normally, external leading is not included in the height of a line of text.   DT_HIDEPREFIX                     Ignores the ampersand (&) prefix character in the text. The letter that follows will not be underlined, but other mnemonic-prefix characters are still processed. Example: input string: \"A&bc&&d\" normal: \"Abc&d\" DT_HIDEPREFIX: \"Abc&d\" Compare with DT_NOPREFIX and DT_PREFIXONLY.   DT_INTERNAL   Uses the system font to calculate text metrics.   DT_LEFT   Aligns text to the left.   DT_MODIFYSTRING   Modifies the specified string to match the displayed text. This value has no effect unless DT_END_ELLIPSIS or DT_PATH_ELLIPSIS is specified.   DT_NOCLIP   Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.   DT_NOFULLWIDTHCHARBREAK                     Prevents a line break at a DBCS (double-wide character string), so that the line breaking rule is equivalent to SBCS strings. For example, this can be used in Korean windows, for more readability of icon labels. This value has no effect unless DT_WORDBREAK is specified.   DT_NOPREFIX   Turns off processing of prefix characters. Normally, DrawText interprets the mnemonic-prefix character & as a directive to underscore the character that follows, and the mnemonic-prefix characters && as a directive to print a single &. By specifying DT_NOPREFIX, this processing is turned off. For example, Example: input string: \"A&bc&&d\" normal: \"Abc&d\" DT_NOPREFIX: \"A&bc&&d\" Compare with DT_HIDEPREFIX and DT_PREFIXONLY.   DT_PATH_ELLIPSIS   For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified rectangle. If the string contains backslash (\\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the last backslash. The string is not modified unless the DT_MODIFYSTRING flag is specified. Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.   DT_PREFIXONLY                     Draws only an underline at the position of the character following the ampersand (&) prefix character. Does not draw any other characters in the string. For example, Example: input string: \"A&bc&&d\"n normal: \"Abc&d\" DT_PREFIXONLY: \" _    \" Compare with DT_HIDEPREFIX and DT_NOPREFIX.   DT_RIGHT   Aligns text to the right.   DT_RTLREADING   Layout in right-to-left reading order for bidirectional text when the font selected into the hdc is a Hebrew or Arabic font. The default reading order for all text is left-to-right.   DT_SINGLELINE   Displays text on a single line only. Carriage returns and line feeds do not break the line.   DT_TABSTOP   Sets tab stops. Bits 15-8 (high-order byte of the low-order word) of the uFormat parameter specify the number of characters for each tab. The default number of characters per tab is eight. The DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP, and DT_NOPREFIX values cannot be used with the DT_TABSTOP value.   DT_TOP   Justifies the text to the top of the rectangle.   DT_VCENTER   Centers text vertically. This value is used only with the DT_SINGLELINE value.   DT_WORDBREAK   Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the lpRect parameter. A carriage return-line feed sequence also breaks the line. If this is not specified, output is on one line.   DT_WORD_ELLIPSIS   Truncates any word that does not fit in the rectangle and adds ellipses. Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The DrawTextEx function draws formatted text in the specified rectangle.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lprc->top to the bottom of the drawn text If the function fails, the return value is zero. ",
    "remarks": "The DrawTextEx function supports only fonts whose escapement and orientation are both zero. The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "DrawTextEx",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context in which to draw."
      },
      {
        "in_out": "_Inout_",
        "type": "LPTSTR",
        "name": "lpchText",
        "description": "A pointer to the string that contains the text to draw. If the cchText parameter is -1, the string must be null-terminated. If dwDTFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchText",
        "description": "The length of the string pointed to by lpchText. If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawTextEx computes the character count automatically."
      },
      {
        "in_out": "_Inout_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "A pointer to a RECT structure that contains the rectangle, in logical coordinates, in which the text is to be formatted."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "dwDTFormat",
        "description": "The formatting options. This parameter can be one or more of the following values.  ValueMeaning  DT_BOTTOM   Justifies the text to the bottom of the rectangle. This value is used only with the DT_SINGLELINE value.   DT_CALCRECT   Determines the width and height of the rectangle. If there are multiple lines of text, DrawTextEx uses the width of the rectangle pointed to by the lprc parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, DrawTextEx modifies the right side of the rectangle so that it bounds the last character in the line. In either case, DrawTextEx returns the height of the formatted text, but does not draw the text.   DT_CENTER   Centers text horizontally in the rectangle.   DT_EDITCONTROL   Duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average character width is calculated in the same manner as for an edit control, and the function does not display a partially visible last line.   DT_END_ELLIPSIS   For displayed text, replaces the end of a string with ellipses so that the result fits in the specified rectangle. Any word (not at the end of the string) that goes beyond the limits of the rectangle is truncated without ellipses. The string is not modified unless the DT_MODIFYSTRING flag is specified. Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.   DT_EXPANDTABS   Expands tab characters. The default number of characters per tab is eight.   DT_EXTERNALLEADING   Includes the font external leading in line height. Normally, external leading is not included in the height of a line of text.   DT_HIDEPREFIX                     Ignores the ampersand (&) prefix character in the text. The letter that follows will not be underlined, but other mnemonic-prefix characters are still processed. Example: input string: \"A&bc&&d\" normal: \"Abc&d\" DT_HIDEPREFIX: \"Abc&d\" Compare with DT_NOPREFIX and DT_PREFIXONLY.   DT_INTERNAL   Uses the system font to calculate text metrics.   DT_LEFT   Aligns text to the left.   DT_MODIFYSTRING   Modifies the specified string to match the displayed text. This value has no effect unless DT_END_ELLIPSIS or DT_PATH_ELLIPSIS is specified.   DT_NOCLIP   Draws without clipping. DrawTextEx is somewhat faster when DT_NOCLIP is used.   DT_NOFULLWIDTHCHARBREAK                     Prevents a line break at a DBCS (double-wide character string), so that the line-breaking rule is equivalent to SBCS strings. For example, this can be used in Korean windows, for more readability of icon labels. This value has no effect unless DT_WORDBREAK is specified.   DT_NOPREFIX   Turns off processing of prefix characters. Normally, DrawTextEx interprets the ampersand (&) mnemonic-prefix character as a directive to underscore the character that follows, and the double-ampersand (&&) mnemonic-prefix characters as a directive to print a single ampersand. By specifying DT_NOPREFIX, this processing is turned off. Compare with DT_HIDEPREFIX and DT_PREFIXONLY   DT_PATH_ELLIPSIS   For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified rectangle. If the string contains backslash (\\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the last backslash. The string is not modified unless the DT_MODIFYSTRING flag is specified. Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.   DT_PREFIXONLY                     Draws only an underline at the position of the character following the ampersand (&) prefix character. Does not draw any character in the string. Example: input string: \"A&bc&&d\" normal: \"Abc&d\" PREFIXONLY: \" _   \" Compare with DT_NOPREFIX and DT_HIDEPREFIX.   DT_RIGHT   Aligns text to the right.   DT_RTLREADING   Layout in right-to-left reading order for bidirectional text when the font selected into the hdc is a Hebrew or Arabic font. The default reading order for all text is left-to-right.   DT_SINGLELINE   Displays text on a single line only. Carriage returns and line feeds do not break the line.   DT_TABSTOP   Sets tab stops. The DRAWTEXTPARAMS structure pointed to by the lpDTParams parameter specifies the number of average character widths per tab stop.   DT_TOP   Justifies the text to the top of the rectangle.   DT_VCENTER   Centers text vertically. This value is used only with the DT_SINGLELINE value.   DT_WORDBREAK   Breaks words. Lines are automatically broken between words if a word extends past the edge of the rectangle specified by the lprc parameter. A carriage return-line feed sequence also breaks the line.   DT_WORD_ELLIPSIS   Truncates any word that does not fit in the rectangle and adds ellipses. Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS."
      },
      {
        "in_out": "_In_",
        "type": "LPDRAWTEXTPARAMS",
        "name": "lpDTParams",
        "description": "A pointer to a DRAWTEXTPARAMS structure that specifies additional formatting options. This parameter can be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EnumFontFamExProc function is an application defined callback function used with the EnumFontFamiliesEx function. It is used to process the fonts. It is called once for each enumerated font. The FONTENUMPROC type defines a pointer to this callback function. EnumFontFamExProc is a placeholder for the application defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value must be a nonzero value to continue enumeration; to stop enumeration, the return value must be zero. ",
    "remarks": "An application must register this callback function by passing its address to the EnumFontFamiliesEx function. When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system. Unlike the EnumFontFamProc callback function, EnumFontFamExProc receives extended information about a font. The ENUMLOGFONTEX structure includes the localized name of the script (character set) and the NEWTEXTMETRICEX structure includes a font-coverage signature. ",
    "return_type": "int CALLBACK",
    "category": "Font and Text",
    "name": "EnumFontFamExProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "const",
        "type": "LOGFONT*",
        "name": "lpelfe",
        "description": "A pointer to an LOGFONT structure that contains information about the logical attributes of the font.              To obtain additional information about the font, you can cast the result as an ENUMLOGFONTEX or ENUMLOGFONTEXDV structure."
      },
      {
        "in_out": "const",
        "type": "TEXTMETRIC*",
        "name": "lpntme",
        "description": "A pointer to a structure that contains information about the physical attributes of a font. The function uses the NEWTEXTMETRICEX structure for TrueType fonts; and the TEXTMETRIC structure for other fonts.               This can be an ENUMTEXTMETRIC structure."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "FontType",
        "description": "The type of the font. This parameter can be a combination of these values: DEVICE_FONTTYPERASTER_FONTTYPETRUETYPE_FONTTYPE"
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam",
        "description": "The application-defined data passed by the EnumFontFamiliesEx function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The EnumFontFamiliesEx function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the LOGFONT structure. EnumFontFamiliesEx enumerates fonts based on typeface name, character set, or both.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device. ",
    "remarks": "The EnumFontFamiliesEx function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the lfCharSet and lfFaceName members in the LOGFONT structure. As with EnumFontFamilies, EnumFontFamiliesEx enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for lfCharSet and lfFaceName.  The following code sample shows how these values are used. The callback functions for EnumFontFamilies and EnumFontFamiliesEx are very similar. The main difference is that the ENUMLOGFONTEX structure includes a script field. Note, based on the values of lfCharSet and lfFaceName, EnumFontFamiliesEx will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts. The fonts for many East Asian languages have two typeface names: an English name and a localized name. EnumFonts, EnumFontFamilies, and EnumFontFamiliesEx return the English typeface name if the system locale does not match the language of the font. When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "EnumFontFamiliesEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context from which to enumerate the fonts."
      },
      {
        "in_out": "_In_",
        "type": "LPLOGFONT",
        "name": "lpLogfont",
        "description": "A pointer to a LOGFONT structure that contains information about the fonts to enumerate. The function examines the following members.  MemberDescription lfCharSetIf set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set. lfFaceNameIf set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name. lfPitchAndFamilyMust be set to zero for all language versions of the operating system."
      },
      {
        "in_out": "_In_",
        "type": "FONTENUMPROC",
        "name": "lpEnumFontFamExProc",
        "description": "A pointer to the application defined callback function. For more information, see the EnumFontFamExProc function."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "An application defined value. The function passes this value to the callback function along with font information."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is not used and must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The ExtTextOut function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the string is drawn, the return value is nonzero. However, if the ANSI version of ExtTextOut is called with ETO_GLYPH_INDEX, the function returns TRUE even though the function does nothing. If the function fails, the return value is zero. ",
    "remarks": "The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the GetTextAlign function. The text-alignment settings are altered by calling the SetTextAlign function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.   If the lpDx parameter is NULL, the ExtTextOut function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the lpDx parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell. By default, the current position is not used or updated by this function. However, an application can call the SetTextAlign function with the fMode parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls ExtTextOut for a specified device context. When this flag is set, the system ignores the X and Y parameters on subsequent ExtTextOut calls. For the ANSI version of ExtTextOut, the lpDx array has the same number of INT values as there are bytes in lpString. For DBCS characters, you can apportion the dx in the lpDx entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of ExtTextOut, each Unicode glyph gets a single pdx entry. Note, the alpDx values from GetTextExtentExPoint are not the same as the lpDx values for ExtTextOut. To use the alpDx values in lpDx, you must first process them. For an example, see \"Setting Fonts for Menu-Item Text Strings\" in Using Menus. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "ExtTextOut",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "The x-coordinate, in logical coordinates, of the reference point used to position the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "The y-coordinate, in logical coordinates, of the reference point used to position the string."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuOptions",
        "description": "Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.  ValueMeaning  ETO_CLIPPED   The text will be clipped to the rectangle.   ETO_GLYPH_INDEX   The lpString array refers to an array returned from GetCharacterPlacement and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts. For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.   ETO_IGNORELANGUAGE   Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.   ETO_NUMERICSLATIN   To display numbers, use European digits.   ETO_NUMERICSLOCAL   To display numbers, use digits appropriate to the locale.   ETO_OPAQUE   The current background color should be used to fill the rectangle.   ETO_PDY   When this is set, the array pointed to by lpDx contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.   ETO_RTLREADING   Middle East language edition of Windows: If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in SetTextAlign. This value is preserved for backward compatibility.     The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "A pointer to an optional RECT structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since cbCount specifies the length of the string."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbCount",
        "description": "The length of the string pointed to by lpString. This value may not exceed 8192."
      },
      {
        "in_out": "_In_",
        "type": "const INT*",
        "name": "lpDx",
        "description": "A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[i] logical units separate the origins of character cell i and character cell i + 1."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetAspectRatioFilterEx function retrieves the setting for the current aspect-ratio filter.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The aspect ratio is the ratio formed by the width and height of a pixel on a specified device. The system provides a special filter, the aspect-ratio filter, to select fonts that were designed for a particular device. An application can specify that the system should only retrieve fonts matching the specified aspect ratio by calling the SetMapperFlags function. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetAspectRatioFilterEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpAspectRatio",
        "description": "Pointer to a SIZE structure that receives the current aspect-ratio filter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetCharABCWidths function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero If the function fails, the return value is zero. ",
    "remarks": "The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C. When the GetCharABCWidths function retrieves negative A or C widths for a character, that character includes underhangs or overhangs. To convert the ABC widths to font design units, an application should use the value stored in the otmEMSquare member of a OUTLINETEXTMETRIC structure. This value can be retrieved by calling the GetOutlineTextMetrics function. The ABC widths of the default character are used for characters outside the range of the currently selected font. To retrieve the widths of characters in non-TrueType fonts, applications should use the GetCharWidth function. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharABCWidths",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFirstChar",
        "description": "The first character in the group of consecutive characters from the current font."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uLastChar",
        "description": "The last character in the group of consecutive characters from the current font."
      },
      {
        "in_out": "_Out_",
        "type": "LPABC",
        "name": "lpabc",
        "description": "A pointer to an array of ABC structures that receives the character widths, in logical units. This array must contain at least as many ABC structures as there are characters in the range specified by the uFirstChar and uLastChar parameters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetCharABCWidthsFloat function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Unlike the GetCharABCWidths function that returns widths only for TrueType fonts, the GetCharABCWidthsFloat function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format. If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C. The ABC spaces are measured along the character base line of the selected font. The ABC widths of the default character are used for characters outside the range of the currently selected font. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharABCWidthsFloat",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iFirstChar",
        "description": "Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iLastChar",
        "description": "Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character."
      },
      {
        "in_out": "_Out_",
        "type": "LPABCFLOAT",
        "name": "lpABCF",
        "description": "Pointer to an array of ABCFLOAT structures that receives the character widths, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The GetCharABCWidthsI function retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C. When the GetCharABCWidthsI function retrieves negative A or C widths for a character, that character includes underhangs or overhangs. To convert the ABC widths to font design units, an application should use the value stored in the otmEMSquare member of a OUTLINETEXTMETRIC structure. This value can be retrieved by calling the GetOutlineTextMetrics function. The ABC widths of the default character are used for characters outside the range of the currently selected font. To retrieve the widths of glyph indices in non-TrueType fonts, applications should use the GetCharWidthI function. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharABCWidthsI",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "giFirst",
        "description": "The first glyph index in the group of consecutive glyph indices from the current font. This parameter is only used if the pgi parameter is NULL."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cgi",
        "description": "The number of glyph indices."
      },
      {
        "in_out": "_In_",
        "type": "LPWORD",
        "name": "pgi",
        "description": "A pointer to an array that contains glyph indices. If this parameter is NULL, the giFirst parameter is used instead. The cgi parameter specifies the number of glyph indices in this array."
      },
      {
        "in_out": "_Out_",
        "type": "LPABC",
        "name": "lpabc",
        "description": "A pointer to an array of ABC structures that receives the character widths, in logical units. This array must contain at least as many ABC structures as there are glyph indices specified by the cgi parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The GetCharacterPlacement function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the dwFlags parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified GCP_RESULTS structure or to one or more arrays specified by the structure.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word. If the function fails, the return value is zero. ",
    "remarks": "GetCharacterPlacement ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the ExtTextOut function and in place of the GetTextExtentPoint32 function (and occasionally in place of the GetCharWidth32 and GetCharABCWidths functions). Using GetCharacterPlacement to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the ExtTextOut function renders text by using GetCharacterPlacement to retrieve the intercharacter spacing and index arrays before calling ExtTextOut. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the lpGlyphs output array is used in the call to ExtTextOut, the ETO_GLYPH_INDEX flag must be set. GetCharacterPlacement checks the lpOrder, lpDX, lpCaretPos, lpOutString, and lpGlyphs members of the GCP_RESULTS structure and fills the corresponding arrays if these members are not set to NULL. If GetCharacterPlacement cannot fill an array, it sets the corresponding member to NULL. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the lpDX and/or lpCaretPos members must have valid addresses. Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected. When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error. ExtTextOut expects an lpDX entry for each byte of a DBCS string, whereas GetCharacterPlacement assigns an lpDX entry for each glyph. To correct this mismatch when using this combination of functions, either use GetGlyphIndices or expand the lpDX array with zero-width entries for the corresponding second byte of a DBCS byte pair. If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call GetCharacterPlacement for glyph indexes and the lpDX array. Then use the lpDX array to do the extent calculation using the advance width of each character, where nMaxFit is the number of characters whose glyph indexes advance width is less than the width of the leading character. ",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetCharacterPlacement",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to the character string to process. The string does not need to be zero-terminated, since nCount specifies the length of the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The length of the string pointed to by lpString."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nMaxExtent",
        "description": "The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the dwFlags parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop."
      },
      {
        "in_out": "_Inout_",
        "type": "LPGCP_RESULTS",
        "name": "lpResults",
        "description": "A pointer to a GCP_RESULTS structure that receives the results of the function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.  ValueMeaning  GCP_CLASSIN   Specifies that the lpClass array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if GetFontLanguageInfo returned the GCP_REORDER flag.   GCP_DIACRITIC   Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them. Use GetFontLanguageInfo to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to GetCharacterPlacement, depending on the needs of your application.   GCP_DISPLAYZWG   For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the lpGlyphs and lpDx arrays. You can use the GCP_DISPLAYZWG flag to display these characters.   GCP_GLYPHSHAPE   Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if GetFontLanguageInfo returns this value for a string, this value must be used with GetCharacterPlacement.   GCP_JUSTIFY   Adjusts the extents in the lpDx array so that the string length is the same as nMaxExtent. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.   GCP_KASHIDA   Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by nMaxExtent. In the lpDx array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use GetFontLanguageInfo to determine whether the current font supports Kashidas. Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a GetTextMetrics call). Note that just because GetFontLanguageInfo returns the GCP_KASHIDA flag does not mean that it has to be used in the call to GetCharacterPlacement, just that the option is available.   GCP_LIGATE   Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English). Use GetFontLanguageInfo to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the lpGlyphs array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information. If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults->lpOutString in one call to GetCharacterPlacement is the input string of a second call). Note that just because GetFontLanguageInfo returns the GCP_LIGATE flag does not mean that it has to be used in the call to GetCharacterPlacement, just that the option is available.   GCP_MAXEXTENT   Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the nMaxExtent parameter.   GCP_NEUTRALOVERRIDE   Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.   GCP_NUMERICOVERRIDE   Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.   GCP_NUMERICSLATIN   Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use GetStringTypeEx to see if the language supports more than one number format.   GCP_NUMERICSLOCAL   Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use GetStringTypeEx to see if the language supports more than one number format.   GCP_REORDER   Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already. If this flag is set for Semitic languages and the lpClass array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set. If the GCP_REORDER value is not specified, the lpString parameter is taken to be visual ordered for languages where this is used, and the lpOutString and lpOrder fields are ignored. Use GetFontLanguageInfo to determine whether the current font supports reordering.   GCP_SYMSWAPOFF   Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.   GCP_USEKERNING   Use kerning pairs in the font (if any) when creating the widths arrays. Use GetFontLanguageInfo to determine whether the current font supports kerning pairs. Note that just because GetFontLanguageInfo returns the GCP_USEKERNING flag does not mean that it has to be used in the call to GetCharacterPlacement, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.     It is recommended that an application use the GetFontLanguageInfo function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, GetCharacterPlacement ignores the value. The GCP_NODIACRITICS value is no longer defined and should not be used."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetCharWidth32 function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "GetCharWidth32 cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use GetCharABCWidths. The range is inclusive; that is, the returned widths include the widths of the characters specified by the iFirstChar and iLastChar parameters. If a character does not exist in the current font, it is assigned the width of the default character. For an example, see \"Displaying Keyboard Input\" in Using Keyboard Input. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharWidth32",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iFirstChar",
        "description": "The first character in the group of consecutive characters."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iLastChar",
        "description": "The last character in the group of consecutive characters, which must not precede the specified first character."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the character widths, in logical coordinates."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetCharWidthFloat function retrieves the fractional widths of consecutive characters in a specified range from the current font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.) If the iFirstChar parameter specifies the letter a and the iLastChar parameter specifies the letter z, GetCharWidthFloat retrieves the widths of all lowercase characters. If a character does not exist in the current font, it is assigned the width of the default character. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharWidthFloat",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iFirstChar",
        "description": "The code point of the first character in the group of consecutive characters."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iLastChar",
        "description": "The code point of the last character in the group of consecutive characters."
      },
      {
        "in_out": "_Out_",
        "type": "PFLOAT",
        "name": "pxBuffer",
        "description": "A pointer to a buffer that receives the character widths, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The GetCharWidthI function retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The GetCharWidthI function processes a consecutive glyph indices if the pgi parameter is NULL with the giFirst parameter indicating the first glyph index to process and the cgi parameter indicating how many glyph indices to process. Otherwise the GetCharWidthI function processes the array of glyph indices pointed to by the pgi parameter with the cgi parameter indicating how many glyph indices to process. If a character does not exist in the current font, it is assigned the width of the default character. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharWidthI",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "giFirst",
        "description": "The first glyph index in the group of consecutive glyph indices."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cgi",
        "description": "The number of glyph indices."
      },
      {
        "in_out": "_In_",
        "type": "LPWORD",
        "name": "pgi",
        "description": "A pointer to an array of glyph indices. If this parameter is not NULL, it is used instead of the giFirst parameter."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the widths, in logical coordinates."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The GetFontData function retrieves font metric data for a TrueType font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of bytes returned. If the function fails, the return value is GDI_ERROR. ",
    "remarks": "This function is intended to be used to retrieve TrueType font information directly from the font file by font-manipulation applications. For information about embedding fonts see the Font Embedding Reference. An application can sometimes use the GetFontData function to save a TrueType font with a document. To do this, the application determines whether the font can be embedded by checking the otmfsType member of the OUTLINETEXTMETRIC structure. If bit 1 of otmfsType is set, embedding is not permitted for the font. If bit 1 is clear, the font can be embedded. If bit 2 is set, the embedding is read-only. If embedding is permitted, the application can retrieve the entire font file, specifying zero for the dwTable, dwOffset, and cbData parameters. If an application attempts to use this function to retrieve information for a non-TrueType font, an error occurs. ",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetFontData",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTable",
        "description": "The name of a font metric table from which the font data is to be retrieved. This parameter can identify one of the metric tables documented in the TrueType Font Files specification published by Microsoft Corporation. If this parameter is zero, the information is retrieved starting at the beginning of the file for TrueType font files or from the beginning of the data for the currently selected font for TrueType Collection files. To retrieve the data from the beginning of the file for TrueType Collection files specify 'ttcf' (0x66637474)."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOffset",
        "description": "The offset from the beginning of the font metric table to the location where the function should begin retrieving information. If this parameter is zero, the information is retrieved starting at the beginning of the table specified by the dwTable parameter. If this value is greater than or equal to the size of the table, an error occurs."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvBuffer",
        "description": "A pointer to a buffer that receives the font information. If this parameter is NULL, the function returns the size of the buffer required for the font data."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbData",
        "description": "The length, in bytes, of the information to be retrieved. If this parameter is zero, GetFontData returns the size of the data specified in the dwTable parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetFontLanguageInfo function returns information about the currently selected font for the specified display context. Applications typically use this information and the GetCharacterPlacement function to prepare a character string for display.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value identifies characteristics of the currently selected font. The function returns 0 if the font is \"normalized\" and can be treated as a simple Latin font; it returns GCP_ERROR if an error occurs. Otherwise, the function returns a combination of the following values.  The return value, when masked with FLI_MASK, can be passed directly to the GetCharacterPlacement function. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetFontLanguageInfo",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a display device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetFontUnicodeRanges function returns information about which Unicode characters are supported by a font. The information is returned as a GLYPHSET structure.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns number of bytes written to the GLYPHSET structure or, if the lpgs parameter is NULL, it returns the size of the GLYPHSET structure required to store the information. If the function fails, it returns zero. No extended error information is available. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetFontUnicodeRanges",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_Out_",
        "type": "LPGLYPHSET",
        "name": "lpgs",
        "description": "A pointer to a GLYPHSET structure that receives the glyph set information. If this parameter is NULL, the function returns the size of the GLYPHSET structure required to store the information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The GetGlyphIndices function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted. If the function fails, the return value is GDI_ERROR. ",
    "remarks": "This function attempts to identify a single-glyph representation for each character in the string pointed to by lpstr. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the Uniscribe functions. ",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetGlyphIndices",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpstr",
        "description": "A pointer to the string to be converted."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "c",
        "description": "The length of both the length of the string pointed to by lpstr and the size (in WORDs) of the buffer pointed to by pgi."
      },
      {
        "in_out": "_Out_",
        "type": "LPWORD",
        "name": "pgi",
        "description": "This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fl",
        "description": "Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.  ValueMeaning  GGI_MARK_NONEXISTING_GLYPHS   Marks unsupported glyphs with the hexadecimal value 0xffff."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The GetGlyphOutline function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes. If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR. ",
    "remarks": "The glyph outline returned by the GetGlyphOutline function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the otmEMSquare member of the OUTLINETEXTMETRIC structure. The glyph bitmap returned by GetGlyphOutline when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64. The native buffer returned by GetGlyphOutline when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a TTPOLYGONHEADER structure followed by one or more curves. Each curve in the contour is defined by a TTPOLYCURVE structure followed by a number of POINTFX data points. POINTFX points are absolute positions, not relative moves. The starting point of a contour is given by the pfxStart member of the TTPOLYGONHEADER structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the cpfx member of TTPOLYCURVE structure. The size of each contour in the buffer, in bytes, is stored in the cb member of TTPOLYGONHEADER structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by GetGlyphOutline. The GLYPHMETRICS structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the OUTLINETEXTMETRIC structure. An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the lpMatrix parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication. Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications. ",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetGlyphOutline",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uChar",
        "description": "The character for which data is to be returned."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uFormat",
        "description": "The format of the data that the function retrieves. ..."
      },
      {
        "in_out": "_Out_",
        "type": "LPGLYPHMETRICS",
        "name": "lpgm",
        "description": "A pointer to the GLYPHMETRICS structure describing the placement of the glyph in the character cell."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbBuffer",
        "description": "The size, in bytes, of the buffer (*lpvBuffer) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvBuffer",
        "description": "A pointer to the buffer that receives information about the outline character. If this value is NULL, the function returns the required size of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "const MAT2*",
        "name": "lpmat2",
        "description": "A pointer to a MAT2 structure specifying a transformation matrix for the character."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetKerningPairs function retrieves the character-kerning pairs for the currently selected font for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "WinGdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of kerning pairs returned. If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetKerningPairs",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumPairs",
        "description": "The number of pairs in the lpkrnpair array. If the font has more than nNumPairs kerning pairs, the function returns an error."
      },
      {
        "in_out": "_Out_",
        "type": "LPKERNINGPAIR",
        "name": "lpkrnpair",
        "description": "A pointer to an array of KERNINGPAIR structures that receives the kerning pairs. The array must contain at least as many structures as specified by the nNumPairs parameter. If this parameter is NULL, the function returns the total number of kerning pairs for the font."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetOutlineTextMetrics function retrieves text metrics for TrueType fonts.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero or the size of the required buffer. If the function fails, the return value is zero. ",
    "remarks": "The OUTLINETEXTMETRIC structure contains most of the text metric information provided for TrueType fonts (including a TEXTMETRIC structure). The sizes returned in OUTLINETEXTMETRIC are in logical units; they depend on the current mapping mode. ",
    "return_type": "UINT",
    "category": "Font and Text",
    "name": "GetOutlineTextMetrics",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbData",
        "description": "The size, in bytes, of the array that receives the text metrics."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPOUTLINETEXTMETRIC",
        "name": "lpOTM",
        "description": "A pointer to an OUTLINETEXTMETRIC structure. If this parameter is NULL, the function returns the size of the buffer required for the retrieved metric data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetRasterizerCaps function returns flags indicating whether TrueType fonts are installed in the system.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The GetRasterizerCaps function enables applications and printer drivers to determine whether TrueType fonts are installed. If the TT_AVAILABLE flag is set in the wFlags member of the RASTERIZER_STATUS structure, at least one TrueType font is installed. If the TT_ENABLED flag is set, TrueType is enabled for the system. The actual number of bytes copied is either the member specified in the cb parameter or the length of the RASTERIZER_STATUS structure, whichever is less. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetRasterizerCaps",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRASTERIZER_STATUS",
        "name": "lprs",
        "description": "A pointer to a RASTERIZER_STATUS structure that receives information about the rasterizer."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cb",
        "description": "The number of bytes to be copied into the structure pointed to by the lprs parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The GetTabbedTextExtent function computes the width and height of a character string. If the string contains one or more tab characters, the width of the string is based upon the specified tab stops. The GetTabbedTextExtent function uses the currently selected font to compute the dimensions of the string.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the dimensions of the string in logical units. The height is in the high-order word and the width is in the low-order word. If the function fails, the return value is 0. GetTabbedTextExtent will fail if hDC is invalid and if nTabPositions is less than 0. ",
    "remarks": "The current clipping region does not affect the width and height returned by the GetTabbedTextExtent function. Because some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string. If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is NULL, tabs are expanded to eight times the average character width. If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the array to which lpnTabStopPositions points. ",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "GetTabbedTextExtent",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to a character string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The length of the text string. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTabPositions",
        "description": "The number of tab-stop positions in the array pointed to by the lpnTabStopPositions parameter."
      },
      {
        "in_out": "_In_",
        "type": "const LPINT",
        "name": "lpnTabStopPositions",
        "description": "A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetTextAlign function retrieves the text-alignment setting for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the status of the text-alignment flags. For more information about the return value, see the Remarks section. The return value is a combination of the following values.  When the current font has a vertical default base line (as with Kanji), the following values are used instead of TA_BASELINE and TA_CENTER.  If the function fails, the return value is GDI_ERROR. ",
    "remarks": "The bounding rectangle is a rectangle bounding all of the character cells in a string of text. Its dimensions can be obtained by calling the GetTextExtentPoint32 function. The text-alignment flags determine how the TextOut and ExtTextOut functions align a string of text in relation to the string's reference point provided to TextOut or ExtTextOut. The text-alignment flags are not necessarily single bit flags and may be equal to zero. The flags must be examined in groups of related flags, as shown in the following list. If the current font has a vertical default base line, the related flags are as shown in the following list. To verify that a particular flag is set in the return value of this function: For an example, see Setting the Text Alignment. ",
    "return_type": "UINT",
    "category": "Font and Text",
    "name": "GetTextAlign",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetTextCharacterExtra function retrieves the current intercharacter spacing for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the current intercharacter spacing, in logical coordinates. If the function fails, the return value is 0x8000000. ",
    "remarks": "The intercharacter spacing defines the extra space, in logical units along the base line, that the TextOut or ExtTextOut functions add to each character as a line is written. The spacing is used to expand lines of text. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "GetTextCharacterExtra",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetTextColor function retrieves the current text color for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the current text color as a COLORREF value. If the function fails, the return value is CLR_INVALID. No extended error information is available. ",
    "remarks": "The text color defines the foreground color of characters drawn by using the TextOut or ExtTextOut function. ",
    "return_type": "COLORREF",
    "category": "Font and Text",
    "name": "GetTextColor",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The GetTextExtentExPoint function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "If both the lpnFit and alpDx parameters are NULL, calling the GetTextExtentExPoint function is equivalent to calling the GetTextExtentPoint function. For the ANSI version of GetTextExtentExPoint, the lpDx array has the same number of INT values as there are bytes in lpString. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character. Note, the alpDx values for GetTextExtentExPoint are not the same as the lpDx values for ExtTextOut. To use the alpDx values in lpDx, you must first process them. When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to GM_ADVANCED and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the SIZE structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the SIZE structure as { cx : 18, cy : 116 }. This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the GetCharWidth, which returns the width of each individual character rounded to logical units. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetTextExtentExPoint",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszStr",
        "description": "A pointer to the null-terminated string for which extents are to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchString",
        "description": "The number of characters in the string pointed to by the lpszStr parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nMaxExtent",
        "description": "The maximum allowable width, in logical units, of the formatted string."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "lpnFit",
        "description": "A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the nMaxExtent parameter. When the lpnFit parameter is NULL, the nMaxExtent parameter is ignored."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "alpDx",
        "description": "A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the nMaxExtent parameter. This array must have at least as many elements as characters specified by the cchString parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the lpnFit parameter. Any values in the rest of the array should be ignored. If alpDx is NULL, the function does not compute partial string widths. For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the alpDx array up to the number specified by the lpnFit parameter match one-to-one with code points. Again, you should ignore the rest of the values in the alpDx array."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpSize",
        "description": "A pointer to a SIZE structure that receives the dimensions of the string, in logical units. This parameter cannot be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The GetTextExtentExPointI function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "If both the lpnFit and alpDx parameters are NULL, calling the GetTextExtentExPointI function is equivalent to calling the GetTextExtentPointI function. When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to GM_ADVANCED and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the SIZE structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the SIZE structure as { cx : 18, cy : 116 }. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetTextExtentExPointI",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPWORD",
        "name": "pgiIn",
        "description": "A pointer to an array of glyph indices for which extents are to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cgi",
        "description": "The number of glyphs in the array pointed to by the pgiIn parameter."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nMaxExtent",
        "description": "The maximum allowable width, in logical units, of the formatted string."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "lpnFit",
        "description": "A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the nMaxExtent parameter. When the lpnFit parameter is NULL, the nMaxExtent parameter is ignored."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "alpDx",
        "description": "A pointer to an array of integers that receives partial glyph extents. Each element in the array gives the distance, in logical units, between the beginning of the glyph indices array and one of the glyphs that fits in the space specified by the nMaxExtent parameter. Although this array should have at least as many elements as glyph indices specified by the cgi parameter, the function fills the array with extents only for as many glyph indices as are specified by the lpnFit parameter. If lpnFit is NULL, the function does not compute partial string widths."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpSize",
        "description": "A pointer to a SIZE structure that receives the dimensions of the glyph indices array, in logical units. This value cannot be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetTextExtentPoint32 function computes the width and height of the specified string of text.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The GetTextExtentPoint32 function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string. The calculated string width takes into account the intercharacter spacing set by the SetTextCharacterExtra function and the justification set by SetTextJustification. This is true for both displaying on a screen and for printing. However, if lpDx is set in ExtTextOut, GetTextExtentPoint32 does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account. When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the SetTextCharacterExtra function and the justification set by SetTextJustification. However, if lpDx is set in ExtTextOut, GetTextExtentPoint32 does not take into account either intercharacter spacing or justification. However, when printing with EMF: When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to GM_ADVANCED and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the SIZE structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the SIZE structure as { cx : 18, cy : 116 }. GetTextExtentPoint32 doesn't consider \"\\n\" (new line) or \"\\r\\n\" (carriage return and new line) characters when it computes the height of a text string. For an example, see Drawing Text from Different Fonts on the Same Line. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetTextExtentPoint32",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the c parameter specifies the length of the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "c",
        "description": "The length of the string pointed to by lpString."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpSize",
        "description": "A pointer to a SIZE structure that receives the dimensions of the string, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetTextExtentPointI function computes the width and height of the specified array of glyph indices.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The GetTextExtentPointI function uses the currently selected font to compute the dimensions of the array of glyph indices. The width and height, in logical units, are computed without considering any clipping. When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to GM_ADVANCED and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the SIZE structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the SIZE structure as { cx : 18, cy : 116 }. Because some devices kern characters, the sum of the extents of the individual glyph indices may not be equal to the extent of the entire array of glyph indices. The calculated string width takes into account the intercharacter spacing set by the SetTextCharacterExtra function. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetTextExtentPointI",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPWORD",
        "name": "pgiIn",
        "description": "Pointer to array of glyph indices."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cgi",
        "description": "Specifies the number of glyph indices."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpSize",
        "description": "Pointer to a SIZE structure that receives the dimensions of the string, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetTextFace function retrieves the typeface name of the font that is selected into the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of characters copied to the buffer. If the function fails, the return value is zero. ",
    "remarks": "The typeface name is copied as a null-terminated character string. If the name is longer than the number of characters specified by the nCount parameter, the name is truncated. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "GetTextFace",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The length of the buffer pointed to by lpFaceName. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpFaceName",
        "description": "A pointer to the buffer that receives the typeface name. If this parameter is NULL, the function returns the number of characters in the name, including the terminating null character."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetTextMetrics function fills the specified buffer with the metrics for the currently selected font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "To determine whether a font is a TrueType font, first select it into a DC, then call GetTextMetrics, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that GetDC returns an uninitialized DC, which has \"System\" (a bitmap font) as the default font; thus the need to select a font into the DC. For an example, see \"Displaying Keyboard Input\" in Using Keyboard Input or Drawing Text from Different Fonts on the Same Line. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetTextMetrics",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_Out_",
        "type": "LPTEXTMETRIC",
        "name": "lptm",
        "description": "A pointer to the TEXTMETRIC structure that receives the text metrics."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PolyTextOut function draws several strings using the font and text colors currently selected in the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Each POLYTEXT structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the SetTextAlign function. An application can determine the current text-alignment setting for the specified device context by calling the GetTextAlign function. To draw a single string of text, the application should call the ExtTextOut function. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "PolyTextOut",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const POLYTEXT*",
        "name": "pptxt",
        "description": "A pointer to an array of POLYTEXT structures describing the strings to be drawn. The array contains one structure for each string to be drawn."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cStrings",
        "description": "The number of POLYTEXT structures in the pptxt array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The RemoveFontMemResourceEx function removes the fonts added from a memory image file.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. No extended error information is available. ",
    "remarks": "This function removes a font that was added by the AddFontMemResourceEx function. To remove the font, specify the same path and flags as were used in AddFontMemResourceEx. This function will only remove the font that is specified by fh. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "RemoveFontMemResourceEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "fh",
        "description": "A handle to the font-resource. This handle is returned by the AddFontMemResourceEx function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The RemoveFontResource function removes the fonts in the specified file from the system font table.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a WM_FONTCHANGE message to all top-level windows in the system. The app sends this message by calling the SendMessage function with the hwnd parameter set to HWND_BROADCAST. If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts) and is installed to any location other than the %windir%\\fonts\\ folder, it may be loaded into other active sessions (including session 0). When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it's in use even after you call RemoveFontResource. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call RemoveFontResource in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "RemoveFontResource",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "A pointer to a null-terminated string that names a font resource file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The RemoveFontResourceEx function removes the fonts in the specified file from the system font table.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. No extended error information is available. ",
    "remarks": "This function will only remove the font if the flags specified are the same as when then font was added with the AddFontResourceEx function. When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it's in use even after you call RemoveFontResourceEx. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call RemoveFontResourceEx in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "RemoveFontResourceEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "A pointer to a null-terminated string that names a font resource file."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fl",
        "description": "The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the AddFontResourceEx function. See the AddFontResourceEx function for more information."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pdv",
        "description": "Reserved. Must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetMapperFlags function alters the algorithm the font mapper uses when it maps logical fonts to physical fonts.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the previous value of the font-mapper flag. If the function fails, the return value is GDI_ERROR. ",
    "remarks": "If the dwFlag parameter is set and no matching fonts exist, Windows chooses a new aspect ratio and retrieves a font that matches this ratio. The remaining bits of the dwFlag parameter must be zero. ",
    "return_type": "DWORD",
    "category": "Font and Text",
    "name": "SetMapperFlags",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context that contains the font-mapper flag."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlag",
        "description": "Specifies whether the font mapper should attempt to match a font's aspect ratio to the current device's aspect ratio. If bit zero is set, the mapper selects only matching fonts."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetTextAlign function sets the text-alignment flags for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the previous text-alignment setting. If the function fails, the return value is GDI_ERROR. ",
    "remarks": "The TextOut and ExtTextOut functions use the text-alignment flags to position a string of text on a display or other device. The flags specify the relationship between a reference point and a rectangle that bounds the text. The reference point is either the current position or a point passed to a text output function. The rectangle that bounds the text is formed by the character cells in the text string. The best way to get left-aligned text is to use either or You can also use SetTextAlign (hdc, TA_LEFT) for this purpose, but this loses any vertical or right-to-left settings. For an example, see Setting the Text Alignment. ",
    "return_type": "UINT",
    "category": "Font and Text",
    "name": "SetTextAlign",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fMode",
        "description": "The text alignment by using a mask of the values in the following list. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.  ValueMeaning  TA_BASELINE   The reference point will be on the base line of the text.   TA_BOTTOM   The reference point will be on the bottom edge of the bounding rectangle.   TA_TOP   The reference point will be on the top edge of the bounding rectangle.   TA_CENTER   The reference point will be aligned horizontally with the center of the bounding rectangle.   TA_LEFT   The reference point will be on the left edge of the bounding rectangle.   TA_RIGHT   The reference point will be on the right edge of the bounding rectangle.   TA_NOUPDATECP   The current position is not updated after each text output call. The reference point is passed to the text output function.   TA_RTLREADING   Middle East language edition of Windows: The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.   TA_UPDATECP   The current position is updated after each text output call. The current position is used as the reference point.     When the current font has a vertical default base line, as with Kanji, the following values must be used instead of TA_BASELINE and TA_CENTER.  ValueMeaning  VTA_BASELINE   The reference point will be on the base line of the text.   VTA_CENTER   The reference point will be aligned vertically with the center of the bounding rectangle.     The default values are TA_LEFT, TA_TOP, and TA_NOUPDATECP."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetTextCharacterExtra function sets the intercharacter spacing. Intercharacter spacing is added to each character, including break characters, when the system writes a line of text.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the previous intercharacter spacing. If the function fails, the return value is 0x80000000. ",
    "remarks": "This function is supported mainly for compatibility with existing applications. New applications should generally avoid calling this function, because it is incompatible with complex scripts (scripts that require text shaping; Arabic script is an example of this). The recommended approach is that instead of calling this function and then TextOut, applications should call ExtTextOut and use its lpDx parameter to supply widths. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "SetTextCharacterExtra",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCharExtra",
        "description": "The amount of extra space, in logical units, to be added to each character. If the current mapping mode is not MM_TEXT, the nCharExtra parameter is transformed and rounded to the nearest pixel."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetTextColor function sets the text color for the specified device context to the specified color.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a color reference for the previous text color as a COLORREF value. If the function fails, the return value is CLR_INVALID. ",
    "remarks": "The text color is used to draw the face of each character written by the TextOut and ExtTextOut functions. The text color is also used in converting bitmaps from color to monochrome and vice versa. For an example, see \"Setting Fonts for Menu-Item Text Strings\" in Using Menus. ",
    "return_type": "COLORREF",
    "category": "Font and Text",
    "name": "SetTextColor",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "The color of the text."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SetTextJustification function specifies the amount of space the system should add to the break characters in a string of text. The space is added when an application calls the TextOut or ExtTextOut functions.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The break character is usually the space character (ASCII 32), but it may be defined by a font as some other character. The GetTextMetrics function can be used to retrieve a font's break character. The TextOut function distributes the specified extra space evenly among the break characters in the line. The GetTextExtentPoint32 function is always used with the SetTextJustification function. Sometimes the GetTextExtentPoint32 function takes justification into account when computing the width of a specified line before justification, and sometimes it does not. For more details on this, see GetTextExtentPoint32. This width must be known before an appropriate nBreakExtra value can be computed. SetTextJustification can be used to justify a line that contains multiple strings in different fonts. In this case, each string must be justified separately. Because rounding errors can occur during justification, the system keeps a running error term that defines the current error value. When justifying a line that contains multiple runs, GetTextExtentPoint automatically uses this error term when it computes the extent of the next run, allowing TextOut to blend the error into the new run. After each line has been justified, this error term must be cleared to prevent it from being incorporated into the next line. The term can be cleared by calling SetTextJustification with nBreakExtra set to zero. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "SetTextJustification",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBreakExtra",
        "description": "The total extra space, in logical units, to be added to the line of text. If the current mapping mode is not MM_TEXT, the value identified by the nBreakExtra parameter is transformed and rounded to the nearest pixel."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBreakCount",
        "description": "The number of break characters in the line."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The TabbedTextOut function writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions. Text is written in the currently selected font, background color, and text color.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the dimensions, in logical units, of the string. The height is in the high-order word and the width is in the low-order word. If the function fails, the return value is zero. ",
    "remarks": "If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is NULL, tabs are expanded to eight times the average character width. If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the lpnTabStopPositions array. If the lpnTabStopPositions array contains more than one value, a tab stop is set for each value in the array, up to the number specified by nTabPositions. The nTabOrigin parameter allows an application to call the TabbedTextOut function several times for a single line. If the application calls TabbedTextOut more than once with the nTabOrigin set to the same value each time, the function expands all tabs relative to the position specified by nTabOrigin. By default, the current position is not used or updated by the TabbedTextOut function. If an application needs to update the current position when it calls TabbedTextOut, the application can call the SetTextAlign function with the wFlags parameter set to TA_UPDATECP. When this flag is set, the system ignores the X and Y parameters on subsequent calls to the TabbedTextOut function, using the current position instead. ",
    "return_type": "LONG",
    "category": "Font and Text",
    "name": "TabbedTextOut",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "The x-coordinate of the starting point of the string, in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "The y-coordinate of the starting point of the string, in logical units."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to the character string to draw. The string does not need to be zero-terminated, since nCount specifies the length of the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The length of the string pointed to by lpString."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTabPositions",
        "description": "The number of values in the array of tab-stop positions."
      },
      {
        "in_out": "_In_",
        "type": "const LPINT",
        "name": "lpnTabStopPositions",
        "description": "A pointer to an array containing the tab-stop positions, in logical units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTabOrigin",
        "description": "The x-coordinate of the starting position from which tabs are expanded, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The TextOut function writes a character string at the specified location, using the currently selected font, background color, and text color.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the GetTextAlign function; an application can alter this mode by calling the SetTextAlign function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.   By default, the current position is not used or updated by this function. However, an application can call the SetTextAlign function with the fMode parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls TextOut for a specified device context. When this flag is set, the system ignores the nXStart and nYStart parameters on subsequent TextOut calls. When the TextOut function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the TextOut function in the path bracket. Following is sample code that demonstrates this procedure. For an example, see Enumerating the Installed Fonts. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "TextOut",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXStart",
        "description": "The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYStart",
        "description": "The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to the string to be drawn. The string does not need to be zero-terminated, because cchString specifies the length of the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cchString",
        "description": "The length of the string pointed to by lpString, in characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The CreateScalableFontResource function is available for use in the operating systems specified in the Requirements section. It may be   altered or unavailable in subsequent versions.]",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. If lpszFontRes specifies an existing font file, GetLastError returns ERROR_FILE_EXISTS ",
    "remarks": "The CreateScalableFontResource function is used by applications that install TrueType fonts. An application uses the CreateScalableFontResource function to create a font resource file (typically with a .fot file name extension) and then uses the AddFontResource function to install the font. The TrueType font file (typically with a .ttf file name extension) must be in the System subdirectory of the Windows directory to be used by the AddFontResource function. The CreateScalableFontResource function currently supports only TrueType-technology scalable fonts. When the lpszFontFile parameter specifies only a file name and extension, the lpszCurrentPath parameter must specify a path. When the lpszFontFile parameter specifies a full path, the lpszCurrentPath parameter must be NULL or a pointer to NULL. When only a file name and extension are specified in the lpszFontFile parameter and a path is specified in the lpszCurrentPath parameter, the string in lpszFontFile is copied into the .fot file as the .ttf file that belongs to this resource. When the AddFontResource function is called, the operating system assumes that the .ttf file has been copied into the System directory (or into the main Windows directory in the case of a network installation). The .ttf file need not be in this directory when the CreateScalableFontResource function is called, because the lpszCurrentPath parameter contains the directory information. A resource created in this manner does not contain absolute path information and can be used in any installation. When a path is specified in the lpszFontFile parameter and NULL is specified in the lpszCurrentPath parameter, the string in lpszFontFile is copied into the .fot file. In this case, when the AddFontResource function is called, the .ttf file must be at the location specified in the lpszFontFile parameter when the CreateScalableFontResource function was called; the lpszCurrentPath parameter is not needed. A resource created in this manner contains absolute references to paths and drives and does not work if the .ttf file is moved to a different location. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "CreateScalableFontResource",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwHidden",
        "description": "Specifies whether the font is a read-only font. This parameter can be one of the following values.  ValueMeaning  0   The font has read/write permission.   1   The font has read-only permission and should be hidden from other applications in the system. When this flag is set, the font is not enumerated by the EnumFonts or EnumFontFamilies function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFontRes",
        "description": "A pointer to a null-terminated string specifying the name of the font resource file to create. If this parameter specifies an existing font resource file, the function fails."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFontFile",
        "description": "A pointer to a null-terminated string specifying the name of the scalable font file that this function uses to create the font resource file."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszCurrentPath",
        "description": "A pointer to a null-terminated string specifying the path to the scalable font file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EnumFontFamilies function enumerates the fonts in a specified font family that are available on a specified device.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value is the last value returned by the callback function. Its meaning is implementation specific. ",
    "remarks": "For each font having the typeface name specified by the lpszFamily parameter, the EnumFontFamilies function retrieves information about that font and passes it to the function pointed to by the lpEnumFontFamProc parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero. When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system. The fonts for many East Asian languages have two typeface names: an English name and a localized name. EnumFonts, EnumFontFamilies, and EnumFontFamiliesEx return the English typeface name if the system locale does not match the language of the font. For examples, see Enumerating the Installed Fonts. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "EnumFontFamilies",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context from which to enumerate the fonts."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFamily",
        "description": "A pointer to a null-terminated string that specifies the family name of the desired fonts. If lpszFamily is NULL, EnumFontFamilies selects and enumerates one font of each available type family."
      },
      {
        "in_out": "_In_",
        "type": "FONTENUMPROC",
        "name": "lpEnumFontFamProc",
        "description": "A pointer to the application defined callback function. For information, see EnumFontFamProc."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "A pointer to application-supplied data. The data is passed to the callback function along with the font information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EnumFontFamProc function is an application defined callback function used with the EnumFontFamilies function. It receives data describing the available fonts. The FONTENUMPROC type defines a pointer to this callback function. EnumFontFamProc is a placeholder for the application definedfunction name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value must be a nonzero value to continue enumeration; to stop enumeration, it must return zero. ",
    "remarks": "An application must register this callback function by passing its address to the EnumFontFamilies function. When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system. The AND (&) operator can be used with the RASTER_FONTTYPE, DEVICE_FONTTYPE, and TRUETYPE_FONTTYPE constants to determine the font type. If the RASTER_FONTTYPE bit is set, the font is a raster font. If the TRUETYPE_FONTTYPE bit is set, the font is a TrueType font. If neither bit is set, the font is a vector font. DEVICE_FONTTYPE is set when a device (for example, a laser printer) supports downloading TrueType fonts or when the font is a device-resident font; it is zero if the device is a display adapter, dot-matrix printer, or other raster device. An application can also use DEVICE_FONTTYPE to distinguish graphics device interface (GDI)-supplied raster fonts from device-supplied fonts. GDI can simulate bold, italic, underline, and strikeout attributes for GDI-supplied raster fonts, but not for device-supplied fonts. ",
    "return_type": "int CALLBACK",
    "category": "Font and Text",
    "name": "EnumFontFamProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ENUMLOGFONT*",
        "name": "lpelf",
        "description": "A pointer to an ENUMLOGFONT structure that contains information about the logical attributes of the font. This structure is locally defined.               This can be an ENUMLOGFONTEXDV structure."
      },
      {
        "in_out": "_In_",
        "type": "NEWTEXTMETRIC*",
        "name": "lpntm",
        "description": "A pointer to a NEWTEXTMETRIC structure that contains information about the physical attributes of the font, if the font is a TrueType font. If the font is not a TrueType font, this parameter is a pointer to a TEXTMETRIC structure.               This can be an ENUMTEXTMETRIC structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "FontType",
        "description": "The type of the font. This parameter can be a combination of the following values: DEVICE_FONTTYPERASTER_FONTTYPETRUETYPE_FONTTYPE"
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "A pointer to the application-defined data passed by the EnumFontFamilies function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EnumFonts function enumerates the fonts available on a specified device. For each font with the specified typeface name, the EnumFonts function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value is the last value returned by the callback function. Its meaning is defined by the application. ",
    "remarks": "Use EnumFontFamiliesEx instead of EnumFonts. The EnumFontFamiliesEx function differs from the EnumFonts function in that it retrieves the style names associated with a TrueType font. With EnumFontFamiliesEx, you can retrieve information about font styles that cannot be enumerated using the EnumFonts function. The fonts for many East Asian languages have two typeface names: an English name and a localized name. EnumFonts, EnumFontFamilies, and EnumFontFamiliesEx return the English typeface name if the system locale does not match the language of the font. ",
    "return_type": "int",
    "category": "Font and Text",
    "name": "EnumFonts",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context from which to enumerate the fonts."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFaceName",
        "description": "A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If lpFaceName is NULL, EnumFonts randomly selects and enumerates one font of each available typeface."
      },
      {
        "in_out": "_In_",
        "type": "FONTENUMPROC",
        "name": "lpFontFunc",
        "description": "A pointer to the application definedcallback function. For more information, see EnumFontsProc."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "A pointer to any application-defined data. The data is passed to the callback function along with the font information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EnumFontsProc function is an application definedcallback function that processes font data from the EnumFonts function. The FONTENUMPROC type defines a pointer to this callback function. EnumFontsProc is a placeholder for the application definedfunction name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value must be a nonzero value to continue enumeration; to stop enumeration, it must be zero. ",
    "remarks": "The AND (&) operator can be used with the RASTER_FONTTYPE and DEVICE_FONTTYPE constants to determine the font type. The RASTER_FONTTYPE bit of the FontType parameter specifies whether the font is a raster or vector font. If the bit is one, the font is a raster font; if zero, it is a vector font. The DEVICE_FONTTYPE bit of FontType specifies whether the font is a device-based or graphics device interface (GDI)-based font. If the bit is one, the font is a device-based font; if zero, it is a GDI-based font. If the device is capable of text transformations (scaling, italicizing, and so on) only the base font is enumerated. The user must inquire into the device's text-transformation abilities to determine which additional fonts are available directly from the device. An application must register the EnumFontsProc function by passing its address to the EnumFonts function. ",
    "return_type": "int CALLBACK",
    "category": "Font and Text",
    "name": "EnumFontsProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LOGFONT*",
        "name": "lplf",
        "description": "A pointer to a LOGFONT structure that contains information about the logical attributes of the font.               This can be an ENUMLOGFONTEXDV structure."
      },
      {
        "in_out": "_In_",
        "type": "const TEXTMETRIC*",
        "name": "lptm",
        "description": "A pointer to a TEXTMETRIC structure that contains information about the physical attributes of the font.               This can be an ENUMTEXTMETRIC structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "The type of the font. This parameter can be a combination of the following values: DEVICE_FONTTYPERASTER_FONTTYPETRUETYPE_FONTTYPE"
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lpData",
        "description": "A pointer to the application-defined data passed by EnumFonts."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetCharWidth function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "GetCharWidth cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use GetCharABCWidths. The range is inclusive; that is, the returned widths include the widths of the characters specified by the iFirstChar and iLastChar parameters. If a character does not exist in the current font, it is assigned the width of the default character. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetCharWidth",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iFirstChar",
        "description": "The first character in the group of consecutive characters."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iLastChar",
        "description": "The last character in the group of consecutive characters, which must not precede the specified first character."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the character widths, in logical coordinates."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetTextExtentPoint function computes the width and height of the specified string of text.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "WinGdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The GetTextExtentPoint function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly. Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string. The calculated string width takes into account the intercharacter spacing set by the SetTextCharacterExtra function. ",
    "return_type": "BOOL",
    "category": "Font and Text",
    "name": "GetTextExtentPoint",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A pointer to the string that specifies the text. The string does not need to be zero-terminated, since cbString specifies the length of the string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cbString",
        "description": "The length of the string pointed to by lpString."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpSize",
        "description": "A pointer to a SIZE structure that receives the dimensions of the string, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]