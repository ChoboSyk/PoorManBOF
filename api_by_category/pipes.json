[
  {
    "n_arguments": 4,
    "description": "Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "CreatePipe creates the pipe, assigning the specified pipe size to the storage buffer.  CreatePipe also creates handles that the process uses to read from and write to the buffer in subsequent calls to the ReadFile and WriteFile functions. To read from the pipe, a process uses the read handle in a call to the ReadFile function. ReadFile returns when one of the following is true: a write operation completes on the write end of the pipe, the number of bytes requested has been read, or an error occurs. When a process uses WriteFile to write to an anonymous pipe, the write operation is not completed until all bytes are written. If the pipe buffer is full before all bytes are written, WriteFile does not return until another process or thread uses ReadFile to make more buffer space available. Anonymous pipes are implemented using a named pipe with a unique name. Therefore, you can often pass a handle to an anonymous pipe to a function that requires a handle to a named pipe. If CreatePipe fails, the contents of the output parameters are indeterminate. No assumptions should be made about their contents in this event. To free resources used by a pipe, the application should always close handles when they are no longer needed, which is accomplished either by calling the CloseHandle function or when the process associated with the instance handles ends. Note that an instance of a pipe may have more than one handle associated with it. An instance of a pipe is always deleted when the last handle to the instance of the named pipe is closed. For an example, see  Creating a Child Process with Redirected Input and Output. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "CreatePipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "hReadPipe",
        "description": "A pointer to a variable that receives the read handle for the pipe."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "hWritePipe",
        "description": "A pointer to a variable that receives the write handle for the pipe."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpPipeAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpPipeAttributes is NULL, the handle cannot be inherited.     The lpSecurityDescriptor member of the structure specifies a security descriptor for the new pipe. If lpPipeAttributes is NULL, the pipe gets a default security descriptor. The ACLs in the default security descriptor for a pipe come from the primary or impersonation token of the creator."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default buffer size."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the message written to the pipe by the server process is longer than nOutBufferSize,  CallNamedPipe returns FALSE, and GetLastError returns ERROR_MORE_DATA. The remainder of the message is discarded, because  CallNamedPipe closes the handle to the pipe before returning. ",
    "remarks": "Calling CallNamedPipe is equivalent to calling the CreateFile (or WaitNamedPipe, if CreateFile cannot open the pipe immediately), TransactNamedPipe, and CloseHandle functions. CreateFile is called with an access flag of GENERIC_READ | GENERIC_WRITE, and an inherit handle flag of FALSE. CallNamedPipe fails if the pipe is a byte-type pipe. For an example, see  Transactions on Named Pipes. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "CallNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNamedPipeName",
        "description": "The pipe name."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpInBuffer",
        "description": "The data to be written to the pipe."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nInBufferSize",
        "description": "The size of the write buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpOutBuffer",
        "description": "A pointer to the buffer that receives the data read from the pipe."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nOutBufferSize",
        "description": "The size of the read buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpBytesRead",
        "description": "A pointer to a variable that receives the number of bytes read from the pipe."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nTimeOut",
        "description": "The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.  ValueMeaning  NMPWAIT_NOWAIT 0x00000001   Does not wait for the named pipe. If the named pipe is not available, the function returns an error.   NMPWAIT_WAIT_FOREVER 0xffffffff   Waits indefinitely.   NMPWAIT_USE_DEFAULT_WAIT 0x00000000   Uses the default time-out specified in a call to the  CreateNamedPipe function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A client process connects by calling either the  CreateFile or  CallNamedPipe function.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the operation is synchronous, ConnectNamedPipe does not return until the operation has completed. If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the operation is asynchronous, ConnectNamedPipe returns immediately. If the operation is still pending, the return value is zero and GetLastError returns ERROR_IO_PENDING. (You can use the HasOverlappedIoCompleted macro to determine when the operation has finished.) If the function fails, the return value is zero and  GetLastError returns a value other than ERROR_IO_PENDING or ERROR_PIPE_CONNECTED. If a client connects before the function is called, the function returns zero and GetLastError returns ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval between the call to  CreateNamedPipe and the call to  ConnectNamedPipe. In this situation, there is a good connection between client and server, even though the function returns zero. ",
    "remarks": "A named pipe server process can use  ConnectNamedPipe with a newly created pipe instance. It can also be used with an instance that was previously connected to another client process; in this case, the server process must first call the  DisconnectNamedPipe function to disconnect the handle from the previous client before the handle can be reconnected to a new client. Otherwise,  ConnectNamedPipe returns zero, and GetLastError returns ERROR_NO_DATA if the previous client has closed its handle or ERROR_PIPE_CONNECTED if it has not closed its handle. The behavior of  ConnectNamedPipe depends on two conditions: whether the pipe handle's wait mode is set to blocking or nonblocking and whether the function is set to execute synchronously or in overlapped mode. A server initially specifies a pipe handle's wait mode in the  CreateNamedPipe function, and it can be changed by using the  SetNamedPipeHandleState function. The server process can use any of the  wait functions or  SleepEx\u00e2\u0080\u0094 to determine when the state of the event object is signaled, and it can then use the HasOverlappedIoCompleted  macro to determine when the  ConnectNamedPipe operation completes. If the specified pipe handle is in nonblocking mode,  ConnectNamedPipe always returns immediately. In nonblocking mode,  ConnectNamedPipe returns a nonzero value the first time it is called for a pipe instance that is disconnected from a previous client. This indicates that the pipe is now available to be connected to a new client process. In all other situations when the pipe handle is in nonblocking mode,  ConnectNamedPipe returns zero. In these situations, GetLastError returns ERROR_PIPE_LISTENING if no client is connected, ERROR_PIPE_CONNECTED if a client is connected, and ERROR_NO_DATA if a previous client has closed its pipe handle but the server has not disconnected. Note that a good connection between client and server exists only after the ERROR_PIPE_CONNECTED error is received. For an example, see  Multithreaded Pipe Server. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "ConnectNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to the server end of a named pipe instance. This handle is returned by the  CreateNamedPipe function."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure.     If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must point to a valid OVERLAPPED structure. If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is NULL, the function can incorrectly report that the connect operation is complete. If hNamedPipe was created with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, the OVERLAPPED structure should  contain a handle to a manual-reset event object (which the server can create by using the  CreateEvent function). If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is connected or an error occurs. Successful synchronous operations result in the function returning a nonzero value if a client connects after the function is called."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call  GetLastError. ",
    "remarks": "To create an instance of a named pipe by using  CreateNamedPipe, the user must have FILE_CREATE_PIPE_INSTANCE access to the named pipe object. If a new named pipe is being created, the access control list (ACL) from the security attributes parameter defines the discretionary access control for the named pipe. All instances of a named pipe must specify the same pipe type (byte-type or message-type), pipe access (duplex, inbound, or outbound), instance count, and time-out value. If different values are used, this function fails and GetLastError returns ERROR_ACCESS_DENIED. A client process connects to a named pipe by using the CreateFile or CallNamedPipe function. The client side of a named pipe starts out in byte mode, even if the server side is in message mode. To avoid problems receiving data, set the client side to message mode as well. To change the mode of the pipe, the pipe client must open a read-only pipe with GENERIC_READ and  FILE_WRITE_ATTRIBUTES access. The pipe server should not perform a blocking read operation until the pipe client has started. Otherwise, a race condition can occur. This typically occurs when initialization code, such as the C run-time, needs to lock and examine inherited handles. Every time a named pipe is created, the system creates the inbound and/or outbound buffers using nonpaged pool, which is the physical memory used by the kernel. The number of pipe instances (as well as objects such as threads and processes) that you can create is limited by the available nonpaged pool. Each read or write request requires space in the buffer for the read or write data, plus additional space for the internal data structures. The input and output buffer sizes are advisory. The actual buffer size reserved for each end of the named pipe is either the system default, the system minimum or maximum, or the specified size rounded up to the next allocation boundary. The buffer size specified should be small enough that your process will not run out of nonpaged pool, but large enough to accommodate typical requests. Whenever a pipe write operation occurs, the system first tries to charge the memory against the pipe write quota. If the remaining pipe write quota is enough to fulfill the request, the write operation completes immediately. If the remaining pipe write quota is too small to fulfill the request, the system will try to expand the buffers to accommodate the data using nonpaged pool reserved for the process. The write operation will block until the data is read from the pipe so that the additional buffer quota can be released. Therefore, if your specified buffer size is too small, the system will grow the buffer as needed, but the downside is that the operation will block. If the operation is overlapped, a system thread is blocked; otherwise, the application thread is blocked. To free resources used by a named pipe, the application should always close handles when they are no longer needed, which is accomplished either by calling the CloseHandle function or when the process associated with the instance handles ends. Note that an instance of a named pipe may have more than one handle associated with it. An instance of a named pipe is always deleted when the last handle to the instance of the named pipe is closed. For an example, see  Multithreaded Pipe Server. ",
    "return_type": "HANDLE",
    "category": "Pipes",
    "name": "CreateNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The unique pipe name. This string must have the following form: \\\\.\\pipe\\pipename The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOpenMode",
        "description": "The open mode.    The function fails if dwOpenMode specifies anything other than 0 or the flags listed in the following tables. This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.  ModeMeaning  PIPE_ACCESS_DUPLEX 0x00000003   The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of GENERIC_READ and GENERIC_WRITE access to the pipe. The client can specify GENERIC_READ or GENERIC_WRITE, or both, when it connects to the pipe using the  CreateFile function.   PIPE_ACCESS_INBOUND 0x00000001   The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of GENERIC_READ access to the pipe. The client must specify GENERIC_WRITE access when connecting to the pipe. If the client must read pipe settings by calling the GetNamedPipeInfo or GetNamedPipeHandleState functions, the client must specify GENERIC_WRITE and FILE_READ_ATTRIBUTES access when connecting to the pipe.   PIPE_ACCESS_OUTBOUND 0x00000002   The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of GENERIC_WRITE access to the pipe. The client must specify GENERIC_READ access when connecting to the pipe. If the client must change pipe settings by calling the SetNamedPipeHandleState function, the client must specify GENERIC_READ and FILE_WRITE_ATTRIBUTES access when connecting to the pipe.     This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.  ModeMeaning  FILE_FLAG_FIRST_PIPE_INSTANCE 0x00080000   If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with ERROR_ACCESS_DENIED.   FILE_FLAG_WRITE_THROUGH 0x80000000   Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.   FILE_FLAG_OVERLAPPED 0x40000000   Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The  ReadFileEx and  WriteFileEx functions can only be used with a pipe handle in overlapped mode. The  ReadFile,  WriteFile,  ConnectNamedPipe, and  TransactNamedPipe functions can execute either synchronously or as overlapped operations.     This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.  ModeMeaning  WRITE_DAC 0x00040000L   The caller will have write access to the named pipe's discretionary access control list (ACL).   WRITE_OWNER 0x00080000L   The caller will have write access to the named pipe's owner.   ACCESS_SYSTEM_SECURITY 0x01000000L   The caller will have write access to the named pipe's SACL. For more information, see  Access-Control Lists (ACLs) and  SACL Access Right."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwPipeMode",
        "description": "The pipe mode.    The function fails if dwPipeMode specifies anything other than 0 or the flags listed in the following tables. One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.  ModeMeaning  PIPE_TYPE_BYTE 0x00000000   Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.   PIPE_TYPE_MESSAGE 0x00000004   Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The GetLastError function returns ERROR_MORE_DATA when a message is not read completely. This mode can be used with either PIPE_READMODE_MESSAGE or PIPE_READMODE_BYTE.     One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.  ModeMeaning  PIPE_READMODE_BYTE 0x00000000   Data is read from the pipe as a stream of bytes. This mode can be used with either PIPE_TYPE_MESSAGE or PIPE_TYPE_BYTE.   PIPE_READMODE_MESSAGE 0x00000002   Data is read from the pipe as a stream of messages. This mode can be only used if PIPE_TYPE_MESSAGE is also specified.     One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.  ModeMeaning  PIPE_WAIT 0x00000000   Blocking mode is enabled. When the pipe handle is specified in the  ReadFile,  WriteFile, or  ConnectNamedPipe function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.   PIPE_NOWAIT 0x00000001   Nonblocking mode is enabled. In this mode, ReadFile, WriteFile, and  ConnectNamedPipe always return immediately. Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see  Synchronous and Overlapped Input and Output.     One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.  ModeMeaning  PIPE_ACCEPT_REMOTE_CLIENTS 0x00000000   Connections from remote clients can be accepted and checked against the security descriptor for the pipe.   PIPE_REJECT_REMOTE_CLIENTS 0x00000008   Connections from remote clients are automatically rejected."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nMaxInstances",
        "description": "The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through PIPE_UNLIMITED_INSTANCES (255). If this parameter is PIPE_UNLIMITED_INSTANCES, the number of pipe instances that can be created is limited only by the availability of system resources. If nMaxInstances is greater than PIPE_UNLIMITED_INSTANCES, the return value is INVALID_HANDLE_VALUE and GetLastError returns ERROR_INVALID_PARAMETER."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nOutBufferSize",
        "description": "The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nInBufferSize",
        "description": "The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nDefaultTimeOut",
        "description": "The default time-out value, in milliseconds, if the  WaitNamedPipe function specifies NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value. A value of zero will result in a default time-out of 50 milliseconds."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Disconnects the server end of a named pipe instance from a client process.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If the client end of the named pipe is open, the  DisconnectNamedPipe function forces that end of the named pipe closed. The client receives an error the next time it attempts to access the pipe. A client that is forced off a pipe by  DisconnectNamedPipe must still use the CloseHandle function to close its end of the pipe. The pipe exists as long as a server or client process has an open handle to the pipe. When the server process disconnects a pipe instance, any unread data in the pipe is discarded. Before disconnecting, the server can make sure data is not lost by calling the FlushFileBuffers function, which does not return until the client process has read all the data. The server process must call  DisconnectNamedPipe to disconnect a pipe handle from its previous client before the handle can be connected to another client by using the  ConnectNamedPipe function. For an example, see  Multithreaded Pipe Server. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "DisconnectNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to an instance of a named pipe. This handle must be created by the  CreateNamedPipe function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the client computer name for the specified named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeClientComputerName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Pipe",
        "description": "A handle to an instance of a named pipe. This handle must be created by the  CreateNamedPipe function."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "ClientComputerName",
        "description": "The computer name."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ClientComputerNameLength",
        "description": "The size of the ClientComputerName buffer, in bytes."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the client process identifier for the specified named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeClientProcessId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Pipe",
        "description": "A handle to an instance of a named pipe. This handle must be created by the  CreateNamedPipe function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ClientProcessId",
        "description": "The process identifier."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the client session identifier for the specified named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeClientSessionId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Pipe",
        "description": "A handle to an instance of a named pipe. This handle must be created by the  CreateNamedPipe function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ClientSessionId",
        "description": "The session identifier."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  GetNamedPipeHandleState function returns successfully even if all of the pointers passed to it are NULL. To set the pipe handle state, use the  SetNamedPipeHandleState function. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeHandleState",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.     This parameter can also be a handle to an anonymous pipe, as returned by the  CreatePipe function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpState",
        "description": "A pointer to a variable that indicates the current state of the handle. This parameter can be NULL if this information is not needed. Either or both of the following values can be specified.     ValueMeaning  PIPE_NOWAIT 0x00000001   The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.   PIPE_READMODE_MESSAGE 0x00000002   The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpCurInstances",
        "description": "A pointer to a variable that receives the number of current pipe instances. This parameter can be NULL if this information is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpMaxCollectionCount",
        "description": "A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be NULL if this information is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpCollectDataTimeout",
        "description": "A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be NULL if this information is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpUserName",
        "description": "A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.     This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter can be NULL if this information is not required."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nMaxUserNameSize",
        "description": "The size of the buffer specified by the lpUserName parameter, in TCHARs. This parameter is ignored if lpUserName is NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information about the specified named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeInfo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to the named pipe instance. The handle must have GENERIC_READ access to the named pipe for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.     This parameter can also be a handle to an anonymous pipe, as returned by the  CreatePipe function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpFlags",
        "description": "A pointer to a variable that receives the type of the named pipe. This parameter can be NULL if this information is not required. Otherwise, this parameter can be one or more of the following values.     ValueMeaning  PIPE_CLIENT_END 0x00000000   The handle refers to the client end of a named pipe instance. This is the default.   PIPE_SERVER_END 0x00000001   The handle refers to the server end of a named pipe instance. If this value is not specified, the handle refers to the client end of a named pipe instance.   PIPE_TYPE_BYTE 0x00000000   The named pipe is a byte pipe. This is the default.   PIPE_TYPE_MESSAGE 0x00000004   The named pipe is a message pipe. If this value is not specified, the pipe is a byte pipe."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpOutBufferSize",
        "description": "A pointer to a variable that receives the size of the buffer for outgoing data, in bytes. If the buffer size is zero, the buffer is allocated as needed. This parameter can be NULL if this information is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpInBufferSize",
        "description": "A pointer to a variable that receives the size of the buffer for incoming data, in bytes. If the buffer size is zero, the buffer is allocated as needed. This parameter can be NULL if this information is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpMaxInstances",
        "description": "A pointer to a variable that receives the maximum number of pipe instances that can be created. If the variable is set to PIPE_UNLIMITED_INSTANCES (255), the number of pipe instances that can be created is limited only by the availability of system resources. This parameter can be NULL if this information is not required."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the server process identifier for the specified named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeServerProcessId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Pipe",
        "description": "A handle to an instance of a named pipe. This handle must be created by the  CreateNamedPipe function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ServerProcessId",
        "description": "The process identifier."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the server session identifier for the specified named pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "GetNamedPipeServerSessionId",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Pipe",
        "description": "A handle to an instance of a named pipe. This handle must be created by the  CreateNamedPipe function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ServerSessionId",
        "description": "The session identifier."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The ImpersonateNamedPipeClient function impersonates a named-pipe client application.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The ImpersonateNamedPipeClient function allows the server end of a named pipe to impersonate the client end. When this function is called, the named-pipe file system changes the thread of the calling process to start impersonating the security context of the last message read from the pipe. Only the server end of the pipe can call this function. The server can call the  RevertToSelf function when the impersonation is complete. All impersonate functions, including ImpersonateNamedPipeClient allow the requested impersonation if one of the following is true: Windows XP with SP1 and earlier:  The SeImpersonatePrivilege privilege is not supported. For an example that uses this function, see       Verifying Client Access with ACLs. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "ImpersonateNamedPipeClient",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to a named pipe."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Copies data from a named or anonymous pipe into a buffer without removing it from the pipe. It also returns information about data in the pipe.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  PeekNamedPipe function is similar to the  ReadFile function with the following exceptions: If the specified handle is a named pipe handle in byte-read mode, the function reads all available bytes up to the size specified in nBufferSize. For a named pipe handle in message-read mode, the function reads the next message in the pipe. If the message is larger than nBufferSize, the function returns TRUE after reading the specified number of bytes. In this situation, lpBytesLeftThisMessage will receive the number of bytes remaining in the message. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "PeekNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by the  CreateNamedPipe or  CreateFile function, or it can be a handle to the read end of an anonymous pipe, as returned by the  CreatePipe function. The handle must have GENERIC_READ access to the pipe."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives data read from the pipe. This parameter can be NULL if no data is to be read."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBufferSize",
        "description": "The size of the buffer specified by the lpBuffer parameter, in bytes. This parameter is ignored if lpBuffer is NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpBytesRead",
        "description": "A pointer to a variable that receives the number of bytes read from the pipe. This parameter can be NULL if no data is to be read."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpTotalBytesAvail",
        "description": "A pointer to a variable that receives the total number of bytes available to be read from the pipe. This parameter can be NULL if no data is to be read."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpBytesLeftThisMessage",
        "description": "A pointer to a variable that receives the number of bytes remaining in this message. This parameter will be zero for byte-type named pipes or for anonymous pipes. This parameter can be NULL if no data is to be read."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to control local buffering.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. For an example, see  Named Pipe Client. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "SetNamedPipeHandleState",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to the named pipe instance. This parameter can be a handle to the server end of the pipe, as returned by the  CreateNamedPipe function, or to the client end of the pipe, as returned by the  CreateFile function. The handle must have GENERIC_WRITE access to the named pipe for a write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.     This parameter can also be a handle to an anonymous pipe, as returned by the  CreatePipe function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPDWORD",
        "name": "lpMode",
        "description": "The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag. This parameter can be NULL if the mode is not being set. Specify one of the following modes.     ModeMeaning  PIPE_READMODE_BYTE 0x00000000   Data is read from the pipe as a stream of bytes. This mode is the default if no read-mode flag is specified.   PIPE_READMODE_MESSAGE 0x00000002   Data is read from the pipe as a stream of messages. The function fails if this flag is specified for a byte-type pipe.     One of the following wait modes can be specified.  ModeMeaning  PIPE_WAIT 0x00000000   Blocking mode is enabled. This mode is the default if no wait-mode flag is specified. When a blocking mode pipe handle is specified in the  ReadFile,  WriteFile, or  ConnectNamedPipe function, operations are not finished until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.   PIPE_NOWAIT 0x00000001   Nonblocking mode is enabled. In this mode, ReadFile, WriteFile, and  ConnectNamedPipe always return immediately. Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous input and output (I/O) with named pipes."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPDWORD",
        "name": "lpMaxCollectionCount",
        "description": "The maximum number of bytes collected on the client computer before transmission to the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same machine. This parameter is ignored if the client process specifies the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if the collection count is not being set."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPDWORD",
        "name": "lpCollectDataTimeout",
        "description": "The maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the client process specified the FILE_FLAG_WRITE_THROUGH flag in the  CreateFile function when the handle was created. This parameter can be NULL if the collection count is not being set."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Combines the functions that write a message to and read a message from the specified named pipe into a single network operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. If the message to be read is longer than the buffer specified by the nOutBufferSize parameter,  TransactNamedPipe returns FALSE and the GetLastError function returns ERROR_MORE_DATA. The remainder of the message can be read by a subsequent call to ReadFile, ReadFileEx, or  PeekNamedPipe. ",
    "remarks": "TransactNamedPipe fails if the server did not create the pipe as a message-type pipe or if the pipe handle is not in message-read mode. For example, if a client is running on the same machine as the server and uses the \\\\.\\pipe\\pipename format to open the pipe, the pipe is opened in byte mode by the named pipe file system (NPFS). If the client uses the form \\\\server\\pipe\\pipename, the redirector opens the pipe in message mode. A byte mode pipe handle can be changed to message-read mode with the  SetNamedPipeHandleState function. The function cannot be completed successfully until data is written into the buffer specified by the lpOutBuffer parameter. The lpOverlapped parameter is available to enable the calling thread to perform other tasks while the operation is executing in the background. The maximum guaranteed size of a named pipe transaction is 64 kilobytes. In some limited cases, transactions beyond 64 kilobytes are possible, depending on OS versions participating in the transaction and dynamic network conditions. However, there is no guarantee that transactions above 64 kilobytes will succeed. Therefore it's recommended that named pipe transactions be limited to 64 kilobytes of data. For an example, see  Transactions on Named Pipes. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "TransactNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hNamedPipe",
        "description": "A handle to the named pipe returned by the  CreateNamedPipe or  CreateFile function.     This parameter can also be a handle to an anonymous pipe, as returned by the  CreatePipe function."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpInBuffer",
        "description": "A pointer to the buffer containing the data to be written to the pipe."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nInBufferSize",
        "description": "The size of the input buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpOutBuffer",
        "description": "A pointer to the buffer that receives the data read from the pipe."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nOutBufferSize",
        "description": "The size of the output buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpBytesRead",
        "description": "A pointer to the variable that receives the number of bytes read from the pipe.     If lpOverlapped is NULL, lpBytesRead cannot be NULL. If lpOverlapped is not NULL, lpBytesRead can be NULL. If this is an overlapped read operation, you can get the number of bytes read by calling  GetOverlappedResult. If hNamedPipe is associated with an I/O completion port, you can get the number of bytes read by calling  GetQueuedCompletionStatus."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure. This structure is required if hNamedPipe was opened with FILE_FLAG_OVERLAPPED.     If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must point to a valid OVERLAPPED structure. If hNamedPipe was created with FILE_FLAG_OVERLAPPED and lpOverlapped is NULL, the function can incorrectly report that the operation is complete. If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL,  TransactNamedPipe is executed as an overlapped operation. The OVERLAPPED structure should contain a manual-reset event object (which can be created by using the  CreateEvent function). If the operation cannot be completed immediately,  TransactNamedPipe returns FALSE and GetLastError returns ERROR_IO_PENDING. In this situation, the event object is set to the nonsignaled state before  TransactNamedPipe returns, and it is set to the signaled state when the transaction has finished. Also, you can  be notified when an overlapped operation completes by using the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx functions.  In this case, you do not need to assign the manual-reset event in the OVERLAPPED structure, and the completion happens against hNamedPipe in the same way as an asynchronous read or write operation. For more information about overlapped operations, see  Pipes. If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED,  TransactNamedPipe does not return until the operation is complete."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending  ConnectNamedPipe operation on the pipe).",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero. If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If no instances of the specified named pipe exist, the  WaitNamedPipe function returns immediately, regardless of the time-out value. If the time-out interval expires, the WaitNamedPipe function will fail with the error ERROR_SEM_TIMEOUT. If the function succeeds, the process should use the CreateFile function to open a handle to the named pipe. A return value of TRUE indicates that there is at least one instance of the pipe available. A subsequent CreateFile call to the pipe can fail, because the instance was closed by the server or opened by another client. For an example, see  Named Pipe Client. ",
    "return_type": "BOOL",
    "category": "Pipes",
    "name": "WaitNamedPipe",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNamedPipeName",
        "description": "The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the servername if the pipe is local. The following pipe name format is used:     \\\\servername\\pipe\\pipename"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nTimeOut",
        "description": "The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.     ValueMeaning  NMPWAIT_USE_DEFAULT_WAIT 0x00000000   The time-out interval is the default value specified by the server process in the  CreateNamedPipe function.   NMPWAIT_WAIT_FOREVER 0xffffffff   The function does not return until an instance of the named pipe is available."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]