[
  {
    "n_arguments": 5,
    "description": "Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: long If the function succeeds, the return value is a positive value. If the function is unable to broadcast the message, the return value is \u00e2\u0080\u00931. If the dwFlags parameter is BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "If BSF_QUERY is not specified, the function sends the specified message to all requested recipients, ignoring values returned by those recipients. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. For an example, see Terminating a Process. ",
    "return_type": "long",
    "category": "Messages and Message Queues",
    "name": "BroadcastSystemMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD The broadcast option. This parameter can be one or more of the following values.  ValueMeaning  BSF_ALLOWSFW 0x00000080    Enables the recipient to set the foreground window while processing the message.   BSF_FLUSHDISK 0x00000004   Flushes the disk after each recipient processes the message.   BSF_FORCEIFHUNG 0x00000020   Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.   BSF_IGNORECURRENTTASK 0x00000002   Does not send the message to windows that belong to the current task. This prevents an application from receiving its own message.   BSF_NOHANG 0x00000008   Forces a nonresponsive application to time out. If one of the recipients times out, do not continue broadcasting the message.   BSF_NOTIMEOUTIFNOTHUNG 0x00000040   Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.   BSF_POSTMESSAGE 0x00000010   Posts the message. Do not use in combination with BSF_QUERY.   BSF_QUERY 0x00000001   Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.   BSF_SENDNOTIFYMESSAGE 0x00000100    Sends the message using SendNotifyMessage function. Do not use in combination with BSF_QUERY."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "lpdwRecipients",
        "description": "Type: LPDWORD A pointer to a variable that contains and receives information about the recipients of the message.                       When the function returns, this variable receives a combination of these values identifying which recipients actually received the message.  If this parameter is NULL, the function broadcasts to all components.  This parameter can be one or more of the following values.  ValueMeaning  BSM_ALLCOMPONENTS 0x00000000   Broadcast to all system components.   BSM_ALLDESKTOPS 0x00000010    Broadcast to all desktops. Requires the SE_TCB_NAME privilege.   BSM_APPLICATIONS 0x00000008   Broadcast to applications."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uiMessage",
        "description": "Type: UINT The message to be sent.  For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.",
    "library": "User32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: long If the function succeeds, the return value is a positive value. If the function is unable to broadcast the message, the return value is \u00e2\u0080\u00931. If the dwFlags parameter is BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "If BSF_QUERY is not specified, the function sends the specified message to all requested recipients, ignoring values returned by those recipients. If the caller's thread is on a desktop other than that of the window that denied the request, the caller must call SetThreadDesktop(hdesk) to query anything on that window. Also, the caller must call CloseDesktop on the returned hdesk handle. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. ",
    "return_type": "long",
    "category": "Messages and Message Queues",
    "name": "BroadcastSystemMessageEx",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD The broadcast option. This parameter can be one or more of the following values.  ValueMeaning  BSF_ALLOWSFW 0x00000080   Enables the recipient to set the foreground window while processing the message.   BSF_FLUSHDISK 0x00000004   Flushes the disk after each recipient processes the message.   BSF_FORCEIFHUNG 0x00000020   Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.   BSF_IGNORECURRENTTASK 0x00000002   Does not send the message to windows that belong to the current task. This prevents an application from receiving its own message.   BSF_LUID 0x00000400    If BSF_LUID is set, the message is sent to the window that has the same LUID as specified in the luid member of the BSMINFO structure. Windows 2000:  This flag is not supported.   BSF_NOHANG 0x00000008   Forces a nonresponsive application to time out. If one of the recipients times out, do not continue broadcasting the message.   BSF_NOTIMEOUTIFNOTHUNG 0x00000040   Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.   BSF_POSTMESSAGE 0x00000010   Posts the message. Do not use in combination with BSF_QUERY.   BSF_RETURNHDESK 0x00000200    If access is denied and both this and BSF_QUERY are set, BSMINFO returns both the desktop handle and the window handle. If access is denied and only BSF_QUERY is set, only the window handle is returned by BSMINFO. Windows 2000:  This flag is not supported.   BSF_QUERY 0x00000001   Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.    BSF_SENDNOTIFYMESSAGE 0x00000100   Sends the message using SendNotifyMessage function. Do not use in combination with BSF_QUERY."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "lpdwRecipients",
        "description": "Type: LPDWORD A pointer to a variable that contains and receives information about the recipients of the message.   \t\t\t\t\t When the function returns, this variable receives a combination of these values identifying which recipients actually received the message. If this parameter is NULL, the function broadcasts to all components.  This parameter can be one or more of the following values.  ValueMeaning  BSM_ALLCOMPONENTS 0x00000000   Broadcast to all system components.   BSM_ALLDESKTOPS 0x00000010   Broadcast to all desktops. Requires the SE_TCB_NAME privilege.   BSM_APPLICATIONS 0x00000008   Broadcast to applications."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uiMessage",
        "description": "Type: UINT The message to be sent.  For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PBSMINFO",
        "name": "pBSMInfo",
        "description": "Type: PBSMINFO A pointer to a BSMINFO structure that contains additional information if the request is denied and dwFlags is set to BSF_QUERY."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: LRESULT The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored. ",
    "remarks": "The MSG structure must contain valid message values. If the lpmsg parameter points to a WM_TIMER message and the lParam parameter of the WM_TIMER message is not NULL, lParam points to a function that is called instead of the window procedure. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface. For an example, see Creating a Message Loop. ",
    "return_type": "LRESULT",
    "category": "Messages and Message Queues",
    "name": "DispatchMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MSG*",
        "name": "lpmsg",
        "description": "Type: const MSG* A pointer to a structure that contains the message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Determines whether there are mouse-button or keyboard messages in the calling thread's message queue.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the queue contains one or more new mouse-button or keyboard messages, the return value is nonzero. If there are no new mouse-button or keyboard messages in the queue, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "GetInputState",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the function retrieves a message other than WM_QUIT, the return value is nonzero. If the function retrieves the WM_QUIT message, the return value is zero. If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer. To get extended error information, call GetLastError. Because the return value can be nonzero, zero, or -1, avoid code like this: The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this: ",
    "remarks": "An application typically uses the return value to determine whether to end the main message loop and exit the program. The GetMessage function retrieves messages associated with the window identified by the hWnd parameter or any of its children, as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system. Note that GetMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax. During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order: To retrieve input messages before posted messages, use the wMsgFilterMin and wMsgFilterMax parameters. GetMessage does not remove WM_PAINT messages from the queue. The messages remain in the queue until processed. If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window. For an example, see Creating a Message Loop. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "GetMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPMSG",
        "name": "lpMsg",
        "description": "Type: LPMSG A pointer to an MSG structure that receives message information from the thread's message queue."
      },
      {
        "in_out": "_In_opt_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose messages are to be retrieved. The window must belong to the current thread.   If hWnd is NULL, GetMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed.  If hWnd is -1, GetMessage retrieves only messages on the current thread's message queue whose hwnd value is NULL,  that is, thread messages as posted by  PostMessage (when the hWnd parameter is NULL) or PostThreadMessage."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "wMsgFilterMin",
        "description": "Type: UINT The integer value of the lowest message value to be retrieved. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.  Use WM_INPUT here and in wMsgFilterMax to specify only the WM_INPUT messages. If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed)."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "wMsgFilterMax",
        "description": "Type: UINT The integer value of the highest message value to be retrieved. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.  \t\t\t\t\t Use WM_INPUT here and in wMsgFilterMin to specify only the WM_INPUT messages. If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread's message queue.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: LPARAM The return value specifies the extra information. The meaning of the extra information is device specific. ",
    "remarks": "To set a thread's extra message information, use the SetMessageExtraInfo function. ",
    "return_type": "LPARAM",
    "category": "Messages and Message Queues",
    "name": "GetMessageExtraInfo",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the cursor position for the last message retrieved by the GetMessage function.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: DWORD The return value specifies the x- and y-coordinates of the cursor position. The x-coordinate is the low order short and the y-coordinate is the high-order short. ",
    "remarks": "As noted above, the x-coordinate is in the low-order short of the return value; the y-coordinate is in the high-order short (both represent signed values because they can take negative values on systems with multiple monitors). If the return value is assigned to a variable, you can use the MAKEPOINTS macro to obtain a POINTS structure from the return value. You can also use the GET_X_LPARAM or GET_Y_LPARAM macro to extract the x- or y-coordinate. ",
    "return_type": "DWORD",
    "category": "Messages and Message Queues",
    "name": "GetMessagePos",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Retrieves the message time for the last message retrieved by the GetMessage function. The time is a long integer that specifies the elapsed time, in milliseconds, from the time the system was started to the time the message was created (that is, placed in the thread's message queue).",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: LONG The return value specifies the message time. ",
    "remarks": "The return value from the GetMessageTime function does not necessarily increase between subsequent messages, because the value wraps to wraps to the minimum value for a long integer if the timer count exceeds the maximum value for a long integer. To calculate time delays between messages, subtract the time of the first message from the time of the second message (ignoring overflow) and compare the result of the subtraction against the desired delay amount. ",
    "return_type": "LONG",
    "category": "Messages and Message Queues",
    "name": "GetMessageTime",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the type of messages found in the calling thread's message queue.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: DWORD The high-order word of the return value indicates the types of messages currently in the queue. The low-order word indicates the types of messages that have been added to the queue and that are still in the queue since the last call to the GetQueueStatus, GetMessage, or PeekMessage function. ",
    "remarks": "The presence of a QS_ flag in the return value does not guarantee that a subsequent call to the GetMessage or PeekMessage function will return a message. GetMessage and PeekMessage perform some internal filtering that may cause the message to be processed internally. For this reason, the return value from GetQueueStatus should be considered only a hint as to whether GetMessage or PeekMessage should be called. The QS_ALLPOSTMESSAGE and QS_POSTMESSAGE flags differ in when they are cleared. QS_POSTMESSAGE is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages. QS_ALLPOSTMESSAGE is cleared when you call GetMessage or PeekMessage without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be useful when you call PeekMessage multiple times to get messages in different ranges. ",
    "return_type": "DWORD",
    "category": "Messages and Message Queues",
    "name": "GetQueueStatus",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "flags",
        "description": "Type: UINT The types of messages for which to check. This parameter can be one or more of the following values.  ValueMeaning  QS_ALLEVENTS (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY)   An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue.   QS_ALLINPUT (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE)   Any message is in the queue.   QS_ALLPOSTMESSAGE 0x0100   A posted message (other than those listed here) is in the queue.   QS_HOTKEY 0x0080   A WM_HOTKEY message is in the queue.   QS_INPUT (QS_MOUSE | QS_KEY | QS_RAWINPUT)   An input message is in the queue.   QS_KEY 0x0001   A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.   QS_MOUSE (QS_MOUSEMOVE | QS_MOUSEBUTTON)   A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).   QS_MOUSEBUTTON 0x0004   A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).   QS_MOUSEMOVE 0x0002   A WM_MOUSEMOVE message is in the queue.   QS_PAINT 0x0020   A WM_PAINT message is in the queue.   QS_POSTMESSAGE 0x0008   A posted message (other than those listed here) is in the queue.   QS_RAWINPUT 0x0400   A raw input message is in the queue. For more information, see Raw Input. Windows 2000:  This flag is not supported.   QS_SENDMESSAGE 0x0040   A message sent by another thread or application is in the queue.   QS_TIMER 0x0010   A WM_TIMER message is in the queue."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process) by a call to the SendMessage function.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the window procedure is processing a message sent to it from another thread using the SendMessage function, the return value is nonzero. If the window procedure is not processing a message sent to it from another thread using the SendMessage function, the return value is zero. For an example, see Sending a Message. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "InSendMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process).",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: DWORD If the message was not sent, the return value is ISMEX_NOSEND (0x00000000). Otherwise, the return value is one or more of the following values.  ",
    "remarks": "To determine if the sender is blocked, use the following test: fBlocked = ( InSendMessageEx(NULL) & (ISMEX_REPLIED|ISMEX_SEND) ) == ISMEX_SEND; ",
    "return_type": "DWORD",
    "category": "Messages and Message Queues",
    "name": "InSendMessageEx",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Reserved_",
        "type": "LPVOID",
        "name": "lpReserved",
        "description": "Type: LPVOID Reserved; must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If a message is available, the return value is nonzero. If no messages are available, the return value is zero. ",
    "remarks": "PeekMessage retrieves messages associated with the window identified by the hWnd parameter or any of its children as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system. Note that PeekMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax. During this call, the system delivers pending,  nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order: To retrieve input messages before posted messages, use the wMsgFilterMin and wMsgFilterMax parameters. The PeekMessage function normally does not remove WM_PAINT messages from the queue. WM_PAINT messages remain in the queue until they are processed. However, if a WM_PAINT message has a NULL update region, PeekMessage does remove it from the queue. If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When an application is being debugged, the system does not generate a ghost window. For an example, see Examining a Message Queue. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "PeekMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPMSG",
        "name": "lpMsg",
        "description": "Type: LPMSG A pointer to an MSG structure that receives message information."
      },
      {
        "in_out": "_In_opt_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose messages are to be retrieved. The window must belong to the current thread.    If hWnd is NULL, PeekMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed.  If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is NULL, that is, thread messages as posted by  PostMessage (when the hWnd parameter is NULL) or PostThreadMessage."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "wMsgFilterMin",
        "description": "Type: UINT The value of the first message in the range of messages to be examined. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message. If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed)."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "wMsgFilterMax",
        "description": "Type: UINT The value of the last message in the range of messages to be examined. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message. If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed)."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "wRemoveMsg",
        "description": "Type: UINT Specifies how messages are to be handled. This parameter can be one or more of the following values.  ValueMeaning  PM_NOREMOVE 0x0000   Messages are not removed from the queue after processing by PeekMessage.   PM_REMOVE 0x0001   Messages are removed from the queue after processing by PeekMessage.   PM_NOYIELD 0x0002   Prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle). Combine this value with either PM_NOREMOVE or PM_REMOVE.      By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following values.  ValueMeaning  PM_QS_INPUT (QS_INPUT << 16)    Process mouse and keyboard messages.   PM_QS_PAINT (QS_PAINT << 16)    Process paint messages.   PM_QS_POSTMESSAGE ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16)    Process all posted messages, including timers and hotkeys.     PM_QS_SENDMESSAGE (QS_SENDMESSAGE << 16)    Process all sent messages."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit. ",
    "remarks": "When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied). Messages in a message queue are retrieved by calls to the GetMessage or PeekMessage function. Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. Do not post the WM_QUIT message using PostMessage; use the PostQuitMessage function. An accessibility application can use PostMessage to post WM_APPCOMMAND messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications. There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large.  If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.  The minimum acceptable value is 4000. The following example shows how to post a private window message using the PostMessage function. Assume you defined a private window message called WM_COMPLETE: You can post a message to the message queue associated with the thread that created the specified window as shown below: For more examples, see Initiating a Data Link. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "PostMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose window procedure is to receive the message. The following values have special meanings.  ValueMeaning  HWND_BROADCAST ((HWND)0xffff)   The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.    NULL   The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of the current thread.     Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues of threads in processes of lesser or equal integrity level."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "Msg",
        "description": "Type: UINT The message to be posted. For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The PostQuitMessage function posts a WM_QUIT message to the thread's message queue and returns immediately; the function simply indicates to the system that the thread is requesting to quit at some time in the future. When the thread retrieves the WM_QUIT message from its message queue, it should exit its message loop and return control to the system. The exit value returned to the system must be the wParam parameter of the WM_QUIT message. For an example, see Posting a Message. ",
    "return_type": "VOID",
    "category": "Messages and Message Queues",
    "name": "PostQuitMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nExitCode",
        "description": "Type: int The application exit code. This value is used as the wParam parameter of the WM_QUIT message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_THREAD_ID if idThread is not a valid thread identifier, or if the thread specified by idThread does not have a message queue. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit. ",
    "remarks": "When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied). The thread to which the message is posted must have created a message queue, or else the call to PostThreadMessage fails. Use the following method to handle this situation. The thread to which the message is posted retrieves the message by calling the GetMessage or PeekMessage function. The hwnd member of the returned MSG structure is NULL. Messages sent by PostThreadMessage are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.  The minimum acceptable value is 4000. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "PostThreadMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "idThread",
        "description": "Type: DWORD The identifier of the thread to which the message is to be posted. The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section. Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.  This thread must have the SE_TCB_NAME privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.  This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "Msg",
        "description": "Type: UINT The type of message to be posted."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: UINT If the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "The RegisterWindowMessage function is typically used to register messages for communicating between two cooperating applications. If two different applications register the same message string, the applications return the same message value. The message remains registered until the session ends. Only use RegisterWindowMessage when more than one application must process the same message. For sending private messages within a window class, an application can use any integer in the range WM_USER through 0x7FFF. (Messages in this range are private to a window class, not to an application. For example, predefined control classes such as BUTTON, EDIT, LISTBOX, and COMBOBOX may use values in this range.) For an example, see Finding Text. ",
    "return_type": "UINT",
    "category": "Messages and Message Queues",
    "name": "RegisterWindowMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "Type: LPCTSTR The message to be registered."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Replies to a message sent from another thread by the SendMessage function.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the calling thread was processing a message sent from another thread or process, the return value is nonzero. If the calling thread was not processing a message sent from another thread or process, the return value is zero. ",
    "remarks": "By calling this function, the window procedure that receives the message allows the thread that called SendMessage to continue to run as though the thread receiving the message had returned control. The thread that calls the ReplyMessage function also continues to run. If the message was not sent through SendMessage or if the message was sent by the same thread, ReplyMessage has no effect. For an example, see Sending a Message. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "ReplyMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LRESULT",
        "name": "lResult",
        "description": "Type: LRESULT The result of the message processing. The possible values are based on the message sent."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "An application-defined callback function used with the SendMessageCallback function. The system passes the message to the callback function after passing the message to the destination window procedure. The SENDASYNCPROC type defines a pointer to this callback function. SendAsyncProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "This callback function does not return a value. ",
    "remarks": "You install a SendAsyncProc application-defined callback function by passing a SENDASYNCPROC pointer to the SendMessageCallback function. The callback function is only called when the thread that called SendMessageCallback calls GetMessage, PeekMessage, or WaitMessage. ",
    "return_type": "VOID CALLBACK",
    "category": "Messages and Message Queues",
    "name": "SendAsyncProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwnd",
        "description": "Type: HWND A handle to the window whose window procedure received the message.  If the SendMessageCallback function was called with its hwnd parameter set to HWND_BROADCAST, the system calls the SendAsyncProc function once for each top-level window."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uMsg",
        "description": "Type: UINT The message."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "dwData",
        "description": "Type: ULONG_PTR An application-defined value sent from the SendMessageCallback function."
      },
      {
        "in_out": "_In_",
        "type": "LRESULT",
        "name": "lResult",
        "description": "Type: LRESULT The result of the message processing. This value depends on the message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: LRESULT The return value specifies the result of the message processing; it depends on the message sent. ",
    "remarks": "When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied). Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set. For more information on nonqueued messages, see Nonqueued Messages. An accessibility application can use SendMessage to send WM_APPCOMMAND messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications. For an example, see Displaying Keyboard Input. ",
    "return_type": "LRESULT",
    "category": "Messages and Message Queues",
    "name": "SendMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.  Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "Msg",
        "description": "Type: UINT The message to be sent. For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Sends the specified message to a window or windows. It calls the window procedure for the specified window and returns immediately if the window belongs to another thread. After the window procedure processes the message, the system calls the specified callback function, passing the result of the message processing and an application-defined value to the callback function.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the callback function is called only when the thread that called SendMessageCallback also calls GetMessage, PeekMessage, or WaitMessage. If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "SendMessageCallback",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "Msg",
        "description": "Type: UINT The message to be sent. For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "SENDASYNCPROC",
        "name": "lpCallBack",
        "description": "Type: SENDASYNCPROC A pointer to a callback function that the system calls after the window procedure processes the message. For more information, see SendAsyncProc.                        If hWnd is HWND_BROADCAST ((HWND)0xffff), the system calls the SendAsyncProc callback function once for each top-level window."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "dwData",
        "description": "Type: ULONG_PTR An application-defined value to be sent to the callback function pointed to by the lpCallBack parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Sends the specified message to one or more windows.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: LRESULT If the function succeeds, the return value is nonzero. SendMessageTimeout does not provide information about individual windows timing out if HWND_BROADCAST is used. If the function fails or times out, the return value is 0. To get extended error information, call GetLastError. If GetLastError returns ERROR_TIMEOUT, then the function timed out. Windows 2000:  If GetLastError returns 0, then the function timed out. ",
    "remarks": "The function calls the window procedure for the specified window and, if the specified window belongs to a different thread, does not return until the window procedure has processed the message or the specified time-out period has elapsed. If the window receiving the message belongs to the same queue as the current thread, the window procedure is called directly\u00e2\u0080\u0094the time-out value is ignored. This function considers that a thread is not responding if it has not called GetMessage or a similar function within five seconds. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. ",
    "return_type": "LRESULT",
    "category": "Messages and Message Queues",
    "name": "SendMessageTimeout",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of uTimeout multiplied by the number of top-level windows."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "Msg",
        "description": "Type: UINT The message to be sent. For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Any additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Any additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuFlags",
        "description": "Type: UINT The behavior of this function. This parameter can be one or more of the following values.  ValueMeaning  SMTO_ABORTIFHUNG 0x0002   The function returns without waiting for the time-out period to elapse if the receiving thread appears to not respond or \"hangs.\"   SMTO_BLOCK 0x0001   Prevents the calling thread from processing any other requests until the function returns.   SMTO_NORMAL 0x0000   The calling thread is not prevented from processing other requests while waiting for the function to return.   SMTO_NOTIMEOUTIFNOTHUNG 0x0008   The function does not enforce the time-out period as long as the receiving thread is processing messages.   SMTO_ERRORONEXIT 0x0020   The function should return 0 if the receiving window is destroyed or its owning thread dies while the message is being processed."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uTimeout",
        "description": "Type: UINT The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PDWORD_PTR",
        "name": "lpdwResult",
        "description": "Type: PDWORD_PTR The result of the message processing. The value of this parameter depends on the message that is specified."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sends the specified message to a window or windows. If the window was created by the calling thread, SendNotifyMessage calls the window procedure for the window and does not return until the window procedure has processed the message. If the window was created by a different thread, SendNotifyMessage passes the message to the window procedure and returns immediately; it does not wait for the window procedure to finish processing the message.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "SendNotifyMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Type: HWND A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "Msg",
        "description": "Type: UINT The message to be sent. For lists of the system-provided messages, see System-Defined Messages."
      },
      {
        "in_out": "_In_",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Type: WPARAM Additional message-specific information."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM Additional message-specific information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread's message queue. An application can use the GetMessageExtraInfo function to retrieve a thread's extra message information.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: LPARAM The return value is the previous value associated with the current thread. ",
    "remarks": "",
    "return_type": "LPARAM",
    "category": "Messages and Message Queues",
    "name": "SetMessageExtraInfo",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Type: LPARAM The value to be associated with the current thread."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Yields control to other threads when a thread has no other messages in its message queue. The WaitMessage function suspends the thread and does not return until a new message is placed in the thread's message queue.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "Type: Type: BOOL If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "Note that WaitMessage does not return if there is unread input in the message queue after the thread has called a function to check the queue. This is because functions such as PeekMessage, GetMessage, GetQueueStatus, WaitMessage, MsgWaitForMultipleObjects, and MsgWaitForMultipleObjectsEx check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to WaitMessage will not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored. ",
    "return_type": "BOOL",
    "category": "Messages and Message Queues",
    "name": "WaitMessage",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]