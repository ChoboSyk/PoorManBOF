[
  {
    "n_arguments": 2,
    "description": "Adds user keys to the specified encrypted file.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. For example code that uses this function, see Adding Users to an Encrypted File. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "AddUsersToEncryptedFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the encrypted file."
      },
      {
        "in_out": "_In_",
        "type": "PENCRYPTION_CERTIFICATE_LIST",
        "name": "pUsers",
        "description": "A pointer to an  ENCRYPTION_CERTIFICATE_LIST structure that contains the list of new user keys to be added to the file."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Determines whether the file I/O functions are using the ANSI or OEM character set code      page. This function is useful for 8-bit console input and output operations.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the set of file I/O functions is using the ANSI code page, the return value is nonzero. If the set of file I/O functions is using the OEM code page, the return value is zero. ",
    "remarks": "The SetFileApisToOEM function causes a set of file      I/O functions to use the OEM code page. The      SetFileApisToANSI function causes the same set of file      I/O functions to use the ANSI code page. Use the AreFileApisANSI function to      determine which code page the set of file I/O functions is currently using. For a discussion of these functions'      usage, please see the Remarks sections of      SetFileApisToOEM and      SetFileApisToANSI. The file I/O functions whose code page is ascertained by AreFileApisANSI are      those functions exported by KERNEL32.DLL that accept or return a file name. The functions SetFileApisToOEM and      SetFileApisToANSI set the code page for a process, so      AreFileApisANSI returns a value indicating the code page of an entire      process. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "AreFileApisANSI",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The function does not cancel I/O operations that other threads issue for a file handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "IoAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued by the calling thread for the specified file handle was successfully requested. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have been completed. If the function fails, the return value is zero (0). To get extended error information, call  the GetLastError function. ",
    "remarks": "If there are any pending I/O operations in progress for the specified file handle, and they are issued by the calling thread, the CancelIo function cancels them. CancelIo cancels only outstanding I/O on the handle, it does not change the state of the handle; this means that you cannot rely on the state of the handle because you cannot know whether the operation was completed successfully or canceled. The I/O operations must be issued as overlapped I/O. If they are not, the I/O operations do not  return to allow the thread to call the  CancelIo function. Calling the  CancelIo function with a file handle that is not opened with FILE_FLAG_OVERLAPPED does nothing. All I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED, and all completion notifications for the I/O operations occur normally. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CancelIo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file.  The function cancels all pending I/O operations for this file handle."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O      operations in the current process, regardless of which thread created the I/O operation.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "IoAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations         issued by the calling process for the specified file handle was successfully requested. The application must not         free or reuse the OVERLAPPED structure associated with         the canceled I/O operations until they have completed. The thread can use the         GetOverlappedResult function to determine when         the I/O operations themselves have been completed. If the function fails, the return value is 0 (zero). To get extended error information, call the         GetLastError function. If this function cannot find a request to cancel, the return value is 0 (zero), and         GetLastError returns         ERROR_NOT_FOUND. ",
    "remarks": "The CancelIoEx function allows you to cancel      requests in threads other than the calling thread. The      CancelIo function only cancels requests in the same thread that      called the CancelIo function.      CancelIoEx cancels only outstanding I/O on the handle,      it does not change the state of the handle; this means that you cannot rely on the state of the handle because you      cannot know whether the operation was completed successfully or canceled. If there are any pending I/O operations in progress for the specified file handle, the      CancelIoEx function marks them for cancellation. Most      types of operations can be canceled immediately; other operations can continue toward completion before they are      actually canceled and the caller is notified. The      CancelIoEx function does not wait for all canceled      operations to complete. If the file handle is associated with a completion port, an I/O completion packet is not queued to the port if      a synchronous operation is successfully canceled. For asynchronous operations still pending, the cancel operation      will queue an I/O completion packet. The operation being canceled is completed with one of three statuses; you must check the completion status to      determine the completion state. The three statuses are: In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CancelIoEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED data structure that         contains the data used for asynchronous  I/O. If this parameter is NULL, all I/O requests for the hFile         parameter are canceled. If this parameter is not NULL, only those specific I/O requests that were issued         for the file with the specified lpOverlapped overlapped structure are marked as         canceled, meaning that you can cancel one or more requests, while the         CancelIo function cancels all outstanding requests on a file         handle."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Marks pending synchronous I/O operations that are issued by the specified thread as      canceled.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "IoAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call the         GetLastError function. If this function cannot find a request to cancel, the return value is 0 (zero), and         GetLastError returns         ERROR_NOT_FOUND. ",
    "remarks": "The caller must have the      THREAD_TERMINATE access right. If there are any pending I/O operations in progress for the specified thread, the      CancelSynchronousIo function marks them for      cancellation. Most types of operations can be canceled immediately; other operations can continue toward      completion before they are actually canceled and the caller is notified. The      CancelSynchronousIo function does not wait for      all canceled operations to complete. For more information, see      I/O Completion/Cancellation Guidelines. The operation being canceled is completed with one of three statuses; you must check the completion status to      determine the completion state. The three statuses are: In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CancelSynchronousIo",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "A handle to the thread."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Determines whether the  specified name can be used to create a file on a FAT file     system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call         GetLastError. ",
    "remarks": "This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based      application or an MS-DOS-based application. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail). ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CheckNameLegalDOS8Dot3",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "The file name, in 8.3 format."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPSTR",
        "name": "lpOemName",
        "description": "A pointer to a buffer that receives the OEM string that corresponds to Name. This        parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "OemNameSize",
        "description": "The size of the lpOemName buffer, in characters. If        lpOemName is NULL, this parameter must be 0 (zero)."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PBOOL",
        "name": "pbNameContainsSpaces",
        "description": "Indicates whether or not a name contains spaces. This parameter can be NULL. If        the name is not a valid 8.3 FAT file system name, this parameter is undefined."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOL",
        "name": "pbNameLegal",
        "description": "If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when        the current OEM code page is applied to the file name."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Copies an existing file to a new file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The security resource properties (ATTRIBUTE_SECURITY_INFORMATION) for the existing file are       copied to the new file. Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  Security resource properties for the existing file are not copied to the new file until        Windows 8 and Windows Server 2012. File attributes for the existing file are copied to the new file. For example, if an existing file has the      FILE_ATTRIBUTE_READONLY file attribute, a copy created through a call to      CopyFile will also have the      FILE_ATTRIBUTE_READONLY file attribute. For more information, see      Retrieving and Changing File Attributes. This function fails with ERROR_ACCESS_DENIED if the destination file already exists      and has the FILE_ATTRIBUTE_HIDDEN or FILE_ATTRIBUTE_READONLY      attribute set. When CopyFile is used to copy an encrypted file, it attempts       to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,       this function attempts to encrypt the destination file with default keys. If       neither of these methods can be done, CopyFile fails with an       ERROR_ENCRYPTION_FAILED error code. Symbolic link behavior\u00e2\u0080\u0094If the source file is a symbolic link, the actual file copied is       the target of the symbolic link. If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten       by the source file. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see       Retrieving and Changing File Attributes. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CopyFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The name of an existing file. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (CopyFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details.   If lpExistingFileName does not exist,        CopyFile fails, and        GetLastError returns        ERROR_FILE_NOT_FOUND."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The name of the new file. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (CopyFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bFailIfExists",
        "description": "If this parameter is TRUE and the new file specified by        lpNewFileName already exists, the function fails. If this parameter is        FALSE and the new file already exists, the function overwrites the existing file and        succeeds."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Copies an existing file to a new file, notifying the application of its progress through a callback      function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value will return TRUE when passed to the        SUCCEEDED macro.  ",
    "remarks": "This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,      and file attributes. Security attributes for the existing file are not copied to the new file. To copy security      attributes, use the SHFileOperation function. This function fails with      HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) if the destination      file already exists and has the FILE_ATTRIBUTE_HIDDEN or      FILE_ATTRIBUTE_READONLY attribute set. To compile an application that uses this function, define the _WIN32_WINNT macro      as _WIN32_WINNT_WIN8 or later. For more information, see      Using the Windows Headers. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "CopyFile2",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pwszExistingFileName",
        "description": "The name of an existing file. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more         information, see Naming Files, Paths, and Namespaces. Tip  Starting in Windows 10, version 1607, you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\".  See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details.    If lpExistingFileName does not exist, the         CopyFile2 function fails returns         HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pwszNewFileName",
        "description": "The name of the new file. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more         information, see Naming Files, Paths, and Namespaces. Tip  Starting in Windows 10, version 1607, you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_opt_",
        "type": "COPYFILE2_EXTENDED_PARAMETERS*",
        "name": "pExtendedParameters",
        "description": "Optional address of a        COPYFILE2_EXTENDED_PARAMETERS        structure."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "An application-defined callback function used with the      CopyFile2 function. It is called when a portion of      a copy or move operation is completed. The PCOPYFILE2_PROGRESS_ROUTINE type defines a      pointer to this callback function.      CopyFile2ProgressRoutine is a placeholder for the      application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Value from the COPYFILE2_MESSAGE_ACTION        enumeration indicating what action should be taken.  ",
    "remarks": "The COPYFILE2_CALLBACK_STREAM_FINISHED message is the last message for a paused      copy. If COPYFILE2_PROGRESS_PAUSE is returned in response to a      COPYFILE2_CALLBACK_STREAM_FINISHED message then no further callbacks will be sent. To compile an application that uses the PCOPYFILE2_PROGRESS_ROUTINE      function pointer type, define the _WIN32_WINNT macro as 0x0601 or later. For more      information, see      Using the Windows Headers. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "COPYFILE2_MESSAGE_ACTION CALLBACK",
    "category": "Files and I/O (Local file system)",
    "name": "CopyFile2ProgressRoutine",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const COPYFILE2_MESSAGE*",
        "name": "pMessage",
        "description": "Pointer to a COPYFILE2_MESSAGE structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "pvCallbackContext",
        "description": "Copy of value passed in the pvCallbackContext member of the        COPYFILE2_EXTENDED_PARAMETERS structure        passed to CopyFile2."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Copies an existing file to a new file, notifying the application of its progress through a callback      function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information call         GetLastError. If lpProgressRoutine returns PROGRESS_CANCEL due to the         user canceling the operation, CopyFileEx will return zero         and GetLastError will return         ERROR_REQUEST_ABORTED. In this case, the partially copied destination file is         deleted. If lpProgressRoutine returns PROGRESS_STOP due to the         user stopping the operation, CopyFileEx will return zero         and GetLastError will return         ERROR_REQUEST_ABORTED. In this case, the partially copied destination file is left         intact. ",
    "remarks": "This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,       security resource attributes, and file attributes. Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  Security resource attributes (ATTRIBUTE_SECURITY_INFORMATION) for the existing file are not copied to the new file until Windows 8        and Windows Server 2012. The security resource properties (ATTRIBUTE_SECURITY_INFORMATION) for the existing file are       copied to the new file. Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  Security resource properties for the existing file are not copied to the new file until        Windows 8 and Windows Server 2012. This function fails with ERROR_ACCESS_DENIED if the destination file already exists      and has the FILE_ATTRIBUTE_HIDDEN or FILE_ATTRIBUTE_READONLY      attribute set. When encrypted files are copied using CopyFileEx, the       function attempts to encrypt the destination file with the keys used in the encryption of the source file. If       this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these       methods cannot be done, CopyFileEx fails with an       ERROR_ENCRYPTION_FAILED error code. If you want       CopyFileEx to complete the copy operation even if the       destination file cannot be encrypted, include the       COPY_FILE_ALLOW_DECRYPTED_DESTINATION as the value of the       dwCopyFlags parameter in your call to       CopyFileEx.  If COPY_FILE_COPY_SYMLINK  is specified, the following rules apply: If COPY_FILE_COPY_SYMLINK is not specified, the following rules apply: Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  If you are writing an application that is optimizing file copy operations across a LAN, consider using the        TransmitFile function from Windows Sockets        (Winsock). TransmitFile supports high-performance        network transfers and provides a simple interface to send the contents of a file to a remote computer. To use        TransmitFile, you must write a Winsock client        application that sends the file from the source computer as well as a Winsock server application that uses        other Winsock functions to receive the file on the remote computer. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CopyFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The name of an existing file.        In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (CopyFileExW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details.    If lpExistingFileName does not exist, the        CopyFileEx function fails, and the        GetLastError function returns        ERROR_FILE_NOT_FOUND."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The name of the new file.        In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend \"\\\\?\\\" to         the path. For more information, see         Naming a File. Tip  Starting inWindows 10, version 1607, for the unicode version of this function (CopyFileExW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPPROGRESS_ROUTINE",
        "name": "lpProgressRoutine",
        "description": "The address of a callback function of type LPPROGRESS_ROUTINE that is called        each time another portion of the file has been copied. This parameter can be NULL. For        more information on the progress callback function, see the        CopyProgressRoutine function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpData",
        "description": "The argument to be passed to the callback function. This parameter can be        NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPBOOL",
        "name": "pbCancel",
        "description": "If this flag is set to TRUE during the copy operation, the operation is canceled.        Otherwise, the copy operation will continue to completion."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCopyFlags",
        "description": "Flags that specify how the file is to be copied. This parameter can be a combination of the following        values.  ValueMeaning  COPY_FILE_ALLOW_DECRYPTED_DESTINATION 0x00000008   An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.   COPY_FILE_COPY_SYMLINK 0x00000800   If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same          file that the source symbolic link is pointing to.          Windows Server 2003 and Windows XP:  This value is not supported.   COPY_FILE_FAIL_IF_EXISTS 0x00000001   The copy operation fails immediately if the target file already exists.   COPY_FILE_NO_BUFFERING 0x00001000   The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended          for very large file transfers.          Windows Server 2003 and Windows XP:  This value is not supported.   COPY_FILE_OPEN_SOURCE_FOR_WRITE 0x00000004   The file is copied and the original file is opened for write access.   COPY_FILE_RESTARTABLE 0x00000002   Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be          restarted at a later time by specifying the same values for lpExistingFileName and          lpNewFileName as those used in the call that failed. This can significantly slow          down the copy operation as the new file may be flushed multiple times during the copy operation."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information call         GetLastError. If lpProgressRoutine returns PROGRESS_CANCEL due to the         user canceling the operation, CopyFileTransacted         will return zero and GetLastError will return         ERROR_REQUEST_ABORTED. In this case, the partially copied destination file is         deleted. If lpProgressRoutine returns PROGRESS_STOP due to the         user stopping the operation, CopyFileTransacted         will return zero and GetLastError will return         ERROR_REQUEST_ABORTED. In this case, the partially copied destination file is left         intact. If you attempt to call this function with a handle to a transaction that has already been rolled back,         CopyFileTransacted will return either         ERROR_TRANSACTION_NOT_ACTIVE or         ERROR_INVALID_TRANSACTION. ",
    "remarks": "This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,       security attributes, and file attributes. Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista:  Security resource attributes (ATTRIBUTE_SECURITY_INFORMATION) for the existing        file are not copied to the new file until Windows 8 and Windows Server 2012. This function fails with ERROR_ACCESS_DENIED if the destination file already exists      and has the  FILE_ATTRIBUTE_HIDDEN or FILE_ATTRIBUTE_READONLY      attribute set. Encrypted files are not supported by TxF.  If COPY_FILE_COPY_SYMLINK is specified, the following rules apply: If COPY_FILE_COPY_SYMLINK is not specified, the following rules apply: Link tracking is not supported by TxF. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Note that SMB 3.0 does not support TxF. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CopyFileTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The name of an existing file. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. If lpExistingFileName does not exist, the         CopyFileTransacted function fails, and the         GetLastError function returns         ERROR_FILE_NOT_FOUND. The file must reside on the local computer; otherwise, the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The name of the new file. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPPROGRESS_ROUTINE",
        "name": "lpProgressRoutine",
        "description": "The address of a callback function of type LPPROGRESS_ROUTINE that is called        each time another portion of the file has been copied. This parameter can be NULL. For        more information on the progress callback function, see the        CopyProgressRoutine function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpData",
        "description": "The argument to be passed to the callback function. This parameter can be        NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPBOOL",
        "name": "pbCancel",
        "description": "If this flag is set to TRUE during the copy operation, the operation is canceled.        Otherwise, the copy operation will continue to completion."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCopyFlags",
        "description": "Flags that specify how the file is to be copied. This parameter can be a combination of the following        values.  ValueMeaning  COPY_FILE_COPY_SYMLINK 0x00000800   If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same          file that the source symbolic link is pointing to.   COPY_FILE_FAIL_IF_EXISTS 0x00000001   The copy operation fails immediately if the target file already exists.   COPY_FILE_OPEN_SOURCE_FOR_WRITE 0x00000004   The file is copied and the original file is opened for write access.   COPY_FILE_RESTARTABLE 0x00000002   Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be          restarted at a later time by specifying the same values for lpExistingFileName and          lpNewFileName as those used in the call that failed. This can significantly slow          down the copy operation as the new file may be flushed multiple times during the copy operation."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "An application-defined callback function used with the      CopyFileEx,      MoveFileTransacted, and      MoveFileWithProgress functions. It is      called when a portion of a copy or move operation is completed. The      LPPROGRESS_ROUTINE type defines a pointer to this callback function.      CopyProgressRoutine is a placeholder for the      application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "The CopyProgressRoutine function should return         one of the following values.  ",
    "remarks": "An application can use this information to display a progress bar that shows the total number of bytes copied      as a percent of the total file size. ",
    "return_type": "DWORD CALLBACK",
    "category": "Files and I/O (Local file system)",
    "name": "CopyProgressRoutine",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "TotalFileSize",
        "description": "The total size of the file, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "TotalBytesTransferred",
        "description": "The total number of bytes transferred from the source file to the destination file since the copy operation        began."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "StreamSize",
        "description": "The total size of the current file stream, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "StreamBytesTransferred",
        "description": "The total number of bytes in the current stream that have been transferred from the source file to the        destination file since the copy operation began."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwStreamNumber",
        "description": "A handle to the current stream. The first time        CopyProgressRoutine is called, the stream number        is 1."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCallbackReason",
        "description": "The reason that CopyProgressRoutine was        called. This parameter can be one of the following values.  ValueMeaning  CALLBACK_CHUNK_FINISHED 0x00000000   Another part of the data file was copied.   CALLBACK_STREAM_SWITCH 0x00000001   Another stream was created and is about to be copied. This is the callback reason given when the callback          routine is first invoked."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hSourceFile",
        "description": "A handle to the source file."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hDestinationFile",
        "description": "A handle to the destination file"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Argument passed to CopyProgressRoutine by        CopyFileEx,        MoveFileTransacted, or        MoveFileWithProgress."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. When moving a file across volumes, if lpProgressRoutine returns         PROGRESS_CANCEL due to the user canceling the operation,         MoveFileTransacted will return zero and         GetLastError will return         ERROR_REQUEST_ABORTED. The existing file is left intact. When moving a file across volumes, if lpProgressRoutine returns         PROGRESS_STOP due to the user stopping the operation,         MoveFileTransacted will return zero and         GetLastError will return         ERROR_REQUEST_ABORTED. The existing file is left intact. ",
    "remarks": "If the dwFlags parameter specifies      MOVEFILE_DELAY_UNTIL_REBOOT,      MoveFileTransacted fails if it cannot access the registry. The      function transactionally stores the locations of the files to be renamed at restart in the following registry      value: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations This registry  value is of type REG_MULTI_SZ. Each rename operation stores one of      the following NULL-terminated strings, depending on whether the rename is a delete or      not: szDstFile\\0\\0 szSrcFile\\0szDstFile\\0 The string szDstFile\\0\\0 indicates that the file       szDstFile is to be deleted on reboot. The string szSrcFile\\0szDstFile\\0 indicates that       szSrcFile is to be renamed szDstFile on reboot. The system uses these registry entries to complete the operations at restart in the same order that they were      issued. For more information about using the MOVEFILE_DELAY_UNTIL_REBOOT flag, see      MoveFileWithProgress. If a file is moved across volumes,      MoveFileTransacted does not move the security      descriptor with the file. The file is assigned the default security descriptor in the destination directory. This function always fails if you specify the MOVEFILE_FAIL_IF_NOT_TRACKABLE flag;      tracking is not supported by TxF. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "MoveFileTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The current name of the existing file or directory on the local computer. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a        different file system or drive. A new directory must be on the same drive. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPPROGRESS_ROUTINE",
        "name": "lpProgressRoutine",
        "description": "A pointer to a CopyProgressRoutine callback        function that is called each time another portion of the file has been moved. The callback function can be        useful if you provide a user interface that displays the progress of the operation. This parameter can be        NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpData",
        "description": "An argument to be passed to the        CopyProgressRoutine callback function. This        parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The move options. This parameter can be one or more of the following values.  ValueMeaning  MOVEFILE_COPY_ALLOWED 2 (0x2)   If the file is to be moved to a different volume, the function simulates the move by using the           CopyFile and           DeleteFile functions. If the  file is successfully copied to a different volume and the original file is unable to be deleted,           the function succeeds leaving the source file intact. This value cannot be used with MOVEFILE_DELAY_UNTIL_REBOOT.   MOVEFILE_CREATE_HARDLINK 16 (0x10)   Reserved for future use.   MOVEFILE_DELAY_UNTIL_REBOOT 4 (0x4)   The system does not move the file until the operating system is restarted. The system moves the file           immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter           enables the function to delete paging files from previous startups. This value can only be used if the process is in the context of a user who belongs to the administrators           group or the LocalSystem account. This value cannot be used with MOVEFILE_COPY_ALLOWED. The write operation to the registry value as detailed in the Remarks section is what is transacted. The           file move is finished when the computer restarts, after the transaction is complete.   MOVEFILE_REPLACE_EXISTING 1 (0x1)   If a file named lpNewFileName exists, the function replaces its contents with the           contents of the lpExistingFileName file. This value cannot be used if lpNewFileName or           lpExistingFileName names a directory.   MOVEFILE_WRITE_THROUGH 8 (0x8)   A call to MoveFileTransacted means that the          move file operation is complete when the commit operation is completed. This flag is unnecessary; there are no          negative affects if this flag is specified, other than an operation slowdown. The function does not return          until the file has actually been moved on the disk. Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk           before the function returns. The flush occurs at the end of the copy operation. This value has no effect if MOVEFILE_DELAY_UNTIL_REBOOT is set."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Moves a file or directory, including its children. You can provide a callback function that receives      progress notifications.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. When moving a file across volumes, if lpProgressRoutine returns         PROGRESS_CANCEL due to the user canceling the operation,         MoveFileWithProgress will return zero and         GetLastError will return         ERROR_REQUEST_ABORTED. The existing file is left intact. When moving a file across volumes, if lpProgressRoutine returns         PROGRESS_STOP due to the user stopping the operation,         MoveFileWithProgress will return zero and         GetLastError will return         ERROR_REQUEST_ABORTED. The existing file is left intact. ",
    "remarks": "The MoveFileWithProgress function coordinates its operation with the link      tracking service, so link sources can be tracked as they are moved. To delete or rename a file, you must have either delete permission on the file or delete child permission in      the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new      files are inherited, then you should be able to create a file without being able to delete it. However, you can      then create a file, and you will get all the access you request on the handle returned to you at the time you      create the file. If you requested delete permission at the time you created the file, you could delete or rename      the file with that handle but not with any other. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "MoveFileWithProgress",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The name of the existing file or directory on the local computer. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT, the         file cannot exist on a remote share because delayed operations are performed before the network is         available. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (MoveFileWithProgressW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The new name of the file or directory  on the local computer. When moving a file, lpNewFileName can be on a different file system or volume. If         lpNewFileName is on another drive, you must set the         MOVEFILE_COPY_ALLOWED flag in dwFlags. When moving a directory, lpExistingFileName and         lpNewFileName must be on the same drive. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and         lpNewFileName is NULL,         MoveFileWithProgress registers         lpExistingFileName to be deleted when the system restarts. The function fails if it         cannot access the registry to store the information about the delete operation. If         lpExistingFileName refers to a directory, the system removes the directory at restart         only if the directory is empty. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (MoveFileWithProgressW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPPROGRESS_ROUTINE",
        "name": "lpProgressRoutine",
        "description": "A pointer to a CopyProgressRoutine callback        function that is called each time another portion of the file has been moved. The callback function can be        useful if you provide a user interface that displays the progress of the operation. This parameter can be        NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID",
        "name": "lpData",
        "description": "An argument to be passed to the        CopyProgressRoutine callback function. This        parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The move options. This parameter can be one or more of the following values.  ValueMeaning  MOVEFILE_COPY_ALLOWED 2 (0x2)   If the file is to be moved to a different volume, the function simulates the move by using the           CopyFile and           DeleteFile functions. If the  file is successfully copied to a different volume and the original file is unable to be deleted,           the function succeeds leaving the source file intact. This value cannot be used with MOVEFILE_DELAY_UNTIL_REBOOT.   MOVEFILE_CREATE_HARDLINK 16 (0x10)   Reserved for future use.   MOVEFILE_DELAY_UNTIL_REBOOT 4 (0x4)   The system does not move the file until the operating system is restarted. The system moves the file           immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter           enables the function to delete paging files from previous startups. This value can only be used if the process is in the context of a user who belongs to the administrators           group or the LocalSystem account. This value cannot be used with MOVEFILE_COPY_ALLOWED.   MOVEFILE_FAIL_IF_NOT_TRACKABLE 32 (0x20)   The function fails if the source file is a link source, but the file cannot be tracked after the move.          This situation can occur if the destination is a volume formatted with the FAT file system.   MOVEFILE_REPLACE_EXISTING 1 (0x1)   If a file named lpNewFileName exists, the function replaces its contents with           the contents of the lpExistingFileName file. This value cannot be used if lpNewFileName or           lpExistingFileName names a directory.   MOVEFILE_WRITE_THROUGH 8 (0x8)   The function does not return until the file has actually been moved on the disk. Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk           before the function returns. The flush occurs at the end of the copy operation. This value has no effect if MOVEFILE_DELAY_UNTIL_REBOOT is set."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream,      directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The      function returns a handle that can be used to access the file or device for various types of I/O depending on the      file or device and the flags and attributes specified.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or         mail slot. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended         error information, call GetLastError. ",
    "remarks": "To compile an application that uses the CreateFile2      function, define the _WIN32_WINNT macro as 0x0602 or later. For more information, see      Using the Windows Headers. CreateFile2 supports file interaction and most other      types of I/O devices and mechanisms available to Windows developers. This section attempts to cover the varied      issues developers may experience when using CreateFile2 in      different contexts and with different I/O types. The text attempts to use the word file      only when referring specifically to data stored in an actual file on a file system. However, some uses of      file may be referring more generally to an I/O object that supports file-like mechanisms.      This liberal use of the term file is particularly prevalent in constant names and      parameter names because of the previously mentioned historical reasons. When an application is finished using the object handle returned by      CreateFile2, use the      CloseHandle function to close the handle. This not only      frees up system resources, but can have wider influence on things like sharing the file or device and committing      data to disk. Specifics are noted within this topic as appropriate. Some file systems, such as the NTFS file system, support compression or encryption for individual files and       directories. On volumes that have a mounted file system with this support, a new file inherits the compression       and encryption attributes of its directory. You cannot use CreateFile2 to control compression,       decompression, or decryption on a file or directory. For more information, see       Creating and Opening Files,       File Compression and Decompression,       and File Encryption. If the lpSecurityAttributes member of the       CREATEFILE2_EXTENDED_PARAMETERS structure       passed in the pCreateExParams parameter is NULL, the handle       returned by CreateFile2 cannot be inherited by any child       processes your application may create. The following information regarding this member also applies: In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If the call to this function creates a file, there is no change in behavior. Also, consider the following        information regarding FILE_FLAG_OPEN_REPARSE_POINT flag for the        dwFileFlags member of the        CREATEFILE2_EXTENDED_PARAMETERS        structure passed in the pCreateExParams parameter: If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file        information to restore. Cached information includes its short/long name pair and creation time. If you call CreateFile2 on a file that is pending deletion        as a result of a previous call to DeleteFile, the function        fails. The operating system delays file deletion until all handles to the file are closed.        GetLastError returns        ERROR_ACCESS_DENIED. The dwDesiredAccess parameter can be zero, allowing the application to query file        attributes without accessing the file if the application is running with adequate security settings. This is        useful to test for the existence of a file without opening it for read and/or write access, or to obtain other        statistics about the file or directory. See        Obtaining and Setting File Information        and GetFileInformationByHandle. When an application creates a file across a network, it is better to use        GENERIC_READ | GENERIC_WRITE for        dwDesiredAccess than to use GENERIC_WRITE alone. The        resulting code is faster, because the redirector can use the cache manager and send fewer SMBs with more data.        This combination also avoids an issue where writing to a file across a network can occasionally return        ERROR_ACCESS_DENIED. For more information, see        Creating and Opening Files. On NTFS file systems, you can use CreateFile2 to create        separate streams within a file. For more information, see        File Streams. An application cannot create a directory by using        CreateFile2, therefore only the        OPEN_EXISTING value is valid for        dwCreationDisposition for this use case. To create a directory, the application must        call CreateDirectory or        CreateDirectoryEx. To open a directory using CreateFile2, specify the        FILE_FLAG_BACKUP_SEMANTICS flag as part of dwFileFlags        member of the        CREATEFILE2_EXTENDED_PARAMETERS        structure passed in the pCreateExParams parameter. Appropriate security checks still        apply when this flag is used without SE_BACKUP_NAME and        SE_RESTORE_NAME privileges. When using CreateFile2 to open a directory during        defragmentation of a FAT or FAT32 file system volume, do not specify the        MAXIMUM_ALLOWED access right. Access to the directory is denied if this is done.        Specify the GENERIC_READ access right instead. For more information, see        About Directory Management. Direct access to the disk or to a volume is restricted. For more information, see        \"Changes to the file system and to the storage stack to restrict direct disk access and direct volume access in Windows Vista and in Windows Server 2008\"        in the Help and Support Knowledge Base at        http://support.microsoft.com/kb/942448. You can use the CreateFile2 function to open a physical        disk drive or a volume, which returns a direct access storage device (DASD) handle that can be used with the        DeviceIoControl function. This enables you to access        the disk or volume directly, for example such disk metadata as the partition table. However, this type of access        also exposes the disk drive or volume to potential data loss, because an incorrect write to a disk using this        mechanism could make its contents inaccessible to the operating system. To ensure data integrity, be sure to        become familiar with DeviceIoControl and how other        APIs behave differently with a direct access handle as opposed to a file system handle. The following requirements must be met for such a call to succeed: When opening a physical drive x:, the        lpFileName string should be the following form:        \"\\\\.\\PhysicalDriveX\". Hard disk numbers        start at zero. The following table shows some examples of physical drive strings.  To obtain the physical drive identifier for a volume, open a handle to the volume and call the        DeviceIoControl function with        IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS.        This control code returns the disk number and offset for each of the volume's one or more extents; a volume can        span multiple physical disks. For an example of opening a physical drive, see        Calling DeviceIoControl. When opening a volume or removable media drive (for example, a floppy disk drive or flash memory thumb drive),        the lpFileName string should be the following form:        \"\\\\.\\X:\". Do not use a trailing backslash        (\\), which indicates the root directory of a drive. The following table shows some examples of drive strings.  You can also open a volume by referring to its volume name. For more information, see        Naming a Volume. A volume contains one or more mounted file systems. Volume handles can be opened as noncached at the        discretion of the particular file system, even when the noncached option is not specified in        CreateFile2. You should assume that all Microsoft file        systems open volume handles as noncached. The restrictions on noncached I/O for files also apply to volumes. A file system may or may not require buffer alignment even though the data is noncached. However, if the        noncached option is specified when opening a volume, buffer alignment is enforced regardless of the file system        on the volume. It is recommended on all file systems that you open volume handles as noncached, and follow the        noncached I/O restrictions. The IOCTL_CHANGER_* control codes for        DeviceIoControl accept a handle to a changer device.        To open a changer device, use a file name of the following form:        \"\\\\.\\Changerx\" where        x is a number that indicates which device to open, starting with zero. To open        changer device zero in an application that is written in C or C++, use the following file name:        \"\\\\\\\\.\\\\Changer0\". You can open tape drives by using a file name of the following form:        \"\\\\.\\TAPEx\" where        x is a number that indicates which drive to open, starting with tape drive zero. To        open tape drive zero in an application that is written in C or C++, use the following file name:        \"\\\\\\\\.\\\\TAPE0\". For more information, see Backup. The CreateFile2 function can create a handle to a        communications resource, such as the serial port COM1. For communications resources,        the dwCreationDisposition parameter must be        OPEN_EXISTING, the dwShareMode parameter must be zero        (exclusive access), and the hTemplateFile parameter must be        NULL. Read, write, or read/write access can be specified, and the handle can be opened        for overlapped I/O. To specify a COM port number greater than 9, use the following syntax:        \"\\\\.\\COM10\". This syntax works for all port numbers and hardware that        allows COM port numbers to be specified. For more information about communications, see        Communications. The CreateFile2 function can create a handle to console        input (CONIN$). If the process has an open handle to it as a result of inheritance or        duplication, it can also create a handle to the active screen buffer (CONOUT$). The        calling process must be attached to an inherited console or one allocated by the        AllocConsole function. For console handles, set the        CreateFile2 parameters as follows.  Set the members of the        CREATEFILE2_EXTENDED_PARAMETERS        structure passed in the pCreateExParams parameter as follows.  The following table shows various settings of dwDesiredAccess and        lpFileName.  If CreateFile2 opens the client end of a mailslot, the        function returns INVALID_HANDLE_VALUE if the mailslot client attempts to open a local        mailslot before the mailslot server has created it with the        CreateMailSlot function. For more information, see Mailslots. If CreateFile2 opens the client end of a named pipe, the        function uses any instance of the named pipe that is in the listening state. The opening process can duplicate        the handle as many times as required, but after it is opened, the named pipe instance cannot be opened by        another client. The access that is specified when a pipe is opened must be compatible with the access that is        specified in the dwOpenModeparameter of the        CreateNamedPipe function. If the CreateNamedPipe function was not        successfully called on the server prior to this operation, a pipe will not exist and        CreateFile2 will fail with        ERROR_FILE_NOT_FOUND. If there is at least one active pipe instance but there are no available listener pipes on the server, which        means all pipe instances are currently connected,       CreateFile2 fails with       ERROR_PIPE_BUSY. For more information, see Pipes. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "CreateFile2",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the file or device to be created or opened. For information on special device names, see         Defining an MS-DOS Device Name. To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more         information, see File Streams. Tip  Starting with Windows 10, version 1607, you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The requested access to the file or device, which can be summarized as read, write, both or neither zero). The most commonly used values are GENERIC_READ,         GENERIC_WRITE, or both         (GENERIC_READ | GENERIC_WRITE). For more information, see         Generic Access Rights,         File Security and Access Rights,         File Access Rights Constants, and         ACCESS_MASK. If this parameter is zero, the application can query certain metadata such as file, directory, or device         attributes without accessing that file or device, even if GENERIC_READ access would         have been denied. You cannot request an access mode that conflicts with the sharing mode that is specified by the         dwShareMode parameter in an open request that already has an open handle. For more information, see the Remarks section of this topic and         Creating and Opening Files."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwShareMode",
        "description": "The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or         none (refer to the following table). Access requests to attributes or extended attributes are not affected by         this flag. If this parameter is zero and CreateFile2 succeeds, the         file or device cannot be shared and cannot be opened again until the handle to the file or device is closed.         For more information, see the Remarks section. You cannot request a sharing mode that conflicts with the access mode that is specified in an existing         request that has an open handle. CreateFile2 would fail         and the GetLastError function would return         ERROR_SHARING_VIOLATION. To enable a process to share a file or device while another process has the file or device open, use a         compatible combination of one or more of the following values. For more information about valid combinations of         this parameter with the dwDesiredAccess parameter, see         Creating and Opening Files. Note  The sharing options for each open handle remain in effect until that handle is closed, regardless of         process context.    ValueMeaning  0 0x00000000   Prevents other processes from opening a file or device if they request delete, read, or write access.           Exclusive access to a file or directory is only granted if the application has write access to the file.   FILE_SHARE_DELETE 0x00000004   Enables subsequent open operations on a file or device to request delete access. Otherwise, other processes cannot open the file or device if they request delete access. If this flag is not specified, but the file or device has been opened for delete access, the function           fails. Note  Delete access allows both delete and rename operations.     FILE_SHARE_READ 0x00000001   Enables subsequent open operations on a file or device to request read access. Otherwise, other processes cannot open the file or device if they request read access. If this flag is not specified, but the file or device has been opened for read access, the function           fails. If a file or directory is being opened and this flag is not specified, and the caller does not have write           access to the file or directory, the function fails.   FILE_SHARE_WRITE 0x00000002   Enables subsequent open operations on a file or device to request write access. Otherwise, other processes cannot open the file or device if they request write access. If this flag is not specified, but the file or device has been opened for write access or has a file mapping           with write access, the function fails."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationDisposition",
        "description": "An action to take on a file or device that exists or does not exist. For devices other than files, this parameter is usually set to OPEN_EXISTING. For more information, see the Remarks section. This parameter must be one of the following values, which cannot be combined:  ValueMeaning  CREATE_ALWAYS 2   Creates a new file, always. If the specified file exists and is writable, the function overwrites the file, the function succeeds, and           last-error code is set to ERROR_ALREADY_EXISTS (183). If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and           the last-error code is set to zero. For more information, see the Remarks section of this topic.   CREATE_NEW 1   Creates a new file, only if it does not already exist. If the specified file exists, the function fails and the last-error code is set to           ERROR_FILE_EXISTS (80). If the specified file does not exist and is a valid path to a writable location, a new file is created.   OPEN_ALWAYS 4   Opens a file, always. If the specified file exists, the function succeeds and the last-error code is set to           ERROR_ALREADY_EXISTS (183). If the specified file does not exist and is a valid path to a writable location, the function creates a           file and the last-error code is set to zero.   OPEN_EXISTING 3   Opens a file or device, only if it exists. If the specified file or device does not exist, the function fails and the last-error code is set to           ERROR_FILE_NOT_FOUND (2). For more information about devices, see the Remarks section.   TRUNCATE_EXISTING 5   Opens a file and truncates it so that its size is zero bytes, only if it exists. If the specified file does not exist, the function fails and the last-error code is set to           ERROR_FILE_NOT_FOUND (2). The calling process must open the file with the GENERIC_WRITE bit set as part of           the dwDesiredAccess parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCREATEFILE2_EXTENDED_PARAMETERS",
        "name": "pCreateExParams",
        "description": "Pointer to an optional        CREATEFILE2_EXTENDED_PARAMETERS        structure."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 10,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or         mail slot. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended         error information, call GetLastError. ",
    "remarks": "When using the handle returned by       CreateFileTransacted, use the transacted version       of file I/O functions instead of the standard file I/O functions where appropriate. For more information, see       Programming Considerations for       Transactional NTFS. When opening a transacted handle to a directory, that handle must have       FILE_WRITE_DATA (FILE_ADD_FILE) and       FILE_APPEND_DATA (FILE_ADD_SUBDIRECTORY) permissions. These       are included in FILE_GENERIC_WRITE permissions. You should open directories with fewer       permissions if you are just using the handle to create files or subdirectories; otherwise, sharing violations can       occur. You cannot open a file with FILE_EXECUTE access level when that file is a part of       another transaction (that is, another application opened it by calling       CreateFileTransacted).  This means that       CreateFileTransacted fails if the access level       FILE_EXECUTE or FILE_ALL_ACCESS is specified When a non-transacted application calls       CreateFileTransacted with       MAXIMUM_ALLOWED specified for lpSecurityAttributes, a handle       is opened with the same access level every time.  When a transacted application calls       CreateFileTransacted with       MAXIMUM_ALLOWED specified for lpSecurityAttributes, a handle       is opened with a differing amount of access based on whether the file is locked by a transaction. For example,       if the calling application has FILE_EXECUTE access level for a file, the application       only obtains this access if the file that is being opened is either not locked by a transaction, or is locked by       a transaction and the application is already a transacted reader for that file. See Transactional NTFS for a complete       description of transacted operations. Use the CloseHandle function to close an object handle       returned by CreateFileTransacted when the handle       is no longer needed, and prior to committing or rolling back the transaction. Some file systems, such as the NTFS file system, support compression or encryption for individual files and       directories. On volumes that are formatted for that kind of file system, a new file inherits the compression and       encryption attributes of its directory. You cannot use CreateFileTransacted to control       compression on a file or directory. For more information, see       File Compression and Decompression, and       File Encryption. Symbolic link behavior\u00e2\u0080\u0094If the call to this function creates a new file, there is no change       in behavior. If FILE_FLAG_OPEN_REPARSE_POINT is specified: If FILE_FLAG_OPEN_REPARSE_POINT is not specified: A multi-sector write is not guaranteed to be atomic unless you are using a transaction (that is, the handle      created is a transacted handle).  A single-sector write is atomic. Multi-sector writes that are cached may not      always be written to the disk; therefore, specify FILE_FLAG_WRITE_THROUGH to ensure that      an entire multi-sector write is written to the disk without caching. As stated previously, if the lpSecurityAttributes parameter is       NULL, the handle returned by       CreateFileTransacted cannot be inherited by any       child processes your application may create. The following information regarding this parameter also applies: In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Note that SMB 3.0 does not support TxF. If you try to create a file on a floppy drive that does not have a floppy disk or a CD-ROM drive that does not        have a CD, the system displays a message for the user to insert a disk or a CD. To prevent the system from        displaying this message, call the SetErrorMode function        with SEM_FAILCRITICALERRORS. For more information, see        Creating and Opening Files. If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file        information to restore. Cached information includes its short/long name pair and creation time. If you call CreateFileTransacted on a file that        is pending deletion as a result of a previous call to        DeleteFile, the function fails. The operating system        delays file deletion until all handles to the file are closed.       GetLastError returns        ERROR_ACCESS_DENIED. The dwDesiredAccess parameter can        be zero, allowing the application to query  file attributes without accessing the file if the application is        running with adequate security settings. This is useful to test for the existence of a file without opening it        for read and/or write access, or to obtain other statistics about the file or directory. See        Obtaining and Setting File Information        and GetFileInformationByHandle. When an application creates a file across a network, it is better to use        GENERIC_READ | GENERIC_WRITE than to use        GENERIC_WRITE alone. The resulting code is faster, because the redirector can use the        cache manager and send fewer SMBs with more data. This combination also avoids an issue where writing to a file        across a network can occasionally return ERROR_ACCESS_DENIED. On NTFS file systems, you can use        CreateFileTransacted to create separate streams        within a file. For more information, see        File Streams. An application cannot create a directory by using        CreateFileTransacted, therefore only the        OPEN_EXISTING value is valid for dwCreationDisposition for        this use case. To create a directory, the application must call        CreateDirectoryTransacted,        CreateDirectory or        CreateDirectoryEx. To open a directory using CreateFileTransacted,        specify the FILE_FLAG_BACKUP_SEMANTICS flag as part of        dwFlagsAndAttributes. Appropriate security checks still apply when this flag is used        without SE_BACKUP_NAME and SE_RESTORE_NAME privileges. When using CreateFileTransacted to open a        directory during defragmentation of a FAT or FAT32 file system volume, do not specify the        MAXIMUM_ALLOWED access right. Access to the directory is denied if this is done.        Specify the GENERIC_READ access right instead. For more information, see        About Directory Management. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "CreateFileTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of an object to be created or opened. The object must reside on the local computer; otherwise,         the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. For information on special device names,         see Defining an MS-DOS Device Name. To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more         information, see File Streams."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly         used values are GENERIC_READ, GENERIC_WRITE, or both         (GENERIC_READ | GENERIC_WRITE). For more information, see         Generic Access Rights and         File Security and Access Rights. If this parameter is zero, the application can query  file, directory, or device attributes without accessing         that file or device. For more information, see the Remarks section of this topic. You cannot request an access mode that conflicts with the sharing mode that is specified in an open request         that has an open handle. For more information, see         Creating and Opening Files."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwShareMode",
        "description": "The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the         following table). If this parameter is zero and         CreateFileTransacted succeeds, the object cannot         be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section         of this topic. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request         that has an open handle, because that would result in the following sharing violation:         ERROR_SHARING_VIOLATION. For more information, see         Creating and Opening Files. To enable a process to share an object while another process has the object open, use a combination of one or         more of the following values to specify the  access mode they can request to open the object. Note  The sharing options for each open handle remain in effect until that handle is closed, regardless of         process context.    ValueMeaning  0 0x00000000   Disables subsequent open operations on an object to request any type of access to that object.   FILE_SHARE_DELETE 0x00000004   Enables subsequent open operations on an object to request delete access. Otherwise, other processes cannot open the object if they request delete access. If this flag is not specified, but the object has been opened for delete access, the function fails.   FILE_SHARE_READ 0x00000001   Enables subsequent open operations on an object to request read access. Otherwise, other processes cannot open the object if they request read access. If this flag is not specified, but the object has been opened for read access, the function fails.   FILE_SHARE_WRITE 0x00000002   Enables subsequent open operations on an object to request write access. Otherwise, other processes cannot open the object if they request write access. If this flag is not specified, but the object has been opened for write access or has a file mapping with           write access, the function fails."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a SECURITY_ATTRIBUTES         structure that contains an optional         security descriptor and also determines whether         or not the returned handle can be inherited by child processes. The parameter can be         NULL. If the lpSecurityAttributes parameter is NULL, the handle         returned by CreateFileTransacted cannot be         inherited by any child processes your application may create and the object associated with the returned handle         gets a default security descriptor. The bInheritHandle member of the structure specifies whether the returned handle         can be inherited. The  lpSecurityDescriptor member of the structure specifies         a security descriptor for an object, but may         also be NULL. If lpSecurityDescriptor member is NULL, the object         associated with the returned handle is assigned a default security descriptor. CreateFileTransacted ignores the         lpSecurityDescriptor member when opening an existing file, but continues to use the         bInheritHandle member. For more information, see the Remarks section of this topic."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationDisposition",
        "description": "An action to take on files that exist and  do not exist. For more information, see the Remarks section of this topic. This parameter must be one of the following values, which cannot be combined.  ValueMeaning  CREATE_ALWAYS 2   Creates a new file, always. If the specified  file exists and is writable, the function overwrites the file, the function succeeds, and           last-error code is set to ERROR_ALREADY_EXISTS (183). If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and           the last-error code is set to zero. For more information, see the Remarks section of this topic.   CREATE_NEW 1   Creates a new file, only if it does not already exist. If the specified file exists, the function fails and the last-error code is set to           ERROR_FILE_EXISTS (80). If the specified file does not exist and is a valid path to a writable location, a new file is created.   OPEN_ALWAYS 4   Opens a file, always. If the specified file exists, the function succeeds and the last-error code is set to           ERROR_ALREADY_EXISTS (183). If the specified file does not exist and is a valid path to a writable location, the function creates a           file and the last-error code is set to zero.   OPEN_EXISTING 3   Opens a file or device, only if it exists. If the specified file does not exist, the function fails and the last-error code is set to           ERROR_FILE_NOT_FOUND (2). For more information, see the Remarks section of this topic.   TRUNCATE_EXISTING 5   Opens a file and truncates it so that its size is zero bytes, only if it exists. If the specified file does not exist, the function fails and the last-error code is set to           ERROR_FILE_NOT_FOUND (2). The calling process must open the file with the GENERIC_WRITE bit set as part of           the dwDesiredAccess parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlagsAndAttributes",
        "description": "The file attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common default         value. This parameter can include any combination of the available file attributes         (FILE_ATTRIBUTE_*). All other file attributes override         FILE_ATTRIBUTE_NORMAL. This parameter can also contain combinations of flags (FILE_FLAG_*) for control of         buffering behavior, access modes, and other special-purpose flags. These combine with any         FILE_ATTRIBUTE_* values. This parameter can also contain Security Quality of Service (SQOS) information by specifying the         SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in         the table following the attributes and flags tables. Note  When CreateFileTransacted opens an existing          file, it generally combines the file flags with the file attributes of the existing file, and ignores any file          attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in          Creating and Opening Files.    The following file attributes and flags are used only for file objects, not other types of objects that         CreateFileTransacted opens (additional         information can be found in the Remarks section of this topic). For more advanced access to file attributes,         see SetFileAttributes. For a complete list of all         file attributes with their values and descriptions, see         File Attribute Constants.  AttributeMeaning  FILE_ATTRIBUTE_ARCHIVE 32 (0x20)   The file should be archived. Applications use this attribute to mark files for backup or removal.   FILE_ATTRIBUTE_ENCRYPTED 16384 (0x4000)   The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a           directory, this means that encryption is the default for newly created files and subdirectories. For more           information, see File Encryption. This flag has no effect if FILE_ATTRIBUTE_SYSTEM is also specified.   FILE_ATTRIBUTE_HIDDEN 2 (0x2)   The file is hidden. Do not include it in an ordinary directory listing.   FILE_ATTRIBUTE_NORMAL 128 (0x80)   The file does not have other attributes set. This attribute is valid only if used alone.   FILE_ATTRIBUTE_OFFLINE 4096 (0x1000)   The data of a file is not immediately available. This attribute indicates that file data is physically           moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management           software. Applications should not arbitrarily change this attribute.   FILE_ATTRIBUTE_READONLY 1 (0x1)   The file is read only. Applications can read the file, but cannot write to or delete it.   FILE_ATTRIBUTE_SYSTEM 4 (0x4)   The file is part of or used exclusively by an operating system.   FILE_ATTRIBUTE_TEMPORARY 256 (0x100)   The file is being used for temporary storage.  File systems avoid writing data back to mass storage           if sufficient cache memory is available, because an application deletes a temporary file after a handle is           closed. In that case, the system can entirely avoid writing the data.  Otherwise, the data is written after           the handle is closed.      FlagMeaning  FILE_FLAG_BACKUP_SEMANTICS 0x02000000   The file is being opened or created for a backup or restore operation. The system ensures that the           calling process overrides file security checks when the process has SE_BACKUP_NAME           and SE_RESTORE_NAME privileges. For more information, see           Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A directory handle can be passed to some           functions instead of a file handle. For more information, see           Directory Handles.   FILE_FLAG_DELETE_ON_CLOSE 0x04000000   The file is to be deleted immediately after the last transacted writer handle to the file is closed,           provided that the transaction is still active. If a file has been marked for deletion and a transacted writer           handle is still open after the transaction completes, the file will not be deleted. If there are existing open handles to a file, the call fails unless they were all opened with the           FILE_SHARE_DELETE share mode. Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share           mode is specified.   FILE_FLAG_NO_BUFFERING 0x20000000   The file is being opened with no system caching. This flag does not affect hard disk caching or memory           mapped files. When combined with FILE_FLAG_OVERLAPPED, the flag gives maximum           asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager.           However, some I/O operations take more time, because data is not being held in the cache. Also, the file           metadata may still be cached. To flush the metadata to disk, use the           FlushFileBuffers function. An application must meet certain requirements when working with files that are opened with           FILE_FLAG_NO_BUFFERING:  File access must begin at byte offsets within a file that are integer multiples of the volume sector            size. File access must be for numbers of bytes that are integer multiples of the volume sector size. For            example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536,            or 2048 bytes, but not of 335, 981, or 7171 bytes. Buffer addresses for read and write operations should be sector aligned, which means aligned on            addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this            requirement may not be enforced.  One way to align buffers on integer multiples of the volume sector size is to use           VirtualAlloc to allocate the buffers. It allocates           memory that is aligned on addresses that are integer multiples of the operating system's memory page size.           Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses           that are integer multiples of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes           (hard disks), 2048 bytes (CD), or 4096 bytes (hard disks), and therefore, volume sectors can never be larger           than memory pages. An application can determine a volume sector size by calling the           GetDiskFreeSpace function.   FILE_FLAG_OPEN_NO_RECALL 0x00100000   The file data is requested, but it should continue to be located in remote storage. It should not be           transported back to local storage. This flag is for use by remote storage systems.   FILE_FLAG_OPEN_REPARSE_POINT 0x00200000   Normal reparse point processing will not occur;           CreateFileTransacted will attempt to open the           reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the           reparse point is operational. This flag cannot be used with the CREATE_ALWAYS           flag. If the file is not a reparse point, then this flag is ignored.   FILE_FLAG_OVERLAPPED 0x40000000   The file is being opened or created for asynchronous I/O. When the operation is complete, the event           specified in the OVERLAPPED structure is set to the           signaled state. Operations that take a significant amount of time to process return           ERROR_IO_PENDING. If this flag is specified, the file can be used for simultaneous read and write operations. The system does           not maintain the file pointer, therefore you must pass the file position to the read and write functions in           the OVERLAPPED structure or update the file           pointer. If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write           functions specify an OVERLAPPED structure.   FILE_FLAG_POSIX_SEMANTICS 0x0100000   The file is to be accessed according to POSIX rules. This includes allowing multiple files with names,           differing only in case, for file systems that support that naming. Use care when using this option, because           files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit           Windows.   FILE_FLAG_RANDOM_ACCESS 0x10000000   The file is to be accessed randomly. The system can use this as a hint to optimize file caching.   FILE_FLAG_SESSION_AWARE 0x00800000   The file or device is being opened with session awareness. If this flag is not specified, then per-session           devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0.           This flag has no effect for callers not in session 0. This flag is supported only on server editions of           Windows. Windows Server 2008 R2 and Windows Server 2008:  This flag is not supported before Windows Server 2012.   FILE_FLAG_SEQUENTIAL_SCAN 0x08000000   The file is to be accessed sequentially from beginning to end. The system can use this as a hint to           optimize file caching. If an application moves the file pointer for random access, optimum caching may not           occur. However, correct operation is still guaranteed. Specifying this flag can increase performance for applications that read large files using sequential           access. Performance gains can be even more noticeable for applications that read large files mostly           sequentially, but occasionally skip over small ranges of bytes. This flag  has no effect if the file system does not support cached I/O and           FILE_FLAG_NO_BUFFERING.   FILE_FLAG_WRITE_THROUGH 0x80000000   Write operations will not go through any intermediate cache, they will go directly to disk. If FILE_FLAG_NO_BUFFERING is not also specified, so that system caching is in           effect, then the data is written to the system cache, but is flushed to disk without delay. If FILE_FLAG_NO_BUFFERING is also specified, so that system caching is not in           effect, then the data is immediately flushed to disk without going through the system cache. The operating           system also requests a write-through the hard disk cache to persistent media. However, not all hardware           supports this write-through capability.     The dwFlagsAndAttributes parameter can also specify Security Quality of Service         information. For more information, see         Impersonation Levels. When the calling         application specifies the SECURITY_SQOS_PRESENT flag as part of         dwFlagsAndAttributes, it can also contain one or more of the following values.  Security flagMeaning  SECURITY_ANONYMOUS   Impersonates a client at the Anonymous impersonation level.   SECURITY_CONTEXT_TRACKING   The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is           static.   SECURITY_DELEGATION   Impersonates a client at the Delegation impersonation level.   SECURITY_EFFECTIVE_ONLY   Only the enabled aspects of the client's security context are available to the server. If you do not           specify this flag, all aspects of the client's security context are available. This allows the client to limit the groups and privileges that a server can use while impersonating the           client.   SECURITY_IDENTIFICATION   Impersonates a client at the Identification impersonation level.   SECURITY_IMPERSONATION   Impersonate a client at the impersonation level. This is the default behavior if no other flags are           specified along with the SECURITY_SQOS_PRESENT flag."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "hTemplateFile",
        "description": "A valid handle to a template file with the GENERIC_READ access right. The template         file supplies file attributes and extended attributes for the file that is being created. This parameter can be         NULL. When opening an existing file,         CreateFileTransacted ignores the template         file. When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the         CreateTransaction function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUSHORT",
        "name": "pusMiniVersion",
        "description": "The miniversion to be opened. If the transaction specified in hTransaction is not         the transaction that is modifying the file, this parameter should be NULL. Otherwise,         this parameter can be a miniversion identifier returned by the         FSCTL_TXFS_CREATE_MINIVERSION control         code, or one of the following values.  ValueMeaning  TXFS_MINIVERSION_COMMITTED_VIEW 0x0000   The view of the file as of its last commit.   TXFS_MINIVERSION_DIRTY_VIEW 0xFFFF   The view of the file as it is being modified by the transaction.   TXFS_MINIVERSION_DEFAULT_VIEW 0xFFFE   Either the committed or dirty view of the file, depending on the context. A transaction that is modifying          the file gets the dirty view, while a transaction that is not modifying the file gets the committed          view."
      },
      {
        "in_out": "_Reserved_",
        "type": "PVOID",
        "name": "pExtendedParameter",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Establishes a hard link between an existing file and a new file. This function is only      supported on the NTFS file system, and only for files, not directories.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call         GetLastError. The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023         links are created for a file, an error results. ",
    "remarks": "Any directory entry for a file that is created with      CreateFile or      CreateHardLink is a hard link to an associated file.      An additional hard link that is created with the      CreateHardLink      function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,      which can be different names in the same directory, or the same or different names in different directories.      However, all hard links to a file must be on the same volume. Because hard links are only directory entries for a file, many changes to that file are instantly visible to      applications that access it through the hard links that reference it. However, the directory entry size and      attribute information is updated only for the link through which the change was made. The security descriptor belongs to the file to which a hard link points. The link itself is only a directory      entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,      you a change the security descriptor of the underlying file, and all hard links that point to the file allow the      newly specified access. You cannot give a file different security descriptors on a per-hard-link basis. This function does not modify the security descriptor of the file to be linked to, even if security descriptor      information is passed in the lpSecurityAttributes parameter. Use DeleteFile to delete hard links. You can delete      them in any order regardless of the order in which they are created. Flags, attributes, access, and sharing that are specified in      CreateFile operate on a per-file basis. That is, if you      open a file that does not allow sharing, another application cannot share the file by creating a new hard link to      the file. When you create a hard link on the NTFS file system, the file attribute information in the directory entry is      refreshed only when the file is opened, or when      GetFileInformationByHandle is called with      the handle of a specific file. Symbolic link behavior\u00e2\u0080\u0094If the path points to a symbolic link, the function creates a hard       link to the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability. The following code snippet shows you how to call      CreateHardLink so that it does not modify the security      descriptor of a file. The pszExistingFileName parameter can be the original file name,      or any existing link to a file. After this code is executed, pszNewLinkName refers to      the file. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CreateHardLink",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the new file.        This parameter may include the path but cannot specify the name of a directory. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (CreateHardLinkW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The name of the existing file.        This parameter may include the path cannot specify the name of a directory. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (CopyFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "Reserved; must be NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call         GetLastError. The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023         links are created for a file, an error results. The files must reside on the local computer; otherwise,         the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. ",
    "remarks": "Any directory entry for a file that is created with      CreateFileTransacted or      CreateHardLinkTransacted is a hard link to an      associated file. An additional hard link that is created with the      CreateHardLinkTransacted function allows you to      have multiple directory entries for a file, that is, multiple hard links to the same file, which can be different      names in the same directory, or the same or different names in different directories. However, all hard links to a      file must be on the same volume. Because hard links are only directory entries for a file, when an application modifies a file through any hard      link, all applications that use any other hard link to the file see the changes. Also, all of the directory      entries are updated if the file changes. For example, if a file size changes, all of the hard links to the file      show the new file size. The security descriptor belongs to the file to which a hard link points. The link itself is only a directory      entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,      you a change the security descriptor of the underlying file, and all hard links that point to the file allow the      newly specified access. You cannot give a file different security descriptors on a per-hard-link basis. This function does not modify the security descriptor of the file to be linked to, even if security descriptor      information is passed in the lpSecurityAttributes parameter. Use DeleteFileTransacted to delete hard links.      You can delete them in any order regardless of the order in which they are created. Flags, attributes, access, and sharing that are specified in      CreateFileTransacted operate on a per-file basis.      That is, if you open a file that does not allow sharing, another application cannot share the file by creating a      new hard link to the file. When you create a hard link on the NTFS file system, the file attribute information in the directory entry is      refreshed only when the file is opened, or when      GetFileInformationByHandle is called with the      handle of a specific file. Symbolic links:  If the path points to a symbolic link, the function creates a hard link to the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Note that SMB 3.0 does not support TxF. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "CreateHardLinkTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the new file. This parameter cannot specify the name of a directory."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The name of the existing file. This parameter cannot specify the name of a directory."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Creates an input/output (I/O) completion port and associates it with a specified file handle, or creates an I/O completion port that is not yet associated with a file handle, allowing association at a later time.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "IoAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to an I/O completion port: If the function fails, the return value is NULL. To get extended error information, call  the GetLastError function. ",
    "remarks": "The I/O system can be instructed to send I/O completion notification packets to I/O completion ports, where they are queued. The  CreateIoCompletionPort function provides this functionality. An I/O completion port and its handle are associated with the process that created it and is not sharable between processes. However, a single handle is sharable between threads in the same process. CreateIoCompletionPort can be used in three distinct modes: To create an I/O completion port without associating it, set the FileHandle parameter to INVALID_HANDLE_VALUE, the ExistingCompletionPort parameter to NULL, and the CompletionKey parameter to zero (which is ignored in this case). Set the NumberOfConcurrentThreads parameter to the desired concurrency value for the new I/O completion port, or zero for the default (the number of processors in the system). The handle passed in the FileHandle parameter can be any handle that supports overlapped I/O. Most commonly, this is a handle opened by the CreateFile function using the FILE_FLAG_OVERLAPPED flag (for example, files, mail slots, and pipes). Objects created by other functions such as socket can also be associated with an I/O completion port. For an example using sockets, see AcceptEx. A handle can be associated with only one I/O completion port, and after the association is made, the handle remains associated with that I/O completion port until it is closed. For more information on I/O completion port theory, usage, and associated functions, see I/O Completion Ports. Multiple file handles can be associated with a single I/O completion port by calling CreateIoCompletionPort multiple times with the same I/O completion port handle in the ExistingCompletionPort parameter and a different file handle in the FileHandle parameter each time. Use the CompletionKey parameter to help your application track which I/O operations have completed. This value is not used by CreateIoCompletionPort for functional control; rather, it is attached to the file handle specified in the FileHandle parameter at the time of association with an I/O completion port. This completion key should be unique for each file handle, and it accompanies the file handle throughout the internal completion queuing process. It is returned in the GetQueuedCompletionStatus function call when a completion packet arrives. The CompletionKey parameter is also used by the PostQueuedCompletionStatus function to queue your own special-purpose completion packets. After an instance of an open handle is associated with an I/O completion port, it cannot be used in the                  ReadFileEx or  WriteFileEx function because these functions have their own asynchronous I/O mechanisms. It is best not to share a file handle associated with an I/O completion port by using either handle inheritance or a call to the  DuplicateHandle function. Operations performed with such duplicate handles generate completion notifications. Careful consideration is advised. The I/O completion port handle and every file handle associated with that particular I/O completion port are known as references to the I/O completion port. The I/O completion port is released when there are no more references to it. Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources. After these conditions are satisfied, close the I/O completion port handle by calling the  CloseHandle function. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "CreateIoCompletionPort",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "An open file handle or INVALID_HANDLE_VALUE. The handle must be to an object that supports overlapped I/O. If a handle is provided, it has to have been opened for overlapped I/O completion. For example, you must specify the FILE_FLAG_OVERLAPPED flag when using the  CreateFile function to obtain the handle. If INVALID_HANDLE_VALUE is specified, the function creates an I/O completion port without associating it with a file handle. In this case, the ExistingCompletionPort parameter must be NULL and the CompletionKey parameter is ignored."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "ExistingCompletionPort",
        "description": "A handle to an existing I/O completion port or NULL. If this parameter specifies an existing I/O completion port, the function associates it with the handle specified by the FileHandle parameter. The function returns the handle of the existing I/O completion port if successful; it does not create a new I/O completion port. If this parameter is NULL, the function creates a new I/O completion port and, if the FileHandle parameter is valid, associates it with the new I/O completion port. Otherwise no file handle association occurs. The function returns the handle to the new I/O completion port if successful."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "CompletionKey",
        "description": "The per-handle user-defined completion key that is included in every I/O completion packet for the specified file handle. For more information, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "NumberOfConcurrentThreads",
        "description": "The maximum number of threads that the operating system can allow to concurrently process I/O completion packets for the I/O completion port. This parameter is ignored if the ExistingCompletionPort parameter is not NULL. If this parameter is zero, the system allows as many concurrently running threads as there are processors in the system."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a symbolic link.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of      the path name; relative links are determined relative to where relative\u00e2\u0080\u0093link specifiers are      in a specified path. Relative links are specified using the following conventions: To remove a symbolic link, delete the file (using      DeleteFile or similar APIs) or remove the directory (using      RemoveDirectory or similar APIs) depending on what type      of symbolic link is used. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs does not support soft link or any other reparse points. ",
    "return_type": "BOOLEAN",
    "category": "Files and I/O (Local file system)",
    "name": "CreateSymbolicLink",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpSymlinkFileName",
        "description": "The symbolic link to be created. This parameter may include the path. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (CreateSymbolicLinkW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpTargetFileName",
        "description": "The name of the target for the symbolic link to be created.  If lpTargetFileName has a device name associated with it, the link is treated as        an absolute link; otherwise, the link is treated as a relative link. This parameter may include the path. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (CreateSymbolicLinkW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Indicates whether the link target, lpTargetFileName, is a directory.  ValueMeaning   0x0   The link target is a file.   SYMBOLIC_LINK_FLAG_DIRECTORY 0x1   The link target is a directory."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of      the path name; relative links are determined relative to where relative\u00e2\u0080\u0093link specifiers are      in a specified path. Relative links are specified using the following conventions: In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "BOOLEAN",
    "category": "Files and I/O (Local file system)",
    "name": "CreateSymbolicLinkTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpSymlinkFileName",
        "description": "The symbolic link to be created."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpTargetFileName",
        "description": "The name of the target for the symbolic link to be created. If lpTargetFileName has a device name associated with it, the link is treated as an         absolute link; otherwise, the link is treated as a relative link."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Indicates whether the link target, lpTargetFileName, is a directory.  ValueMeaning   0x0   The link target is a file.   SYMBOLIC_LINK_FLAG_DIRECTORY 0x1   The link target is a directory."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Decrypts an encrypted file or directory.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  DecryptFile function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,  DecryptFile simply returns a nonzero value, which indicates success. If lpFileName specifies a read-only file, the function fails and GetLastError returns ERROR_FILE_READ_ONLY. If lpFileName specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted. In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "DecryptFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file or directory to be decrypted. The caller must have the FILE_READ_DATA, FILE_WRITE_DATA, FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, and SYNCHRONIZE access rights. For more information, see  File Security and Access Rights."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call         GetLastError. ",
    "remarks": "If an application attempts to delete a file that does not exist, the      DeleteFileTransacted function fails with      ERROR_FILE_NOT_FOUND. If the file is a read-only file, the function fails with      ERROR_ACCESS_DENIED. The following list identifies some tips for deleting, removing, or closing files: If you set up a directory with all access except delete and delete child, and the access control lists (ACL)        of new files are inherited, then you can create a file without being able to delete it. However, then you can        create a file, and then get all the access you request on the handle that is returned to you at the time you        create the file. If you request delete permission at the time you create a file, you can delete or rename the file with that        handle, but not with any other handle. For more information, see        File Security and Access Rights. The DeleteFileTransacted function fails if an      application attempts to delete a file that has other handles open for normal I/O or as a memory-mapped file      (FILE_SHARE_DELETE must have been specified when other handles were opened). The DeleteFileTransacted function marks a file      for deletion on close. The file is deleted after the last transacted writer handle to the file is closed, provided      that the transaction is still active. If a file has been marked for deletion and a transacted writer handle is      still open after the transaction completes, the file will not be deleted. Symbolic links:  If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you        must call CreateFile and specify        FILE_FLAG_DELETE_ON_CLOSE. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "DeleteFileTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file to be deleted. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. The file must reside on the local computer; otherwise, the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Copies the EFS metadata from one file or directory to another.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "Exclusive access to the destination file or directory is required by EFS for the call to this function. If this access is not provided, this function will fail. The caller should have the EFS key for the source file or directory, and at least the READ_ATTRIBUTE ACL for the source file or directory. The specified source and destination file or directories should reside on the same computer; otherwise, an error will be returned. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "DuplicateEncryptionInfoFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "SrcFileName",
        "description": "The name of the file or directory from which the EFS metadata is to be copied. This source file or directory must be encrypted."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "DstFileName",
        "description": "The name of the file or directory to which the EFS metadata is to be copied.     This destination file or directory does not have to be encrypted before the call to this function; however if this function completes successfully, it will be encrypted. If the value of SrcFileName specifies a file, the value of this parameter must also specify a file, and likewise for directories. If a file or directory with the name specified by this parameter does not exist, a file or directory (depending on whether SrcFileName specifies a file or directory) will be created."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCreationDistribution",
        "description": "Describes how the destination file or directory identified by the DstFileName parameter value is to be opened. The following are the valid values of this parameter.     ValueMeaning  CREATE_ALWAYS 2   Always create the destination file or directory. Any value passed in this parameter other than CREATE_NEW will be processed as CREATE_ALWAYS.   CREATE_NEW 1   Create the destination file or directory only if it does not already exist. If it does exist, and this value is specified, this function will fail."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAttributes",
        "description": "The file attributes of the destination file or directory. The FILE_READ_ONLY attribute is currently not processed by this function."
      },
      {
        "in_out": "_In_opt_",
        "type": "const LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies the security attributes of the destination file or directory, if it does not already exist. If you specify NULL, the file or directory gets a default security descriptor. The ACLs in the default security descriptor for a file or directory are inherited from its parent directory."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Encrypts a file or directory.  All data streams in a file are encrypted. All new files      created in an encrypted directory are encrypted.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The EncryptFile function requires exclusive access to      the file being encrypted, and will fail if another process is using the file. If the file is already encrypted, EncryptFile simply      returns a nonzero value, which indicates success. If the file is compressed,      EncryptFile will decompress the file before encrypting      it. If lpFileName specifies a read-only file, the function fails and      GetLastError returns      ERROR_FILE_READ_ONLY. If lpFileName specifies a directory that      contains a read-only file, the functions succeeds but the directory is not encrypted. To decrypt an encrypted file, use the      DecryptFile function. In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "EncryptFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file or directory to be encrypted. The caller must have the FILE_READ_DATA, FILE_WRITE_DATA,         FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, and         SYNCHRONIZE access rights. For more information, see         File Security and Access Rights."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Disables or enables encryption of the specified directory and the files in it. It does not      affect encryption of subdirectories below the indicated directory.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinEfs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Under normal circumstances, EncryptFile will not encrypt      files and directories with the FILE_ATTRIBUTE_SYSTEM attribute set. It is possible to      override the FILE_ATTRIBUTE_SYSTEM attribute and encrypt files. Also, if a file or      directory is marked with the FILE_ATTRIBUTE_SYSTEM attribute, it will normally be     invisible to the user in directory listings and Windows Explorer directory windows.      EncryptionDisable disables encryption of directories and files. It does not      affect the visibility of files with the FILE_ATTRIBUTE_SYSTEM attribute set. If TRUE is passed in,      EncryptionDisable will write the following to the      Desktop.ini file in the directory (creating it if necessary): If the section already exists but Disable is set to 0, it will be set to 1. Thereafter, EncryptFile will fail on the      directory and the files in it, and the code that      GetLastError returns will be      ERROR_DIR_EFS_DISALLOWED. This function does not affect encryption of subdirectories      within the given directory. The user can also manually add or edit the above lines in the Desktop.ini file and produce the      same effect. EncryptionDisable affects only      FileEncryptionStatus and      EncryptFile. After the directory is      encrypted, any new files and new subdirectories created without the      FILE_ATTRIBUTE_SYSTEM attribute will be encrypted. If FALSE is passed in,      EncryptionDisable will write the following to the      Desktop.ini file: This means that  file encryption is permitted on the files in that directory. If you try to use EncryptionDisable to set the      directory to the state it is already in, the function succeeds but has no effect. If you try to use EncryptionDisable to disable or      enable encryption on a file, the attempt will fail. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "EncryptionDisable",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "DirPath",
        "description": "The name of the directory for which to enable or        disable encryption."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "Disable",
        "description": "Indicates whether to disable encryption (TRUE) or enable it        (FALSE)."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "An application-defined callback function used with      ReadEncryptedFileRaw. The system calls      ExportCallback one or more times, each time with a block      of the encrypted file's data, until it has received all of the file data.      ExportCallback writes the encrypted file's data to      another storage media, usually for purposes of backing up the file.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it must set the return value to ERROR_SUCCESS. If the function fails, set the return value to a nonzero error code defined in WinError.h. For         example, if this function fails because an API that it calls fails, you can set the return value to the value         returned by GetLastError for the failed API. ",
    "remarks": "You can use the application-defined context block for internal tracking of information such as the file handle       and the current offset in the file. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "ExportCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PBYTE",
        "name": "pbData",
        "description": "A pointer to a block of the encrypted file's data to be backed up. This block of data is allocated by the        system."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "pvCallbackContext",
        "description": "A pointer to an application-defined and allocated context block. The application passes this pointer to        ReadEncryptedFileRaw, and        ReadEncryptedFileRaw passes this pointer to the        callback function so that it can have access to application-specific data. This data can be a structure and can        contain any data the application needs, such as the handle to the file that contains the backup copy of the        encrypted file."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulLength",
        "description": "The size of the data pointed to by the pbData parameter, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the encryption status of the specified file.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "FileEncryptionStatus",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpStatus",
        "description": "A pointer to a variable that receives the encryption status of the file. This parameter can be one of the        following values.  ValueMeaning  FILE_ENCRYPTABLE 0   The file can be encrypted.          Home, Home Premium, Starter, and ARM Editions of Windows:  FILE_ENCRYPTABLE may be returned but EFS does not support encrypting files on            these editions of Windows.   FILE_IS_ENCRYPTED 1   The file is encrypted.   FILE_READ_ONLY 8   The file is a read-only file.   FILE_ROOT_DIR 3   The file is a root directory. Root directories cannot be encrypted.   FILE_SYSTEM_ATTR 2   The file is a system file. System files cannot be encrypted.   FILE_SYSTEM_DIR 4   The file is a system directory. System directories cannot be encrypted.   FILE_SYSTEM_NOT_SUPPORT 6   The file system does not support file encryption.   FILE_UNKNOWN 5   The encryption status is unknown. The file may be encrypted.   FILE_USER_DISALLOWED 7   Reserved for future use."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "An application-defined callback function used with the      ReadFileEx and      WriteFileEx functions. It is called when the asynchronous      input and output (I/O) operation is completed or canceled and the calling thread is in an alertable      state (by using the SleepEx,      MsgWaitForMultipleObjectsEx,      WaitForSingleObjectEx, or      WaitForMultipleObjectsEx function with the      fAlertable parameter set to TRUE).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The return value for an asynchronous operation is 0 (ERROR_SUCCESS) if the operation      completed successfully or if the operation completed with a warning. To determine whether an I/O operation was      completed successfully, check that dwErrorCode is 0, call      GetOverlappedResult, then call      GetLastError. For example, if the buffer was not large      enough to receive all of the data from a call to ReadFileEx,      dwErrorCode is set to 0,      GetOverlappedResult fails, and      GetLastError returns      ERROR_MORE_DATA. Returning from this function allows another pending I/O completion routine to be called. All waiting      completion routines are called before the alertable thread's wait is completed with a return code of      WAIT_IO_COMPLETION. The system may call the waiting completion routines in any order.      They may or may not be called in the order the I/O functions are completed. Each time the system calls a completion routine, it uses some of the application's stack. If the completion      routine does additional asynchronous I/O and alertable waits, the stack may grow. For more information, see      Asynchronous Procedure Calls. For  example code, see       Named Pipe Server Using Completion Routines. ",
    "return_type": "VOID CALLBACK",
    "category": "Files and I/O (Local file system)",
    "name": "FileIOCompletionRoutine",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwErrorCode",
        "description": "The I/O completion status. This parameter can be one of the        system error codes."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNumberOfBytesTransfered",
        "description": "The number of bytes transferred. If an error occurs, this parameter is zero."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to the OVERLAPPED structure specified by         the asynchronous I/O function. The system does not use the OVERLAPPED structure         after the completion routine is called, so the completion routine can deallocate the memory used by the         overlapped structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Reads data from the specified file or input/output (I/O) device. It reports its completion status      asynchronously, calling the specified completion routine when reading is completed or canceled and the calling      thread is in an alertable wait state.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. If the function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped read         operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable         wait state, the system calls the function pointed to by lpCompletionRoutine, and the         wait state completes with a return code of WAIT_IO_COMPLETION. If the function succeeds, and the file reading operation completes, but the calling thread is not in an         alertable wait state, the system queues the completion routine call, holding the call until the calling thread         enters an alertable wait state. For information about alertable waits and overlapped input/output operations,         see About Synchronization. If ReadFileEx attempts to read past the         end-of-file (EOF), the call to         GetOverlappedResult for that operation returns         FALSE and GetLastError         returns ERROR_HANDLE_EOF. ",
    "remarks": "When using ReadFileEx you should check      GetLastError even when the function returns \"success\" to      check for conditions that are \"successes\" but have some outcome you might want to know about. For example, a      buffer overflow when calling ReadFileEx will return      TRUE, but GetLastError will      report the overflow with ERROR_MORE_DATA. If the function call is successful and there      are no warning conditions, GetLastError will return      ERROR_SUCCESS. The ReadFileEx function may fail if there are too many      outstanding asynchronous I/O requests. In the event of such a failure,      GetLastError can return      ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY. To cancel all pending asynchronous I/O operations, use either: Use CancelSynchronousIo to cancel pending       synchronous I/O operations. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. If part of the file specified by hFile is locked by another process, and the read      operation specified in a call to ReadFileEx overlaps the      locked portion, the call to ReadFileEx fails. When attempting to read data from a mailslot whose buffer is too small,      ReadFileEx returns FALSE, and      GetLastError returns      ERROR_INSUFFICIENT_BUFFER. Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read      into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read      operation is using until the read operation completes. An application uses the      MsgWaitForMultipleObjectsEx,      WaitForSingleObjectEx,      WaitForMultipleObjectsEx, and      SleepEx functions to enter an alertable wait state. For more      information about alertable waits and overlapped input/output, see      About Synchronization. There are strict requirements for successfully working with files opened with      CreateFile using      FILE_FLAG_NO_BUFFERING. For details see      File Buffering. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If there is a transaction bound to the file handle, then the function returns data from the transacted view of        the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the handle.        For additional information, see        About Transactional NTFS. For an example, see      Named Pipe Server Using Completion Routines. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "ReadFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer,         tape drive, socket, communications resource, mailslot, or pipe). This parameter can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the         CreateFile function, or a socket handle returned by the         socket or         accept function. This handle also must have the GENERIC_READ access right. For more information on         access rights, see         File Security and Access Rights."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the data read from the file or device. This buffer must remain valid for the duration of the read operation. The application should not use this         buffer until the read operation is completed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToRead",
        "description": "The number of bytes to be read."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED data structure that         supplies data to be used during the asynchronous (overlapped) file read operation. For files that support byte offsets, you must specify a byte offset at which to start reading from the file.         You specify this offset by setting the Offset and         OffsetHigh members of the         OVERLAPPED structure. For files or devices that do not         support byte offsets, Offset and OffsetHigh are         ignored. The ReadFileEx function ignores the         OVERLAPPED structure's         hEvent member. An application is free to use that member for its own purposes in the         context of a ReadFileEx call.         ReadFileEx signals completion of its read operation by         calling, or queuing a call to, the completion routine pointed to by         lpCompletionRoutine, so it does not need an event handle. The ReadFileEx function does use the         OVERLAPPED structure's         Internal and InternalHigh members. An application should         not set these members. The OVERLAPPED data structure must remain valid for         the duration of the read operation. It should not be a variable that can go out of scope while the read         operation is pending completion."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine to be called when the read operation is complete and the calling thread        is in an alertable wait state. For more information about the completion routine, see        FileIOCompletionRoutine."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when writing is completed or canceled and the calling thread is in an alertable wait state.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. If the WriteFileEx function succeeds, the calling         thread has an asynchronous I/O operation pending: the overlapped write operation to the file.         When this I/O operation finishes, and the calling thread is blocked in an alertable wait state, the         operating system calls the function pointed to by lpCompletionRoutine, and the wait         completes with a return code of WAIT_IO_COMPLETION. If the function succeeds and the file-writing operation finishes, but the calling thread is not in an         alertable wait state, the system queues the call to *lpCompletionRoutine, holding the         call until the calling thread enters an alertable wait state. For more information about         alertable wait states and overlapped input/output operations, see About Synchronization. ",
    "remarks": "When using WriteFileEx you should check      GetLastError even when the function returns \"success\" to      check for conditions that are \"successes\" but have some outcome you might want to know about. For example, a      buffer overflow when calling WriteFileEx will return      TRUE, but GetLastError will      report the overflow with ERROR_MORE_DATA. If the function call is successful and there      are no warning conditions, GetLastError will return      ERROR_SUCCESS. The WriteFileEx function will fail if the hFile parameter is associated with an I/O completion port. To perform writes using this type of handle, use the WriteFile function. The WriteFileEx function may fail if there are too many outstanding asynchronous I/O requests. In the event of such a failure, GetLastError can return ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY. To cancel all pending asynchronous I/O operations, use either: Use CancelSynchronousIo to cancel pending       synchronous I/O operations. I/O operations that are canceled complete with the error       ERROR_OPERATION_ABORTED. If part of the file specified by hFile is locked by another process, and the specified write operation overlaps the locked      portion, WriteFileEx fails. When writing to a file, the last write time is not fully updated until all handles used for writing have been      closed. Therefore, to ensure an accurate last write time, close the file handle immediately after writing to the      file. Accessing the output buffer while a write operation is using the buffer may lead to corruption of the data      written from that buffer. Applications must not write to, reallocate, or free the output buffer that a write      operation is using until the write operation completes. Note that the time stamps may not be updated correctly for a remote file. To ensure consistent results, use      unbuffered I/O. The system interprets zero bytes to write as specifying a null write operation and  WriteFile does not truncate or extend the file. To truncate or extend a file, use the  SetEndOfFile function. An application uses the      WaitForSingleObjectEx,      WaitForMultipleObjectsEx,      MsgWaitForMultipleObjectsEx,      SignalObjectAndWait, and      SleepEx functions to enter an alertable wait state. For more information about alertable wait      states and overlapped I/O operations, see About Synchronization. If you write directly to a volume that has a mounted file system, you must first obtain exclusive access to the volume. Otherwise, you risk causing data corruption or system instability, because your application's writes may conflict with other changes coming from the file system and leave the contents of the volume in an inconsistent state. To prevent these problems, the following changes have been made in Windows Vista and later: There are strict requirements for successfully working with files opened with CreateFile using FILE_FLAG_NO_BUFFERING. For details see File Buffering. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If there is a transaction bound to the file handle, then the file write is transacted. For more information, see About Transactional NTFS. For an example, see       Named Pipe Server Using Completion Routines. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "WriteFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive,      socket, communications resource, mailslot, or  pipe).          This parameter can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the          CreateFile function, or a socket handle returned by the          socket or          accept function.  Do not associate an I/O completion port with this handle. For more information, see the Remarks section. This handle also must have the GENERIC_WRITE access        right. For more information on access rights, see        File Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "lpBuffer",
        "description": "A pointer to the buffer containing the data to be written to the file or device.       This buffer must remain valid for the duration of the write operation. The caller must not use this buffer        until the write operation is completed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToWrite",
        "description": "The number of bytes to be written to the file or device.        A value of zero specifies a null write operation. The behavior of a null write operation depends on the         underlying file system. Pipe write operations across a network are limited to 65,535 bytes per write. For more information regarding  pipes, see the Remarks section."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED data structure that        supplies data to be used during the overlapped (asynchronous) write operation.        For files that support byte offsets, you must specify a byte offset at which to start writing to the file.         You specify this offset by setting the Offset and         OffsetHigh members of the         OVERLAPPED structure. For files or devices that do not support         byte offsets, Offset and OffsetHigh are ignored. To write to the end of file, specify both the Offset and OffsetHigh members of the OVERLAPPED structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open hFile using FILE_APPEND_DATA access. The WriteFileEx function ignores the         OVERLAPPED structure's         hEvent member. An application is free to use that member for its own purposes in the         context of a WriteFileEx call.         WriteFileEx signals completion of its writing operation         by calling, or queuing a call to, the completion routine pointed to by         lpCompletionRoutine, so it does not need an event handle. The WriteFileEx function does use the         Internal and InternalHigh members of the         OVERLAPPED structure. You should not change the value         of these members. The OVERLAPPED data structure must remain valid for         the duration of the write operation. It should not be a variable that can go out of scope while the write         operation is pending completion."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to a completion routine to be called when the write operation has been completed and the calling        thread is in an alertable wait state. For more information about this completion routine, see        FileIOCompletionRoutine."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Closes a file search handle opened by the      FindFirstFile,      FindFirstFileEx,      FindFirstFileNameW,      FindFirstFileNameTransactedW,      FindFirstFileTransacted,      FindFirstStreamTransactedW, or      FindFirstStreamW functions.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "After the FindClose function is called, the handle      specified by the hFindFile parameter cannot be used in subsequent calls to the      FindNextFile,      FindNextFileNameW,      FindNextStreamW, or      FindClose functions. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see       Listing the Files in a Directory. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "FindClose",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "HANDLE",
        "name": "hFindFile",
        "description": "The file search handle."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Searches a directory for a file or subdirectory with a name that matches a specific name (or partial      name if wildcards are used).",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle used in a subsequent call to         FindNextFile or         FindClose, and  the         lpFindFileData parameter contains information about the first file or directory         found. If the function fails or fails to locate files from the search string in the         lpFileName parameter, the return value is         INVALID_HANDLE_VALUE and the contents of lpFindFileData are         indeterminate. To get extended error information, call the         GetLastError function. If the function fails because no matching files can be found, the         GetLastError function returns         ERROR_FILE_NOT_FOUND. ",
    "remarks": "The FindFirstFile function opens a search handle and      returns information about the first file that the file system finds with a name that matches the specified      pattern. This may or may not be the first file or directory that appears in a directory-listing application (such      as the dir command) when given the same file name string pattern. This is because      FindFirstFile does no sorting of the search results. For      additional information, see FindNextFile. The following list identifies some other search characteristics: After the search handle is established, you can use it to search for other files that match the same pattern      by using the FindNextFile function. When the search handle is no longer needed, close it by using the      FindClose function, not      CloseHandle. As stated previously, you cannot use a trailing backslash (\\) in the lpFileName      input string for FindFirstFile, therefore it may not be      obvious how to search root directories. If you want to see files or get the attributes of a root directory, the      following options would apply: On network shares, you can use an lpFileName in the form of the following:      \"\\\\Server\\Share\\*\". However, you cannot use an lpFileName      that points to the share itself; for example, \"\\\\Server\\Share\" is not valid. To examine a directory that is not a root directory, use the path to that directory, without a trailing      backslash. For example, an argument of \"C:\\Windows\" returns information about the      directory \"C:\\Windows\", not about a directory or file in      \"C:\\Windows\". To examine the files and directories in      \"C:\\Windows\", use an lpFileName of      \"C:\\Windows\\*\". Be aware that some other thread or process could create or delete a file with this name between the time you      query for the result and the time you act on the information. If this is a potential concern for your application,      one possible solution is to use the CreateFile function with      CREATE_NEW (which fails if the file exists) or OPEN_EXISTING      (which fails if the file does not exist). If you are writing a 32-bit application to list all the files in a directory and the application may be  run      on a 64-bit computer, you should call the      Wow64DisableWow64FsRedirectionfunction      before calling FindFirstFile and call      Wow64RevertWow64FsRedirection after the      last call to FindNextFile. For more information, see      File System Redirector. If the path points to a symbolic link, the      WIN32_FIND_DATA buffer contains information about      the symbolic link, not the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  The following C++ example shows you a minimal use of FindFirstFile. For another example, see       Listing the Files in a Directory. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk         (*) or a question mark (?). This parameter should not be NULL, an invalid string (for example, an empty string         or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to         the root and all subdirectories on the path. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (FindFirstFileW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_Out_",
        "type": "LPWIN32_FIND_DATA",
        "name": "lpFindFileData",
        "description": "A pointer to the WIN32_FIND_DATA structure that        receives information about a found file or directory."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Searches a directory for a file or subdirectory with a name and attributes that match those      specified.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle used in a subsequent call to         FindNextFile or         FindClose, and  the         lpFindFileData parameter contains information about the first file or directory         found. If the function fails or fails to locate files from the search string in the         lpFileName parameter, the return value is         INVALID_HANDLE_VALUE and the contents of lpFindFileData are         indeterminate. To get extended error information, call the         GetLastError function. ",
    "remarks": "The FindFirstFileEx function opens a search handle      and returns information about the first file that the file system finds with a name that matches the specified      pattern. This may or may not be the first file or directory that appears in a directory-listing application (such      as the dir command) when given the same file name string pattern. This is because      FindFirstFileEx does no sorting of the search results.      For additional information, see FindNextFile. The following list identifies some other search characteristics: If the underlying file system does not support the specified type of filtering, other than directory      filtering, FindFirstFileEx fails with the error      ERROR_NOT_SUPPORTED. The application must use      FINDEX_SEARCH_OPS type      FileExSearchNameMatch and perform its own filtering. After the search handle is established, use it in the      FindNextFile function to search for other      files that match the same pattern with the same filtering that is being performed. When the search handle is not      needed, it should be closed by using the      FindClose function. As stated previously, you cannot use a trailing backslash (\\) in the lpFileName      input string for FindFirstFileEx, therefore it may not      be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the      following options would apply: On network shares, you can use an lpFileName in the form of the following:      \"\\\\server\\service\\*\". However, you cannot use an lpFileName that points      to the share itself; for example, \"\\\\server\\service\" is not valid. To examine a directory that is not a root directory, use the path to that directory, without a trailing      backslash. For example, an argument of \"C:\\Windows\" returns information about the      directory \"C:\\Windows\", not about a directory or file in      \"C:\\Windows\". To examine the files and directories in      \"C:\\Windows\", use an lpFileName of      \"C:\\Windows\\*\". The following call: Is equivalent to the following call: Be aware that some other thread or process could create or delete a file with this name between the time you      query for the result and the time you act on the information. If this is a potential concern for your application,      one possible solution is to use the CreateFile function with      CREATE_NEW (which fails if the file exists) or OPEN_EXISTING      (which fails if the file does not exist). If you are writing a 32-bit application to list all the files in a directory and the application may be run on      a 64-bit computer, you should call      Wow64DisableWow64FsRedirection before      calling FindFirstFileEx and call      Wow64RevertWow64FsRedirection after the      last call to FindNextFile. For more information, see      File System Redirector. If the path points to a symbolic link, the      WIN32_FIND_DATA buffer contains information about      the symbolic link, not the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  The following code shows a minimal use of       FindFirstFileEx. This program is equivalent to the       example in the FindFirstFile topic. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk         (*) or a question mark (?). This parameter should not be NULL, an invalid string (for example, an empty string         or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all         subdirectories on the path. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (FindFirstFileExW), and         prepend \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (FindFirstFileExW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "FINDEX_INFO_LEVELS",
        "name": "fInfoLevelId",
        "description": "The information level of the returned data.        This parameter is one of the         FINDEX_INFO_LEVELS enumeration values."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFindFileData",
        "description": "A pointer to the buffer that receives the file data.        The pointer type is determined by the level of information that is specified in the         fInfoLevelId parameter."
      },
      {
        "in_out": "_In_",
        "type": "FINDEX_SEARCH_OPS",
        "name": "fSearchOp",
        "description": "The type of filtering to perform that is different from wildcard matching.        This parameter is one of the FINDEX_SEARCH_OPS         enumeration values."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPVOID",
        "name": "lpSearchFilter",
        "description": "A pointer to the search criteria if the specified fSearchOp needs structured        search information.        At this time, none of the supported fSearchOp values require extended search         information. Therefore, this pointer must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAdditionalFlags",
        "description": "Specifies additional flags that control the search.  ValueMeaning  FIND_FIRST_EX_CASE_SENSITIVE 1   Searches are case-sensitive.   FIND_FIRST_EX_LARGE_FETCH 2   Uses a larger buffer for directory queries, which can increase performance of the find operation. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported until Windows Server 2008 R2 and Windows 7."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Creates an enumeration of all the hard links to the specified file. The      FindFirstFileNameW function returns a handle to the      enumeration that can be used on subsequent calls to the      FindNextFileNameW function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle that can be used with the         FindNextFileNameW function or closed with the         FindClose function. If the function fails, the return value is INVALID_HANDLE_VALUE (0xffffffff). To         get extended error information, call the GetLastError         function. ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstFileNameW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the file. Tip  Starting with Windows 10, version 1607, you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved; specify zero (0)."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "StringLength",
        "description": "The size of the buffer pointed to by the LinkName parameter, in characters. If        this call fails and the error returned from the        GetLastError function is        ERROR_MORE_DATA (234), the value that is returned by this parameter is the size that        the buffer pointed to by LinkName  must be to contain all the data."
      },
      {
        "in_out": "_Inout_",
        "type": "PWCHAR",
        "name": "LinkName",
        "description": "A pointer to a buffer to store the first link name found for lpFileName."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle that can be used with the         FindNextFileNameW function or closed with the         FindClose function. If the function fails, the return value is INVALID_HANDLE_VALUE (0xffffffff). To         get extended error information, call the GetLastError        function. ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstFileNameTransactedW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the file. The file must reside on the local computer; otherwise, the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE (6805)."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved; specify zero (0)."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "StringLength",
        "description": "The size of the buffer pointed to by the LinkName parameter, in characters. If this         call fails and the error is ERROR_MORE_DATA (234), the value that is returned by this         parameter is the size that the buffer pointed to by LinkName must be to contain all         the data."
      },
      {
        "in_out": "_Inout_",
        "type": "PWCHAR",
        "name": "LinkName",
        "description": "A pointer to a buffer to store the first link name found for lpFileName."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the         CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle used in a subsequent call to         FindNextFile or         FindClose, and  the lpFindFileData parameter contains information about the first file or directory found. If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate. To get extended         error information, call the GetLastError function. ",
    "remarks": "The FindFirstFileTransacted function opens a search handle and      returns information about the first file that the file system finds with a name that matches the specified pattern. This may or may not be the first file or directory that appears in a directory-listing application (such as the dir command) when given the same file name string pattern. This is because FindFirstFileTransacted does no sorting of the search results. For additional information, see FindNextFile. The following list      identifies some other search characteristics: If the underlying file system does not support the specified type of filtering, other than directory      filtering, FindFirstFileTransactedfails with the error      ERROR_NOT_SUPPORTED. The application must use      FINDEX_SEARCH_OPS type      FileExSearchNameMatch and perform its own filtering. After the search handle is established, use it in the      FindNextFile function to search for other      files that match the same pattern with the same filtering that is being performed. When the search handle is not      needed, it should be closed by using the      FindClose function. As stated previously, you cannot use a trailing backslash (\\) in the lpFileName input string for      FindFirstFileTransacted, therefore it may not be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the following options would apply: On network shares, you can use an lpFileName in the form of the following:      \"\\\\server\\service\\*\". However, you cannot use an lpFileName that points to      the share itself; for example, \"\\\\server\\service\" is not valid. To examine a directory that is not a root directory, use the path to that directory, without a trailing      backslash. For example, an argument of \"C:\\Windows\" returns information about the directory      \"C:\\Windows\", not about a directory or file in \"C:\\Windows\". To examine the files and directories in \"C:\\Windows\", use an lpFileName of \"C:\\Windows\\*\". Be aware that some other thread or process could create or delete a file with this name between the time you query for the result      and the time you act on the information. If this is a potential concern for your application,  one possible solution is to use the      CreateFile function with      CREATE_NEW (which fails if the file exists) or OPEN_EXISTING (which fails      if the file does not exist). If you are writing a 32-bit application to list all the files in a directory and the application may be run on      a 64-bit computer, you should call      Wow64DisableWow64FsRedirection before      calling FindFirstFileTransacted and call Wow64RevertWow64FsRedirection after the last call to FindNextFile. For more information, see File System Redirector. If the path points to a symbolic link, the      WIN32_FIND_DATA buffer contains information about      the symbolic link, not the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstFileTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk         (*) or a question mark (?). This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and         all subdirectories on the path. In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to         32,767 wide characters, call the Unicode version of the function and prepend \"\\\\?\\\" to the         path. For more information, see         Naming a File. The file must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_In_",
        "type": "FINDEX_INFO_LEVELS",
        "name": "fInfoLevelId",
        "description": "The information level of the returned data.        This parameter is one of the         FINDEX_INFO_LEVELS enumeration values."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFindFileData",
        "description": "A pointer to the WIN32_FIND_DATA structure that         receives information about a found file or subdirectory."
      },
      {
        "in_out": "_In_",
        "type": "FINDEX_SEARCH_OPS",
        "name": "fSearchOp",
        "description": "The type of filtering to perform that is different from wildcard matching.        This parameter is one of the FINDEX_SEARCH_OPS         enumeration values."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPVOID",
        "name": "lpSearchFilter",
        "description": "A pointer to the search criteria if the specified fSearchOp needs structured search         information.        At this time, none of the supported fSearchOp values require extended search         information. Therefore, this pointer must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAdditionalFlags",
        "description": "Specifies additional flags that control the search.  ValueMeaning  FIND_FIRST_EX_CASE_SENSITIVE 1   Searches are case-sensitive."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle that can be used in subsequent calls to the         FindNextStreamWfunction. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended         error information, call GetLastError. ",
    "remarks": "All files contain a default data stream. On NTFS, files can also contain one or more named data streams. On      FAT file systems, files cannot have more that the default data stream, and therefore, this function will not      return valid results when used on FAT filesystem files. This function works on all file systems that supports hard      links; otherwise, the function returns ERROR_STATUS_NOT_IMPLEMENTED (6805). The FindFirstStreamTransactedW function      opens a search handle and returns information about the first stream in the specified file or directory. For      files, this is always the default data stream, ::$DATA. After the search handle has been established, use it in      the FindNextStreamW function to search for other      streams in the specified file or directory. When the search handle is no longer needed, it should be closed using      the FindClosefunction. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstStreamTransactedW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The fully qualified file name. The file must reside on the local computer; otherwise, the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE (6805)."
      },
      {
        "in_out": "_In_",
        "type": "STREAM_INFO_LEVELS",
        "name": "InfoLevel",
        "description": "The information level of the returned data. This parameter is one of the values in the        STREAM_INFO_LEVELS enumeration type.  ValueMeaning  FindStreamInfoStandard 0   The data is returned in a          WIN32_FIND_STREAM_DATA structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFindStreamData",
        "description": "A pointer to a buffer that receives the file data. The format of this data depends on the value of         the InfoLevel parameter."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved for future use. This parameter must be zero."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the         CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the first stream with a ::$DATA stream type in the specified file or      directory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a search handle that can be used in subsequent calls to the         FindNextStreamW function. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended         error information, call GetLastError. If no  streams can be found, the function fails and         GetLastError returns         ERROR_HANDLE_EOF (38). ",
    "remarks": "The FindFirstStreamW function opens a search      handle and returns information about the first ::$DATA stream in the specified file or directory. For      files, this is always the default data stream, \"::$DATA\". After the search handle has been      established, use it in the FindNextStreamW function to      search for other streams in the specified file or directory. When the search handle is no longer needed, it should      be closed using the FindClose function. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 supports list of streams less than or equal to 64K. ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "FindFirstStreamW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The fully qualified file name."
      },
      {
        "in_out": "_In_",
        "type": "STREAM_INFO_LEVELS",
        "name": "InfoLevel",
        "description": "The information level of the returned data. This parameter is one of the values in the        STREAM_INFO_LEVELS enumeration type.  ValueMeaning  FindStreamInfoStandard 0   The data is returned in a          WIN32_FIND_STREAM_DATA structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFindStreamData",
        "description": "A pointer to a buffer that receives the file stream data. The format of this data depends on the value of        the InfoLevel parameter."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved for future use. This parameter must be zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Continues enumerating the hard links to a file using the handle returned by a successful call to the      FindFirstFileNameW function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call         GetLastError. If no matching files can be found, the GetLastError         function returns ERROR_HANDLE_EOF. ",
    "remarks": "If the function returns TRUE, there are more hard links to enumerate. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "FindNextFileNameW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFindStream",
        "description": "A handle to the enumeration that is returned by a successful call to        FindFirstFileNameW."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "StringLength",
        "description": "The size of the LinkName parameter, in characters. If this call fails and the        error is ERROR_MORE_DATA, the value that is returned by this parameter is the size        that LinkName  must be to contain all the data."
      },
      {
        "in_out": "_Inout_",
        "type": "PWCHAR",
        "name": "LinkName",
        "description": "A pointer to a buffer to store the first link name found for lpFileName."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Continues a file search from a previous call to the      FindFirstFile,      FindFirstFileEx, or      FindFirstFileTransacted functions.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero and  the lpFindFileData         parameter contains information about the next file or directory found. If the function fails, the return value is zero and the contents of lpFindFileData         are indeterminate. To get extended error information, call the         GetLastError function. If the function fails because no more matching files can be found, the         GetLastError function returns         ERROR_NO_MORE_FILES. ",
    "remarks": "This function uses the same search filters that were used to create the search handle passed in the      hFindFile parameter. For additional information, see      FindFirstFile and      FindFirstFileEx. The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is      dependent on the file system. If the data  must be sorted,      the application must do the ordering after obtaining all the results. The order in which this function returns the file names is dependent on the file system type. With the NTFS      file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,      the names are usually returned in the order the files were written to the disk, which may or may not be in      alphabetical order. However, as stated previously, these behaviors are not guaranteed. If the path points to a symbolic link, the      WIN32_FIND_DATA buffer contains information about the      symbolic link, not the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If there is a transaction bound to the file enumeration handle, then the files that are returned are subject        to transaction isolation rules. For an example, see       Listing the Files in a Directory. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "FindNextFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFindFile",
        "description": "The search handle returned by a previous call to the        FindFirstFile or        FindFirstFileEx function."
      },
      {
        "in_out": "_Out_",
        "type": "LPWIN32_FIND_DATA",
        "name": "lpFindFileData",
        "description": "A pointer to the WIN32_FIND_DATA structure        that receives information about the found file or subdirectory."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Continues a stream search started by a previous call to the      FindFirstStreamW function.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. If no  more streams can be found,         GetLastError returns         ERROR_HANDLE_EOF (38). ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "FindNextStreamW",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFindStream",
        "description": "The search handle returned by a previous call to the        FindFirstStreamW function."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFindStreamData",
        "description": "A pointer to the        WIN32_FIND_STREAM_DATA structure that        receives information about the stream."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Flushes the buffers of a specified file and causes all buffered data to be written to a file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. The function fails if hFile is a handle to the console output. That is because the console output is not buffered. The function returns FALSE, and GetLastError returns ERROR_INVALID_HANDLE. ",
    "remarks": "Typically the  WriteFile and  WriteFileEx functions write data to an internal buffer that the operating system writes to a disk or communication pipe on a regular basis. The  FlushFileBuffers function writes all the buffered information for a specified file to the device or pipe. Due to disk caching interactions within the system, the  FlushFileBuffers function can be inefficient when used after every write to a disk drive device when many writes are being performed separately. If an application is  performing multiple writes to disk and also needs to ensure critical data is  written to persistent media, the application should use unbuffered I/O  instead of frequently calling FlushFileBuffers. To open a file for unbuffered I/O, call the CreateFile function with the FILE_FLAG_NO_BUFFERING and FILE_FLAG_WRITE_THROUGH flags. This prevents the file contents from being cached and flushes the metadata to disk with each write. For more information, see CreateFile. To flush all open files on a volume, call FlushFileBuffers with a handle to the volume. The caller must have administrative privileges. For more information, see  Running with Special Privileges. When opening a volume with CreateFile, the lpFileName string should be the following form: \\\\.\\x: or \\\\?\\Volume{GUID}. Do not use a trailing backslash in the volume name, because that indicates the root directory of a drive. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see  Multithreaded Pipe Server. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "FlushFileBuffers",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the open file.  The file handle must have the GENERIC_WRITE access right. For more information, see  File Security and Access Rights. If hFile is a handle to a communications device, the function only flushes the transmit buffer. If hFile is a handle to the server end of a named pipe, the function does not return until the client has read all buffered data from the pipe."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Frees a certificate hash list.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "ReFS:  This function is not supported. ",
    "return_type": "void",
    "category": "Files and I/O (Local file system)",
    "name": "FreeEncryptionCertificateHashList",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PENCRYPTION_CERTIFICATE_HASH_LIST",
        "name": "pHashes",
        "description": "A pointer to a certificate hash list structure,  ENCRYPTION_CERTIFICATE_HASH_LIST, which was returned by the  QueryUsersOnEncryptedFile or  QueryRecoveryAgentsOnEncryptedFile function."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable      file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the file is executable, the return value is nonzero. The function sets the variable pointed to by         lpBinaryType to indicate the file's executable type. If the file is not executable, or if the function fails, the return value is zero. To get extended error         information, call GetLastError. If the file is a DLL,         the last error code is ERROR_BAD_EXE_FORMAT. ",
    "remarks": "As an alternative, you can obtain the same information by calling the      SHGetFileInfo function, passing the      SHGFI_EXETYPE flag in the uFlags parameter. Symbolic link behavior\u00e2\u0080\u0094If the path points to a symbolic link, the target file is      used. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetBinaryType",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpApplicationName",
        "description": "The full path of the file whose executable type is to be determined. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpBinaryType",
        "description": "A pointer to a variable to receive information about the executable type of the file specified by        lpApplicationName. ..."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the low-order DWORD of the actual number of bytes of disk storage used to store the specified file, and if lpFileSizeHigh is non-NULL, the function puts the high-order DWORD of that actual value into the DWORD pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files. If the function fails, and lpFileSizeHigh is NULL, the return value is INVALID_FILE_SIZE. To get extended error information, call  GetLastError. If the return value is INVALID_FILE_SIZE and lpFileSizeHigh is non-NULL, an application must call GetLastError to determine whether the function has succeeded (value is NO_ERROR) or failed (value is other than NO_ERROR). ",
    "remarks": "An application can determine whether a volume is compressed by calling  GetVolumeInformation, then checking the status of the FS_VOL_IS_COMPRESSED flag in the DWORD value pointed to by that function's lpFileSystemFlags parameter. If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to  GetFileSize. Symbolic link behavior\u00e2\u0080\u0094If the path points to a symbolic link, the function returns the file size of the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetCompressedFileSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file.     Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning. This parameter may include the path. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (GetCompressedFileSizeW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpFileSizeHigh",
        "description": "The high-order DWORD of the compressed file size. The function's return value is the low-order DWORD of the compressed file size.     This parameter can be NULL if the high-order DWORD of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order DWORD."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the low-order DWORD of the actual number of bytes of disk storage used to store the specified file, and if lpFileSizeHigh is non-NULL, the function puts the high-order DWORD of that actual value into the DWORD pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files. If the function fails, and lpFileSizeHigh is NULL, the return value is INVALID_FILE_SIZE. To get extended error information, call  GetLastError. If the return value is INVALID_FILE_SIZE and lpFileSizeHigh is non-NULL, an application must call GetLastError to determine whether the function has succeeded (value is NO_ERROR) or failed (value is other than NO_ERROR). ",
    "remarks": "An application can determine whether a volume is compressed by calling  GetVolumeInformation, then checking the status of the FS_VOL_IS_COMPRESSED flag in the DWORD value pointed to by that function's lpFileSystemFlags parameter. If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to  GetFileSize. Symbolic links:  If the path points to a symbolic link, the function returns the file size of the target. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetCompressedFileSizeTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file.     Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning. The file must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpFileSizeHigh",
        "description": "A pointer to a variable that receives the high-order DWORD of the compressed file size. The function's return value is the low-order DWORD of the compressed file size.     This parameter can be NULL if the high-order DWORD of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order DWORD."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is 1. If the function fails, the return value is LZERROR_BADVALUE. There is no extended error information for this function; do not call  GetLastError. ",
    "remarks": "The contents of the buffer pointed to by the lpszBuffer parameter is the original file name if the file was compressed by using the /r option. If the /r option was not used, this function duplicates the name in the lpszSource parameter into the lpszBuffer buffer. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "INT",
    "category": "Files and I/O (Local file system)",
    "name": "GetExpandedName",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpszSource",
        "description": "The name of the compressed file."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszBuffer",
        "description": "A pointer to a buffer that receives the original name of the compressed file."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves file system attributes for a specified file or directory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value contains the attributes of the specified file or directory. For a         list of attribute values and their descriptions, see         File Attribute Constants. If the function fails, the return value is INVALID_FILE_ATTRIBUTES. To get extended         error information, call GetLastError. ",
    "remarks": "When GetFileAttributes is called on a directory      that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory      in the volume that the mounted folder associates with the directory. To obtain the file attributes of the      associated volume, call      GetVolumeNameForVolumeMountPoint to      obtain the name of the associated volume. Then use the resulting name in a call to      GetFileAttributes. The results are the attributes of      the root directory on the associated volume. If you call GetFileAttributes for a network share,      the function fails, and GetLastError returns      ERROR_BAD_NETPATH. You must specify a path to a subfolder on that share. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Symbolic link behavior\u00e2\u0080\u0094If the path points to a symbolic link, the function returns      attributes for the symbolic link. If a file is open for modification in a transaction, no other thread can open the file for modification until        the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try        modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread        modifies the file before the transacted thread does, and the file is still open when the transaction attempts to        open it, the transaction receives the error ERROR_TRANSACTIONAL_CONFLICT. For an example, see       Retrieving and Changing File Attributes. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileAttributes",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file or directory.         In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function (GetFileAttributesW), and prepend         \"\\\\?\\\" to the path. For more information, see         File Names, Paths, and Namespaces. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (GetFileAttributesW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves attributes for a specified file or directory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero (0). To get extended error information, call         GetLastError. ",
    "remarks": "The GetFileAttributes function retrieves file      system attribute information. GetFileAttributesEx      can obtain other sets of file or directory attribute information. Currently,      GetFileAttributesEx retrieves a set of standard      attributes that is a superset of the file system attribute information. When the GetFileAttributesEx function is      called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root      directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the      associated volume, call      GetVolumeNameForVolumeMountPoint to      obtain the name of the associated volume. Then use the resulting name in a call to      GetFileAttributesEx. The results are the attributes      of the root directory on the associated volume. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  Symbolic link behavior\u00e2\u0080\u0094If the path points to a symbolic link, the function returns      attributes for the symbolic link. If a file is open for modification in a transaction, no other thread can open the file for modification until        the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try        modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread        modifies the file before the transacted thread does, and the file is still open when the transaction attempts to        open it, the transaction receives the error ERROR_TRANSACTIONAL_CONFLICT. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileAttributesEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file or directory. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function (GetFileAttributesExW), and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (GetFileAttributesExW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "GET_FILEEX_INFO_LEVELS",
        "name": "fInfoLevelId",
        "description": "A class of attribute information to retrieve. This parameter can be the following value from the        GET_FILEEX_INFO_LEVELS enumeration.  ValueMeaning  GetFileExInfoStandard   The lpFileInformation parameter is a          WIN32_FILE_ATTRIBUTE_DATA          structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFileInformation",
        "description": "A pointer to a buffer that receives the attribute information. The type of attribute information that is stored into this buffer is determined by the value of         fInfoLevelId."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended         error information, call GetLastError. ",
    "remarks": "When GetFileAttributesTransacted is      called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root directory in the volume that the mounted folder associates with the directory. To obtain the      file attributes of the associated volume, call      GetVolumeNameForVolumeMountPoint to      obtain the name of the associated volume. Then use the resulting name in a call to      GetFileAttributesTransacted. The results are      the attributes of the root directory on the associated volume. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. Symbolic links:  If the path points to a symbolic link, the function returns attributes for the symbolic link. If a file is open for modification in a transaction, no other thread can open the file for modification until        the transaction is committed. Conversely, if a file is open for modification outside of a transaction, no        transacted thread can open the file for modification until the non-transacted handle is closed. If a        non-transacted thread has a handle opened to modify a file, a call to        GetFileAttributesTransacted for that file        will fail with an ERROR_TRANSACTIONAL_CONFLICT error. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileAttributesTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file or directory.        In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_In_",
        "type": "GET_FILEEX_INFO_LEVELS",
        "name": "fInfoLevelId",
        "description": "The level of attribute information to retrieve.        This parameter can be the following value from the         GET_FILEEX_INFO_LEVELS enumeration.  ValueMeaning  GetFileExInfoStandard   The lpFileInformation parameter is a          WIN32_FILE_ATTRIBUTE_DATA          structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFileInformation",
        "description": "A pointer to a buffer that receives the attribute information.        The type of attribute information that is stored into this buffer is determined by the value of         fInfoLevelId. If the fInfoLevelId parameter is         GetFileExInfoStandard then this parameter points to a         WIN32_FILE_ATTRIBUTE_DATA          structure"
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves the bandwidth reservation properties of the volume on which the specified file resides.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns nonzero if successful or zero otherwise. To get extended error information, call         GetLastError. ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileBandwidthReservation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpPeriodMilliseconds",
        "description": "A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the        time from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has        been reserved for this handle, then the value returned is the minimum reservation period supported for this        volume."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpBytesPerPeriod",
        "description": "A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the        volume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of        bytes per period supported for the volume."
      },
      {
        "in_out": "_Out_",
        "type": "LPBOOL",
        "name": "pDiscardable",
        "description": "TRUE if I/O should be completed with an error if a driver is unable to satisfy an        I/O operation before the period expires. FALSE if the underlying subsystem does not        support failing in this manner."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpTransferSize",
        "description": "The minimum size of any individual I/O request that may be issued by the application. All I/O requests        should be multiples of TransferSize. If no bandwidth has been reserved for this        handle, then the value returned is the minimum transfer size supported for this volume."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumOutstandingRequests",
        "description": "The number of TransferSize chunks  allowed to be outstanding with the operating        system."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves file information for the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero and file information data is contained in the buffer         pointed to by the lpFileInformation parameter. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Depending on the underlying network features of the operating system and the type of server connected to, the      GetFileInformationByHandle function may fail,      return partial information, or full information for the given file. You can compare the VolumeSerialNumber and FileIndex      members returned in the      BY_HANDLE_FILE_INFORMATION structure to      determine if two paths map to the same target; for example, you can compare two file paths and determine if they      map to the same directory. IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If there is a transaction bound to the thread at the time of the call, then the function returns the        compressed file size of the isolated file view. For more information, see        About Transactional NTFS. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileInformationByHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file that contains the information to be retrieved. This handle should not be a pipe handle."
      },
      {
        "in_out": "_Out_",
        "type": "LPBY_HANDLE_FILE_INFORMATION",
        "name": "lpFileInformation",
        "description": "A pointer to a        BY_HANDLE_FILE_INFORMATION structure that        receives the file information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves file information for the specified file.",
    "library": "Kernel32.lib;  FileExtd.lib on Windows Server 2003 and Windows XP",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h);  FileExtd.h on Windows Server 2003 and Windows XP",
    "return_value": "If the function succeeds, the return value is nonzero and file information data is contained in the buffer         pointed to by the lpFileInformation parameter. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "If FileInformationClass is FileStreamInfo and the calls      succeed but no streams are returned, the error that is returned by      GetLastError is      ERROR_HANDLE_EOF. Certain file information classes behave slightly differently on different operating system releases. These      classes are supported by the underlying drivers, and any information they return is subject to change between      operating system releases. The following table shows the valid file information class types and their corresponding data structure types       for use with this function.  If there is a transaction bound to the thread at the time of the call, then the function returns the        compressed file size of the isolated file view. For more information, see        About Transactional NTFS. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileInformationByHandleEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file that contains the information to be retrieved. This handle should not be a pipe handle."
      },
      {
        "in_out": "_In_",
        "type": "FILE_INFO_BY_HANDLE_CLASS",
        "name": "FileInformationClass",
        "description": "A FILE_INFO_BY_HANDLE_CLASS enumeration         value that specifies the type of information to be retrieved. For a table of valid values, see the Remarks section."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpFileInformation",
        "description": "A pointer to the buffer that receives the requested file information. The structure that is returned        corresponds to the class that is specified by FileInformationClass. For a table of        valid structure types, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferSize",
        "description": "The size of the lpFileInformation buffer, in bytes."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the size of the specified file, in bytes.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the low-order doubleword of the file size, and, if         lpFileSizeHigh is non-NULL, the function puts the         high-order doubleword of the file size into the variable pointed to by that parameter. If the function fails and lpFileSizeHigh is NULL, the         return value is INVALID_FILE_SIZE. To get extended error information, call         GetLastError. When         lpFileSizeHigh is NULL, the results returned for large         files are ambiguous, and you will not be able to determine the actual size of the file. It is recommended that         you use GetFileSizeEx instead. If the function fails and lpFileSizeHigh is non-NULL, the         return value is INVALID_FILE_SIZE and         GetLastError will return a value other than         NO_ERROR. ",
    "remarks": "You cannot use the GetFileSize function with a handle of      a nonseeking device such as a pipe or a communications device. To determine the file type for      hFile, use the GetFileType      function. The GetFileSize function retrieves the uncompressed size      of a file. Use the GetCompressedFileSize      function to obtain the compressed size of a file. Note that if the return value is INVALID_FILE_SIZE (0xffffffff), an application must      call GetLastError to determine whether the function has      succeeded or failed. The reason the function may appear to fail when it has not is that      lpFileSizeHigh could be non-NULL or the file size could be      0xffffffff. In this case, GetLastError will return      NO_ERROR (0) upon success. Because of this behavior, it is recommended that you use      GetFileSizeEx instead. Transacted Operations:  If there is a transaction bound to the file handle, then the function returns information for the isolated        file view. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see       Creating a View Within a File. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileSize",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpFileSizeHigh",
        "description": "A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can        be NULL if the application does not require the high-order doubleword."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the size of the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "Transacted Operations:  If there is a transaction bound to the file handle, then the function returns information for the isolated        file view. Windows Store apps:  GetFileSizeEx is not supported. Use        GetFileInformationByHandleEx. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileSizeEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The handle must have been created with the        FILE_READ_ATTRIBUTES access right or equivalent, or the caller must have sufficient permission on the directory that contains the file.        For more information, see        File Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "lpFileSize",
        "description": "A pointer to a LARGE_INTEGER structure that        receives the file size, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the file type of the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "The function returns one of the following values.  You can distinguish between a \"valid\" return of FILE_TYPE_UNKNOWN and its return due to a calling error (for example, passing an invalid handle to  GetFileType) by calling  GetLastError. If the function worked properly and FILE_TYPE_UNKNOWN was returned, a call to GetLastError will return NO_ERROR. If the function returned FILE_TYPE_UNKNOWN due to an error in calling  GetFileType,  GetLastError will return the error code. ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetFileType",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the final path for the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length of the string received by         lpszFilePath, in TCHARs. This value does not include the         size of the terminating null character. Windows Server 2008 and Windows Vista:  For the ANSI version of this function,          GetFinalPathNameByHandleA, the return value          includes the size of the terminating null character. If the function fails because lpszFilePath is too small to hold the string plus the         terminating null character, the return value is the required buffer size, in         TCHARs. This value includes the size of the terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call         GetLastError.  ",
    "remarks": "A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link       named \"C:\\tmp\\mydir\" that points to \"D:\\yourdir\", the final path would be       \"D:\\yourdir\". The string that is returned by this function uses the \\\\?\\       syntax. For more information, see CreateFile. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  The following example demonstrates the us of the       GetFinalPathNameByHandle function. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetFinalPathNameByHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to a file or directory."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszFilePath",
        "description": "A pointer to a buffer that receives the path of hFile."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchFilePath",
        "description": "The size of lpszFilePath, in TCHARs. This value does        not include a NULL termination character."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The type of result to return.  This parameter can be one of the following values.  ValueMeaning  FILE_NAME_NORMALIZED 0x0   Return the normalized drive name. This is the default.   FILE_NAME_OPENED 0x8   Return the opened file name (not normalized).     This parameter can also include one of the following values.  ValueMeaning  VOLUME_NAME_DOS 0x0   Return the path with the drive letter. This is the default.   VOLUME_NAME_GUID 0x1   Return the path with a volume GUID path instead of the drive name.    VOLUME_NAME_NONE 0x4   Return the path with no drive information.   VOLUME_NAME_NT 0x2   Return the path with the volume device path."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the full path and file name of the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length, in TCHARs, of the         string copied to lpBuffer, not including the terminating null character. If the lpBuffer buffer is too small to contain the path, the return value is the         size, in TCHARs, of the buffer that is required to hold the path and the         terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "GetFullPathName merges the name of the current drive      and directory with a specified file name to determine the full path and file name of a specified file. It also      calculates the address of the file name portion of the full path and file name. This function does not verify that the resulting path and file name are valid, or that they see an existing      file on the associated volume. Note that the lpFilePart parameter does not      require string buffer space, but only enough for a single address. This is because it simply returns an address      within the buffer that already exists for lpBuffer. Share and volume names are      valid input for lpFileName. For example, the following list identities the returned path      and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume: GetFullPathName does not convert the specified file      name, lpFileName. If the specified file name exists, you can use      GetLongPathName or      GetShortPathName to convert to long or short path      names, respectively. If the return value is greater than or equal to the value specified in      nBufferLength, you can call the function again with a buffer that is large enough to      hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the      Example Code section. Multithreaded applications and shared library code should not use the      GetFullPathName function and should avoid using relative      path names. The current directory state written by the      SetCurrentDirectory function is stored as a global      variable in each process, therefore multithreaded applications cannot reliably use this value without possible      data corruption from other threads that may also be reading or setting this value. This limitation also applies      to the SetCurrentDirectory and      GetCurrentDirectory functions. The exception being      when the application is guaranteed to be running in a single thread, for example parsing file names from the      command line argument string in the main thread prior to creating any additional threads. Using relative path      names in multithreaded applications or shared library code can yield unpredictable results and is not      supported. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  The following C++ example shows a basic use of       GetFullPathName,       GetLongPathName, and       GetShortPathName. For another example using dynamic       allocation, see GetShortPathName. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetFullPathName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the  file. This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume         name. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function (GetFullPathNameW), and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (GetFullPathNameW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBufferLength",
        "description": "The size of the buffer to receive the null-terminated string for the drive and path, in        TCHARs."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the null-terminated string for the  drive and path."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR*",
        "name": "lpFilePart",
        "description": "A pointer to a buffer that receives the address (within lpBuffer) of the final        file name component in the path.  This parameter can be  NULL. If lpBuffer        refers to a directory and not a file, lpFilePart receives zero."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length, in TCHARs, of the         string copied to lpBuffer, not including the terminating null character. If the lpBuffer buffer is too small to contain the path, the return value is the         size, in TCHARs, of the buffer that is required to hold the path and the         terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "GetFullPathNameTransacted merges the name      of the current drive and directory with a specified file name to determine the full path and file name of a      specified file. It also calculates the address of the file name portion of the full path and file name. This      function does not verify that the resulting path and file name are valid, or that they see an existing file on the      associated volume. Share and volume names are valid input for lpFileName. For example, the following      list identities the returned path and file names if test-2 is a remote computer and U: is a network mapped drive: GetFullPathNameTransacted does not convert      the specified file name, lpFileName. If the specified file name exists, you can use      GetLongPathNameTransacted,      GetLongPathName, or      GetShortPathName to convert to long or short path      names, respectively. If the return value is greater than the value specified in nBufferLength, you can      call the function again with a buffer that is large enough to hold the path. For an example of this case as well      as using zero length buffer for dynamic allocation, see the Example Code section. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetFullPathNameTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file. This string can use short (the 8.3 form) or long file names. This string can be a share or volume name. The file must reside on the local computer; otherwise, the function fails and the last error code is set to         ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBufferLength",
        "description": "The size of the buffer to receive the null-terminated string  for the drive and path,  in        TCHARs."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the null-terminated string for the  drive and path."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR*",
        "name": "lpFilePart",
        "description": "A pointer to a buffer that receives the address (in lpBuffer) of the final file         name component in the path. Specify NULL if you do not need to receive this         information. If lpBuffer points to a directory and not a file,         lpFilePart receives 0 (zero)."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Converts the specified path to its long form.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length, in TCHARs, of the         string copied to lpszLongPath, not including the terminating null character. If the lpBuffer buffer is too small to contain the path, the return value is the         size, in TCHARs, of the buffer that is required to hold the path and the         terminating null character. If the function fails for any other reason, such as if the file does not         exist, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow      this convention. Therefore, do not assume that you can skip calling      GetLongPathName if the path does not contain a tilde (~)      character. If the file or directory exists but a long path is not found,      GetLongPathName succeeds, having copied the string      referred to by the lpszShortPath parameter to the buffer referred to by the      lpszLongPath parameter. If the return value is greater than the value specified in cchBuffer, you can call      the function again with a buffer that is large enough to hold the path. For an example of this case, see the      Example Code section for GetFullPathName. It is possible to have access to a file or directory but not have access to some of the parent directories of      that file or directory. As a result, GetLongPathName may      fail when it is unable to query the parent directory of a path component to determine the long name for that      component. This check can be skipped for directory components that have file extensions longer than 3 characters,      or total lengths longer than 12 characters. For more information, see the      Short vs. Long Names section of      Naming Files, Paths, and Namespaces. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example that uses GetLongPathName, see the       Example Code section for GetFullPathName. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetLongPathName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszShortPath",
        "description": "The path to be converted. In the ANSI version of this function,         GetLongPathNameA, the name is limited to         MAX_PATH (260) characters. To extend this limit to 32,767 wide characters, call the         Unicode version of the function, GetLongPathNameW,         and prepend \"\\\\?\\\" to the path. For more information, see         Naming Files, Paths, and Namespaces. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (GetLongPathNameW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszLongPath",
        "description": "A pointer to the buffer to receive the long path. You can use the same buffer you used for the lpszShortPath parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchBuffer",
        "description": "The size of the buffer lpszLongPath points to, in        TCHARs."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length, in TCHARs, of the         string copied to lpszLongPath, not including the terminating null character. If the lpBuffer buffer is too small to contain the path, the return value is the         size, in TCHARs, of the buffer that is required to hold the path and the         terminating null character. If the function fails for any other reason, such as if the file does not exist, the return value is zero. To         get extended error information, call         GetLastError. ",
    "remarks": "On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow      this convention. Therefore, do not assume that you can skip calling      GetLongPathNameTransacted if the path does not      contain a tilde (~) character. If a long path is not found, this function returns the name specified in the      lpszShortPath parameter in the lpszLongPath parameter. If the return value is greater than the value specified in cchBuffer, you can call      the function again with a buffer that is large enough to hold the path. For an example of this case, see the      Example Code section for GetFullPathName. It is possible to have access to a file or directory but not have access to some of the parent directories of      that file or directory. As a result,      GetLongPathNameTransacted may fail when it is      unable to query the parent directory of a path component to determine the long name for that component. This check      can be skipped for directory components that have file extensions longer than 3 characters, or total lengths      longer than 12 characters. For more information, see the      Short vs. Long Names section of      Naming Files, Paths, and Namespaces. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetLongPathNameTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszShortPath",
        "description": "The path to be converted. In the ANSI version of this function, the name is limited to MAX_PATH (260)         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and         prepend \"\\\\?\\\" to the path. For more information, see        Naming Files, Paths, and Namespaces. The path must reside on the local computer; otherwise, the function fails and the last error code is set to        ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszLongPath",
        "description": "A pointer to the buffer to receive the long path. You can use the same buffer you used for the lpszShortPath parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchBuffer",
        "description": "The size of the buffer lpszLongPath points to, in        TCHARs."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Attempts to dequeue an I/O completion packet from the specified I/O completion port. If there is no completion packet queued, the function waits for a pending I/O operation associated  with the completion port to complete.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns nonzero (TRUE) if successful or zero (FALSE) otherwise. To get extended error information, call  GetLastError. For more information, see the Remarks section. ",
    "remarks": "This function associates a thread with the specified completion port. A thread can be associated with at most one completion port. If a call to GetQueuedCompletionStatus fails because the completion port handle associated with it is closed while the call is outstanding, the function returns FALSE, *lpOverlapped will be NULL,  and GetLastError will return ERROR_ABANDONED_WAIT_0. Windows Server 2003 and Windows XP:  Closing the completion port handle while a call is outstanding will not result in the previously stated behavior.  The function will continue to wait until an entry is removed from the port or until a time-out occurs, if specified as a value other than INFINITE. If theGetQueuedCompletionStatus function succeeds, it dequeued a completion packet for a successful I/O operation from the completion port and has stored information in the variables pointed to by the following parameters: lpNumberOfBytes, lpCompletionKey, and lpOverlapped. Upon failure (the return value is FALSE), those same parameters can contain particular value combinations as follows: For more information on I/O completion port theory, usage, and associated functions, see I/O Completion Ports. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetQueuedCompletionStatus",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "CompletionPort",
        "description": "A handle to the completion port. To create a completion port, use the  CreateIoCompletionPort function."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytes",
        "description": "A pointer to a variable that receives the number of bytes transferred during an I/O operation that has completed."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "lpCompletionKey",
        "description": "A pointer to a variable that receives the completion key value associated with the file handle whose I/O operation has completed. A completion key is a per-file key that is specified in a call to  CreateIoCompletionPort."
      },
      {
        "in_out": "_Out_",
        "type": "LPOVERLAPPED*",
        "name": "lpOverlapped",
        "description": "A pointer to a variable that receives the address of the  OVERLAPPED structure that was specified when the completed I/O operation was started.     \t\t\t\t\t\t Even if you have passed the function a file handle associated with a completion port and a valid  OVERLAPPED structure, an application can prevent completion port notification. This is done by specifying a valid event handle for the hEvent member of the OVERLAPPED structure, and setting its low-order bit. A valid event handle whose low-order bit is set keeps I/O completion from being queued to the completion port."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion port. If a completion packet does not appear within the specified time, the function times out, returns FALSE, and sets *lpOverlapped to NULL. If dwMilliseconds is INFINITE, the function will never time out. If dwMilliseconds is zero and there is no I/O operation to dequeue, the function will time out immediately."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves  multiple completion port entries simultaneously. It waits for pending I/O      operations that are associated with the specified completion port to complete.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "IoAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns nonzero (TRUE) if successful or zero (FALSE) otherwise. To get extended error information, call         GetLastError. ",
    "remarks": "This function associates a thread with the specified completion port. A thread can be associated with at most       one completion port. This function returns TRUE when at least one pending I/O is completed, but it is       possible that one or more I/O operations failed. Note that it is up to the user of this function to check the       list of returned entries in the lpCompletionPortEntries parameter to determine which of       them correspond to any possible failed I/O operations by looking at the status contained in the       lpOverlapped member in each       OVERLAPPED_ENTRY. This function returns FALSE when no I/O operation was dequeued. This typically means       that an error occurred while processing the parameters to this call, or that the       CompletionPort handle was closed or is otherwise invalid. The       GetLastError function provides extended error       information. If a call to GetQueuedCompletionStatusEx       fails because the handle associated with it is closed, the function returns FALSE and       GetLastError will return       ERROR_ABANDONED_WAIT_0. Server applications may have several threads calling the       GetQueuedCompletionStatusEx function       for the same completion port.  As I/O operations complete, they are queued to this port in first-in-first-out       order. If a thread is actively waiting on this call, one or more queued requests complete the call for that       thread only. For more information on I/O completion port theory, usage, and associated functions, see       I/O Completion Ports. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "GetQueuedCompletionStatusEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "CompletionPort",
        "description": "A handle to the completion port. To create a completion port, use the         CreateIoCompletionPort function."
      },
      {
        "in_out": "_Out_",
        "type": "LPOVERLAPPED_ENTRY",
        "name": "lpCompletionPortEntries",
        "description": "On input, points to a pre-allocated array of         OVERLAPPED_ENTRY structures. On output, receives an array of OVERLAPPED_ENTRY         structures that hold the entries. The number of array elements is provided by         ulNumEntriesRemoved. The number of bytes transferred during each I/O, the completion key that indicates on which file each I/O         occurred, and the overlapped structure address used in each original I/O are all returned in the         lpCompletionPortEntries array."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulCount",
        "description": "The maximum number of entries to remove."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ulNumEntriesRemoved",
        "description": "A pointer to a variable that receives the number of entries actually removed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMilliseconds",
        "description": "The number of milliseconds that the caller is willing to wait for a completion packet to appear at the         completion port. If a completion packet does not appear within the specified time, the function times out and         returns FALSE. If dwMilliseconds is INFINITE (0xFFFFFFFF), the function         will never time out. If dwMilliseconds is zero and there is no I/O operation to         dequeue, the function will time out immediately."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fAlertable",
        "description": "If this parameter is FALSE, the function does not return until the time-out period         has elapsed or an entry is retrieved. If the parameter is TRUE and there are no available entries, the function performs         an alertable wait. The thread returns when the system queues an I/O completion routine or APC to the thread and         the thread executes the function. A completion routine is queued when the ReadFileEx or         WriteFileEx function in which it was specified has         completed, and the calling thread is the thread that initiated the operation. An APC is queued when you call         QueueUserAPC."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the short path form of the specified path.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length, in TCHARs, of the         string that is copied to lpszShortPath, not including the terminating null         character. If the lpszShortPath buffer is too small to contain the path, the return value is         the size of the buffer, in TCHARs, that is required to hold the path and the         terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The path that the lpszLongPath parameter specifies does not have to be a full or      long path. The short form can be longer than the specified path. If the return value is greater than the value specified in the cchBuffer parameter,      you can call the function again with a buffer that is large enough to hold the path. For an example of this case      in addition to using zero-length buffer for dynamic allocation, see the Example Code section. If the specified path is already in its short form  and conversion is not needed, the function simply copies      the specified path to the buffer specified by the lpszShortPath parameter. You can set the lpszShortPath parameter to the same value as the      lpszLongPath parameter; in other words, you can set the output buffer for the short path      to the address of the input path string. Always ensure that the cchBuffer parameter      accurately represents the total size, in TCHARs, of this buffer. You can obtain the long name of a file from the short name by calling the      GetLongPathName function. Alternatively, where      GetLongPathName is not available, you can call      FindFirstFile on each component of the path to get the      corresponding long name. It is possible to have access to a file or directory but not have access to some of the parent directories of      that file or directory. As a result, GetShortPathName      may fail when it is unable to query the parent directory of a path component  to determine the short name for that      component. This check can be skipped for directory components that already meet the requirements of a short name.      For more information, see the      Short vs. Long Names section of      Naming Files, Paths, and Namespaces. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support short names on shares with continuous availability capability. Resilient File System (ReFS) doesn't support short names. If you call GetShortPathName on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name. For an example that uses GetShortPathName, see       the Example Code section for GetFullPathName. The following C++ example shows how to use a dynamically allocated output buffer. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetShortPathName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszLongPath",
        "description": "The path string. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming Files, Paths, and Namespaces."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszShortPath",
        "description": "A pointer to a buffer to receive the null-terminated short form of the path that         lpszLongPath specifies. Passing NULL for this parameter and zero for cchBuffer         will always return the required buffer size for a specified lpszLongPath."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchBuffer",
        "description": "The size of the buffer  that lpszShortPath points to, in         TCHARs. Set this parameter to zero if lpszShortPath is set to NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Creates a name for a temporary file. If a unique file name is generated, an empty file is created and      the handle to it is released; otherwise, only a file name is generated.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the unique numeric value used in the temporary file         name. If the uUnique parameter is nonzero, the return value specifies that same         number. If the function fails, the return value is zero. To get extended error information, call         GetLastError.  The following is a possible return value.  ",
    "remarks": "The GetTempFileName function creates a temporary      file name of the following form: <path>\\<pre><uuuu>.TMP The following table describes the file name syntax.  If uUnique is zero,      GetTempFileName creates an empty file and closes it. If      uUnique is not zero, you must create the file yourself. Only a file name is created,      because GetTempFileName is not able to guarantee that      the file name is unique. Only the lower 16 bits of the uUnique parameter are used. This limits      GetTempFileName to a maximum of 65,535 unique file names      if the lpPathName and lpPrefixString parameters remain the      same. Due to the algorithm used to generate file names,      GetTempFileName can perform poorly when creating a large      number of files with the same prefix. In such cases, it is recommended that you construct unique file names based      on GUIDs. Temporary files whose names have been created by this function are not automatically deleted. To delete these      files call DeleteFile. To avoid problems resulting when converting an ANSI string, an application should call the      CreateFile function to create a temporary file. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see       Creating and Using a Temporary File. ",
    "return_type": "UINT",
    "category": "Files and I/O (Local file system)",
    "name": "GetTempFileName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpPathName",
        "description": "The directory path for the file name. ..."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpPrefixString",
        "description": "The null-terminated prefix string. The function uses up to the first three characters of this string as the         prefix of the file name. This string must consist of characters in the OEM-defined character set."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uUnique",
        "description": "An unsigned integer to be used in creating the temporary file name. For more information, see Remarks. If uUnique is zero, the function attempts to form a unique file name using the         current system time. If the file already exists, the number is increased by one and the functions tests if this         file already exists. This continues until a unique filename is found; the function creates a file by that name         and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when         uUnique is nonzero."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpTempFileName",
        "description": "A pointer to the buffer that receives the temporary file name. This buffer should be         MAX_PATH characters to accommodate the path plus the terminating null character."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the path of the directory designated for temporary files.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length, in TCHARs, of the         string copied to lpBuffer, not including the terminating null character. If the         return value is greater than nBufferLength, the return value is the length, in         TCHARs, of the buffer required to hold the path. If the function fails, the return value is zero. To get extended error information, call         GetLastError. The maximum possible return value is MAX_PATH+1 (261). ",
    "remarks": "The GetTempPath function checks for the existence of      environment variables in the following order and uses the first path found: Note that the function does not verify that the path exists, nor does it test to see if the current process has       any kind of access rights to the path. The GetTempPath       function returns the properly formatted string that specifies the fully qualified path based on the environment       variable search order as previously specified. The application should verify the existence of the path and       adequate access rights to the path prior to any use for file I/O operations. Symbolic link behavior\u00e2\u0080\u0094If the path points to a symbolic link, the temp path name      maintains any symbolic links. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see       Creating and Using a Temporary File. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "GetTempPath",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBufferLength",
        "description": "The size of the string buffer identified by lpBuffer, in        TCHARs."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpBuffer",
        "description": "A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.        The returned string ends with a backslash, for example, \"C:\\TEMP\\\"."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "An application-defined callback function used with      WriteEncryptedFileRaw. The system calls      ImportCallback one or more times, each time to retrieve a      portion of a backup file's data.      ImportCallback reads the data from a backup file      sequentially and restores the data, and  the system continues calling it until  it has read all of the backup file      data.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, it must set the return value to ERROR_SUCCESS, and set         the value pointed to by the ulLength parameter to the number of bytes copied into         pbData. When the end of the backup file is reached, set ulLength to zero to tell the system         that the entire file has been processed. If the function fails, set the return value to a nonzero error code defined in WinError.h. For         example, if this function fails because an API that it calls fails, you can set the return value to the value         returned by GetLastError for the failed API. ",
    "remarks": "The system calls the ImportCallback function until the       callback function indicates there is no more data to restore. To indicate that there is no more data to be       restored, set *ulLength to 0 and use a return code of       ERROR_SUCCESS. You can use the application-defined context block for internal tracking       of information such as the file handle and the current offset in the file. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "ImportCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PBYTE",
        "name": "pbData",
        "description": "A pointer to a system-supplied buffer that will receive a block of data to be restored."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "pvCallbackContext",
        "description": "A pointer to an application-defined and allocated context block. The application passes this pointer to        WriteEncryptedFileRaw, and it passes this        pointer to the callback function so that the callback function can have access to application-specific data.        This data can be a structure and can contain any data the application needs, such as the handle to the file that        contains the backup copy of the encrypted file."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "ulLength",
        "description": "On function entry, this parameter specifies the length of the buffer the system has supplied. The callback         function must write no more than this many bytes to the buffer pointed to by the         pbData parameter. On exit, the function must set this to the number of bytes of data written into the         pbData."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Locks the specified file  for exclusive access  by the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero (TRUE). If the function fails, the return value is zero (FALSE). To get extended error information, call  GetLastError. ",
    "remarks": "If the call to LockFile completes synchronously, a completion entry may not be queued when a completion port is associated with the file handle. The  UnlockFile function unlocks a file region locked by  LockFile. Locking a region of a file gives the threads of the locking process exclusive access to the specified region using this file handle. If the file handle is  inherited by a process created by the locking process, the child process is not granted access to the locked region. If the locking process opens the file a second time, it cannot access the specified region through this second handle until it unlocks the region. Locking a region of a file does not prevent reading from a mapped file view. You can lock bytes that are beyond the end of the current  file. This is useful to coordinate adding records to the end of a file. Exclusive locks cannot overlap an existing locked region of a file. For more information, see LockFileEx. If  LockFile cannot lock a region of a file, it returns zero immediately. It does not block. To issue a file lock request that will block until the lock is acquired, use  LockFileEx without the LOCKFILE_FAIL_IMMEDIATELY flag. If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see  Appending One File to Another File. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "LockFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The file handle must have been created with the GENERIC_READ or GENERIC_WRITE access right. For more information, see  File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetLow",
        "description": "The low-order 32 bits of the starting byte offset in the file where the lock should begin."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetHigh",
        "description": "The high-order 32 bits of the starting byte offset in the file where the lock should begin."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToLockLow",
        "description": "The low-order 32 bits of the length of the byte range to be locked."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToLockHigh",
        "description": "The high-order 32 bits of the length of the byte range to be locked."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Locks the specified file  for exclusive access  by the calling process. This function can operate either synchronously or asynchronously and can request either an exclusive or a shared lock.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero (TRUE). If the function fails, the return value is zero (FALSE). To get extended error information, call  GetLastError. ",
    "remarks": "Locking a region of a file is used to acquire shared or exclusive access to the specified region using this file handle. If the file handle is  inherited by a process created by the locking process, the child process is not granted access to the locked region. If the locking process opens the file a second time, it cannot access the specified region through this second handle until it unlocks the region. Locking a portion of a file for exclusive access denies all other processes both read and write access to the specified region of the file. Locking a region that goes beyond the current end-of-file position is not an error. Locking a portion of a file for shared access denies all processes write access to the specified region of the file, including the process that first locks the region. All processes can read the locked region. Locking a region of a file does not prevent reading from a mapped file view. The  LockFileEx function operates asynchronously if the file handle was opened for asynchronous I/O, unless the LOCKFILE_FAIL_IMMEDIATELY flag is specified. If an exclusive lock is requested for a range of a file that already has a shared or exclusive lock, the function returns the error ERROR_IO_PENDING. The system will signal the event specified in the  OVERLAPPED structure after the lock is granted. To determine when the lock has been granted, use the  GetOverlappedResult function or one of the  wait functions. For more information, see Synchronous and Asynchronous I/O. If the file handle was not opened for asynchronous I/O and the lock is not available, this call waits until the lock is granted or an error occurs, unless the LOCKFILE_FAIL_IMMEDIATELY flag is specified. Exclusive locks cannot overlap an existing locked region of a file. Shared locks can overlap a locked region provided locks held on that region are shared locks. A shared lock can overlap an exclusive lock if both locks were created using the same file handle. When a shared lock overlaps an exclusive lock, the only possible access is a read by the owner of the locks.  If the same range is locked with an exclusive and a shared lock, two unlock operations are necessary to unlock the region; the first unlock operation unlocks the exclusive lock, the second unlock operation unlocks the shared lock. If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "LockFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The handle must have been created with either the GENERIC_READ or GENERIC_WRITE access right. For more information, see  File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter may be one or more of the following values.  ValueMeaning  LOCKFILE_EXCLUSIVE_LOCK 0x00000002   The function requests an exclusive lock. Otherwise, it requests a shared lock.   LOCKFILE_FAIL_IMMEDIATELY 0x00000001   The function returns immediately if it is unable to acquire the requested lock. Otherwise, it waits."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "Reserved parameter; must be set to zero."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToLockLow",
        "description": "The low-order 32 bits of the length of the byte range to lock."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToLockHigh",
        "description": "The high-order 32 bits of the length of the byte range to lock."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure that the function uses with the locking request. This structure, which is required, contains the file offset of the beginning of the lock range. You must initialize the hEvent member to a valid handle or zero."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Closes a file that was opened by using the  LZOpenFile function.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The handle identifying the file must be retrieved by calling the  LZOpenFile function. If the handle is retrieved by calling the  CreateFile or  OpenFile function, an error occurs. If the file has been compressed by the Lempel-Ziv algorithm and opened by using  LZOpenFile,  LZClose frees any global heap space that was allocated to expand the file. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "void APIENTRY",
    "category": "Files and I/O (Local file system)",
    "name": "LZClose",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "hFile",
        "description": "A handle to the file to be closed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates, opens, reopens, or deletes the specified file.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "If the function succeeds and the value specified by the wStyle parameter is not         OF_READ, the return value is a handle identifying the file. If the file is compressed         and opened with wStyle set to OF_READ, the return value is         a special file handle. If the function fails, the return value is an LZERROR_* code. These codes have         values less than zero. There is no extended error information for this function; do not call         GetLastError. The following is the list of the error codes that LZOpenFile can return upon         failure.  ",
    "remarks": "If the wStyle parameter is the OF_READ flag (or      OF_READ and any of the OF_SHARE_* flags) and the file is      compressed, LZOpenFile calls the      LZInit function, which performs the required initialization for      the decompression operations. The handle this function returns is compatible only with the functions in Lz32.dll; it should not be used      for other file operations. If LZOpenFile is unable to open the file specified by      lpFileName, on some versions of Windows it attempts to open a file with almost the same      file name, except the last character is replaced with an underscore (\"_\"). Thus, if an attempt to      open \"MyProgram.exe\" fails, LZOpenFile tries to open      \"MyProgram.ex_\". Installation packages often substitute the underscore for the last letter of a      file name extension to indicate that the file is compressed. For example, \"MyProgram.exe\"      compressed might be named \"MyProgram.ex_\". To determine the name of the file opened (if any),      examine the szPathName member of the      OFSTRUCT structure in the      lpReOpenBuf parameter. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "INT",
    "category": "Files and I/O (Local file system)",
    "name": "LZOpenFile",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpFileName",
        "description": "The name of the file."
      },
      {
        "in_out": "_Out_",
        "type": "LPOFSTRUCT",
        "name": "lpReOpenBuf",
        "description": "A pointer to the OFSTRUCT structure that is to receive         information about the file when the file is first opened. The structure can be used in subsequent calls to the         LZOpenFile function to see the open file. The szPathName member of this structure contains characters from the original         equipment manufacturer (OEM) character set."
      },
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "wStyle",
        "description": "The action to be taken. This parameter can be one or more of the following values.  ValueMeaning  OF_CANCEL 0x0800   Ignored. Provided only for compatibility with 16-bit Windows. Use the OF_PROMPT          style to display a dialog box containing a Cancel button.   OF_CREATE 0x1000   Directs LZOpenFile to create a new file. If the file already exists, it          is truncated to zero length.   OF_DELETE 0x0200   Deletes the file.   OF_EXIST 0x4000   Opens the file and then closes it to test for a file's existence.   OF_PARSE 0x0100   Fills the OFSTRUCT structure but carries out no          other action.   OF_PROMPT 0x2000   Displays a dialog box if the requested file does not exist. The dialog box informs the user that the          system cannot find the file, and it contains Retry and          Cancel buttons. Clicking the Cancel button directs          LZOpenFile to return a file not found error message.   OF_READ 0x0000   Opens the file for reading only.   OF_READWRITE 0x0002   Opens the file for reading and writing.   OF_REOPEN 0x8000   Opens the file using information in the reopen buffer.   OF_SHARE_DENY_NONE 0x0040   Opens the file without denying other processes read or write access to the file.          LZOpenFile fails if the file has been opened in compatibility mode by any          other process.   OF_SHARE_DENY_READ 0x0030   Opens the file and denies other processes read access to the file.          LZOpenFile fails if the file has been opened in compatibility mode or has          been opened for read access by any other process.   OF_SHARE_DENY_WRITE 0x0020   Opens the file and denies other processes write access to the file.          LZOpenFile fails if the file has been opened in compatibility mode or has          been opened for write access by any other process.   OF_SHARE_EXCLUSIVE 0x0010   Opens the file in exclusive mode, denying other processes both read and write access to the file.          LZOpenFile fails if the file has been opened in any other mode for read or          write access, even by the current process.   OF_WRITE 0x0001   Opens the file for writing only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Copies a source file to a destination file. If the source file has been compressed by the Lempel-Ziv algorithm, this function creates a decompressed destination file. If the source file is not compressed, this function duplicates the original file.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the size, in bytes, of the destination file. If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that  LZCopy calls neither  SetLastError nor  SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The following is a list of error codes that  LZCopy can return upon failure.  There is no extended error information for this function; do not call GetLastError. ",
    "remarks": "The handles identifying the source and destination files must be retrieved by calling the  LZInit or  LZOpenFile function. If the function succeeds, the file identified by the hfDest parameter is always uncompressed. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "LONG",
    "category": "Files and I/O (Local file system)",
    "name": "LZCopy",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "hfSource",
        "description": "A handle to the source file."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "hfDest",
        "description": "A handle to the destination file."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Allocates memory for the internal data structures required to decompress files, and then creates and initializes them.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a new LZ file handle. If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that  LZInit calls neither  SetLastError nor  SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The following is the list of the error codes that  LZInit can return upon failure.  There is no extended error information for this function; do not call GetLastError. ",
    "remarks": "A maximum of 16 compressed files can be open at any given time. Similarly, a maximum of 16 uncompressed files can be open at any given time. An application should be careful to close the handle returned by  LZInit when it is done using the file; otherwise, the application can inadvertently hit the 16-file limit. The handle this function returns is compatible only with the functions in Lz32.dll; it should not be used for other file operations. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "INT",
    "category": "Files and I/O (Local file system)",
    "name": "LZInit",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "hfSource",
        "description": "A handle to the file."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Reads (at most) the specified number of bytes from a file and copies them into a buffer.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the number of bytes read. If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that  LZRead calls neither SetLastError nor SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The following is the list of error codes that  LZRead can return upon failure.  There is no extended error information for this function; do not call GetLastError. ",
    "remarks": "The handle identifying the file must be retrieved by calling either the  LZInit or  LZOpenFile function. If the file is compressed,  LZRead operates on an expanded image of the file and copies the bytes of data into the specified buffer. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "INT",
    "category": "Files and I/O (Local file system)",
    "name": "LZRead",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "hFile",
        "description": "A handle to the file."
      },
      {
        "in_out": "_Out_",
        "type": "LPSTR",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the bytes read from the file. Ensure that this buffer is larger than cbRead."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "cbRead",
        "description": "The count of bytes to be read."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Moves a file pointer the specified number of bytes from a starting position.",
    "library": "Lz32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LzExpand.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the offset from the beginning of the file to the new pointer position. If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that  LZSeek calls neither SetLastError nor SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The following is the list of error codes that  LZSeek can return upon failure.  There is no extended error information for this function; do not call GetLastError. ",
    "remarks": "The handle identified by the hFile parameter must be retrieved by calling either the  LZInit or  LZOpenFile function. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "LONG",
    "category": "Files and I/O (Local file system)",
    "name": "LZSeek",
    "is_callback": 0,
    "dll": "Lz32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "hFile",
        "description": "A handle to the file."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lOffset",
        "description": "The number of bytes by which to move the file pointer."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "iOrigin",
        "description": "The starting position of the pointer. This parameter must be one of the following values.     ValueMeaning   0   Moves the file pointer lOffset bytes from the beginning of the file.    1   Moves the file pointer lOffset bytes from the current position.    2   Moves the file pointer lOffset bytes from the end of the file."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Moves an existing file or a directory, including its children.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The MoveFile function will move (rename) either a file or a      directory (including its children) either in the same directory or across directories. The one caveat is that the      MoveFile function will fail on directory moves when the      destination is on a different volume. If a file is moved across volumes, MoveFile does not move      the security descriptor with the file. The file will be assigned the default security descriptor in the      destination directory. The MoveFile function coordinates its operation with the      link tracking service, so link sources can be tracked as they are moved. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "MoveFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The current name of the file or directory on the local computer. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (MoveFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a         different file system or drive. A new directory must be on the same drive. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (MoveFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Moves an existing file or directory, including its children, with various move options.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call         GetLastError. ",
    "remarks": "If the dwFlags parameter specifies       MOVEFILE_DELAY_UNTIL_REBOOT,       MoveFileEx fails if it cannot access the registry. The       function stores the locations of the files to be renamed at restart in the following registry value: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations This registry  value is of type REG_MULTI_SZ. Each rename operation stores one         of the following NULL-terminated strings, depending on whether the rename is a delete or not: The string szDstFile\\0\\0 indicates that the file       szDstFile is to be deleted on reboot. The string       szSrcFile\\0szDstFile\\0 indicates that       szSrcFile is to be renamed szDstFile on reboot. The system uses these registry entries to complete the operations at restart in the same order that they were       issued. For example, the following code fragment creates registry entries that delete       szDstFile and rename szSrcFile to be       szDstFile at restart: Because the actual move and deletion operations specified with the       MOVEFILE_DELAY_UNTIL_REBOOT flag take place after the calling application has ceased       running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects       success or failure in placing the appropriate entries into the registry. The system deletes a directory that is tagged for deletion with the       MOVEFILE_DELAY_UNTIL_REBOOT flag only if it is empty. To ensure deletion of directories,       move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot       time, but they must be deleted or moved before the system can delete the directory. The move and deletion operations are carried out at boot time in the same order that they are specified in the       calling application. To delete a directory that has files in it at boot time, first delete the files. Windows Server 2003 and Windows XP:  For information about special situations where MOVEFILE_DELAY_UNTIL_REBOOT       functionality can fail, and a suggested workaround solution, see       Files are not exchanged when Windows Server 2003 restarts if you use the MoveFileEx function to schedule a replacement for some files       in the Help and Support Knowledge Base. If a file is moved across volumes, MoveFileEx does not       move the security descriptor with the file. The file is assigned the default security descriptor in the       destination directory. The MoveFileEx function coordinates its operation with       the link tracking service,       so link sources can be tracked as they are moved. To delete or rename a file, you must have either delete permission on the file or delete child permission in       the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of       new files are inherited, then you should be able to create a file without being able to delete it. However, you       can then create a file, and get all the access you request on the handle that is returned to you at the time that       you create the file. If you request delete permission at the time you create the file, you can delete or rename       the file with that handle but not with any other handle.  For more information, see       File Security and Access Rights. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see        Creating and Using a Temporary File. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "MoveFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpExistingFileName",
        "description": "The current name of the file or directory on the local computer. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT, the         file cannot exist on a remote share, because delayed operations are performed before the network is         available. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File  Tip  Starting with Windows 10, version 1607, for the unicode version of this function (MoveFileExW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpNewFileName",
        "description": "The new name of the file or directory on the local computer. When moving a file, the destination can be on a different file system or volume. If the destination is on         another drive, you must set the MOVEFILE_COPY_ALLOWED flag in         dwFlags. When moving a directory, the destination must be on the same drive. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and         lpNewFileName is  NULL,         MoveFileEx registers the         lpExistingFileName file to be deleted when the system restarts. If         lpExistingFileName refers to a directory, the system removes the directory at restart         only if the directory is empty. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File  Tip  Starting with Windows 10, version 1607, for the unicode version of this function (MoveFileExW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one or more of the following values.  ValueMeaning  MOVEFILE_COPY_ALLOWED 2 (0x2)   If the file is to be moved to a different volume, the function simulates the move by using the          CopyFile and          DeleteFile functions. If the  file is successfully copied to a different volume and the original file is unable to be deleted,           the function succeeds leaving the source file intact. This value cannot be used with MOVEFILE_DELAY_UNTIL_REBOOT.   MOVEFILE_CREATE_HARDLINK 16 (0x10)   Reserved for future use.   MOVEFILE_DELAY_UNTIL_REBOOT 4 (0x4)   The system does not move the file until the operating system is restarted. The system moves the file          immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter          enables the function to delete paging files from previous startups. This value can be used only if the process is in the context of a user who belongs to the administrators           group or the LocalSystem account.           This value cannot be used with MOVEFILE_COPY_ALLOWED. Windows Server 2003 and Windows XP:  For information about special situations where this functionality can fail, and a suggested workaround           solution, see           Files are not exchanged when Windows Server 2003 restarts if you use the MoveFileEx function to schedule a replacement for some files           in the Help and Support Knowledge Base.   MOVEFILE_FAIL_IF_NOT_TRACKABLE 32 (0x20)   The function fails if the source file is a link source, but the file cannot be tracked after the move.          This situation can occur if the destination is a volume formatted with the FAT file system.   MOVEFILE_REPLACE_EXISTING 1 (0x1)   If a file named lpNewFileName exists, the function replaces its contents with           the contents of the lpExistingFileName file, provided that security requirements           regarding access control lists (ACLs) are met. For more information, see the Remarks section of this           topic. This value cannot be used if lpNewFileName or           lpExistingFileName names a directory.   MOVEFILE_WRITE_THROUGH 8 (0x8)   The function does not return until the file is actually moved on the disk. Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk           before the function returns. The flush occurs at the end of the copy operation. This value has no effect if MOVEFILE_DELAY_UNTIL_REBOOT is set."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Creates, opens, reopens, or deletes a file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the file, call the CloseHandle function using this handle. If the function fails, the return value is HFILE_ERROR. To get extended error         information, call GetLastError. ",
    "remarks": "If the lpFileName parameter specifies a file name and extension only, this function      searches for a matching file in the following directories and the order shown: The lpFileName parameter cannot contain wildcard characters. The OpenFile function does not support the      OF_SEARCH flag that the 16-bit Windows      OpenFile function supports. The      OF_SEARCH flag directs the system to search for a matching file even when a file name      includes a full path. Use the SearchPath function to search      for a file. A sharing violation occurs if an attempt is made to open a file or directory for deletion on a remote machine      when the value of the uStyle parameter is the OF_DELETE access      flag OR'ed with any other access flag, and the remote file or directory has not been opened with      FILE_SHARE_DELETE share access. To avoid the sharing violation in this scenario, open      the remote file or directory with OF_DELETE access only, or call      DeleteFile without first opening the file or directory for      deletion. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "HFILE",
    "category": "Files and I/O (Local file system)",
    "name": "OpenFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "lpFileName",
        "description": "The name of the file. The string must consist of characters from the 8-bit Windows character set. The         OpenFile function does not support Unicode file names or         opening named pipes."
      },
      {
        "in_out": "_Out_",
        "type": "LPOFSTRUCT",
        "name": "lpReOpenBuff",
        "description": "A pointer to the OFSTRUCT structure that receives         information about a file when it is first opened. The structure can be used in subsequent calls to the         OpenFile function to see an open file. The OFSTRUCT structure contains a path string         member with a length that is limited to OFS_MAXPATHNAME characters, which is 128         characters. Because of this, you cannot use the OpenFile         function to open a file with a path length that exceeds 128 characters. The         CreateFile function does not have this path         length limitation."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uStyle",
        "description": "The action to be taken. ..."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Opens the file that matches the specified identifier.",
    "library": "Kernel32.lib;  FileExtd.lib on Windows Server 2003 and Windows XP",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h);  FileExtd.h on Windows Server 2003 and Windows XP",
    "return_value": "If the function succeeds, the return value is an open handle to a specified file. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended         error information, call GetLastError. ",
    "remarks": "Use the CloseHandle function to close an object handle      that OpenFileById returns. If you call OpenFileById on a file that is pending      deletion as a result of a previous call to DeleteFile, the      function fails. The operating system delays file deletion until all handles to the file are closed.      GetLastError returns      ERROR_ACCESS_DENIED. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "OpenFileById",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to any file on a volume or share on which the file to be opened is stored."
      },
      {
        "in_out": "_In_",
        "type": "LPFILE_ID_DESCRIPTOR",
        "name": "lpFileID",
        "description": "A pointer to a FILE_ID_DESCRIPTOR that identifies         the file to open."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The access to the object. Access can be read, write, or both. For more information, see        File Security and Access       Rights. You cannot request an access mode that conflicts with the sharing mode that is specified in an       open request that has an open handle. If this parameter is zero (0), the application can query file and device attributes without accessing a       device. This is useful for an application to determine the size of a floppy disk drive and the formats it       supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or       directory without opening them for read or write access."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwShareMode",
        "description": "The sharing mode of an object, which can be read, write, both, or none. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request         that has an open handle, because that would result in the following sharing violation:         (ERROR_SHARING_VIOLATION). For more information, see         Creating and Opening Files. If this parameter is zero (0) and OpenFileById         succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more         information, see the Remarks section of this topic. The sharing options remain in effect until you close the handle to an object. To enable a processes to share an object while another process has the object open, use a combination of one         or more of the following values to specify the access mode they can request to open the object.  ValueMeaning  FILE_SHARE_DELETE 0x00000004   Enables subsequent open operations on an object to request delete access. Otherwise, other processes cannot open the object if they request delete access. If this flag is not specified, but the object has been opened for delete access, the function fails.   FILE_SHARE_READ 0x00000001   Enables subsequent open operations on an object to request read access. Otherwise, other processes cannot open the object if they request read access. If this flag is not specified, but the object has been opened for read access, the function fails.   FILE_SHARE_WRITE 0x00000002   Enables subsequent open operations on an object to request write access. Otherwise, other processes cannot open the object if they request write access. If this flag is not specified, but the object has been opened for write access or has a file mapping with           write access, the function fails."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "Reserved."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The file flags. When OpenFileById opens a file, it combines the file         flags with existing file attributes, and ignores any supplied file attributes. This parameter can include any         combination of the following flags.  ValueMeaning  FILE_FLAG_BACKUP_SEMANTICS 0x02000000   A file is being opened for a backup or restore operation. The system ensures that the calling process           overrides file security checks when the process has SE_BACKUP_NAME and           SE_RESTORE_NAME privileges. For more information, see           Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A directory handle can be passed to some           functions  instead of a file handle. For more information, see           Directory Handles.   FILE_FLAG_NO_BUFFERING 0x20000000   The system opens a file with no system caching. This flag does not affect hard disk caching. When combined           with FILE_FLAG_OVERLAPPED, the flag gives maximum asynchronous performance, because           the I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take           more time, because data is not being held in the cache. Also, the file metadata may still be cached. To flush           the metadata to disk, use the FlushFileBuffers           function. An application must meet certain requirements when working with files that are opened with           FILE_FLAG_NO_BUFFERING:  File access must begin at byte offsets within a file that are integer multiples of the volume sector            size. File access must be for numbers of bytes that are integer multiples of the volume sector size. For            example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or            2048 bytes, but not of 335, 981, or 7171 bytes. Buffer addresses for read and write operations should be sector aligned, which means aligned on            addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this            requirement may not be enforced.  One way to align buffers on integer multiples of the volume sector size is to use           VirtualAlloc to allocate the buffers. It allocates           memory that is aligned on addresses that are integer multiples of the operating system's memory page size.           Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses           that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes           (hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages. An application can determine a volume sector size by calling the           GetDiskFreeSpace function.   FILE_FLAG_OPEN_NO_RECALL 0x00100000   The file data is requested, but it should continue to be located in remote storage. It should not be           transported back to local storage. This flag is for use by remote storage systems.   FILE_FLAG_OPEN_REPARSE_POINT 0x00200000   When this flag is used, normal reparse point           processing does not occur, and OpenFileById attempts           to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that           controls the reparse point is operational. This flag cannot be used with the           CREATE_ALWAYS flag. If the file is not a reparse point, then this flag is           ignored.   FILE_FLAG_OVERLAPPED 0x40000000   The file is being opened or created for asynchronous I/O. When the operation is complete, the event           specified to the call in the OVERLAPPED structure is           set to the signaled state. Operations that take a significant amount of time to process return           ERROR_IO_PENDING. If this flag is specified, the file can be used for simultaneous read and write operations. The system does           not maintain the file pointer, therefore you must pass the file position to the read and write functions in           the OVERLAPPED  structure or update the file           pointer. If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write           functions specify an OVERLAPPED structure.   FILE_FLAG_RANDOM_ACCESS 0x10000000   A file is accessed randomly. The system can use this as a hint to optimize file caching.   FILE_FLAG_SEQUENTIAL_SCAN 0x08000000   A file is accessed sequentially from beginning to end. The system can use this as a hint to optimize file           caching. If an application moves the file pointer for random access, optimum caching may not occur. However,           correct operation is still guaranteed. Specifying this flag can increase performance for applications that read large files using sequential           access. Performance gains can be even more noticeable for applications that read large files mostly           sequentially, but occasionally skip over small ranges of bytes.   FILE_FLAG_WRITE_THROUGH 0x80000000   The system writes through any intermediate cache and goes directly to disk. If FILE_FLAG_NO_BUFFERING is not also specified, so that system caching is in           effect, then the data is written to the system cache, but is flushed to disk without delay. If FILE_FLAG_NO_BUFFERING is also specified, so that system caching is not in           effect, then the data is immediately flushed to disk without going through the system cache. The operating           system also requests a write-through the hard disk cache to persistent media. However, not all hardware           supports this write-through capability."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Posts an I/O completion packet to an I/O completion port.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "IoAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError . ",
    "remarks": "The I/O completion packet will satisfy an outstanding call to the  GetQueuedCompletionStatus function. This function returns with the three values passed as the second, third, and fourth parameters of the call to  PostQueuedCompletionStatus. The system does not use or validate these values. In particular, the lpOverlapped parameter need not point to an OVERLAPPED structure. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  CsvFs will do redirected IO for compressed files. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "PostQueuedCompletionStatus",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "CompletionPort",
        "description": "A handle to an I/O completion port to which the I/O completion packet is to be posted."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNumberOfBytesTransferred",
        "description": "The value to be returned through the lpNumberOfBytesTransferred parameter of the  GetQueuedCompletionStatus function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "dwCompletionKey",
        "description": "The value to be returned through the lpCompletionKey parameter of the  GetQueuedCompletionStatus function."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "The value to be returned through the lpOverlapped parameter of the  GetQueuedCompletionStatus function."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a list of recovery agents for the specified file.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "When the list of recovery agents is no longer needed, free it by calling the  FreeEncryptionCertificateHashList function. In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "QueryRecoveryAgentsOnEncryptedFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the file."
      },
      {
        "in_out": "_Out_",
        "type": "PENCRYPTION_CERTIFICATE_HASH_LIST*",
        "name": "pRecoveryAgents",
        "description": "A pointer to a  ENCRYPTION_CERTIFICATE_HASH_LIST structure that receives a list of recovery agents."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a list of users for the specified file.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "When the list of users is no longer needed, call the  FreeEncryptionCertificateHashList function to free the list. In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "QueryUsersOnEncryptedFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the file."
      },
      {
        "in_out": "_Out_",
        "type": "PENCRYPTION_CERTIFICATE_HASH_LIST*",
        "name": "pUsers",
        "description": "A pointer to a  ENCRYPTION_CERTIFICATE_HASH_LIST structure that receives the list of users."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified      by the file pointer if supported by the device.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero         (FALSE). To get extended error information, call the         GetLastError function. ",
    "remarks": "The ReadFile function returns when one of the following       conditions occur: The ReadFile function may fail with      ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY whenever      there are too many outstanding asynchronous I/O requests. To cancel all pending asynchronous I/O operations, use either: Use CancelSynchronousIo to cancel pending       synchronous I/O operations. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. The ReadFile function may fail with      ERROR_NOT_ENOUGH_QUOTA, which means the calling process's buffer could not be      page-locked. For additional information, see      SetProcessWorkingSetSize. If part of a file is locked by another process and the read operation overlaps the locked portion, this      function fails. Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read      into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read      operation is using until the read operation completes. This can be particularly problematic when using an      asynchronous file handle. Additional information regarding synchronous versus asynchronous file handles can be      found in the Synchronization and File Position section and      in the CreateFile reference topic. Characters can be read from the console input buffer by using      ReadFile with a handle to console input. The console mode      determines the exact behavior of the ReadFile function. By      default, the console mode is ENABLE_LINE_INPUT, which indicates that      ReadFile should read until it reaches a carriage return. If you      press Ctrl+C, the call succeeds, but GetLastError returns      ERROR_OPERATION_ABORTED. For more information, see      CreateFile. When reading from a communications device, the behavior of      ReadFile is determined by the current communication time-out as      set and retrieved by using the SetCommTimeouts and      GetCommTimeouts functions. Unpredictable results can      occur if you fail to set the time-out values. For more information about communication time-outs, see      COMMTIMEOUTS. If ReadFile attempts to read from a mailslot that has a      buffer that is too small, the function returns FALSE and      GetLastError returns      ERROR_INSUFFICIENT_BUFFER. There are strict requirements for successfully working with files opened with      CreateFile using the      FILE_FLAG_NO_BUFFERING flag. For details see      File Buffering. If hFile was opened with FILE_FLAG_OVERLAPPED, the       following conditions are in effect: If hFile is opened with FILE_FLAG_OVERLAPPED, it is an        asynchronous file handle; otherwise it is synchronous. The rules for using the        OVERLAPPED structure are slightly different for each,        as previously noted. Considerations for working with asynchronous file handles: Considerations for working with synchronous file handles: For more information, see CreateFile and        Synchronous and Asynchronous I/O. If an anonymous pipe is being used and the  write handle has been closed, when        ReadFile attempts to read using the pipe's corresponding read        handle, the function returns FALSE and        GetLastError returns        ERROR_BROKEN_PIPE. If a named pipe is being read in message mode and the next message is longer than the        nNumberOfBytesToRead parameter specifies,        ReadFile returns FALSE and        GetLastError returns        ERROR_MORE_DATA. The remainder of the message can be read by a subsequent call to the        ReadFile or        PeekNamedPipefunction. If the lpNumberOfBytesRead parameter is zero when        ReadFile returns TRUE on a pipe,        the other end of the pipe called the WriteFile function with        nNumberOfBytesToWrite set to zero. For more information about pipes, see Pipes. If there is a transaction bound to the file handle, then the function returns data from the transacted view of        the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the        handle. For more information, see        About Transactional NTFS. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For a code example that shows you how to test for end-of-file, see       Testing for the End of  a File. For other       examples, see       Creating and Using a Temporary File and       Opening a File for Reading or Writing. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "ReadFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive,         socket, communications resource, mailslot, or  pipe). The hFile parameter must have been created with read access. For more information,         see Generic Access Rights and         File Security and Access Rights. For asynchronous read operations, hFile can be any handle that is opened with the         FILE_FLAG_OVERLAPPED flag by the         CreateFile function, or a socket handle returned by the         socket or         accept function."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "A pointer to the buffer that receives the data read from a file or device. This buffer must remain valid for the duration of the read operation. The caller must not use this buffer         until the read operation is completed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToRead",
        "description": "The maximum number of bytes to be read."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesRead",
        "description": "A pointer to the variable that receives the number of bytes read when using a synchronous         hFile parameter. ReadFile sets         this value to zero  before doing any work or error checking. Use NULL for this         parameter if this is an asynchronous operation to avoid potentially erroneous results. This parameter can be NULL only when the lpOverlapped         parameter is not NULL. For more information, see the Remarks section."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED structure is         required if the hFile parameter was opened with         FILE_FLAG_OVERLAPPED, otherwise it can be NULL. If hFile is opened with FILE_FLAG_OVERLAPPED, the         lpOverlapped parameter must point to a         valid and unique OVERLAPPED structure, otherwise the         function can incorrectly report that the read operation is complete. For an hFile that supports byte offsets, if you use this parameter you must specify         a byte offset at which to start reading from the file or device. This offset is specified by setting the         Offset and OffsetHigh members of the         OVERLAPPED structure. For an         hFile that does not support byte offsets, Offset and         OffsetHigh are ignored. For more information about different combinations of lpOverlapped and         FILE_FLAG_OVERLAPPED, see the Remarks section and the         Synchronization and File Position section."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Reads data from a file and stores it in an array of buffers.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call the         GetLastError function. If ReadFileScatter attempts to read past the         end-of-file (EOF), the call to         GetOverlappedResult for that operation returns         FALSE and GetLastError         returns ERROR_HANDLE_EOF. If the function returns before the read operation is complete, the function returns zero (0), and         GetLastError returns         ERROR_IO_PENDING. ",
    "remarks": "This function is not supported for 32-bit applications by WOW64 on Itanium-based systems. The FILE_SEGMENT_ELEMENT union is defined as follows: Assigning a pointer to the Buffer member will sign-extend the value if the code is       compiled as 32-bits; this can break large-address aware applications running on systems configured with       4-Gigabyte Tuning or running on under WOW64 on 64-bit       Windows. Therefore, use the PtrToPtr64 macro when assigning pointers to       Buffer. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If there is a transaction bound to the file handle, then the function returns data from the transacted view of        the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the        handle. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "ReadFileScatter",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file to be read. The file handle must be created with the GENERIC_READ right, and the         FILE_FLAG_OVERLAPPED and FILE_FLAG_NO_BUFFERING flags. For         more information, see         File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "FILE_SEGMENT_ELEMENT",
        "name": "aSegmentArray[]",
        "description": "A pointer to an array of FILE_SEGMENT_ELEMENT         buffers that receives the data. For a description of this union, see Remarks. Each element can receive one page of data. Note  To determine the size of a system page, use         GetSystemInfo.   The array must contain enough elements to store nNumberOfBytesToRead bytes of data,         plus one element for the terminating NULL. For example, if there are 40 KB to be         read and the page size is 4 KB, the array must have 11 elements that includes 10 for the data and one for         the NULL. Each buffer must be at least the size of a system memory page and must be aligned on a system memory page         size boundary. The system reads one system memory page of data into each buffer. The function stores the data in the buffers in sequential order. For example, it stores data into the first         buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there         are no more buffers."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToRead",
        "description": "The total number of bytes to be read from the file. Each element of aSegmentArray        contains a one-page chunk of this total. Because the file must be opened with        FILE_FLAG_NO_BUFFERING, the number of bytes must be a multiple of the sector size of        the file system where the file is located."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPDWORD",
        "name": "lpReserved",
        "description": "This parameter is reserved for future use and must be NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED data         structure. The ReadFileScatter function requires a valid         OVERLAPPED structure. The         lpOverlapped parameter         cannot be NULL. The ReadFileScatter function starts reading data         from the file at a position that is specified by the Offset and         OffsetHigh members of the         OVERLAPPED structure. The ReadFileScatter function may return before the         read operation is complete. In that scenario, the         ReadFileScatter function returns the value 0         (zero), and the GetLastError function returns the         value ERROR_IO_PENDING. This asynchronous operation of         ReadFileScatter lets the calling process continue         while the read operation completes. You can call the         GetOverlappedResult,         HasOverlappedIoCompleted, or         GetQueuedCompletionStatus functions to         obtain information about the completion of the read operation. For more information, see         Synchronous and Asynchronous I/O."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Removes specified certificate hashes from a specified file.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "The  RemoveUsersFromEncryptedFile function removes the specified certificate hashes if they exist in the specified file. If any of the certificate hashes are not found in the specified file, they are ignored and no error code is returned. Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "RemoveUsersFromEncryptedFile",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpFileName",
        "description": "The name of the file."
      },
      {
        "in_out": "_In_",
        "type": "PENCRYPTION_CERTIFICATE_HASH_LIST",
        "name": "pHashes",
        "description": "A pointer to an  ENCRYPTION_CERTIFICATE_HASH_LIST structure that contains a list of certificate hashes to be removed from the file."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Reopens the specified file system object with different access rights, sharing mode, and      flags.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is an open handle to the specified file. If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended         error information, call GetLastError. ",
    "remarks": "The dwFlags parameter cannot contain any of the file attribute flags      (FILE_ATTRIBUTE_*). These can only be specified when the file is created. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "HANDLE",
    "category": "Files and I/O (Local file system)",
    "name": "ReOpenFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hOriginalFile",
        "description": "A handle to the object to be reopened. The object must have been created by the         CreateFile function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccess",
        "description": "The required access to the object. For a list of values, see  \t      File Security and Access Rights. You  \t      cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose  \t      handle is still open. If this parameter is zero (0), the application can query device attributes without accessing the device. This         is useful if an application wants to determine the size of a floppy disk drive and the formats it supports         without requiring a floppy in the drive."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwShareMode",
        "description": "The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode         specified in a previous open request whose handle is still open. If this parameter is zero (0) and CreateFile succeeds,         the object cannot be shared and cannot be opened again until the handle is closed. To enable other processes to share the object while your process has it open, use a combination of one or         more of the following values to specify the type of access they can request when they open the object. These         sharing options remain in effect until you close the handle to the object.  ValueMeaning  FILE_SHARE_DELETE 0x00000004   Enables subsequent open operations on the object to request delete access. Otherwise, other processes           cannot open the object if they request delete access. If the object has already been opened with delete access, the sharing mode must include this flag.   FILE_SHARE_READ 0x00000001   Enables subsequent open operations on the object to request read access. Otherwise, other processes cannot           open the object if they request read access. If the object has already been opened with read access, the sharing mode must include this flag.   FILE_SHARE_WRITE 0x00000002   Enables subsequent open operations on the object to request write access. Otherwise, other processes cannot           open the object if they request write access. If the object has already been opened with write access, the sharing mode must include this flag."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The file flags. This parameter can be one or more of the following values.  ValueMeaning  FILE_FLAG_BACKUP_SEMANTICS 0x02000000   Indicates that the file is being opened or created for a backup or restore operation. The system ensures           that the calling process overrides file security checks, provided it has the           SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more           information, see           Changing Privileges in a Token. You can also set this flag to obtain a handle to a directory. Where indicated, a directory handle can be           passed to some functions in place of a file handle.   FILE_FLAG_DELETE_ON_CLOSE 0x04000000   Indicates that the operating system is to delete the file immediately after all of its handles have been           closed, not just the specified handle but also any other open or duplicated handles. Subsequent open requests for the file fail, unless FILE_SHARE_DELETE is used.   FILE_FLAG_NO_BUFFERING 0x20000000   Instructs the system to open the file with no intermediate buffering or caching. When combined with           FILE_FLAG_OVERLAPPED, the flag gives maximum asynchronous performance, because the           I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take           longer, because data is not being held in the cache. An application must meet specific requirements when working with files opened with           FILE_FLAG_NO_BUFFERING:  File access must begin at byte offsets within the file that are integer multiples of the volume sector            size. File access must be for numbers of bytes that are integer multiples of the volume sector size. For            example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or            2048 bytes, but not of 335, 981, or 7171 bytes. Buffer addresses for read and write operations should be sector aligned (aligned on addresses in memory            that are integer multiples of the volume sector size). Depending on the disk, this requirement may not be            enforced.  One way to align buffers on integer multiples of the volume sector size is to use           VirtualAlloc to allocate the buffers. It allocates           memory that is aligned on addresses that are integer multiples of the operating system memory page size.           Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses           that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes           (hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages. An application can determine a volume sector size by calling the           GetDiskFreeSpace function.   FILE_FLAG_OPEN_NO_RECALL 0x00100000   Indicates that the file data is requested, but it should continue to reside in remote storage. It should           not be transported back to local storage. This flag is intended for use by remote storage systems.   FILE_FLAG_OPEN_REPARSE_POINT 0x00200000   When this flag is used, normal reparse point           processing does not occur, and ReOpenFile attempts to           open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that           controls the reparse point is operational. This flag cannot be used with the           CREATE_ALWAYS flag. If the file is not a reparse point, then this flag is ignored.   FILE_FLAG_OVERLAPPED 0x40000000   Instructs the system to initialize the object, so that operations that take a significant amount of time to         process return ERROR_IO_PENDING. When the operation is finished, the specified event is set to the signaled         state. When you specify FILE_FLAG_OVERLAPPED, the file read and write functions           must specify an           OVERLAPPED structure. That is, when           FILE_FLAG_OVERLAPPED is specified, an application must           perform overlapped reading and writing. When FILE_FLAG_OVERLAPPED is specified, the system does not maintain the file           pointer. The file position must be passed as part of the lpOverlapped parameter           (pointing to an OVERLAPPED structure) to the file           read and write functions. This flag also enables more than one operation to be performed simultaneously with the handle (a           simultaneous read and write operation, for example).   FILE_FLAG_POSIX_SEMANTICS 0x0100000   Indicates that the file is to be accessed according to POSIX rules. This includes allowing multiple files           with names, differing only in case, for file systems that support such naming. Use care when using this           option because files created with this flag may not be accessible by applications written for MS-DOS or           16-bit Windows.   FILE_FLAG_RANDOM_ACCESS 0x10000000   Indicates that the file is accessed randomly. The system can use this as a hint to optimize file           caching.   FILE_FLAG_SEQUENTIAL_SCAN 0x08000000   Indicates that the file is to be accessed sequentially from beginning to end. The system can use this as a           hint to optimize file caching. If an application moves the file pointer for random access, optimum caching           may not occur; however, correct operation is still guaranteed. Specifying this flag can increase performance for applications that read large files using sequential           access. Performance gains can be even more noticeable for applications that read large files mostly           sequentially, but occasionally skip over small ranges of bytes.   FILE_FLAG_WRITE_THROUGH 0x80000000   Instructs the system to write through any intermediate cache and go directly to disk. The system can still           cache write operations, but cannot lazily flush them.     If the handle represents the client side of a named pipe, the dwFlags parameter can         also contain Security Quality of Service information. For more information, see         Impersonation Levels. When the calling         application specifies the SECURITY_SQOS_PRESENT flag, the         dwFlags parameter can contain one or more of the following values.  ValueMeaning  SECURITY_ANONYMOUS   Impersonate the client at the Anonymous impersonation level.   SECURITY_CONTEXT_TRACKING   The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is           static.   SECURITY_DELEGATION   Impersonate the client at the Delegation impersonation level.   SECURITY_EFFECTIVE_ONLY   Only the enabled aspects of the client security context are available to the server. If you do not specify           this flag, all aspects of the client security context are available. This allows the client to limit the groups and privileges that a server can use while impersonating the           client.   SECURITY_IDENTIFICATION   Impersonate the client at the Identification impersonation level.   SECURITY_IMPERSONATION   Impersonate the client at the Impersonation impersonation level."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Replaces one file with another file, with the option of creating a backup copy of the original      file. The replacement file assumes the name of the replaced file and its identity.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. The following are possible error codes         for this function.  If any other error is returned, such as ERROR_INVALID_PARAMETER, the replaced and         replacement files will retain their original file names. In this scenario, a backup file         does not exist and it is not guaranteed that the         replacement file will have inherited all of the attributes and streams of the replaced file. ",
    "remarks": "The ReplaceFile function combines several steps within a       single function. An application can call ReplaceFile instead       of calling separate functions to save the data to a new file, rename the original file using a temporary name,       rename the new file to have the same name as the original file, and delete the original file. Another advantage is       that ReplaceFile not only copies the new file data, but also       preserves the following attributes of the original file: For example, if the replacement file is encrypted, but the replaced file is not encrypted, the resulting file       is not encrypted. Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  Security resource attributes (ATTRIBUTE_SECURITY_INFORMATION) for the original        file are not preserved until Windows 8 and Windows Server 2012. The resulting file has the same file ID as the replacement file. The backup file, replaced file, and replacement file must all reside on the same volume. To delete or rename a file, you must have either delete permission on the file or delete child permission in       the parent directory. If you set up a directory with all access except delete and delete child and the DACLs of       new files are inherited, then you should be able to create a file without being able to delete it. However, you       can then create a file, and you will get all the access you request on the handle returned to you at the time you       create the file. If you requested delete permission at the time you created the file, you could delete or rename       the file with that handle but not with any other. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "ReplaceFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpReplacedFileName",
        "description": "The name of the file to be replaced. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (ReplaceFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details.   This file is opened with the GENERIC_READ, DELETE, and         SYNCHRONIZE access rights. The sharing mode is         FILE_SHARE_READ | FILE_SHARE_WRITE |         FILE_SHARE_DELETE. The caller must have write access to the file to be replaced. For more information, see         File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpReplacementFileName",
        "description": "The name of the file that will replace the lpReplacedFileName file. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (ReplaceFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details.   The function attempts to open this file with the SYNCHRONIZE,         GENERIC_READ, GENERIC_WRITE,         DELETE, and WRITE_DAC access rights so that it can preserve         all attributes and ACLs. If this fails, the function attempts to open the file with the         SYNCHRONIZE, GENERIC_READ,         DELETE, and WRITE_DAC access rights. No sharing mode is         specified."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpBackupFileName",
        "description": "The name of the file that will serve as a backup copy of the lpReplacedFileName         file. If this parameter is NULL, no backup file is created. In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         Naming a File. Tip  Starting with Windows 10, version 1607, for the unicode version of this function (ReplaceFileW), you can opt-in to remove the MAX_PATH limitation without prepending \"\\\\?\\\". See the \"Maximum Path Length Limitation\" section of Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwReplaceFlags",
        "description": "The replacement options. This parameter can be one or more of the following values.  ValueMeaning  REPLACEFILE_WRITE_THROUGH 0x00000001   This value is not supported.   REPLACEFILE_IGNORE_MERGE_ERRORS 0x00000002   Ignores errors that occur while merging information (such as attributes and ACLs) from the replaced file to           the replacement file. Therefore, if you specify this flag and do not have WRITE_DAC           access, the function succeeds but the ACLs are not preserved.   REPLACEFILE_IGNORE_ACL_ERRORS 0x00000004   Ignores errors that occur while merging ACL information from the replaced file to the replacement file.           Therefore, if you specify this flag and do not have WRITE_DAC access, the function           succeeds but the ACLs are not preserved. To compile an application that uses this value, define the           _WIN32_WINNT macro as 0x0600 or later. Windows Server 2003 and Windows XP:  This value is not supported."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPVOID",
        "name": "lpExclude",
        "description": "Reserved for future use."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPVOID",
        "name": "lpReserved",
        "description": "Reserved for future use."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "Searches for a specified file in a specified path.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the value returned is the length, in TCHARs, of the         string that is copied to the buffer, not including the terminating null character. If the return value is         greater than nBufferLength, the value returned is the size of the buffer that is         required to hold the path, including the terminating null character. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "If the lpPath parameter is NULL,       SearchPath searches for a matching file based on the current       value of the following registry value:  HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\SafeProcessSearchMode When the value of this REG_DWORD registry value is set to 1,       SearchPath first searches the folders that are specified in       the system path, and then searches the current working folder. When the value of this registry value is set to 0,       the computer first searches the current working folder, and then searches the folders that are specified in the       system path. The system default value for this registry key is 0. The search mode used by the SearchPath function can also       be set per-process by calling the SetSearchPathMode       function. The SearchPath function is not recommended as a method of       locating a .dll file if the intended use of the output is in a call to the       LoadLibrary function. This can result in locating the       wrong .dll file because the search order of the SearchPath       function differs from the search order used by the       LoadLibrary function. If you need to locate and load a       .dll file, use the LoadLibrary function. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "SearchPath",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpPath",
        "description": "The path to be searched for the file. If this parameter is NULL, the         function searches for a matching file using a registry-dependent system  search path. For more information, see         the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file for which to search."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpExtension",
        "description": "The extension to be added to the file name when searching for the file. The first character of the file name         extension must be a period (.). The extension is added only if the specified file name does not end with an         extension. If a file name extension is not required or if the file name contains an extension, this parameter can be         NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBufferLength",
        "description": "The size of the buffer that receives the valid path and file name (including the terminating null        character), in TCHARs."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpBuffer",
        "description": "A pointer to the buffer to receive the path and file name of the file found. The  string is a        null-terminated string."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR*",
        "name": "lpFilePart",
        "description": "A pointer to the variable to receive the address (within lpBuffer) of the last        component of the valid path and file name, which is the address of the character immediately following the final        backslash (\\) in the path."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the physical file size for the specified file to the current position of the file pointer.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call  GetLastError. ",
    "remarks": "The SetEndOfFile function can be used to truncate or extend a file. If the file is extended, the contents of the file between the old end of the file  and the new  end of the file are not defined. Each file stream has the following: The SetEndOfFile function sets the file size. Use SetFileValidData to set the valid data length. If   CreateFileMapping is called to create a file mapping object for hFile, UnmapViewOfFile must be called first to unmap all views and call  CloseHandle to close the file mapping object before you can call  SetEndOfFile. If there is a transaction bound to the handle, then the change in the end-of-file position is transacted. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetEndOfFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file to be extended or truncated.  The file handle must be created with the GENERIC_WRITE access right. For more information, see  File Security and Access Rights."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "Causes the file I/O functions to use the ANSI character set code page for the current      process. This function is useful for 8-bit console input and output operations.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The file I/O functions whose code page is set by SetFileApisToANSI are those      functions exported by KERNEL32.DLL that accept or return a file name.      SetFileApisToANSI sets the code page per process, rather than per thread or per      computer. The SetFileApisToANSI function complements the      SetFileApisToOEM function, which causes the same set      of file I/O functions to use the OEM character set code page. The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by      default. This means that strings returned by the console functions may not be processed correctly by other      functions, and vice versa. For example, if the      FindFirstFileA function returns a string that contains      certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the      WriteConsoleA function does not display the string      properly. Use the AreFileApisANSI function to determine      which code page the set of file I/O functions is currently using. Use the      SetConsoleCP and      SetConsoleOutputCP functions to set the code page      for the 8-bit console functions. To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console      applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that      solution, a console application can call the      SetFileApisToOEM function to cause the      set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the      SetFileApisToANSI function to set those functions back to the ANSI code      page. When dealing with command lines, a console application should obtain the command line in Unicode form and then      convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the      argv parameter of the command-line main function      contains ANSI character set strings in this case. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "void",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileApisToANSI",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Causes the file I/O functions for the process to use the OEM character set code page. This      function is useful for 8-bit console input and output operations.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The file I/O functions whose code page is set by SetFileApisToOEM are those      functions exported by KERNEL32.DLL that accept or return a file name.      SetFileApisToOEM sets the code page per process, rather than per thread or per      computer. The SetFileApisToOEM function is complemented by the      SetFileApisToANSI function, which causes the same       set of file I/O functions to use the ANSI character set code page. The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by      default. This means that strings returned by the console functions may not be processed correctly by other      functions, and vice versa. For example, if the      FindFirstFileA function returns a string that contains      certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the      WriteConsoleA function will not display the string      properly. Use the AreFileApisANSI function to determine      which code page the set of file I/O functions is currently using. Use the      SetConsoleCP and      SetConsoleOutputCP functions to set the code page      for the 8-bit console functions. To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console      applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that      solution, a console application can call the SetFileApisToOEM function to cause      the set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the      SetFileApisToANSI function to set those functions      back to the ANSI code page. When dealing with command lines, a console application should obtain the command line in Unicode form and then      convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the      argv parameter of the command-line main function      contains ANSI character set strings in this case. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "void",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileApisToOEM",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the attributes for a file or directory.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The following table describes how to set the attributes that cannot be set using      SetFileAttributes. For a complete list of all file      attribute values and their descriptions, see      File Attribute Constants.  If a file is open for modification in a transaction, no other thread can open the file for modification until        the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try        modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread        modifies the file before the transacted thread does, and the file is still open when the transaction attempts to        open it, the transaction receives the error ERROR_TRANSACTIONAL_CONFLICT. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see       Retrieving and Changing File Attributes. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileAttributes",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file whose attributes are to be set.        In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function (SetFileAttributesW) and prepend         \"\\\\?\\\" to the path. For more information, see         File Names, Paths, and Namespaces. Tip  Starting in Windows 10, version 1607, for the unicode version of this function (SetFileAttributesW), you can opt-in to remove the MAX_PATH character limitation without prepending \"\\\\?\\\". See the \"Maximum Path Limitation\" section of  Naming Files, Paths, and Namespaces for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileAttributes",
        "description": "The file attributes to set for the file. This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values         override FILE_ATTRIBUTE_NORMAL. Not all attributes are supported by this function. For more information, see the Remarks section. The following is a list of supported attribute values.  ValueMeaning  FILE_ATTRIBUTE_ARCHIVE 32 (0x20)   A file or directory that is an archive file or directory. Applications typically use this attribute to          mark files for backup or removal.   FILE_ATTRIBUTE_HIDDEN 2 (0x2)   The file or directory is hidden. It is not included in an ordinary directory listing.   FILE_ATTRIBUTE_NORMAL 128 (0x80)   A file that does not have other attributes set. This attribute is valid only when used alone.   FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 8192 (0x2000)   The file or directory is not to be indexed by the content indexing service.   FILE_ATTRIBUTE_OFFLINE 4096 (0x1000)   The data of a file is not available immediately. This attribute indicates that the file data is          physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical          storage management software. Applications should not arbitrarily change this attribute.   FILE_ATTRIBUTE_READONLY 1 (0x1)   A file that is read-only. Applications can read the file, but cannot write to it or delete it. This          attribute is not honored on directories. For more information, see \"You cannot view or change the Read-only or          the System attributes of folders in Windows Server 2003, in Windows XP, or in          Windows Vista.   FILE_ATTRIBUTE_SYSTEM 4 (0x4)   A file or directory that the operating system uses a part of, or uses exclusively.   FILE_ATTRIBUTE_TEMPORARY 256 (0x100)   A file that is being used for temporary storage. File systems avoid writing data back to mass storage if          sufficient cache memory is available, because typically, an application deletes a temporary file after the          handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is          written after the handle is closed."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "[Microsoft strongly recommends developers utilize alternative means to achieve your      application's needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily      available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more      information, and alternatives to TxF, please see      Alternatives to using Transactional NTFS.]",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The following table describes how to set the attributes that cannot be set using      SetFileAttributesTransacted. Note that these      are not transacted operations.  If a file is open for modification in a transaction, no other thread can successfully open the file for      modification until the transaction is committed. If a transacted thread opens the file first, any subsequent      threads that attempt to open the file for modification before the transaction is committed will receive a sharing      violation. If a non-transacted thread opens the file for modification before the transacted thread does, and it is      still open when the transacted thread attempts to open it, the transaction will receive the      ERROR_TRANSACTIONAL_CONFLICT error. For more information on transactions, see      Transactional NTFS. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support TxF. If a file is open for modification in a transaction, no other thread can open the file for modification until        the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try        modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread        modifies the file before the transacted thread does, and the file is still open when the transaction attempts to        open it, the transaction receives the error ERROR_TRANSACTIONAL_CONFLICT. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileAttributesTransacted",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the file whose attributes are to be set.        In the ANSI version of this function, the name is limited to MAX_PATH characters.         To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend         \"\\\\?\\\" to the path. For more information, see         File Names, Paths, and Namespaces. The file must reside on the local computer; otherwise, the function fails and the last error code is set to        ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileAttributes",
        "description": "The file attributes to set for the file. For a list of file attribute value and their descriptions, see         File Attribute Constants. This parameter can be         one or more values, combined using the bitwise-OR operator. However, all other values override         FILE_ATTRIBUTE_NORMAL. Not all attributes are supported by this function. For more information, see the Remarks section. The following is a list of supported attribute values.  FILE_ATTRIBUTE_ARCHIVE (32 (0x20)) FILE_ATTRIBUTE_HIDDEN (2 (0x2)) FILE_ATTRIBUTE_NORMAL (128 (0x80)) FILE_ATTRIBUTE_NOT_CONTENT_INDEXED (8192 (0x2000)) FILE_ATTRIBUTE_OFFLINE (4096 (0x1000)) FILE_ATTRIBUTE_READONLY (1 (0x1)) FILE_ATTRIBUTE_SYSTEM (4 (0x4)) FILE_ATTRIBUTE_TEMPORARY (256 (0x100))"
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to the transaction. This handle is returned by the        CreateTransaction function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a      number of bytes in a period of milliseconds for I/O requests on the specified  file handle.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns nonzero if successful or zero otherwise. A reservation can fail if there is not enough bandwidth available on the volume because of existing         reservations; in this case ERROR_NO_SYSTEM_RESOURCES is returned. To get extended error information, call         GetLastError. ",
    "remarks": "The requested bandwidth reservation must be greater than or equal to one packet per period. The minimum period,       in milliseconds, maximum bytes per period, and minimum transfer size, in bytes, for a specific volume are       returned through the lpPeriodMilliseconds, lpBytesPerPeriod,       and  lpTransferSize parameters to       GetFileBandwidthReservation on a       handle that has not been used in a call to       SetFileBandwidthReservation. In other       words: 1 \u00e2\u0089\u00a4 (nBytesPerPeriod)\u00c3\u0097(*lpPeriodMilliseconds)/(*lpTransferSize)/(nPeriodMilliseconds) IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileBandwidthReservation",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nPeriodMilliseconds",
        "description": "The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the        kernel until the time the I/O should be completed. The minimum supported value for the file        stream can be determined by looking at the value returned through the        lpPeriodMilliseconds parameter to the        GetFileBandwidthReservation function,        on a handle that has not had a bandwidth reservation set."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBytesPerPeriod",
        "description": "The bandwidth to reserve, in bytes per period. The maximum supported value for the file        stream can be determined by looking at the value returned through the        lpBytesPerPeriod parameter to the        GetFileBandwidthReservation function,        on a handle that has not had a bandwidth reservation set."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bDiscardable",
        "description": "Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation        before the period expires. If one of the drivers for the specified file stream does not support this        functionality, this function may return success and ignore the flag. To verify whether the setting will be        honored, call the        GetFileBandwidthReservation function        using the same hFile handle and examine the *pDiscardable        return value."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpTransferSize",
        "description": "A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by        the application. All I/O requests should be multiples of TransferSize."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumOutstandingRequests",
        "description": "A pointer to a variable that receives the number of TransferSize chunks the        application should allow to be outstanding with the operating system. This allows the storage stack to keep the        device busy and allows maximum throughput."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the  notification modes for a file handle, allowing you to  specify how completion notifications      work for the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns nonzero if successful or zero otherwise. To get extended error information, call         GetLastError. ",
    "remarks": "To compile an application that uses this function, define the _WIN32_WINNT macro      as 0x0600 or later. For more information, see      Using the Windows Headers. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileCompletionNotificationModes",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle to the file."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Flags",
        "description": "The modes to be set.  One or more modes can be set at the same time; however, after a mode has been set for        a file handle, it cannot be removed.  ValueMeaning  FILE_SKIP_COMPLETION_PORT_ON_SUCCESS 0x1   If the following three conditions are true, the I/O Manager does not queue a completion entry to the port,           when it would ordinarily do so. The conditions are:           A completion port is associated with the file handle. The file is opened for asynchronous I/O. A request returns success immediately without returning             ERROR_PENDING.  When the FileHandle parameter is a socket, this mode is only compatible with           Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a           non-IFS LSP is installed, use the           WSAEnumProtocols function and examine the           dwServiceFlag1 member in each returned           WSAPROTOCOL_INFO structure. If the           XP1_IFS_HANDLES (0x20000) bit is cleared then the specified LSP is not an IFS LSP.           Vendors that have non-IFS LSPs are encouraged to migrate to the           Windows Filtering Platform           (WFP).   FILE_SKIP_SET_EVENT_ON_HANDLE 0x2   The I/O Manager does not set the event for the file object if a request returns with a success code, or the           error returned is ERROR_PENDING and the function that is called is not a           synchronous function. If an explicit event is provided for the request, it is still signaled."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Sets the file information for the specified file.",
    "library": "Kernel32.lib;  FileExtd.lib on Windows Server 2003 and Windows XP",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h);  FileExtd.h on Windows Server 2003 and Windows XP",
    "return_value": "Returns nonzero if successful or zero otherwise. To get extended error information, call         GetLastError. ",
    "remarks": "Certain file information classes behave slightly differently on different operating system releases. These      classes are supported by the underlying drivers, and any information they return is subject to change between      operating system releases. The following table shows the valid file information classes and their corresponding data structure types for       use with this function.  You must specify appropriate access flags when creating the file handle for use with      SetFileInformationByHandle. For example, if      the application is using FILE_DISPOSITION_INFO with      the DeleteFile member set to TRUE, the file would need      DELETE access requested in the call to the      CreateFile function. To see an example of this, see the      Example Code section. For more information about file permissions, see      File Security and Access Rights. If there is a transaction bound to the handle, then the changes made will be transacted for the information      classes FileBasicInfo, FileRenameInfo,      FileAllocationInfo, FileEndOfFileInfo, and      FileDispositionInfo. If FileDispositionInfo is specified,      only the delete operation is transacted if a DeleteFile      operation was requested. In this case, if the transaction is not committed before the handle is closed, the      deletion will not occur. For more information about TxF, see      Transactional NTFS (TxF). In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability. The following C++ example shows how to create a file and mark it for deletion when the handle is closed. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileInformationByHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file for which to change information. This handle must be opened with the appropriate permissions for the requested change. For more information,         see the Remarks and Example Code sections. This handle should not be a pipe handle."
      },
      {
        "in_out": "_In_",
        "type": "FILE_INFO_BY_HANDLE_CLASS",
        "name": "FileInformationClass",
        "description": "A FILE_INFO_BY_HANDLE_CLASS enumeration         value that specifies the type of information to be changed. For a table of valid values, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpFileInformation",
        "description": "A pointer to the buffer that contains the information to change  for the specified file information class.         The structure that this parameter points to corresponds to the class that is specified by         FileInformationClass. For a table of valid structure types, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferSize",
        "description": "The size of lpFileInformation, in bytes."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "Associates a virtual address range with the specified file handle. This indicates that the      kernel should optimize any further asynchronous I/O requests with overlapped structures inside this range. The      overlapped range is locked in memory, and then unlocked when the file is closed. After a range is associated with      a file handle, it cannot be disassociated.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Returns nonzero if successful or zero otherwise. To get extended error information, call         GetLastError. ",
    "remarks": "SetFileIoOverlappedRange can be used to       improve performance in an application that issues a high number of asynchronous unbuffered I/O and uses a defined       range of overlapped structures. Because this range of structures is locked in memory, the kernel can avoid       acquiring certain locks when updating the overlapped structures with the results of the I/O request. SetFileIoOverlappedRange requires the       caller to have the SeLockMemoryPrivilege       access privilege. This function has no effect on buffered and synchronous I/O. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileIoOverlappedRange",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle to the file. This file handle must be opened with FILE_READ_ATTRIBUTES access rights."
      },
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "OverlappedRangeStart",
        "description": "The starting address for the range."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The length of the range, in bytes."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Moves the file pointer of the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds and lpDistanceToMoveHigh is         NULL, the return value is the low-order DWORD of the new         file pointer. Note  If the function returns a value other than INVALID_SET_FILE_POINTER, the call           to SetFilePointer has succeeded. You do not need to           call GetLastError. If function succeeds and lpDistanceToMoveHigh is not         NULL, the return value is the low-order DWORD of the new         file pointer and lpDistanceToMoveHigh contains the high order         DWORD of the new file pointer. If the function fails, the return value is INVALID_SET_FILE_POINTER. To get         extended error information, call GetLastError. If a new file pointer is a negative value, the function fails, the file pointer is not moved, and the code         returned by GetLastError is         ERROR_NEGATIVE_SEEK. If lpDistanceToMoveHigh is NULL and the new file position         does not fit in a 32-bit value, the function fails and returns         INVALID_SET_FILE_POINTER. ",
    "remarks": "The file pointer that is identified by the value of the hFile parameter is not used      for overlapped read and write operations. The hFile parameter must refer to a file stored on a seeking device; for example, a disk volume. Calling the      SetFilePointer function with a handle to a non-seeking      device such as a pipe or a communications device is not supported, even though the      SetFilePointer function may not return an error. The behavior of the      SetFilePointer function in this case is undefined. To specify the offset for overlapped operations To determine the file type for hFile For information about how to determine the position of a file pointer, see      Positioning a File Pointer. Be careful when you set a file pointer in a multithreaded application. You must synchronize access to shared      resources. For example, an application with threads that share a file handle, update the file pointer, and read      from the file must protect this sequence by using a critical section object or mutex object. For more information,      see Critical Section Objects and      Mutex Objects. If the hFile handle is opened with the      FILE_FLAG_NO_BUFFERING flag set, an application can move the file pointer only to      sector-aligned positions. A sector-aligned position is a position that is a whole number multiple of the volume      sector size. An application can obtain a volume sector size by calling the      GetDiskFreeSpace function. If an application calls SetFilePointer with distance       to move values that result in a position not sector-aligned and a handle that is opened with       FILE_FLAG_NO_BUFFERING, the function fails, and       GetLastError returns        ERROR_INVALID_PARAMETER. It is not an error to set a file pointer to a position beyond the end of the file. The size of the file does      not increase until you call the SetEndOfFile,      WriteFile, or      WriteFileEx function. A write operation increases the size      of the file to the file pointer position plus the size of the buffer written, which results in the intervening      bytes uninitialized. If the return value is INVALID_SET_FILE_POINTER and if      lpDistanceToMoveHigh is non-NULL, an application must call      GetLastError to determine whether or not the function has      succeeded or failed. The following code example shows you that scenario. Although the parameter lpDistanceToMoveHigh is used to manipulate huge files, the      value of the parameter should be set when moving files of any size. If it is set to      NULL, then lDistanceToMove has a maximum value of      2^31\u00e2\u0080\u00932, or 2 gigabytes less 2, because all file pointer values are signed values. Therefore,      if there is even a small chance for the file to increase to that size, it is best to treat the file as a huge file      and work with 64-bit file pointers. With      file compression on the NTFS file      system, and sparse files, it is possible to have files that      are large even if the underlying volume is not very large. If lpDistanceToMoveHigh is not NULL, then      lpDistanceToMoveHigh and lDistanceToMove form a single 64-bit      signed value. The lDistanceToMove parameter is treated as the low-order 32 bits of the      value, and lpDistanceToMoveHigh as the high-order 32 bits, which means that      lpDistanceToMoveHigh is a sign extension of      lDistanceToMove. To move the file pointer from zero  to 2 gigabytes, lpDistanceToMoveHigh must be      set to either NULL or a sign extension of lDistanceToMove. To      move the pointer more than 2 gigabytes, use lpDistanceToMoveHigh and      lDistanceToMove as a single 64-bit quantity. For example, to move in the range from 2      gigabytes to 4 gigabytes set the contents of lpDistanceToMoveHigh to zero, or to      \u00e2\u0080\u00931 for a negative sign extension of lDistanceToMove. To work with 64-bit file pointers, you can declare a LONG, treat it as the upper      half of the 64-bit file pointer, and pass its address in lpDistanceToMoveHigh. This      means that you have to treat two different variables as a logical unit, which can cause an error. It is best to      use the LARGE_INTEGER structure to create a 64-bit value and pass the two 32-bit      values by using the appropriate elements of the union. Also, it is best to use a function to hide the interface to      SetFilePointer. The following code example shows you that      scenario. You can use SetFilePointer to determine the length of      a file. To do this, use FILE_END for dwMoveMethod and seek to      location zero. The file offset returned is the length of the file. However, this practice can have unintended      side effects, for example, failure to save the current file pointer so that the program can return to that      location. It is best to use GetFileSize instead. You can also use the SetFilePointer function to query      the current file pointer position. To do this, specify a move method of FILE_CURRENT and      a distance of zero. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For a code example of appending files, see       Appending One File to Another File. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "SetFilePointer",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file.        The file handle must be created with the GENERIC_READ or         GENERIC_WRITE access right. For more information, see         File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "lDistanceToMove",
        "description": "The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.        If lpDistanceToMoveHigh is not NULL,         lpDistanceToMoveHigh and lDistanceToMove form a single         64-bit signed value that specifies the distance to move. If lpDistanceToMoveHigh is NULL,         lDistanceToMove is a 32-bit signed value. A positive value for         lDistanceToMove moves the file pointer forward in the file, and a negative value         moves the file pointer back."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PLONG",
        "name": "lpDistanceToMoveHigh",
        "description": "A pointer to the high order 32-bits of the signed 64-bit distance to move.        If you do not need the high order 32-bits, this pointer must be set to NULL. When  not NULL, this parameter also receives the high order         DWORD of the new value of the file pointer. For more information, see the Remarks         section in this topic."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMoveMethod",
        "description": "The starting point for the file pointer move.        This parameter can be one of the following values.  ValueMeaning  FILE_BEGIN 0   The starting point is zero or the beginning of the file.   FILE_CURRENT 1   The starting point is the current value of the file pointer.   FILE_END 2   The starting point is the current end-of-file position."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Moves the file pointer of the specified file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The file pointer returned by this function is not used for overlapped read and write operations. To specify      the offset for overlapped operations, use the Offset and      OffsetHigh members of the      OVERLAPPED structure. You cannot use the SetFilePointerEx function with a handle to a nonseeking      device such as a pipe or a communications device. To determine the file type for hFile,      use the GetFileType function. Use caution when setting the file pointer in a multithreaded application. You must synchronize access to      shared resources. For example, an application whose threads share a file handle, update the file pointer, and read      from the file must protect this sequence by using a critical section object or a mutex object. For more      information about these objects, see      Critical Section Objects      and Mutex Objects. If the hFile handle was opened with the      FILE_FLAG_NO_BUFFERING flag set, an application can move the file pointer only to      sector-aligned positions. A sector-aligned position is a position that is a whole number multiple of the volume's      sector size. An application can obtain a volume's sector size by calling the      GetDiskFreeSpace function. If an application      calls SetFilePointerEx with distance-to-move values that result in a position      that is not sector-aligned and a handle that was opened with FILE_FLAG_NO_BUFFERING, the      function fails, and GetLastError returns      ERROR_INVALID_PARAMETER. For additional information, see      File Buffering. Note that it is not an error to set the file pointer to a position beyond the end of the file. The size of the      file does not increase until you call the SetEndOfFile,      WriteFile, or      WriteFileEx function. A write operation increases the size      of the file to the file pointer position plus the size of the buffer written, leaving the intervening bytes      uninitialized. You can use SetFilePointerEx to determine the length of a file. To do this,      use FILE_END for dwMoveMethod and seek to location zero. The      file offset returned is the length of the file. However, this practice can have unintended side effects, such as      failure to save the current file pointer so that the program can return to that location. It is simpler and safer      to use the GetFileSizeEx function instead. You can also use SetFilePointerEx to query the current file pointer position.      To do this, specify a move method of FILE_CURRENT and a distance of zero. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFilePointerEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The file handle must have been created with the        GENERIC_READ or GENERIC_WRITE access right. For more        information, see        File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "liDistanceToMove",
        "description": "The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a        negative value moves the file pointer backward."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PLARGE_INTEGER",
        "name": "lpNewFilePointer",
        "description": "A pointer to a variable to receive the new file pointer. If this parameter is        NULL, the new file pointer is not returned."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMoveMethod",
        "description": "The starting point for the file pointer move. This parameter can be one of the following values.  ValueMeaning  FILE_BEGIN 0   The starting point is zero or the beginning of the file. If this flag is specified, then the          liDistanceToMove parameter is interpreted as an unsigned value.   FILE_CURRENT 1   The start point is the current value of the file pointer.   FILE_END 2   The starting point is the current end-of-file position."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the short name for the specified file. The file must be on an NTFS file system      volume.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call        GetLastError.        GetLastError may return one of the following error         codes that are specific to this function.  ",
    "remarks": "The caller of this function must have the SE_RESTORE_NAME privilege. For more      information, see Running with Special Privileges. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileShortName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The file must be opened with either the GENERIC_ALL access         right or GENERIC_WRITE|DELETE, and with the         FILE_FLAG_BACKUP_SEMANTICS file attribute."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpShortName",
        "description": "A pointer to a string that specifies the short name for the file.  Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the hFile parameter. If  a short file name does not exist, the function will do nothing and return success.  Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This behavior is not supported. The parameter must contain a valid string of one or more characters."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets the valid data length of the specified file. This function is useful in very limited scenarios. For more information, see the Remarks section.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is 0. To get extended error information, call  GetLastError. ",
    "remarks": "The SetFileValidData function sets the logical end of a file. To set the size of a file, use the SetEndOfFile function. The physical file size is also referred to as the end of the file. Each file stream has the following properties: Typically, the  SetFileValidData function is used by system-level applications on their own private data.   Not all file systems  use valid data length.  Some file systems can track multiple valid data ranges. In general, most applications will never need to call this function. The SetFileValidData function allows you to avoid filling data with zeros when writing nonsequentially to a file. The function makes the data in the file valid without writing to the file. As a result, although some performance gain may be realized, existing data on disk from previously existing files can inadvertently become available to unintended readers. The following paragraphs provide a more detailed description of this potential security and privacy issue. A caller must have the SE_MANAGE_VOLUME_NAME privilege enabled when opening a file initially. Applications should call SetFileValidData only on files that restrict access to those entities that  have SE_MANAGE_VOLUME_NAME access. The application must ensure that the unwritten ranges of the file are never exposed, or security issues can result as follows. If SetFileValidData is used on a file, the potential performance gain is obtained by not filling the allocated clusters for the file with zeros. Therefore, reading from the file will return whatever the allocated clusters contain, potentially content from other users.  This is not necessarily a security issue at this point, because the caller needs to have SE_MANAGE_VOLUME_NAME privilege for SetFileValidData to succeed,  and all  data on disk can be read by such users.  However, this caller can inadvertently expose this data to other users that cannot acquire the SE_MANAGE_VOLUME_PRIVILEGE privilege if the following holds: If the caller of SetFileValidData opened the file with adequately restrictive access control, the previous conditions would not apply. However, for partially written files extended with SetFileValidData (that is, writing was not completed up to the ValidDataLength supplied in the call) there exists yet another potential privacy or security vulnerability. An administrator could copy the file to a target that is not properly controlled with restrictive ACL permissions, thus inadvertently exposing the extended area's data to unauthorized reading. It is for these reasons that SetFileValidData is not recommended for general purpose use, in addition to performance considerations, as discussed below. For more information about security and access privileges, see  Running with Special Privileges and File Security and Access Rights. You can use the SetFileValidData function to  create large files in very specific circumstances so that the performance of subsequent file I/O can be better than other methods. Specifically, if the extended portion of the file is large and will be written to randomly, such as in a database type of application, the time it takes to extend and write to the file will be faster than using SetEndOfFile and writing randomly. In most other situations, there is usually no performance gain to using SetFileValidData, and sometimes there can be a performance penalty. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetFileValidData",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The file must have been opened with the GENERIC_WRITE access right, and the SE_MANAGE_VOLUME_NAME privilege enabled. For more information, see  File Security and Access Rights.      Note  The file cannot be a network file, or be compressed, sparse, or transacted."
      },
      {
        "in_out": "_In_",
        "type": "LONGLONG",
        "name": "ValidDataLength",
        "description": "The new valid data length.  This parameter must be a positive value that is greater than the current valid data length, but less than the current file size."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the per-process mode that the SearchPath      function uses when locating files.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the operation completes successfully, the         SetSearchPathMode function returns a nonzero         value. If the operation fails, the SetSearchPathMode         function returns zero. To get extended error information, call the         GetLastError function. If the SetSearchPathMode function fails because a         parameter value is not valid, the value returned by the         GetLastError function will be         ERROR_INVALID_PARAMETER. If the SetSearchPathMode function fails because         the combination of current state and parameter value is not valid, the value returned by the         GetLastError function will be         ERROR_ACCESS_DENIED. For more information, see the Remarks section. ",
    "remarks": "If the SetSearchPathMode function has not been      successfully called for the current process, the search mode used by the      SearchPath function is obtained from the system registry. For      more information, see SearchPath. After the SetSearchPathMode function has been      successfully called for the current process, the setting in the system registry is ignored in favor of the mode      most recently set successfully. If the SetSearchPathMode function has been       successfully called for the current process with Flags set to       (BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT),       safe mode is set permanently for the calling process. Any subsequent calls to the       SetSearchPathMode function from within that process       that attempt to change the search mode will fail with ERROR_ACCESS_DENIED from the       GetLastError function. It is not possible to permanently disable safe search mode. This function does not modify the system registry. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "SetSearchPathMode",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "The search mode to use.  ValueMeaning  BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE 0x00000001   Enable safe process search mode for the process.   BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE 0x00010000   Disable safe process search mode for the process.   BASE_SEARCH_PATH_PERMANENT 0x00008000   Optional flag to use in combination with           BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE to make this mode permanent for this           process. This is done by bitwise OR operation: (BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT) This flag cannot be combined with the BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE          flag."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Sets the user's current key to the specified certificate.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winefs.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  SMB 3.0 does not support EFS on shares with continuous availability capability. ",
    "return_type": "DWORD",
    "category": "Files and I/O (Local file system)",
    "name": "SetUserFileEncryptionKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PENCRYPTION_CERTIFICATE",
        "name": "pEncryptionCertificate",
        "description": "A pointer to a certificate that will be the user's key. This parameter is a pointer to an  ENCRYPTION_CERTIFICATE structure."
      }
    ],
    "min_client": "Windows XP Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Unlocks a region in an open file. Unlocking a region enables other processes to access the region.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "This function always operates synchronously, but may not queue a completion entry when a completion port is associated with the file handle. Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must correspond exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and then unlocked using a single region that spans both locked regions. If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "UnlockFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file that contains a region locked with  LockFile. The file handle must have been created with either the GENERIC_READ or GENERIC_WRITE access right. For more information, see  File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetLow",
        "description": "The low-order word of the starting byte offset in the file where the locked region begins."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFileOffsetHigh",
        "description": "The high-order word of the starting byte offset in the file where the locked region begins."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToUnlockLow",
        "description": "The low-order word of the length of the byte range to be unlocked."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToUnlockHigh",
        "description": "The high-order word of the length of the byte range to be unlocked."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Unlocks a region in the specified file. This function can operate either synchronously or      asynchronously.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero or NULL. To get extended error         information, call GetLastError. ",
    "remarks": "Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must      correspond exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and      then unlocked using a single region that spans both locked regions. Locks are released before the CloseHandle function is      finished processing. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "UnlockFileEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The handle must have been created with either the        GENERIC_READ or GENERIC_WRITE access right. For more        information, see        File Security and Access Rights."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "Reserved parameter; must be zero."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToUnlockLow",
        "description": "The low-order part of the length of the byte range to unlock."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToUnlockHigh",
        "description": "The high-order part of the length of the byte range to unlock."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED structure that the        function uses with the unlocking request. This structure contains the file offset of the beginning of the unlock        range. You must initialize the hEvent member to a valid handle or zero. For more        information, see        Synchronous and Asynchronous I/O."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates all the data sources from a specified provider for a specified volume.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofEnumEntries",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "The volume name hosting the files for which the backing data sources are requested."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Provider",
        "description": "Indicates which provider's data sources are being requested.  Supported providers for this operation are:  \t  \t  WOF_PROVIDER_WIM Indicates that the function should return the WIM files which are providing data for placeholder files on the specified volume."
      },
      {
        "in_out": "_In_",
        "type": "WofEnumEntryProc",
        "name": "EnumProc",
        "description": "The callback function for each data source. The enumeration will stop          if EnumProc returns FALSE."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "UserData",
        "description": "User defined data passed to EnumProc."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Callback function that gets called for each data source in response to a call to WofEnumEntries.",
    "library": "",
    "min_server": "",
    "header": "",
    "return_value": "A boolean value that indicates whether the enumeration was successful. The enumeration will stop if this callback function returns FALSE.   ",
    "remarks": "",
    "return_type": "BOOL CALLBACK",
    "category": "Files and I/O (Local file system)",
    "name": "WofEnumEntryProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const PVOID",
        "name": "EntryInfo",
        "description": "The structure that contains specific provider info. The Type of EntryInfo is provider-specific.  For WOF_PROVIDER_WIM, it will be PWIM_ENTRY_INFO."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "UserData",
        "description": "Optional user defined data specified in the call to WofEnumEntries."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Callback function that gets called for each file backed by an external data source, such as a WIM file.",
    "library": "",
    "min_server": "",
    "header": "",
    "return_value": "A boolean value that indicates whether the enumeration was successful. The enumeration will stop if this callback function returns FALSE.   ",
    "remarks": "",
    "return_type": "Typedef BOOL CALLBACK",
    "category": "Files and I/O (Local file system)",
    "name": "WofEnumFilesProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "FilePath",
        "description": "Specifies the path to the file which is backed by an external data source."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ExternalFileInfo",
        "description": "Points to a buffer containing information about the data source backing the file.  The type of this buffer depends on the provider; data structures for each provider are:  WOF_PROVIDER_WIMWIM_EXTERNAL_FILE_INFO WOF_PROVIDER_FILEWOF_FILE_COMPRESSION_INFO"
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "UserData",
        "description": "Optional user defined data."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Enumerates all of the files which are compressed with a specified compression algorithm on a specified volume.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofFileEnumFiles",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "A full path to the volume containing the files to enumerate."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Algorithm",
        "description": "The compression algorithm to enumerate.  For a list of valid compression algorithms, see WOF_FILE_COMPRESSION_INFO_V1.  If this value is MAX_ULONG, files compressed with any supported compression algorithm will be returned."
      },
      {
        "in_out": "_In_",
        "type": "WofEnumFilesProc",
        "name": "EnumProc",
        "description": "The callback function for each data source. The enumeration will stop if EnumProc returns FALSE."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "UserData",
        "description": "User defined data passed to EnumProc."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Used to query the version of the driver used to support a particular provider.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "This function returns an HRESULT indicating success or the reason for failure. If no driver is attached on the specified volume for the specified provider, the function will fail with HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION). ",
    "remarks": "On successful completion, the WofVersion value is updated to reflect the version of the WOF driver. This value includes the major and minor version numbers of the operating system in the high-order word, and the build number of the operating system in the low-order word. The major version can be extracted with HIBYTE(HIWORD(WofVersion)); the minor version can be extracted with LOBYTE(HIWORD(WofVersion)); the build number can be extracted with LOWORD(WofVersion).   QuickInfo ",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofGetDriverVersion",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileOrVolumeHandle",
        "description": "A handle to a file or volume opened with CreateFile or a similar API."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Provider",
        "description": "Indicates which provider the version query is intended for. Multiple versions of Wof may exist on the same volume at the same time for different providers."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "WofVersion",
        "description": "Pointer to a ULONG which will contain the version upon successful completion of this function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "Used to determine if a file is being backed by a physical file or is backed by a system data provider, and optionally indicates which provider or additional data about the file.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "This function returns an HRESULT indicating success or the reason for failure. If the buffer specified in ExternalFileInfo is not of the correct size, the function will return S_OK and indicate the required buffer size in BufferLength. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofIsExternalFile",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "FilePath",
        "description": "Specifies the path to the file for which the backing state is desired."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PBOOL",
        "name": "IsExternalFile",
        "description": "Optionally points to a BOOL value. On successful return, this value will be TRUE if the object is externally backed, FALSE if it is a physical file."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "Provider",
        "description": "Optionally points to a ULONG value. On successful return, this value will be set to the provider that externally backs this object. Currently defined providers are:  \t  \t\t  WOF_PROVIDER_WIMIndicates that the data for the file resides in a separate WIM file.  On access, data is transparently extracted, decompressed and provided to applications.  If the file contents are modified, data is transparently decompressed and the file is restored to a regular file.  WOF_PROVIDER_FILEIndicates that the data for the file should be compressed and stored with the file itself. On access, data is transparently decompressed and provided to applications. If the file contents are modified, data is transparently decompressed and the file is restored to a regular file. This provider requires Windows 10."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "ExternalFileInfo",
        "description": "Optionally points to a caller allocated buffer. On successful return, this buffer will contain additional information about the state of the file. If this value is provided, BufferLength must also be specified. Data structures for each defined provider are: \t  \t  WOF_PROVIDER_WIM WIM_EXTERNAL_FILE_INFO  WOF_PROVIDER_FILE WOF_FILE_COMPRESSION_INFO"
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PULONG",
        "name": "BufferLength",
        "description": "Optionally points to a value that contains the length of the buffer specified in ExternalFileInfo. On return, this value will be set to the size of the buffer consumed, or the size of the buffer required. If the buffer is of insufficient length, this function will succeed indicating the required size and will not populate the buffer in ExternalFileInfo. This length should correspond to one of the structures defined above:  \t  \t  WOF_PROVIDER_WIMsizeof(WIM_EXTERNAL_FILE_INFO) WOF_PROVIDER_FILEsizeof(WOF_FILE_COMPRESSION_INFO)"
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Used to change a file from being backed by a physical file to one backed by a system data provider.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "This function returns an HRESULT indicating success or the reason for failure. ",
    "remarks": "When using WOF_PROVIDER_FILE, the operation may fail with ERROR_COMPRESSION_NOT_BENEFICIAL. This indicates that an attempt was made to compress the data, but no disk space was saved, so the file was not compressed. For most applications, this can be treated as a success condition. ",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofSetFileDataLocation",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle to a file opened with CreateFile or a similar API."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Provider",
        "description": "Indicates which provider is backing this file. Currently defined providers are:  \t  \t  WOF_PROVIDER_WIMIndicates that the data for the file should be obtained from a WIM file.  On access, data is transparently extracted from the WIM file and provided to applications.  If the file contents are modified, data is transparently decompressed and the file is restored to the same physical form it had if this API were not used. WOF_PROVIDER_FILEIndicates that the data for the file should be compressed and stored with the file itself. On access, data is transparently decompressed and provided to applications. If the file contents are modified, data is transparently decompressed and the file is restored to the same physical form it had if this API were not used. This provider requires Windows 10."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ExternalFileInfo",
        "description": "Provides data specific to the specified provider. Data structures for each defined provider are:  \t    WOF_PROVIDER_WIM WIM_EXTERNAL_FILE_INFO  WOF_PROVIDER_FILE WOF_FILE_COMPRESSION_INFO"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length of provider specific data, in bytes. This should correspond to the structures defined above:   WOF_PROVIDER_WIMsizeof(WIM_EXTERNAL_FILE_INFO) WOF_PROVIDER_FILEsizeof(WOF_FILE_COMPRESSION_INFO)"
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Indicates whether compression should be used on a particular volume, and if so, which compression algorithm should be used.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If binaries on this volume should be compressed, the return value is TRUE; otherwise it is FALSE. This function will return FALSE if the system does not support compression on the specified volume. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "WofShouldCompressBinaries",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "Volume",
        "description": "Specifies the path to the volume whose compression state is desired."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Algorithm",
        "description": "Points to a ULONG value. If the function returns TRUE, indicating compression is desired, this value will contain the algorithm that should be used for this volume."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "Adds a single WIM data source to a volume such that files can be created on the volume which are stored within the WIM.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofWimAddEntry",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "The path to the volume upon which files residing in the WIM should be created."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "WimPath",
        "description": "The path to the WIM file which should be used to provide data to files."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "WimType",
        "description": "The type of WIM. Can be WIM_BOOT_OS_WIM or WIM_BOOT_NOT_OS_WIM."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "WimIndex",
        "description": "Index of the image in the WIM which is applied."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "DataSourceId",
        "description": "On successful return, contains the data source used to identify the entry.  This data source can be used to create new files with WofSetFileDataLocation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "Enumerates all of the files which are being backed by a specified WIM data source on a specified volume.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofWimEnumFiles",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "The path to the volume which hosts WIM-backed files."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "DataSourceId",
        "description": "Identifier used to identify the WIM entry."
      },
      {
        "in_out": "_In_",
        "type": "WofEnumFilesProc",
        "name": "EnumProc",
        "description": "The callback function for file provided by the WIM entry."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "UserData",
        "description": "Optional user defined data passed to EnumProc."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Removes a single WIM data source from backing files on a volume.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "If the volume currently has files whose data is derived from the WIM file, the data for those files will become permanently inaccessible. It is good practice to remove any files referring to the WIM file prior to removing the data source from a volume.  Once all data sources for a WIM file have been removed, the WIM file itself can be renamed or deleted. ",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofWimRemoveEntry",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "The volume name which contained files whose data was provided by the WIM."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "DataSourceId",
        "description": "Identifes the WIM entry."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Temporarily removes a WIM data source from backing files on a volume until the volume is remounted or the data source is updated with WofWimUpdateEntry.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "If the volume currently has files whose data is derived from the WIM file, the data for those files will become temporarily inaccessible. This should not be performed on a WIM from which the system is currently operating. ",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofWimSuspendEntry",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "The volume name which contained files whose data was provided by the WIM."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "DataSourceId",
        "description": "Identifies the WIM entry."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "Updates a WIM entry to point to a different WIM file location.",
    "library": "Wofutil.lib",
    "min_server": "",
    "header": "Wofapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Files and I/O (Local file system)",
    "name": "WofWimUpdateEntry",
    "is_callback": 0,
    "dll": "Wofutil.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "VolumeName",
        "description": "The volume name which contains files whose data is provided by the WIM."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "DataSourceId",
        "description": "Identifies the WIM entry."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "NewWimPath",
        "description": "The new location of the WIM file."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Disables file system redirection for the calling thread. File system redirection is enabled by      default.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "This function is useful for 32-bit applications that want to gain access to the native system32 directory. By      default, WOW64 file system redirection is enabled. The      Wow64DisableWow64FsRedirection/Wow64RevertWow64FsRedirection      function pairing is a replacement for the functionality of the      Wow64EnableWow64FsRedirection      function. To restore file system redirection, call the      Wow64RevertWow64FsRedirection      function. Every successful call to the      Wow64DisableWow64FsRedirection function      must have a matching call to the      Wow64RevertWow64FsRedirection      function. This will ensure redirection is re-enabled and frees associated system resources. Disabling file system redirection affects only operations made by the current thread. Some functions, such as      CreateProcessAsUser, do their work on another      thread, which is not affected by the state of file system redirection in the calling thread. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  The following example uses       Wow64DisableWow64FsRedirection to       disable file system redirection so that a 32-bit application that is running under WOW64 can open the 64-bit       version of Notepad.exe in %SystemRoot%\\System32 instead of being redirected       to the 32-bit version in %SystemRoot%\\SysWOW64. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "Wow64DisableWow64FsRedirection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "OldValue",
        "description": "The WOW64 file system redirection value. The system uses this parameter to store information necessary to         revert (re-enable) file system redirection. Note  This value is for system use only. To avoid unpredictable behavior, do not modify this value in any         way."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Enables or disables file system redirection for the calling thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "Boolean value indicating whether the function succeeded. If TRUE, the function        succeeded; if FALSE, the function failed. ",
    "remarks": "This function is useful for 32-bit applications that want to gain access to the native system32 directory. By      default, WOW64 file system redirection is enabled. File redirection is enabled or disabled only for the thread calling this function. This affects only      operations made by the current thread. Some functions, such as      CreateProcessAsUser, do their work on another      thread, which is not affected by the state of file system redirection in the calling thread. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  ",
    "return_type": "BOOLEAN",
    "category": "Files and I/O (Local file system)",
    "name": "Wow64EnableWow64FsRedirection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wow64FsEnableRedirection",
        "description": "Indicates the type of request for WOW64 system folder redirection. If        TRUE, requests redirection be enabled; if FALSE, requests        redirection be disabled."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Restores file system redirection for the calling thread.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a nonzero value. If the function fails, the return value is FALSE (zero). To get extended error         information, call GetLastError. ",
    "remarks": "The Wow64DisableWow64FsRedirection/Wow64RevertWow64FsRedirection function pair is a replacement for the functionality of the Wow64EnableWow64FsRedirection function. To disable file system redirection, call the            Wow64DisableWow64FsRedirection function. Every call to the Wow64DisableWow64FsRedirection function must have a matching call to the      Wow64RevertWow64FsRedirection      function. This will ensure redirection is re-enabled and frees associated system resources. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  For an example, see the       Wow64DisableWow64FsRedirection       function. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "Wow64RevertWow64FsRedirection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "OldValue",
        "description": "The WOW64 file system redirection value. This value is obtained from the        Wow64DisableWow64FsRedirection        function."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Writes data to the specified file or input/output (I/O) device.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero         (FALSE). To get extended error information, call the         GetLastError function. ",
    "remarks": "The WriteFile function returns when one of the following       conditions occur: The WriteFile function may fail with      ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY whenever      there are too many outstanding asynchronous I/O requests. To cancel all pending asynchronous I/O operations, use either: Use the CancelSynchronousIo function to       cancel pending synchronous I/O operations. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. The WriteFile function may fail with      ERROR_NOT_ENOUGH_QUOTA, which means the calling process's buffer could not be      page-locked. For more information, see      SetProcessWorkingSetSize. If part of the file is locked by another process and the write operation overlaps the locked portion,      WriteFile fails. When writing to a file, the last write time is not fully updated until all handles used for writing have been      closed. Therefore, to ensure an accurate last write time, close the file handle immediately after writing to the      file. Accessing the output buffer while a write operation is using the buffer may lead to corruption of the data      written from that buffer. Applications must not write to, reallocate, or free the output buffer that a write      operation is using until the write operation completes. This can be particularly problematic when using an      asynchronous file handle. Additional information regarding synchronous versus asynchronous file handles can be      found later in the Synchronization and File Position      section and      Synchronous and Asynchronous I/O. Note that the time stamps may not be updated correctly for a remote file. To ensure consistent results, use      unbuffered I/O. The system interprets zero bytes to write as specifying a null write operation and      WriteFile does not truncate or extend the file. To truncate or      extend a file, use the SetEndOfFile      function. Characters can be written to the screen buffer using      WriteFile with a handle to console output. The exact behavior      of the function is determined by the console mode. The data is written to the current cursor position. The cursor      position is updated after the write operation. For more information about console handles, see      CreateFile. When writing to a communications device, the behavior of      WriteFile is determined by the current communication time-out      as set and retrieved by using the SetCommTimeouts and      GetCommTimeouts functions. Unpredictable results can      occur if you fail to set the time-out values. For more information about communication time-outs, see      COMMTIMEOUTS. Although a single-sector write is atomic, a multi-sector write is not guaranteed to be atomic unless you are      using a transaction (that is, the handle created is a transacted handle; for example, a handle created using      CreateFileTransacted). Multi-sector      writes that are cached may not always be written to the disk right away; therefore, specify      FILE_FLAG_WRITE_THROUGH in      CreateFile to ensure that an entire multi-sector write is      written to the disk without potential caching delays. If you write directly to a volume that has a mounted file system, you must first obtain exclusive access to      the volume. Otherwise, you risk causing data corruption or system instability, because your application's writes      may conflict with other changes coming from the file system and leave the contents of the volume in an      inconsistent state. To prevent these problems, the following changes have been made in Windows Vista      and later: There are strict requirements for successfully working with files opened with      CreateFile using      FILE_FLAG_NO_BUFFERING. For details see      File Buffering. If hFile was opened with FILE_FLAG_OVERLAPPED, the       following conditions are in effect: In Windows Server 2012, this function is supported by the following technologies.  If hFile is opened with FILE_FLAG_OVERLAPPED, it is an        asynchronous file handle; otherwise it is synchronous. The rules for using the        OVERLAPPED structure are slightly different for each,        as previously noted. Considerations for working with asynchronous file handles: Considerations for working with synchronous file handles: For more information, see CreateFile and        Synchronous and Asynchronous I/O. If an anonymous pipe is being used and the read handle has been closed, when        WriteFile attempts to write using the pipe's corresponding        write handle, the function returns FALSE and        GetLastError returns        ERROR_BROKEN_PIPE. If the pipe buffer is full when an application uses the        WriteFile function to write to a pipe, the write operation        may not finish immediately. The write operation will be completed when a read operation (using the        ReadFile function) makes more system buffer space available        for the pipe. When writing to a non-blocking, byte-mode pipe handle with insufficient buffer space,        WriteFile returns TRUE with        *lpNumberOfBytesWritten < nNumberOfBytesToWrite. For more information about pipes, see Pipes. If there is a transaction bound to the file handle, then the file write is transacted. For more information,        see About Transactional NTFS. For some examples, see       Creating and Using a Temporary File       and       Opening a File for Reading or Writing. The following C++ example shows how to align sectors for unbuffered file writes. The       Size variable is the size of the original data block you are interested in writing to       the file. For additional rules regarding unbuffered file I/O, see       File Buffering. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "WriteFile",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer,         tape drive, socket, communications resource, mailslot, or  pipe). The hFile parameter must have been created with the write access. For more         information, see         Generic Access Rights and         File Security and Access Rights. For asynchronous write operations, hFile can be any handle opened with the         CreateFile function using the         FILE_FLAG_OVERLAPPED flag or a socket handle returned by the         socket or         accept function."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpBuffer",
        "description": "A pointer to the buffer containing the data to be written to the file or device. This buffer must remain valid for the duration of the write operation. The caller must not use this buffer          until the write operation is completed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToWrite",
        "description": "The number of bytes to be written to the file or device. A value of zero specifies a null write operation. The behavior of a null write operation depends on the          underlying file system or communications technology. Windows Server 2003 and Windows XP:  Pipe write operations across a network are limited in size per write. The amount varies per platform.           For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more           information regarding pipes, see the Remarks section."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesWritten",
        "description": "A pointer to the variable that receives the number of bytes written when using a synchronous          hFile parameter. WriteFile sets          this value to zero before doing any work or error checking. Use NULL for this          parameter if this is an asynchronous operation to avoid potentially erroneous results. This parameter can be NULL only when the lpOverlapped          parameter is not NULL. For more information, see the Remarks section."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED structure is         required if the hFile parameter was opened with         FILE_FLAG_OVERLAPPED, otherwise this parameter can be         NULL. For an hFile that supports byte offsets, if you use this parameter you must specify         a byte offset at which to start writing to the file or device. This offset is specified by setting the         Offset and OffsetHigh members of the         OVERLAPPED structure. For an         hFile that does not support byte offsets, Offset and         OffsetHigh are ignored. To write to the end of file, specify both the Offset and         OffsetHigh members of the         OVERLAPPED structure as 0xFFFFFFFF. This is         functionally equivalent to previously calling the         CreateFile function to open         hFile using FILE_APPEND_DATA access. For more information about different combinations of lpOverlapped and         FILE_FLAG_OVERLAPPED, see the Remarks section and the         Synchronization and File Position section."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves data      from an array of buffers and writes the data to a file.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FileAPI.h (include Windows.h);  WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call the         GetLastError function. If the function returns before the write operation is complete, the function returns zero (0), and         the GetLastError function returns         ERROR_IO_PENDING. ",
    "remarks": "This function is not supported for 32-bit applications by WOW64 on the Itanium-based systems. The FILE_SEGMENT_ELEMENT union is defined as follows: Assigning a pointer to the Buffer member will sign-extend the value if the code is       compiled as 32-bits; this can break large-address aware applications running on systems configured with       4-Gigabyte Tuning or running under WOW64 on 64-bit       Windows. Therefore, use the PtrToPtr64 macro when assigning pointers to       Buffer. If part of the file specified by hFile is locked by another process, and the write      operation overlaps the locked portion, the      WriteFileGather function fails. In Windows 8 and Windows Server 2012, this function is supported by the following technologies.  If there is a transaction bound to the file handle, then the operation is transacted. ",
    "return_type": "BOOL",
    "category": "Files and I/O (Local file system)",
    "name": "WriteFileGather",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the file. The file handle must be created with the GENERIC_WRITE        access right, and the FILE_FLAG_OVERLAPPED and        FILE_FLAG_NO_BUFFERING flags. For more information, see        File Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "FILE_SEGMENT_ELEMENT",
        "name": "aSegmentArray[]",
        "description": "A pointer to an array of FILE_SEGMENT_ELEMENT         buffers that contain the data. For a description of this union, see Remarks. Each element contains the address of one page of data.         Note  To determine the size of a system page, use the          GetSystemInfo function.          The array must contain enough elements to store nNumberOfBytesToWrite bytes of data,         and one element for the terminating NULL. For example, if there are 40 KB to be read         and the page size is 4 KB, the array must have 11 elements that includes 10 elements for the data and one         element for the NULL. Each buffer must be at least the size of a system memory page and must be aligned on a system memory page         size boundary. The system writes one system memory page of data from each buffer. The function gathers the data from the buffers in a sequential order. For example, it writes data to the file         from the first buffer, then the second buffer, and so on until there is no more data. Due to the asynchronous operation of this function, precautions must be taken to ensure that this parameter         always references valid memory for the lifetime of the asynchronous writes. For instance, a common programming         error is to use local stack storage and then allow execution to run out of scope."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nNumberOfBytesToWrite",
        "description": "The total number of bytes to be written. Each element of aSegmentArray contains a         one-page chunk of this total. Because the file must be opened with         FILE_FLAG_NO_BUFFERING, the number of bytes must be a multiple of the sector size of         the file system where the file is located. If nNumberOfBytesToWrite is zero (0), the function performs a null write operation.         The behavior of a null write operation depends on the underlying file system. If         nNumberOfBytesToWrite is not zero (0) and the offset and length of the write place         data beyond the current end of the file,         the WriteFileGather function extends the file."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPDWORD",
        "name": "lpReserved",
        "description": "This parameter is reserved for future use and must be NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED data         structure. The WriteFileGather function requires a valid         OVERLAPPED structure. The         lpOverlapped parameter cannot be NULL. The WriteFileGather function starts writing data to         the file at a position that is specified by the Offset and         OffsetHigh members of the         OVERLAPPED structure. The WriteFileGather function may return before the         write operation is complete. In that scenario, the         WriteFileGather function returns the value zero (0),         and the GetLastError function returns the         value ERROR_IO_PENDING. This asynchronous operation of the         WriteFileGather function lets the calling process         continue while the write operation completes. You can call the         GetOverlappedResult,         HasOverlappedIoCompleted, or         GetQueuedCompletionStatus function to         obtain information about the completion of the write operation. For more information, see         Synchronous and Asynchronous I/O."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]