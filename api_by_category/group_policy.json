[
  {
    "n_arguments": 1,
    "description": "The     BrowseForGPO function creates a GPO browser dialog box that allows the user to open or create a GPO.",
    "library": "Gpedit.lib",
    "min_server": "Windows Server 2008",
    "header": "Gpedit.h",
    "return_value": "If the function succeeds, the return value is S_OK. If the user cancels or closes the dialog box, the return value is HRESULT_FROM_WIN32(ERROR_CANCELLED). Otherwise, the function returns one of the COM error codes defined in the header file WinError.h. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "BrowseForGPO",
    "is_callback": 0,
    "dll": "Gpedit.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPGPOBROWSEINFO",
        "name": "lpBrowseInfo",
        "description": "A pointer to a  GPOBROWSEINFO structure that contains information used to initialize the dialog box. When  the BrowseForGPO function returns, this structure contains information about the user's actions."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 3,
    "description": "The CreateGPOLink function creates a link between      the specified GPO and the specified site, domain, or organizational unit.",
    "library": "GPEdit.lib",
    "min_server": "Windows Server 2008",
    "header": "GPEdit.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns         one of the COM error codes defined in the header file WinError.h. Be aware that you should test explicitly for         the return value S_OK. Do not use the SUCCEEDED or         FAILED macro on the returned HRESULT to determine success or failure of the         function. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "CreateGPOLink",
    "is_callback": 0,
    "dll": "GPEdit.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpGPO",
        "description": "A value that specifies the path to the GPO, in ADSI format        (\"LDAP://cn=user, ou=users, dc=coname, dc=com\").        You cannot specify a server name in this parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpContainer",
        "description": "A value that specifies the Active Directory path to the site, domain, or organizational unit."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fHighPriority",
        "description": "A value that specifies the link priority. If this parameter is TRUE, the system        creates the link as the highest priority. If this parameter is FALSE, the system        creates the link as the lowest priority."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The     DeleteAllGPOLinks function deletes all GPO links for the specified site, domain, or organizational unit.",
    "library": "Gpedit.lib",
    "min_server": "Windows Server 2008",
    "header": "Gpedit.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the header file WinError.h. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "DeleteAllGPOLinks",
    "is_callback": 0,
    "dll": "Gpedit.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpContainer",
        "description": "A value that specifies the path to the site, domain, or organizational unit, in ADSI format (LDAP://cn=user, ou=users, dc=coname, dc=com). You cannot specify a server name in this parameter."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     DeleteGPOLink function deletes the link between the specified GPO and the specified site, domain, or organizational unit.",
    "library": "Gpedit.lib",
    "min_server": "Windows Server 2008",
    "header": "Gpedit.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the  header file WinError.h. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "DeleteGPOLink",
    "is_callback": 0,
    "dll": "Gpedit.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpGPO",
        "description": "A value that specifies the path to the GPO, in ADSI format (LDAP://cn=user, ou=users, dc=coname, dc=com). You cannot specify a server name in this parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpContainer",
        "description": "Specifies the Active Directory path to the site, domain, or organizational unit."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The      EnterCriticalPolicySection function pauses the application of policy to allow applications to safely read policy settings. Applications  call this function if they read multiple policy entries and must ensure that the settings are not changed while they are being read. This mutex protects Group Policy processing for all client-side extensions stored in a Group Policy Object (GPO).",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is a handle to a policy section. If the function fails, the return value is NULL. To get extended error information, call the  GetLastError function. ",
    "remarks": "The maximum amount of time an application can hold a critical section is 10 minutes. After 10 minutes, the system releases the critical section and policy can be applied again. To acquire both the computer and user critical section objects, acquire the user critical section object before acquiring the computer critical section object. This will help prevent a deadlock situation. To close the handle, call the  LeaveCriticalPolicySection function. The policy section handle cannot be used in any other Windows functions. ",
    "return_type": "HANDLE",
    "category": "Group Policy",
    "name": "EnterCriticalPolicySection",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bMachine",
        "description": "A value that specifies whether to stop the application of computer policy or user policy. If this value is TRUE, the system stops applying computer policy. If this value is FALSE, the system stops applying user policy."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     ExportRSoPData function exports a WMI namespace that contains RSoP information to a data file. The function writes the information to a data file that can be imported to a WMI namespace with a call to the  ImportRSoPData function.",
    "library": "Gpedit.lib",
    "min_server": "Windows Server 2008",
    "header": "Gpedit.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the header file WinError.h. ",
    "remarks": "It is recommended that you call the  ExportRSoPData function twice: one time to process the user data and a second time to process the computer data. ",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "ExportRSoPData",
    "is_callback": 0,
    "dll": "Gpedit.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpNameSpace",
        "description": "A pointer to a string that specifies the namespace which contains the RSoP data."
      },
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpFileName",
        "description": "A pointer to a string that specifies the name of the file to receive the RSoP data."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The     FreeGPOList function frees the specified list of GPOs.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "FreeGPOList",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PGROUP_POLICY_OBJECT",
        "name": "pGPOList",
        "description": "A pointer to the list of GPO structures. This list is returned by the  GetGPOList or  GetAppliedGPOList function. For more information, see  GROUP_POLICY_OBJECT."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 5,
    "description": "The     GenerateGroupPolicy callback function is an application-defined callback function that each policy extension must export when generating RSoP data in the planning mode. The Group Policy Data Access Service (GPDAS) calls the function after the service simulates the loading of client-side extensions so that extensions can generate policy data.",
    "library": "",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "The policy extension must register this callback function at the registry key: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\ClientExtensionGuid ",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "GenerateGroupPolicy",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A parameter that represents one or more of the following flags.  GPO_INFO_FLAG_SLOWLINK   The policy is applied across a slow link.  GPO_INFO_FLAG_VERBOSE   Write verbose output to the event log."
      },
      {
        "in_out": "_In_",
        "type": "BOOL*",
        "name": "pbAbort",
        "description": "A value that specifies whether to continue processing GPOs. If this parameter is TRUE, GPO processing stops and the extension must deallocate its resources and return promptly. If this parameter is FALSE, GPO processing continues."
      },
      {
        "in_out": "_In_",
        "type": "WCHAR*",
        "name": "pwszSite",
        "description": "A pointer to the site name of the target computer. This parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "PRSOP_TARGET",
        "name": "pComputerTarget",
        "description": "A pointer to an  RSOP_TARGET structure that contains information about a computer. This parameter can be NULL, but if it is NULL, the pUserTarget parameter is required."
      },
      {
        "in_out": "_In_",
        "type": "PRSOP_TARGET",
        "name": "pUserTarget",
        "description": "A pointer to an  RSOP_TARGET structure that contains information about a user. This parameter can be NULL, but if it is NULL, the pComputerTarget parameter is required."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 5,
    "description": "The     GetAppliedGPOList function retrieves the list of GPOs applied for the specified user or computer.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns a system error code. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "To free the GPO list when you have finished processing it, call the  FreeGPOList function. ",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "GetAppliedGPOList",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A value that specifies the policy type. This parameter can be the following value.  GPO_LIST_FLAG_MACHINE   Retrieves information  about the computer policy.   If this value is not specified, the function retrieves only user policy information."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pMachineName",
        "description": "A pointer to the name of the remote computer. The format of the name is \"\\\\computer_name\". If this parameter is NULL, the local computer name is used."
      },
      {
        "in_out": "_In_",
        "type": "PSID",
        "name": "pSidUser",
        "description": "A value that specifies the SID of the user. If pMachineName is not NULL and dwFlags specifies user policy, then pSidUser cannot be NULL. If pMachineName is NULL and pSidUser is NULL, the user is the currently logged-on user. If pMachineName is NULL and pSidUser is not NULL, the user is represented by pSidUser on the local computer. For more information, see  Security Identifiers."
      },
      {
        "in_out": "_In_",
        "type": "GUID*",
        "name": "pGuidExtension",
        "description": "A value that specifies the GUID of the extension."
      },
      {
        "in_out": "_Out_",
        "type": "PGROUP_POLICY_OBJECT*",
        "name": "ppGPOList",
        "description": "A pointer that receives the list of GPO structures. For more information, see  GROUP_POLICY_OBJECT."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 6,
    "description": "The     GetGPOList function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  GetGPOList function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy. Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer. To obtain the most accurate list of GPOs for a computer when calling GetGPOList, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the lpName parameter. An alternate method of obtaining a list of GPOs would be to call the RsopCreateSession method of the RsopPlanningModeProvider WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario. Call the  FreeGPOList function to free the GPO list when you have finished processing it. Generally, you should call  GetGPOList with a token when retrieving a list of GPOs for a user as shown in the following code example. Typically, to retrieve a list of GPOs for a computer, you can call  GetGPOList with the computer name and domain controller name as demonstrated in the following code snippet. To retrieve the list of GPOs applied for a specific user or computer and extension, call the  GetAppliedGPOList function. ",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "GetGPOList",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "A token for the user or computer, returned from the  LogonUser,  CreateRestrictedToken,  DuplicateToken,  OpenProcessToken, or  OpenThreadToken function. This token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. For more information, see  Access Rights for Access-Token Objects and the following Remarks section. If this parameter is NULL, you must supply values for the lpName and lpHostName parameters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  \"CN=user, OU=users, DC=contoso, DC=com\"). If the hToken parameter is not NULL, this parameter must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpHostName",
        "description": "A DNS domain name or domain controller name. Domain controller name can be retrieved using the  DsGetDcName function, specifying DS_DIRECTORY_SERVICE_REQUIRED in the flags parameter. If the hToken parameter is not NULL, this parameter must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpComputerName",
        "description": "A pointer to the name of the computer used to determine the site location. The format of the name is \"\\\\computer_name\". If this parameter is NULL, the local computer name is used."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A value that specifies additional flags that are used to control information retrieval. If you specify GPO_LIST_FLAG_MACHINE, the function retrieves policy information for the computer. If you do not specify GPO_LIST_FLAG_MACHINE, the function retrieves policy information for the user. If you specify GPO_LIST_FLAG_SITEONLY the function returns only site information for the computer or user."
      },
      {
        "in_out": "_Out_",
        "type": "PGROUP_POLICY_OBJECT*",
        "name": "pGPOList",
        "description": "A pointer that receives the list of GPO structures. For more information, see  GROUP_POLICY_OBJECT."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 3,
    "description": "The     GetLocalManagedApplications function can be run on the target computer to get  a list of managed applications on that computer. The function can also be called in the context of a user to get a list of managed applications for that user. This function only returns applications that can be installed by the Windows Installer.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008",
    "header": "Appmgmt.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "GetLocalManagedApplications",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bUserApps",
        "description": "A value that, if TRUE, the prgLocalApps parameter contains a list of managed applications that applies to the user.  If the value of this parameter is FALSE, the prgLocalApps parameter contains a list of managed applications that applies to the local computer."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "pdwApps",
        "description": "The address of a DWORD that specifies the number of applications in the list returned by prgLocalApps."
      },
      {
        "in_out": "_Out_",
        "type": "PLOCALMANAGEDAPPLICATION*",
        "name": "prgLocalApps",
        "description": "The address of an array that contains the list of managed applications. You must call LocalFree to free this array when its contents are no longer required. This parameter cannot be null. The list is returned as a LOCALMANAGEDAPPLICATION structure."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 5,
    "description": "The     GetManagedApplications function gets a list of applications that are displayed in the Add pane of Add/Remove Programs (ARP) for a specified user context.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008",
    "header": "Appmgmt.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "GetManagedApplications",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GUID*",
        "name": "pCategory",
        "description": "A pointer to a GUID that specifies the  category    of applications to be listed. If pCategory is not null, dwQueryFlags must   contain MANAGED_APPS_FROMCATEGORY. If pCategory is null, dwQueryFlags cannot contain MANAGED_APPS_FROMCATEGORY."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwQueryFlags",
        "description": "This parameter can contain one or more of the following values.  MANAGED_APPS_USERAPPLICATIONS   Lists all applications that apply to the user. The parameter pCategory must be null.  MANAGED_APPS_FROMCATEGORY   Lists only applications in the category specified by pCategory.   The pCategory parameter cannot be null."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoLevel",
        "description": "This parameter must be MANAGED_APPS_INFOLEVEL_DEFAULT."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "pdwApps",
        "description": "The count of applications in the list returned by this function."
      },
      {
        "in_out": "_Out_",
        "type": "PMANAGEDAPPLICATION*",
        "name": "prgManagedApps",
        "description": "This parameter is a pointer to an array of MANAGEDAPPLICATION structures. This array contains the list of applications listed in the Add pane of  Add/Remove Programs (ARP). You must call LocalFree to free the array when they array is no longer required."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     GetManagedApplicationCategories function gets a list of application categories for a domain. The list is the same for all users in the domain.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008",
    "header": "Appmgmt.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "The structure returned by GetManagedApplicationCategories must be freed by calling LocalFree when the list is no longer required. ",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "GetManagedApplicationCategories",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "DWORD",
        "name": "dwReserved",
        "description": "This parameter is reserved. Its value must be 0."
      },
      {
        "in_out": "_Out_",
        "type": "APPCATEGORYINFOLIST*",
        "name": "pAppCategory",
        "description": "A APPCATEGORYINFOLIST structure that contains a list of application categories. This structure must be freed by calling LocalFree  when the list is no longer required."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     ImportRSoPData function imports a data file containing RSoP data to a WMI namespace. The file must be one generated by a call to the  ExportRSoPData function.",
    "library": "Gpedit.lib",
    "min_server": "Windows Server 2008",
    "header": "Gpedit.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "ImportRSoPData",
    "is_callback": 0,
    "dll": "Gpedit.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpNameSpace",
        "description": "Pointer to a string specifying the namespace to contain the RSoP data. The namespace must exist prior to calling  ImportRSoPData."
      },
      {
        "in_out": "_In_",
        "type": "LPOLESTR",
        "name": "lpFileName",
        "description": "Pointer to a string specifying the name of the file that contains the RSoP data."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The InstallApplication function can install applications  that have been deployed to target users that belong to a domain. The security context of the user that is calling InstallApplication must be that of a domain user logged onto a computer in a domain that trusts the target user's domain. Group Policy must be successfully applied when the target user logs on.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008",
    "header": "Appmgmt.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "The InstallApplication function can only install applications that have been deployed by using  Group Policy. A domain administrator can deploy applications to  target users by using  the  user configuration section of Group Policy Objects (GPO). The target user must belong to the target domain and the GPO must apply to this  user in the target  domain. The InstallApplication function installs applications according to standard Group Policy inheritance rules.  If the same application is deployed in multiple GPOs, the function installs the version of the application deployed in the highest precedence GPO.  After an application has been  installed for a user, it is not visible to other users on the computer. This is standard for applications that are deployed through user group policy. The InstallApplication function can  install deployed applications that  use Windows Installer (.msi files) or software installation settings (.zap files) to handle setup and installation. The     InstallApplication function can install applications that use a Windows Installer package for their installation.  In this case,  the  user calling InstallApplication is not required to have administrator privileges. The system can install the application because the  Windows Installer  is a trusted application deployed by a domain administrator. The user that receives the application must have access to the location of the .msi files. Remove applications installed using .msi files by calling the Windows Installer function MsiConfigureProduct to uninstall the application. Then call UninstallApplication  to  inform the system that the application is no longer managed on the client by Group Policy.  UninstallApplication should be called even if the uninstall fails because this enables the system to keep the Resultant Set of Policy (RSoP) accurate. The     InstallApplication function can also install applications that use setup applications based on software installation settings (.zap files). The user that receives the application must have access to the location of the .zap files. A .zap file is a text file similar to an .ini file, which enables Windows to publish an application (for example, Setup.exe) for installation with Add or Remove Programs. To publish applications that do not use the Windows Installer, you must create a .zap file, copy the .zap file to the software distribution point servers, and then use Group Policy\u00e2\u0080\u0093based software deployment to publish the application for users.  If the application is deployed using .zap files, the user installing the application must have privileges on the machine to install the software. You cannot use .zap files for assigned applications. Remove applications using software installation settings (.zap files) by calling the uninstall function or a command  specific for the installation application. For information about using installation applications other than  the Windows Installer see article 231747, \"How to Publish non-MSI Programs with .zap Files,\" in the Microsoft Knowledge Base. ",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "InstallApplication",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PINSTALLDATA*",
        "name": "pInstallInfo",
        "description": "A pointer to a INSTALLDATA structure that specifies the application to install."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The      LeaveCriticalPolicySection function resumes the background application of policy. This function closes the handle to the policy section.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "LeaveCriticalPolicySection",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hSection",
        "description": "Handle to a policy section, which is returned by the  EnterCriticalPolicySection function."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 3,
    "description": "The      ProcessGroupPolicyCompleted function notifies the system that the specified extension has finished applying policy.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "ProcessGroupPolicyCompleted",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFGPEXTENSIONID",
        "name": "extensionId",
        "description": "Specifies the unique GUID that identifies the extension."
      },
      {
        "in_out": "_In_",
        "type": "ASYNCCOMPLETIONHANDLE",
        "name": "pAsyncHandle",
        "description": "Asynchronous completion handle. This handle is passed to the  ProcessGroupPolicy function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwStatus",
        "description": "Specifies the completion status of asynchronous processing."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 4,
    "description": "The      ProcessGroupPolicyCompletedEx function notifies the system that the specified policy extension has finished applying policy. The function also reports the status of Resultant Set of Policy (RSoP) logging.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "ProcessGroupPolicyCompletedEx",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REFGPEXTENSIONID",
        "name": "extensionId",
        "description": "Specifies the unique GUID that identifies the policy extension."
      },
      {
        "in_out": "_In_",
        "type": "ASYNCCOMPLETIONHANDLE",
        "name": "pAsyncHandle",
        "description": "Asynchronous completion handle. This handle is passed to the  ProcessGroupPolicyEx callback function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwStatus",
        "description": "Specifies the completion status of asynchronous processing of policy."
      },
      {
        "in_out": "_In_",
        "type": "HRESULT",
        "name": "RsopStatus",
        "description": "Specifies an HRESULT return code that indicates the status of RSoP logging."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 8,
    "description": "The     ProcessGroupPolicy function is an application-defined callback function used when applying policy. The PFNPROCESSGROUPPOLICY type defines a pointer to this callback function.  ProcessGroupPolicy is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If policy was applied successfully, return ERROR_SUCCESS. If there are no changes to the GPO list, and the extension is to be called again, return ERROR_OVERRIDE_NOCHANGES. Returning ERROR_OVERRIDE_NOCHANGES ensures that the extension is called again, even if the NoGPOListChanges registry value is set. (For more information about this registry value, see Remarks.) Otherwise, return a  system error code. ",
    "remarks": "For more information, see  Implementing a Group Policy Client-side Extension. The system calls this function in the context of the  LocalSystem account, which has extensive privileges on the local computer. To use network resources, you must impersonate the user or computer by using the token provided in the hToken parameter. To register this callback function, create a subkey under the following registry key:  HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\ClientExtensionGuid The subkey should be a GUID, so that it is unique. It should contain the following values.  You should update the status message only if you are applying policy synchronously. This allows you to provide feedback and diagnostics during a lengthy policy application. To use the status message callback function, you must verify that pStatusCallback is not NULL. Then load your message string resource. When you call the status function, you must indicate whether the string is verbose. If the string is verbose, the callback function will verify that the computer is in verbose mode and display the message. For more information, see  StatusMessageCallback. ",
    "return_type": "DWORD CALLBACK",
    "category": "Group Policy",
    "name": "ProcessGroupPolicy",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one or more of the following flags.  GPO_INFO_FLAG_MACHINE   Apply computer policy rather than user policy.  GPO_INFO_FLAG_BACKGROUND   Perform a background refresh of the policy.  GPO_INFO_FLAG_ASYNC_FOREGROUND   Perform an asynchronous foreground refresh of policy. For more information about foreground policy application, see  Initial Processing of Group Policy.  GPO_INFO_FLAG_SLOWLINK   The policy is being applied across a slow link.  GPO_INFO_FLAG_VERBOSE   Write verbose output to the event log.  GPO_INFO_FLAG_NOCHANGES   No changes to the GPO were detected.  GPO_INFO_FLAG_LINKTRANSITION   A change in the link speed was detected between policy applications.  GPO_INFO_FLAG_LOGRSOP_TRANSITION   A change in RSoP logging was detected between the application of the previous policy and the application of the current policy.  GPO_INFO_FLAG_FORCED_REFRESH   A forced policy refresh is being applied.  GPO_INFO_FLAG_SAFEMODE_BOOT   Safe mode flag."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "Token for the user or computer, returned from the  LogonUser,  CreateRestrictedToken,  DuplicateToken,  OpenProcessToken, or  OpenThreadToken function. This token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. For more information, see  Access Rights for Access-Token Objects and  Client Impersonation."
      },
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKeyRoot",
        "description": "Handle to the HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER registry key."
      },
      {
        "in_out": "_In_",
        "type": "PGROUP_POLICY_OBJECT",
        "name": "pDeletedGPOList",
        "description": "Pointer that receives the list of deleted GPO structures. For more information, see  GROUP_POLICY_OBJECT."
      },
      {
        "in_out": "_In_",
        "type": "PGROUP_POLICY_OBJECT",
        "name": "pChangedGPOList",
        "description": "Pointer that receives the list of changed GPO structures. For more information, see  GROUP_POLICY_OBJECT."
      },
      {
        "in_out": "_In_",
        "type": "ASYNCCOMPLETIONHANDLE",
        "name": "pHandle",
        "description": "Asynchronous completion handle. If the callback function does not support asynchronous processing, this handle is zero."
      },
      {
        "in_out": "_In_",
        "type": "BOOL*",
        "name": "pbAbort",
        "description": "Specifies whether to continue processing GPOs. If this parameter is TRUE, GPO processing will cease. If this parameter is FALSE, GPO processing will continue."
      },
      {
        "in_out": "_In_",
        "type": "PFNSTATUSMESSAGECALLBACK",
        "name": "pStatusCallback",
        "description": "Pointer to a  StatusMessageCallback callback function that displays status messages. This parameter can be NULL in certain cases. For example, if the system is applying policy in the background, the status user interface is not present and the application cannot send status messages to be displayed. For more information, see the following Remarks section."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 10,
    "description": "The ProcessGroupPolicyEx function is an    application-defined callback function used when applying policy. This extended function also supports the logging of    Resultant Set of Policy (RSoP) data. The PFNPROCESSGROUPPOLICYEX type defines a pointer    to this callback function. ProcessGroupPolicyEx    is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If policy was applied successfully, return ERROR_SUCCESS. If there are no changes to the GPO list, and the extension is to be called again, return ERROR_OVERRIDE_NOCHANGES. Returning ERROR_OVERRIDE_NOCHANGES ensures that the extension is called again, even if the NoGPOListChanges registry value is set. (For more information about this registry value, see Remarks.) Return ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED if the function was called for an asynchronous foreground refresh of policy but policy could not be applied during the asynchronous refresh. Returning ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED indicates that the function must be called again for a synchronous foreground refresh of policy. Otherwise, return a  system error code. ",
    "remarks": "For more information, see  Implementing a Group Policy Client-side Extension. The system calls this function in the context of the  LocalSystem account, which has extensive privileges on the local computer. To use network resources, you must impersonate the user or computer by using the token provided in the hToken parameter. To register this callback function, create a subkey under the following registry key:  HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\ClientExtensionGuid The subkey should be a GUID, so that it is unique. It should contain the following values.  You should update the status message only if you are applying policy synchronously. This allows you to provide feedback and diagnostics during a lengthy policy application. To use the status message callback function, you must verify that pStatusCallback is not NULL. Then load your message string resource. When you call the status function, you must indicate whether the string is verbose. If the string is verbose, the callback function will verify that the computer is in verbose mode and display the message. For more information, see  StatusMessageCallback. ",
    "return_type": "DWORD CALLBACK",
    "category": "Group Policy",
    "name": "ProcessGroupPolicyEx",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be one or more of the following flags.  GPO_INFO_FLAG_MACHINE   Apply computer policy rather than user policy.  GPO_INFO_FLAG_BACKGROUND   Perform a background refresh of the policy. For more information, see the text following this list.  GPO_INFO_FLAG_ASYNC_FOREGROUND   Perform an asynchronous foreground refresh of policy. For more information, see the text following this          list. For more information about foreground policy application, see          Initial Processing of Group Policy.  GPO_INFO_FLAG_SLOWLINK   The policy is being applied across a slow link.  GPO_INFO_FLAG_VERBOSE   Write verbose output to the event log.  GPO_INFO_FLAG_NOCHANGES   No changes to the GPO were detected.  GPO_INFO_FLAG_LINKTRANSITION   A change in the link speed was detected between policy applications.  GPO_INFO_FLAG_LOGRSOP_TRANSITION   A change in RSoP logging was detected between the application of the previous policy and the application          of the current policy.  GPO_INFO_FLAG_FORCED_REFRESH   A forced policy refresh is being applied.  GPO_INFO_FLAG_SAFEMODE_BOOT   Safe mode flag.   The GPO_INFO_FLAG_BACKGROUND flag and the         GPO_INFO_FLAG_ASYNC_FOREGROUND flag can both be set. Because policies are always applied asynchronously during a  background refresh, most extensions handle an asynchronous foreground refresh in the same manner in which they handle a background refresh. Therefore, they do not need to check for the GPO_INFO_FLAG_ASYNC_FOREGROUND flag. In instances when an extension must distinguish between a background refresh of policy and an asynchronous foreground refresh of policy, the extension can check for the GPO_INFO_FLAG_ASYNC_FOREGROUND flag."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "Token for the user or computer, returned from the  LogonUser,  CreateRestrictedToken,  DuplicateToken,  OpenProcessToken, or  OpenThreadToken function. This token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. For more information, see  Access Rights for Access-Token Objects and  Client Impersonation."
      },
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKeyRoot",
        "description": "Handle to the HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER registry key."
      },
      {
        "in_out": "_In_",
        "type": "PGROUP_POLICY_OBJECT",
        "name": "pDeletedGPOList",
        "description": "Pointer that receives the list of deleted GPO structures. For more information, see  GROUP_POLICY_OBJECT."
      },
      {
        "in_out": "_In_",
        "type": "PGROUP_POLICY_OBJECT",
        "name": "pChangedGPOList",
        "description": "Pointer that receives the list of changed GPO structures. For more information, see  GROUP_POLICY_OBJECT."
      },
      {
        "in_out": "_In_",
        "type": "ASYNCCOMPLETIONHANDLE",
        "name": "pHandle",
        "description": "Asynchronous completion handle. If the callback function does not support asynchronous processing, this handle is zero."
      },
      {
        "in_out": "_In_",
        "type": "BOOL*",
        "name": "pbAbort",
        "description": "Specifies whether to continue processing GPOs. If this parameter is TRUE, GPO processing will cease. If this parameter is FALSE, GPO processing will continue."
      },
      {
        "in_out": "_In_",
        "type": "PFNSTATUSMESSAGECALLBACK",
        "name": "pStatusCallback",
        "description": "Pointer to a  StatusMessageCallback callback function that displays status messages. This parameter can be NULL in certain cases. For example, if the system is applying policy in the background, the status user interface is not present and the application cannot send status messages to be displayed. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "IWbemServices*",
        "name": "pWbemServices",
        "description": "Specifies a WMI services pointer to the RSoP namespace to which the policy data should be written. This parameter is NULL when RSoP logging is disabled, indicating that the extension should not log RSoP data."
      },
      {
        "in_out": "_Out_",
        "type": "HRESULT*",
        "name": "pRsopStatus",
        "description": "Pointer to an HRESULT return code that indicates whether RSoP logging was successful."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The     RefreshPolicy function causes policy to be applied immediately on the client computer. To apply policy and specify the type of refresh that should occur, you can call the extended function  RefreshPolicyEx.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "By default, policy is reapplied every 90 minutes. ",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "RefreshPolicy",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bMachine",
        "description": "Specifies whether to refresh the computer policy or user policy. If this value is TRUE, the system refreshes the computer policy. If this value is FALSE, the system refreshes the user policy."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     RefreshPolicyEx function causes policy to be applied immediately on the computer. The extended function allows you to specify the type of policy refresh to apply.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "If you do not need to specify the dwOptions parameter, you can call the  RefreshPolicy function instead. By default, policy is reapplied every 90 minutes. ",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "RefreshPolicyEx",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bMachine",
        "description": "Specifies whether to refresh the computer policy or user policy. If this value is TRUE, the system refreshes the computer policy. If this value is FALSE, the system refreshes the user policy."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOptions",
        "description": "Specifies the type of policy refresh to apply. This parameter can be the following value.  RP_FORCE   Reapply all policies even if no policy change was detected. Note that if there are any client-side extensions that can be applied at boot or logon time, (for example, an application installation extension), the extensions are re-applied at the next boot or logon, even if no policy change is detected."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     RegisterGPNotification function enables an application to receive notification when there is a change in policy. When a policy change occurs, the specified event object is set to the signaled state.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Call the  UnregisterGPNotification function to unregister the handle from receiving policy change notifications. Call the  CloseHandle function to close the handle when it is no longer required. An application can also receive notifications about policy changes when a  WM_SETTINGCHANGE message is broadcast. In this instance, the wParam parameter value is 1 if computer policy was applied; it is zero if user policy was applied. The lParam parameter points to the string \"Policy\". ",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "RegisterGPNotification",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEvent",
        "description": "Handle to an event object. Use the  CreateEvent function to create the event object."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bMachine",
        "description": "Specifies the policy change type. If TRUE, computer policy changes are reported. If FALSE, user policy changes are reported."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 11,
    "description": "The     RSoPAccessCheckByType function determines whether a security descriptor grants a specified set of access rights to the client identified by an RSOPTOKEN.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h. ",
    "remarks": "The  RSoPAccessCheckByType function compares the specified security descriptor with the specified RSOPTOKEN and indicates, in the pbAccessStatus parameter, whether access is granted or denied. ",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "RSoPAccessCheckByType",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "pSecurityDescriptor",
        "description": "Pointer to a  SECURITY_DESCRIPTOR against which access on the object is checked."
      },
      {
        "in_out": "_In_",
        "type": "PSID",
        "name": "pPrincipalSelfSid",
        "description": "Pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), this parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (\"S-1-5-10\"). For more information, see  Security Identifiers and  Well-Known SIDs. This parameter should be NULL if the protected object does not represent a principal."
      },
      {
        "in_out": "_In_",
        "type": "PRSOPTOKEN",
        "name": "pRsopToken",
        "description": "Pointer to a valid RSOPTOKEN representing the client attempting to gain access to the object."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccessMask",
        "description": "Specifies an access mask that indicates the access rights to check. This mask can contain a combination of  generic,  standard and specific access rights. For more information, see  Access Rights and Access Masks."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_TYPE_LIST",
        "name": "pObjectTypeList",
        "description": "Pointer to an array of  OBJECT_TYPE_LIST structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value indicating the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID. The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order,  RSoPAccessCheckByType fails and  GetLastError returns ERROR_INVALID_PARAMETER."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ObjectTypeListLength",
        "description": "Specifies the number of elements in the pObjectTypeList array."
      },
      {
        "in_out": "_In_",
        "type": "PGENERIC_MAPPING",
        "name": "pGenericMapping",
        "description": "Pointer to the  GENERIC_MAPPING structure associated with the object for which access is being checked."
      },
      {
        "in_out": "_In_",
        "type": "PPRIVILEGE_SET",
        "name": "pPrivilegeSet",
        "description": "This parameter is currently unused."
      },
      {
        "in_out": "_In_",
        "type": "LPDWORD",
        "name": "pdwPrivilegeSetLength",
        "description": "This parameter is currently unused."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "pdwGrantedAccessMask",
        "description": "Pointer to an  access mask that receives the granted access rights. If the function succeeds, the pbAccessStatus parameter is set to TRUE, and the mask is updated to contain the standard and specific rights granted. If pbAccessStatus is set to FALSE, this parameter is set to zero. If the function fails, the mask is not modified."
      },
      {
        "in_out": "_Out_",
        "type": "LPBOOL",
        "name": "pbAccessStatus",
        "description": "Pointer to a variable that receives the results of the access check. If the function succeeds, and the requested set of access rights are granted, this parameter is set to TRUE. Otherwise, this parameter is set to FALSE. If the function fails, the status is not modified."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 5,
    "description": "The     RSoPFileAccessCheck function determines whether a file's security descriptor grants a specified set of file access rights to the client identified by an RSOPTOKEN.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h. ",
    "remarks": "The  RSoPFileAccessCheck function indicates, in the pbAccessStatus parameter, whether access is granted or denied to the client identified by the RSOPTOKEN. If access is granted, the requested access mask becomes the object's granted access mask. ",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "RSoPFileAccessCheck",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "pszFileName",
        "description": "Pointer to the name of the relevant file. The file must already exist."
      },
      {
        "in_out": "_In_",
        "type": "PRSOPTOKEN",
        "name": "pRsopToken",
        "description": "Pointer to a valid RSOPTOKEN representing the client attempting to gain access to the file."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDesiredAccessMask",
        "description": "Specifies an access mask that indicates the access rights to check. This mask can contain a combination of  generic,  standard, and specific access rights. For more information, see  Access Rights and Access Masks."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "pdwGrantedAccessMask",
        "description": "Pointer to an access mask that receives the granted access rights. If the function succeeds, the pbAccessStatus parameter is set to TRUE, and the mask is updated to contain the standard and specific rights granted. If pbAccessStatus is set to FALSE, this parameter is set to zero. If the function fails, the mask is not modified."
      },
      {
        "in_out": "_Out_",
        "type": "LPBOOL",
        "name": "pbAccessStatus",
        "description": "Pointer to a variable that receives the results of the access check. If the function succeeds, and the requested set of access rights are granted, this parameter is set to TRUE. Otherwise, this parameter is set to FALSE. If the function fails, the status is not modified."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 3,
    "description": "The      RSoPResetPolicySettingStatus function unlinks the  RSOP_PolicySettingStatus instance from its  RSOP_PolicySetting instance. The function deletes the instances of  RSOP_PolicySettingStatus and  RSOP_PolicySettingLink. Optionally, you can also specify that the function delete the instance of  RSOP_PolicySetting.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h. ",
    "remarks": "To link (associate) the  RSOP_PolicySettingStatus instance to its  RSOP_PolicySetting instance, you can call the  RSoPSetPolicySettingStatus function. ",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "RSoPResetPolicySettingStatus",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is currently unused."
      },
      {
        "in_out": "_In_",
        "type": "IWbemServices*",
        "name": "pServices",
        "description": "Specifies a WMI services pointer to the RSoP namespace to which the policy data is to be written. This parameter is required."
      },
      {
        "in_out": "_In_",
        "type": "IWbemClassObject*",
        "name": "pSettingInstance",
        "description": "Pointer to an instance of  RSOP_PolicySetting containing the policy setting. This parameter is required and can also point to the instance's children."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 5,
    "description": "The      RSoPSetPolicySettingStatus function creates an instance of  RSOP_PolicySettingStatus and an instance of  RSOP_PolicySettingLink. The function links (associates)  RSOP_PolicySettingStatus to its  RSOP_PolicySetting instance.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is S_OK. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h. ",
    "remarks": "To unlink an  RSOP_PolicySettingStatus instance from its  RSOP_PolicySetting instance, you can call the  RSoPResetPolicySettingStatus function. ",
    "return_type": "HRESULT",
    "category": "Group Policy",
    "name": "RSoPSetPolicySettingStatus",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is currently unused."
      },
      {
        "in_out": "_In_",
        "type": "IWbemServices*",
        "name": "pServices",
        "description": "Specifies a WMI services pointer to the RSoP namespace to which the policy data is to be written. This parameter is required."
      },
      {
        "in_out": "_In_",
        "type": "IWbemClassObject*",
        "name": "pSettingInstance",
        "description": "Pointer to an instance of  RSOP_PolicySetting containing the policy setting. This parameter is required and can point to the instance's children."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nInfo",
        "description": "Specifies the number of elements in the pStatus array."
      },
      {
        "in_out": "_In_",
        "type": "POLICYSETTINGSTATUSINFO*",
        "name": "pStatus",
        "description": "Pointer to an array of  POLICYSETTINGSTATUSINFO structures."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     StatusMessageCallback function is an application-defined callback function used to display status messages when applying policy. The PFNSTATUSMESSAGECALLBACK type defines a pointer to this callback function.  StatusMessageCallback is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the message was displayed successfully, return ERROR_SUCCESS. Otherwise, return a  system error code. ",
    "remarks": "Pass a pointer to the  StatusMessageCallback function when the system calls the  ProcessGroupPolicy or the  ProcessGroupPolicyEx callback function. The status user interface has two modes: standard and verbose. Verbose messages are displayed only when the computer is in verbose mode. To enable verbose mode, set the following registry value to 1, log out, and log on. There is no need to restart the computer.  HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\VerboseStatus ",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "StatusMessageCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bVerbose",
        "description": "Specifies whether the message is verbose. If this parameter is TRUE, the message is verbose. If this parameter is FALSE, the message is not verbose."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpMessage",
        "description": "Pointer to a buffer that contains the message string."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 2,
    "description": "The     UninstallApplication function uninstalls a group policy  application that handles setup and installation using Windows Installer .msi files. The UninstallApplication function should only be called in the context of the user for whom the user group policy application has previously attempted an uninstall by calling the MsiConfigureProduct function. The InstallApplication function can install group policy applications.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008",
    "header": "Appmgmt.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see  System Error Codes or the header file WinError.h. ",
    "remarks": "Remove a group policy application that uses .msi files by calling  the Windows Installer function MsiConfigureProduct to uninstall the application. Then call UninstallApplication  to  inform the system that the application is no longer managed on the client by Group Policy.  UninstallApplication should be called even if the uninstall fails because this enables the system to keep the Resultant Set of Policy (RSoP) accurate. Remove applications installed using software installation settings (.zap files) by calling  the uninstall function or command  specific for the installation application. For information about using installation applications other than  the Windows Installer see article 231747, \"How to Publish non-MSI Programs with .zap Files,\" in the Microsoft Knowledge Base. ",
    "return_type": "DWORD",
    "category": "Group Policy",
    "name": "UninstallApplication",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WCHAR*",
        "name": "ProductCode",
        "description": "The Windows Installer product code of the product being uninstalled. The product code of the application should be provided in the form of  a Windows Installer GUID as a string with braces."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwStatus",
        "description": "The status of the uninstall attempt. The dwStatus parameter is the Windows success code of the uninstall attempt returned by MsiConfigureProduct.  The system can use this to ensure that the  Resultant Set of Policy (RSoP) indicates whether the uninstall failed or succeeded."
      }
    ],
    "min_client": "Windows Vista"
  },
  {
    "n_arguments": 1,
    "description": "The      UnregisterGPNotification function unregisters the specified policy-notification handle from receiving policy change notifications.",
    "library": "Userenv.lib",
    "min_server": "Windows Server 2008",
    "header": "Userenv.h",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The caller must call the  CloseHandle function to close the handle when it is no longer needed. ",
    "return_type": "BOOL",
    "category": "Group Policy",
    "name": "UnregisterGPNotification",
    "is_callback": 0,
    "dll": "Userenv.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEvent",
        "description": "Policy-notification handle passed to the  RegisterGPNotification function."
      }
    ],
    "min_client": "Windows Vista"
  }
]