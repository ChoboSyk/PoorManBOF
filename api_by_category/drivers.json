[
  {
    "n_arguments": 5,
    "description": "The IoGetDeviceProperty routine retrieves information about a device such as configuration information and the name of its PDO.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetDeviceProperty returns STATUS_SUCCESS if the call was successful. Possible error return values include the following.  ",
    "remarks": "IoGetDeviceProperty retrieves device setup information from the registry. Use this routine, rather than accessing the registry directly, to insulate a driver from differences across platforms and from possible changes in the registry structure. For many DeviceProperty requests, it can take two or more calls to IoGetDeviceProperty to determine the required BufferLength. The first call should use a best-guess value. If the return status is STATUS_BUFFER_TOO_SMALL, the driver should free its current buffer, allocate a buffer of the size returned in ResultLength, and call IoGetDeviceProperty again. Because some of the setup properties are dynamic, the data size can change between the time the required size is returned and driver calls this routine again. Therefore, drivers should call IoGetDeviceProperty inside a loop that runs until the return status is not STATUS_BUFFER_TOO_SMALL. Function drivers that support devices on a legacy bus and a PnP bus can use the DevicePropertyBusNumber, DevicePropertyBusTypeGuid, and DevicePropertyLegacyBusType properties to distinguish between the buses. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoGetDeviceProperty",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the physical device object (PDO) for the device being queried."
      },
      {
        "in_out": "_In_",
        "type": "DEVICE_REGISTRY_PROPERTY",
        "name": "DeviceProperty",
        "description": "Specifies the device property being requested. Must be one of the following DEVICE_REGISTRY_PROPERTY enumeration values:   DevicePropertyAddress  Requests the address of the device on the bus. PropertyBuffer points to a ULONG. The interpretation of this address is bus-specific. The caller of this routine should call the routine again to request the DevicePropertyBusTypeGuid, or possibly the DevicePropertyLegacyBusType, so it can interpret the address. An address value of 0xFFFFFFFF indicates that the underlying bus driver did not supply a bus address for the device.  DevicePropertyBootConfiguration  Requests the hardware resources assigned to the device by the firmware, in raw form. PropertyBuffer points to a CM_RESOURCE_LIST structure.  DevicePropertyBootConfigurationTranslated  The hardware resources assigned to the device by the firmware, in translated form. PropertyBuffer points to a CM_RESOURCE_LIST structure.  DevicePropertyBusNumber  Requests the legacy bus number of the bus the device is connected to. PropertyBuffer points to a ULONG.  DevicePropertyBusTypeGuid  Requests the GUID for the bus that the device is connected to. The system-defined bus type GUIDs are listed in the Wdmguid.h header file. PropertyBuffer points to a GUID, which is a 16-byte structure that contains the GUID in binary form.  DevicePropertyClassGuid  Requests the GUID for the device's setup class. PropertyBuffer points to a NULL-terminated array of WCHAR. This routine returns the GUID in a string format as follows, where each \"c\" represents a hexadecimal character: {cccccccc-cccc-cccc-cccc-cccccccccccc}  DevicePropertyClassName  Requests the name of the device's setup class, in text format. PropertyBuffer points to a NULL-terminated WCHAR string.   DevicePropertyCompatibleIDs  Requests the compatible IDs reported by the device. PropertyBuffer points to a REG_MULTI_SZ value.  DevicePropertyDeviceDescription  Requests a string describing the device, such as \"Microsoft PS/2 Port Mouse\", typically defined by the manufacturer. PropertyBuffer points to a NULL-terminated WCHAR string.   DevicePropertyDriverKeyName  Requests the name of the driver-specific registry key. PropertyBuffer points to a NULL-terminated WCHAR string.  DevicePropertyEnumeratorName  Requests the name of the enumerator for the device, such as \"PCI\" or \"root\". PropertyBuffer points to a NULL-terminated WCHAR string.  DevicePropertyFriendlyName  Requests a string that can be used to distinguish between two similar devices, typically defined by the class installer. PropertyBuffer points to a NULL-terminated WCHAR string.   DevicePropertyHardwareID  Requests the hardware IDs provided by the device that identify the device. PropertyBuffer points to a REG_MULTI_SZ value.  DevicePropertyInstallState  (Windows XP and later versions of Windows.) Requests the device's installation state. The installation state is returned as a DEVICE_INSTALL_STATE enumeration value (see the Ntddk.h header file).   DevicePropertyLegacyBusType  Requests the bus type, such as PCIBus or PCMCIABus. PropertyBuffer points to an INTERFACE_TYPE enumeration value.  DevicePropertyLocationInformation  Requests information about the device's location on the bus; the interpretation of this information is bus-specific. PropertyBuffer points to a NULL-terminated WCHAR string.  DevicePropertyManufacturer  Requests a string identifying the manufacturer of the device. PropertyBuffer points to a NULL-terminated WCHAR string.  DevicePropertyPhysicalDeviceObjectName  Requests the name of the PDO for this device. PropertyBuffer points to a NULL-terminated WCHAR string.  DevicePropertyRemovalPolicy  (Windows XP and later versions of Windows.) Requests the device's current removal policy. The operating system uses this value as a hint to determine how the device is normally removed. The PropertyBuffer parameter points to a DEVICE_REMOVAL_POLICY enumeration value.  DevicePropertyUINumber  Requests a number associated with the device that can be displayed in the user interface. PropertyBuffer points to a ULONG value. This number is typically a user-perceived slot number, such as a number printed next to the slot on the board, or some other number that makes locating the physical device easier for the user. If the device is on a bus that has no UI number convention, or if the bus driver for the device cannot determine the UI number, this value is 0xFFFFFFFF."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BufferLength",
        "description": "Specifies the size, in bytes, of the caller-supplied PropertyBuffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "PropertyBuffer",
        "description": "Pointer to a caller-supplied buffer to receive the property information. The buffer can be allocated from pageable memory. The type of the buffer is determined by the DeviceProperty (see above)."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ResultLength",
        "description": "Pointer to a ULONG to receive the size of the property information returned at PropertyBuffer. If IoGetDeviceProperty returns STATUS_BUFFER_TOO_SMALL, it sets this parameter to the required buffer length."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 8,
    "description": "The IoReportDetectedDevice routine reports a non-PnP device to the PnP manager.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoReportDetectedDevice returns STATUS_SUCCESS on success, or the appropriate error code on failure. ",
    "remarks": "Drivers for legacy devices use IoReportDetectedDevice to report their devices to the system. A driver should only call IoReportDetectedDevice to report a legacy, non-PnP device. PnP devices should be reported in response to an IRP_MN_QUERY_DEVICE_RELATIONS request. Drivers only need to call IoReportDetectedDevice the first time they are loaded because the PnP manager caches the reported information. Drivers that use this routine should store a flag in the registry to indicate whether they have already done device detection. A driver typically calls this routine from its DriverEntry routine. A few drivers, like certain NDIS or EISA drivers, might call this routine from an AddDevice routine. On successful completion of IoReportDetectedDevice, the caller should attach an FDO to the PDO returned at DeviceObject. Once the caller attaches its FDO, the caller is the function driver for the device, at least temporarily. There are no filter drivers. The PnP manager owns the PDO. The PnP manager considers the device to be started and therefore does not call the driver's AddDevice routine and does not send an IRP_MN_START_DEVICE request. The driver must be prepared to handle all other PnP IRPs, however. IoReportDetectedDevice marks the device as a root-enumerated device and this identification is persistent across system boots. During subsequent system boots the PnP manager \"detects\" the device on the root-enumerated list and configures it like a PnP device: the PnP manager queries for device information, identifies the appropriate drivers and calls their AddDevice routines, and sends all the appropriate PnP IRPs. The system generates two compatible ID strings for the device, of the form DETECTEDInterface\\Driver and DETECTED\\Driver. Interface is the string name of the INTERFACE_TYPE of the first bus specified in the ResourceList parameter. Interface is set to \"Internal\" if no bus is specified. Driver is the driver's service name. A driver can provide additional hardware IDs or compatible IDs by handling the IRP_MN_QUERY_ID request. A driver writer must provide an INF file that matches any of the specified hardware IDs or compatible IDs. The INF file should specify the original driver that called IoReportDetectedDevice as the driver to load for those IDs. The system uses this information to rebuild the driver stack for the device, for example on restart. Callers of IoReportDetectedDevice must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoReportDetectedDevice",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDRIVER_OBJECT",
        "name": "DriverObject",
        "description": "Pointer to the driver object of the driver that detected the device."
      },
      {
        "in_out": "_In_",
        "type": "INTERFACE_TYPE",
        "name": "LegacyBusType",
        "description": "Specifies the type of bus on which the device resides. The PnP manager uses this information to match the reported device to its PnP-enumerated instance, if one exists. The interface types, such as PCIBus, are defined in Wdm.h. If a driver does not know the LegacyBusType for the device, the driver supplies the value InterfaceTypeUndefined for this parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BusNumber",
        "description": "Specifies the bus number for the device. The PnP manager uses this information to match the reported device to its PnP-enumerated instance, if one exists. The bus number distinguishes the bus on which the device resides from other buses of the same type on the computer. The bus-numbering scheme is bus-specific. If a driver does not know the BusNumber for the device, the driver supplies the value -1 for this parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SlotNumber",
        "description": "Specifies the logical slot number of the device. The PnP manager uses this information to match the reported device to its PnP-enumerated instance, if one exists. If a driver does not know the SlotNumber for the device, the driver supplies the value -1 for this parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCM_RESOURCE_LIST",
        "name": "ResourceList",
        "description": "Pointer to the resource list the driver used to detect the device. Resources in this list are in raw, untranslated form."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_RESOURCE_REQUIREMENTS_LIST",
        "name": "ResourceRequirements",
        "description": "Optionally points to a resource requirements list for the detected device. NULL if the caller does not have this information for the device."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ResourceAssigned",
        "description": "Specifies whether the device's resources have already been reported to the PnP manager. If ResourceAssigned is TRUE, the resources have already been reported, possibly with IoReportResourceForDetection, and the PnP manager will not attempt to claim them on behalf of the device. If TRUE, the PnP manager will also not claim resources when the device is root-enumerated on subsequent boots."
      },
      {
        "in_out": "_Inout_",
        "type": "PDEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Optionally points to a PDO for the detected device.  NULL if the caller does not have a PDO for the device, which is typically the case. If DeviceObject is NULL, the PnP manager creates a PDO for the device and returns a pointer to the caller. If the caller supplies a PDO, the PnP manager does not create a new PDO. On a given call to this routine the DeviceObject parameter is either an IN or an OUT parameter, but not both."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The IoReportResourceForDetection routine claims hardware resources in the configuration registry for a legacy device.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoReportResourceForDetection returns STATUS_SUCCESS if the resources are claimed. Possible error return values include the following.  ",
    "remarks": "This routine is for drivers that detect earlier hardware which cannot be enumerated by Plug and Play (PnP). If a driver supports only PnP hardware, it does no detection and therefore does not call IoReportResourceForDetection. The PnP system enumerates each PnP device, assigns resources to the device, and passes those resources to the device's drivers in an IRP_MN_START_DEVICE request. If a PnP driver supports legacy hardware, however, it must call IoReportResourceForDetection to claim hardware resources before it attempts to detect the device. Callers of this routine specify a CM_RESOURCE_LIST in either a DeviceList or a DriverList that is allocated from paged memory and that consists of raw, untranslated resources. The caller is responsible for freeing the memory. A driver that can control more than one legacy card at the same time should claim the resources for each device against the device object for the respective device (using the DeviceObject, DeviceList, and DeviceListSize parameters). Such a driver must not claim these resources against their driver object. A CM_RESOURCE_LIST contains two variable-sized arrays. Each array has a default size of one. If either array has more than one element, the caller must allocate memory dynamically to contain the additional elements. Only one CM_PARTIAL_RESOURCE_DESCRIPTOR can be part of each CM_FULL_RESOURCE_DESCRIPTOR in the list, except for the last full resource descriptor in the CM_RESOURCE_LIST, which can have additional partial resource descriptors in its array. IoReportResourceForDetection, with the help of the PnP manager, determines whether the resources being requested conflict with resources that have already been claimed. If a conflict is detected, this routine sets the BOOLEAN at ConflictDetected to TRUE and returns STATUS_CONFLICTING_ADDRESSES. If no conflict is detected, this routine claims the resources, sets the BOOLEAN at ConflictDetected to FALSE, and returns STATUS_SUCCESS. If this routine succeeds and the driver detects a legacy device, the driver reports the device to the PnP manager by calling IoReportDetectedDevice. In that call, the driver sets ResourceAssigned to TRUE so the PnP manager does not attempt to claim the resources again. When a driver no longer requires the resources claimed by a call to this routine, the driver calls this routine again with a DriverList or DeviceList with a Count of zero. If a driver claims resources on a device-specific basis for more than one device, the driver must call this routine for each such device. A driver can call this routine more than once for a given device. If one set of resources fails, the driver can call the routine again for the same device with a different set of resources. If a set of resources succeeds, the driver can call this routine again with a new list; the new list replaces the previous list. Callers of IoReportResourceForDetection must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoReportResourceForDetection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDRIVER_OBJECT",
        "name": "DriverObject",
        "description": "Pointer to the driver object that was input to the driver's DriverEntry routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCM_RESOURCE_LIST",
        "name": "DriverList",
        "description": "Optionally points to a caller-supplied buffer that contains the driver's resource list, if the driver claims the same resources for all its devices. If the caller specifies a DeviceList, this parameter is ignored."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "DriverListSize",
        "description": "Specifies the size in bytes of an optional DriverList. If DriverList is NULL, this parameter should be zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Optionally points to the device object representing device for which the driver is attempting to claim resources."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCM_RESOURCE_LIST",
        "name": "DeviceList",
        "description": "Optionally points to a caller-supplied buffer containing the device's resource list. If the driver claims the same resources for all its devices, the caller can specify a DriverList instead."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "DeviceListSize",
        "description": "Specifies the size in bytes of an optional DeviceList. If DeviceList is NULL, this parameter should be zero."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "ConflictDetected",
        "description": "Pointer to a caller-supplied Boolean value that is set to TRUE on return if the resources are not available."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoGetDmaAdapter routine returns a pointer to the DMA adapter structure for a physical device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetDmaAdapter returns a pointer to a DMA_ADAPTER structure, which contains pointers to functions that support system-defined DMA operations. If the structure cannot be allocated, the routine returns NULL. ",
    "remarks": "Before calling this routine, a driver must zero-initialize the DEVICE_DESCRIPTION structure pointed to by DeviceDescription and then add the relevant information for its device to this structure. On success, the DmaOperations member of the routine's return value points to a DMA_ADAPTER structure. This structure contains a pointer to a DMA_OPERATIONS structure, which is a table of pointers to functions that the driver can subsequently use to perform DMA operations. The version of this structure that the routine returns is determined as follows: A PnP driver calls IoGetDmaAdapter when its AddDevice routine is called or when it handles a PnP IRP_MN_START_DEVICE request for a device. This IRP includes information about the device's hardware resources that the driver must supply in the DeviceDescription structure. The caller uses the MaximumLength member in the DeviceDescription structure to indicate the optimal number of map registers it can use. The I/O manager will attempt to allocate enough map registers to accommodate a DMA transfer operation of this maximum size. On output, the I/O manager returns, in the NumberOfMapRegisters parameter, the number of map registers that it allocates. Drivers should check the returned value; there is no guarantee a driver will receive the same number of map registers it requested. To free the adapter object, the driver should call PutDmaAdapter through the pointer returned in the DMA_ADAPTER structure. ",
    "return_type": "struct _DMA_ADAPTER*",
    "category": "Drivers",
    "name": "IoGetDmaAdapter",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "Pointer to the physical device object for the device requesting the DMA adapter structure."
      },
      {
        "in_out": "_In_",
        "type": "struct _DEVICE_DESCRIPTION*",
        "name": "DeviceDescription",
        "description": "Pointer to a DEVICE_DESCRIPTION structure, which describes the attributes of the physical device."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "NumberOfMapRegisters",
        "description": "A pointer to, on output, the maximum number of map registers that the driver can allocate for any DMA transfer operation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The IoGetConfigurationInformation routine returns a pointer to the I/O manager's global configuration information structure, which contains the current values for how many physical disk, floppy, CD-ROM, tape, SCSI HBA, serial, and parallel devices have device objects created to represent them by drivers as they are loaded.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoGetConfigurationInformation returns a pointer to the configuration information structure. This structure is defined as follows: ",
    "remarks": "Certain types of device drivers can use the configuration information structure's values to construct device object names with appropriate digit suffixes when each driver creates its device objects. Note that the digit suffix for device object names is a zero-based count, while the counts maintained in the configuration information structure represent the number of device objects of a particular type already created. That is, the configuration information counts are one-based. Any driver that calls IoGetConfigurationInformation must increment the count for its kind of device in this structure when it creates a device object to represent a physical device. The system-supplied SCSI port driver supplies the count of SCSI HBAs present in the computer. SCSI class drivers can read this value to determine how many HBA-specific miniport drivers might control a SCSI bus with an attached device of the class driver's type. The configuration information structure also contains a value indicating whether an already loaded driver has claimed either of the \"AT\" disk I/O address ranges. ",
    "return_type": "PCONFIGURATION_INFORMATION",
    "category": "Drivers",
    "name": "IoGetConfigurationInformation",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The HalExamineMBR routine reads the master boot record (MBR) of a disk and returns data from the MBR if the MBR is of the type specified by the caller.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "For a list of system-defined MBR partition type identifiers, see the table in PARTITION_INFORMATION. These identifiers are defined in the Ntdddisk.h header file. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "HalExamineMBR",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the device object for the device being examined."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SectorSize",
        "description": "The minimum number of bytes that an I/O operation can fetch from the device being examined. If this value is less than 512, HalExamineMBR reads 512 bytes to ensure that it reads an entire partition table."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MBRTypeIdentifier",
        "description": "MBR partition type identifier. This parameter specifies the type of MBR that may be on the disk. For more information, see Remarks."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "Buffer",
        "description": "A pointer to a location to which HalExamineMBR writes a pointer to a buffer that contains data from the MBR. The layout of the buffer depends on the MBR partition type. HalExamineMBR allocates the storage for this buffer. The caller must deallocate this buffer as soon as possible by calling the ExFreePool routine. HalExamineMBR sets *Buffer = NULL if the MBR partition type of the disk does not match that specified by MBRTypeIdentifier or if there is an error."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoReadPartitionTable routine is obsolete and is provided only to support existing drivers. New drivers must use IoReadPartitionTableEx. IoReadPartitionTable reads a list of partitions on a disk having a specified sector size and creates an entry in the partition list for each recognized partition.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "This routine returns a value of STATUS_SUCCESS if at least one sector table was read. Otherwise, it returns an error status and sets the pointer at PartitionBuffer to NULL. ",
    "remarks": "IoReadPartitionTable must only be used by disk drivers. Other drivers should use the IOCTL_DISK_GET_DRIVE_LAYOUT disk I/O request instead. Disk device drivers call this routine during driver initialization. It is the responsibility of the caller to deallocate the PartitionBuffer that was allocated by this routine with ExFreePool. The algorithm used by this routine is determined by the Boolean value ReturnRecognizedPartitions: Read each partition table and, for each and every entry, fill in a partition information entry. Extended partitions are located to find each partition on the disk; entries are built for these as well. ",
    "return_type": "NTSTATUS FASTCALL",
    "category": "Drivers",
    "name": "IoReadPartitionTable",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object for the disk whose partitions are to be read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SectorSize",
        "description": "Specifies the size of the sectors on the disk."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ReturnRecognizedPartitions",
        "description": "Indicates whether only recognized partitions or all partition entries should be returned."
      },
      {
        "in_out": "_Out_",
        "type": "struct _DRIVE_LAYOUT_INFORMATION**",
        "name": "PartitionBuffer",
        "description": "Pointer to an uninitialized address. If successful, IoReadPartitionTable allocates the memory for this buffer from nonpaged pool and returns the drive layout information in it."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoInvalidateDeviceRelations routine notifies the PnP manager that the relations for a device (such as bus relations, ejection relations, removal relations, and the target device relation) have changed.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "For some relation types, such as BusRelations, this routine causes the PnP manager or power manager to gather updated relations information by sending an IRP_MN_QUERY_DEVICE_RELATIONS request to the drivers for the device. For other relation types, such as EjectionRelations, the PnP manager does not need to gather new relation information immediately; the PnP manager queries drivers for ejection relations only when it is preparing to eject a device. After a bus driver calls IoInvalidateDeviceRelations to inform the PnP manager that a device has disappeared, the bus driver must continue to handle PnP IRPs for that device until it receives an IRP_MN_REMOVE_DEVICE request. In response to this IRP, the bus driver returns STATUS_NO_SUCH_DEVICE. Until the bus driver successfully completes the IRP_MN_REMOVE_DEVICE request, the bus driver can access the device extension to check its flags for the device. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoInvalidateDeviceRelations",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the PDO for the device."
      },
      {
        "in_out": "_In_",
        "type": "DEVICE_RELATION_TYPE",
        "name": "Type",
        "description": "Specifies a DEVICE_RELATION_TYPE enumeration value that describes the type of relations that have changed. Possible values include BusRelations, EjectionRelations, RemovalRelations, and TargetDeviceRelation. Starting with Windows 7, the PowerRelations value is also supported."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoInvalidateDeviceState routine notifies the PnP manager that some aspect of the PnP state of a device has changed.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers call this routine to indicate that something has changed with respect to one of the following aspects of a device's PnP state: For descriptions of the preceding constants, see PNP_DEVICE_STATE. In response to this routine, the PnP manager sends an IRP_MN_QUERY_PNP_DEVICE_STATE request to the device stack, to determine the current PnP state of the device. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoInvalidateDeviceState",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "Pointer to the PDO for the device."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The IoRegisterPlugPlayNotification routine registers a Plug and Play (PnP) notification callback routine to be called when a PnP event of the specified category occurs.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoRegisterPlugPlayNotification returns STATUS_SUCCESS or an appropriate error status. ",
    "remarks": "A driver registers for an event category. Each category includes one or more types of PnP events. A driver can register different callback routines for different event categories or can register a single callback routine. A single callback routine can cast the NotificationStructure to a PLUGPLAY_NOTIFICATION_HEADER and use the Event field to determine the exact type of the notification structure. PnP notification callback routines should complete their tasks as quickly as possible and return control to the PnP manager, to prevent delays in notifying other drivers and applications that have registered for the event. The PnP manager does not take out a reference on the file object when a driver registers for notification of an EventCategoryTargetDeviceChange event. If the driver's PnP notification callback routine requires access to the file object, the driver should take out an extra reference on the file object before calling IoRegisterPlugPlayNotification. Typically, Kernel-Mode Driver Framework (KMDF) drivers should call IoRegisterPlugPlayNotification from their EvtDeviceSelfManagedIoInit callback function, and should call IoUnregisterPlugPlayNotification from their EvtDeviceSelfManagedIoCleanup callback function. These drivers should not call IoRegisterPlugPlayNotification from their EvtDriverDeviceAdd callback function; otherwise, the PnP notification callback routine might be called before the driver stack is started by PnP, in which case the driver will not be prepared to handle the notification. For more information, see Using PnP Notification. To define a PnP notification callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a PnP notification callback routine that is named MyCallbackRoutine, use the DRIVER_NOTIFICATION_CALLBACK_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The DRIVER_NOTIFICATION_CALLBACK_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the DRIVER_NOTIFICATION_CALLBACK_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoRegisterPlugPlayNotification",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IO_NOTIFICATION_EVENT_CATEGORY",
        "name": "EventCategory",
        "description": "The category of PnP event for which the callback routine is being registered. EventCategory must be one of the following:    EventCategoryDeviceInterfaceChange  PnP events in this category include the arrival (enabling) of a new instance of a device interface class (GUID_DEVICE_INTERFACE_ARRIVAL), or the removal (disabling) of an existing device interface instance (GUID_DEVICE_INTERFACE_REMOVAL).  EventCategoryHardwareProfileChange  PnP events in this category include query-change (GUID_HWPROFILE_QUERY_CHANGE), change-complete (GUID_HWPROFILE_CHANGE_COMPLETE), and change-cancel (GUID_HWPROFILE_CHANGE_CANCELLED) of a hardware profile.  EventCategoryTargetDeviceChange  PnP events in this category include events related to removing a device: the device's drivers received a query-remove IRP (GUID_TARGET_DEVICE_QUERY_REMOVE), the drivers completed a remove IRP (GUID_TARGET_DEVICE_REMOVE_COMPLETE), or the drivers received a cancel-remove IRP (GUID_TARGET_DEVICE_REMOVE_CANCELLED). This category is also used for custom notification events."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EventCategoryFlags",
        "description": "Flag bits that modify the registration operation. Possible values include:   PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES  Only valid with an EventCategory of EventCategoryDeviceInterfaceChange. If set, the PnP manager calls the driver callback routine for each device interface instance that is currently registered and active and registers the callback routine for future arrivals or removals of device interface instances."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "EventCategoryData",
        "description": "A pointer to further information about the events for which CallbackRoutine is being registered. The information varies for different EventCategory values:   When EventCategory is EventCategoryDeviceInterfaceChange, EventCategoryData must point to a GUID specifying a device interface class. CallbackRoutine will be called when an interface of that class is enabled or removed.   When EventCategory is EventCategoryHardwareProfileChange, EventCategoryData must be NULL.   When EventCategory is EventCategoryTargetDeviceChange, EventCategoryData must point to the file object for which PnP notification is requested."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_OBJECT",
        "name": "DriverObject",
        "description": "A pointer to the caller's driver object. To ensure that the driver remains loaded while it is registered for PnP notification, this call increments the reference count on DriverObject. The PnP manager decrements the reference count when this registration is removed."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_NOTIFICATION_CALLBACK_ROUTINE",
        "name": "CallbackRoutine",
        "description": "A pointer to the PnP notification callback routine to be called when the specified PnP event occurs. The function prototype for this callback routine is defined as follows:       Copy      typedef NTSTATUS    DRIVER_NOTIFICATION_CALLBACK_ROUTINE(     _In_ PVOID NotificationStructure,     _Inout_opt_ PVOID Context     );      The callback routine's NotificationStructure is specific to the EventCategory value, as shown in the following table.  Event categoryNotification structure  EventCategoryDeviceInterfaceChange   DEVICE_INTERFACE_CHANGE_NOTIFICATION    EventCategoryHardwareProfileChange   HWPROFILE_CHANGE_NOTIFICATION    EventCategoryTargetDeviceChange   TARGET_DEVICE_REMOVAL_NOTIFICATION      The callback routine's Context parameter contains the context data the driver supplied during registration. For information about including a function declaration for the callback routine  that meets the requirements of Static Driver Verifier (SDV), see Examples. The PnP manager calls driver callback routines at IRQL = PASSIVE_LEVEL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "A pointer to a caller-allocated buffer containing context that the PnP manager passes to the callback routine."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "NotificationEntry",
        "description": "A pointer to an opaque value returned by this call that identifies the registration. Pass this value to the IoUnregisterPlugPlayNotificationEx routine to remove the registration. (In versions of Windows before Windows 7, call the IoUnregisterPlugPlayNotification routine instead of IoUnregisterPlugPlayNotificationEx.)"
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "This routine is obsolete in Windows 7 and later versions of Windows. For more information, see the following Remarks section.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoUnregisterPlugPlayNotification always returns STATUS_SUCCESS if NotificationEntry is valid. ",
    "remarks": "In Windows 7 and later versions of Windows, this function is obsolete and is provided only to support existing drivers. Use the IoUnregisterPlugPlayNotificationEx routine instead. IoUnregisterPlugPlayNotification removes one PnP notification registration; that is, the registration of one driver callback routine for one PnP event category. Drivers should unregister a notification first, then free any related context buffer. A driver cannot be unloaded until it removes all of its PnP notification registrations because there is a reference on its driver object for each active registration. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoUnregisterPlugPlayNotification",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "NotificationEntry",
        "description": "Pointer to an opaque value representing the registration to be removed. The value was returned by a previous call to IoRegisterPlugPlayNotification."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoRequestDeviceEject routine notifies the PnP manager that the device eject button was pressed.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Note that this routine reports a request for device eject, not media eject. Typically, a PnP bus driver calls IoRequestDeviceEject to notify the PnP manager that a user pressed the device eject button on one of its child devices. A driver calls this routine, rather than sending an IRP_MN_EJECT request, because this routine allows the PnP manager to coordinate additional actions for the eject besides sending the IRP. For example, the PnP manager notifies user-mode and kernel-mode components that registered for notification of changes on the device. The PnP manager directs an orderly shutdown of the device. The PnP manager: When a device is ejected, its child devices are physically removed from the system along with it. A user-mode application can initiate a device eject. In that case, no driver calls this routine but the operating system calls the PnP manager to initiate the steps listed above. Callers of IoRequestDeviceEject must be running at IRQL <= DISPATCH_LEVEL. The PnP manager performs most of its device-eject tasks listed above at IRQL = PASSIVE_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoRequestDeviceEject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "Pointer to the PDO for the device."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoReportTargetDeviceChange routine notifies the PnP manager that a custom event has occurred on a device.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoReportTargetDeviceChange returns STATUS_SUCCESS or an appropriate error status. Possible error status values include the following.  ",
    "remarks": "After IoReportTargetDeviceChange notifies the PnP manager that a custom event has occurred on a device, the PnP manager sends notification of the event to drivers that registered for notification on the device. Do not use this routine to report system PnP events, such as GUID_TARGET_DEVICE_REMOVE_COMPLETE. A driver that defines a custom device event calls IoReportTargetDeviceChange to inform the PnP manager that the custom event has occurred. Custom notification can be used for events like a volume label change. A driver should call the asynchronous form of this routine, IoReportTargetDeviceChangeAsynchronous, instead of this routine, to prevent deadlocks. Certain kernel-mode components can call this synchronous routine. For example, a file system can call IoReportTargetDeviceChange to report a \"get off the volume\" custom event when a component tries to open the volume for exclusive access. Clients that register for notification on file system volumes are careful to not request an exclusive open in a PnP notification callback routine. The custom notification structure contains a driver-defined event with its own GUID. Driver writers can generate GUIDs with Uuidgen.exe or Guidgen.exe (which are included in the Microsoft Windows SDK). Callers of IoReportTargetDeviceChange must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. To report a target device change from IRQL > PASSIVE_LEVEL, call IoReportTargetDeviceChangeAsynchronous. IoReportTargetDeviceChange is not supported on Windows 98/Me; it returns STATUS_NOT_IMPLEMENTED. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoReportTargetDeviceChange",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "Pointer to the PDO of the device being reported."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "NotificationStructure",
        "description": "Pointer to a caller-supplied TARGET_DEVICE_CUSTOM_NOTIFICATION structure describing the custom event. The PnP manager sends this structure to drivers that registered for notification of the event. NotificationStructure.FileObject must be NULL. NotificationStructure.Event must contain the custom GUID for the event. The other fields of the NotificationStructure must be filled in as appropriate for the custom event. The PnP manager fills in the NotificationStructure.FileObject field when it sends notifications to registrants."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoOpenDeviceInterfaceRegistryKey routine returns a handle to a registry key for storing information about a particular device interface instance.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoOpenDeviceInterfaceRegistryKey returns STATUS_SUCCESS if the call was successful. Possible error return values include the following.  ",
    "remarks": "IoOpenDeviceInterfaceRegistryKey opens a nonvolatile subkey of the registry key for the device interface instance specified by SymbolicLinkName. Drivers can store information in this subkey that is specific to this instance of the device interface, such as the default resolution for a camera. User-mode applications can access this subkey using SetupDiXxx routines. The driver must call ZwClose to close the handle returned from this routine when access is no longer required. Callers of IoOpenDeviceInterfaceRegistryKey must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoOpenDeviceInterfaceRegistryKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "SymbolicLinkName",
        "description": "Pointer to a string identifying the device interface instance. This string was obtained from a previous call to IoGetDeviceInterfaces, IoGetDeviceInterfaceAlias, or IoRegisterDeviceInterface."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies the ACCESS_MASK value that represents the access the caller requires to the key, such as KEY_READ, KEY_WRITE, or KEY_ALL_ACCESS. See ZwCreateKey for a description of each KEY_XXX access right."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "DeviceInterfaceKey",
        "description": "Pointer to a returned handle to the requested registry key if the call is successful."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoOpenDeviceRegistryKey routine returns a handle to a device-specific or a driver-specific registry key for a particular device instance.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoOpenDeviceRegistryKey returns STATUS_SUCCESS if the call was successful. Possible error return values include the following.  ",
    "remarks": "The driver must call ZwClose to close the handle returned from this routine when access is no longer required. The registry keys opened by this routine are nonvolatile. User-mode setup applications, such as class installers, can access these registry keys using device installation functions such as SetupDiOpenDevRegKey. To create registry keys, use INF AddReg directives in an INF file or use SetupDiCreateDevRegKey in a setup application. Callers of IoOpenDeviceRegistryKey must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoOpenDeviceRegistryKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the PDO of the device instance for which the registry key is to be opened."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DevInstKeyType",
        "description": "Specifies flags indicating whether to open a device-specific hardware key or a driver-specific software key. The flags also indicate whether the key is relative to the current hardware profile. For more information about hardware and software keys, see Registry Keys for Drivers. The flags are defined as follows:   PLUGPLAY_REGKEY_DEVICE  Open the Device Parameters subkey under the device's hardware key. The key is located under the key for the device instance specified by DeviceObject. This flag cannot be specified with PLUGPLAY_REGKEY_DRIVER.  PLUGPLAY_REGKEY_DRIVER  Open a software key for storing driver-specific information. This flag cannot be specified with PLUGPLAY_REGKEY_DEVICE.  PLUGPLAY_REGKEY_CURRENT_HWPROFILE  Open a key relative to the current hardware profile for device or driver information. This allows the driver to access configuration information that is hardware-profile-specific. The caller must specify either PLUGPLAY_REGKEY_DEVICE or PLUGPLAY_REGKEY_DRIVER with this flag."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies the ACCESS_MASK value that represents the access the caller needs to the key. See the ZwCreateKey routine for a description of each KEY_XXX access right."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "DevInstRegKey",
        "description": "Pointer to a caller-allocated buffer that, on successful return, contains a handle to the requested registry key."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoRegisterDeviceInterface routine registers a device interface class, if it has not been previously registered, and creates a new instance of the interface class, which a driver can subsequently enable for use by applications or other system components.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoRegisterDeviceInterface returns STATUS_SUCCESS if the call was successful. Possible error return values include the following.  ",
    "remarks": "IoRegisterDeviceInterface registers a device interface class, if it has not been previously registered, and creates a new instance of the interface class. A driver can call this routine several times for a given device to register several interface classes and create instances of the classes. A function or filter driver typically registers device interfaces in its AddDevice routine. For example, a fault-tolerant volume driver might register an instance of a fault-tolerant-volume interface and an instance of a volume interface for a particular volume. If the device interface class has not been registered previously, the I/O manager creates a registry key for it, along with instance-specific persistent storage under the key. Drivers can access this persistent storage using IoOpenDeviceInterfaceRegistryKey. A driver registers an interface instance once and then calls IoSetDeviceInterfaceState to enable and disable the interface. Registered interfaces persist across operating system reboots. If the specified interface is already registered, the I/O manager passes its name in SymbolicLinkName and returns the informational success status STATUS_OBJECT_NAME_EXISTS. Most drivers use a NULL reference string for a device interface instance. If a driver uses a non-NULL reference string, it must do additional work, including possibly managing its own namespace and security. A filter driver that exposes a device interface must use a NULL ReferenceString to avoid conflicts with other drivers in the device stack. Callers of this routine are not required to remove the registration for a device interface when it is no longer needed. Device interface registrations can be removed from user mode, if necessary. Callers of IoRegisterDeviceInterface must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoRegisterDeviceInterface",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "A pointer to the PDO for the device."
      },
      {
        "in_out": "_In_",
        "type": "const GUID*",
        "name": "InterfaceClassGuid",
        "description": "A pointer to the class GUID that identifies the functionality (the device interface class) being registered."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "ReferenceString",
        "description": "Optionally points to a UNICODE_STRING. The string must not contain any path separator characters (\"/\" or \"\\\"). Function drivers typically specify NULL for this parameter. Filter drivers must specify NULL. Reference strings are only used by a few bus drivers, such as swenum, which is a bus driver that uses device interface instances as placeholders for software devices created on demand. When an instance of an interface is opened, the I/O manager passes the instance's reference string to the driver. The string becomes part of the interface instance's name (as an appended path component). The driver can then use the reference string to differentiate between two interface instances of the same class for a single device. On Microsoft Windows 98/Me systems, the ReferenceString value can be no longer than MAX_PATH characters. There is no length limit on Windows 2000 and later versions of Windows."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "SymbolicLinkName",
        "description": "A pointer to a Unicode string structure allocated by the caller. If this routine is successful, it initializes the Unicode string and allocates the string buffer containing the kernel-mode path to the symbolic link for an instance of the specified device interface class.  The caller must treat SymbolicLinkName as opaque and must not disassemble it. The caller is responsible for freeing SymbolicLinkName with RtlFreeUnicodeString when it is no longer needed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoSetDeviceInterfaceState routine enables or disables an instance of a previously registered device interface class.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoSetDeviceInterfaceState returns STATUS_SUCCESS if the call was successful. This routine returns an informational status of STATUS_OBJECT_NAME_EXISTS if the caller requested to enable a device interface that was already enabled. Possible error return values are described following.  ",
    "remarks": "IoSetDeviceInterfaceState enables an instance of a registered device interface for use by applications and other system components. The interface class must have been previously registered with IoRegisterDeviceInterface or from user mode. Applications and other system components can open only interfaces that are enabled. A function or a filter driver typically calls this routine with Enable set to TRUE after it successfully starts a device in response to an IRP_MN_START_DEVICE IRP. Such a driver should disable the device interface instance (that is, call IoSetDeviceInterfaceState and set Enable to FALSE) when it removes the device in response to an IRP_MN_REMOVE_DEVICE IRP or an IRP_MN_SURPRISE_REMOVAL IRP. If a driver does not disable a device interface when it processes these removal IRPs, the driver should not subsequently attempt to do so because the PnP manager will disable the interface when the PnP manager removes the device. If a device is removed suddenly (for example, by a surprise removal) but still has a valid device interface instance, a problem will occur if the device is reattached. This problem occurs when the PnP manager enumerates the newly attached device and enables a device interface instance, which will exist at the same registry path as the existing device interface instance. Note that if the driver calls IoSetDeviceInterfaceState to disable a device interface instance in response to an IRP_MN_SURPRISE_REMOVAL IRP, the driver must not attempt to disable the same device interface instance in response to an IRP_MN_REMOVE_DEVICE IRP. If a call to IoSetDeviceInterfaceState successfully exposes a device interface instance, the system notifies any components that registered for PnP notification of a device class change. Similarly, if a call to this routine disables an existing device interface instance, the system sends appropriate notifications. The PnP manager does not send notification of interface instance arrivals until the IRP_MN_START_DEVICE IRP completes, indicating that all the drivers for the device have completed their start operations. In addition, the PnP manager fails create requests for the device until the IRP_MN_START_DEVICE IRP completes. Callers of IoSetDeviceInterfaceState must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoSetDeviceInterfaceState",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "SymbolicLinkName",
        "description": "Pointer to a string that identifies the device interface instance that is being enabled or disabled. This string was obtained from a previous call to IoRegisterDeviceInterface or IoGetDeviceInterfaces."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Enable",
        "description": "TRUE indicates that the device interface is being enabled. FALSE indicates that the device interface is being disabled."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlCheckRegistryKey routine checks for the existence of a given named key in the registry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the given named key exists in the registry along the given relative path, RtlCheckRegistryKey returns STATUS_SUCCESS. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlCheckRegistryKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RelativeTo",
        "description": "Specifies whether Path is an absolute registry path or is relative to a predefined key path as one of the following.  ValueMeaning  RTL_REGISTRY_ABSOLUTE  Path is an absolute registry path.   RTL_REGISTRY_CONTROL  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Control.   RTL_REGISTRY_DEVICEMAP  Path is relative to \\Registry\\Machine\\Hardware\\DeviceMap.   RTL_REGISTRY_SERVICES  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Services.   RTL_REGISTRY_USER  Path is relative to the registry settings for the current user. (For a system process, this is \\Users\\.Default.)  This is equivalent to HKEY_CURRENT_USER in user mode.   RTL_REGISTRY_WINDOWS_NT  Path is relative to \\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion.   RTL_REGISTRY_HANDLE  This value should not be passed into this routine. Despite the redundancy of a check for the existence of an already-opened key, it has the side effect of closing the passed handle."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "Path",
        "description": "Specifies the registry path according to the RelativeTo value. If RTL_REGISTRY_HANDLE is set, Path is a handle to be used directly."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlCreateRegistryKey routine adds a key object in the registry along a given relative path.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlCreateRegistryKey returns STATUS_SUCCESS if the key is created. ",
    "remarks": "RtlCreateRegistryKey creates only the keys that you specify. It does not create missing keys in the path to the specified key. If any keys in the path are missing, the call will fail. To ensure that all keys in the path exist, you must call RtlCreateRegistryKey once for each key in the path. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlCreateRegistryKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RelativeTo",
        "description": "Specifies whether Path is an absolute registry path or is relative to a predefined key path as one of the following.  ValueMeaning  RTL_REGISTRY_ABSOLUTE  Path is an absolute registry path.   RTL_REGISTRY_SERVICES  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Services.   RTL_REGISTRY_CONTROL  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Control.   RTL_REGISTRY_WINDOWS_NT  Path is relative to \\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion.   RTL_REGISTRY_DEVICEMAP  Path is relative to \\Registry\\Machine\\Hardware\\DeviceMap.   RTL_REGISTRY_USER  Path is relative to \\Registry\\User\\CurrentUser. (For a system process, this is \\Users\\.Default.)"
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "Path",
        "description": "Specifies the registry path according to the RelativeTo value."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The RtlQueryRegistryValues routine allows the caller to query several values from the registry subtree with a single call.",
    "library": "Ntoskrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlQueryRegistryValues returns an NTSTATUS code. The possible return values include:  RtlQueryRegistryValues also terminates processing of the table if the QueryRoutine function for a table entry returns an NTSTATUS error code, and returns that error code as its result. (With one exception: If QueryRoutine returns STATUS_BUFFER_TOO_SMALL, the error code is ignored.) ",
    "remarks": "The caller specifies an initial key path and a table. The table contains one or more entries that describe the key values and subkey names in which the caller is interested. The table is terminated by an entry with a NULL QueryRoutine member and a NULL Name member. The table must be allocated from nonpaged pool. If the RTL_QUERY_REGISTRY_TYPECHECK flag is set in a table entry, the caller must specify the expected REG_XXX type in the 8 most significant bits (MSBs) of the 32-bit DefaultType member of the table entry. As shown in the following code example, the RTL_QUERY_REGISTRY_TYPECHECK_SHIFT constant, which is defined to be 24, can be used as the shift count required to place the expected REG_XXX type in the 8 MSBs of the DefaultType member. Starting with Windows 8, if an RtlQueryRegistryValues call accesses an untrusted hive, and the caller sets the RTL_QUERY_REGISTRY_DIRECT flag for this call, the caller must additionally set the RTL_QUERY_REGISTRY_TYPECHECK flag. A violation of this rule by a call from user mode causes an exception.  A violation of this rule by a call from kernel mode causes a 0x139 bug check (KERNEL_SECURITY_CHECK_FAILURE). Only system hives are trusted. An RtlQueryRegistryValues call that accesses a system hive does not cause an exception or a bug check if the RTL_QUERY_REGISTRY_DIRECT flag is set and the RTL_QUERY_REGISTRY_TYPECHECK flag is not set. However, as a best practice, the RTL_QUERY_REGISTRY_TYPECHECK flag should always be set if the RTL_QUERY_REGISTRY_DIRECT flag is set. Similarly, in versions of Windows before Windows 8, as a best practice, an RtlQueryRegistryValues call that sets the RTL_QUERY_REGISTRY_DIRECT flag should additionally set the RTL_QUERY_REGISTRY_TYPECHECK flag. However, failure to follow this recommendation does not cause an exception or a bug check. The following is a list of system hives: Support for the RTL_QUERY_REGISTRY_TYPECHECK flag is available through Windows Update for Windows 7, Windows Vista, Windows Server 2003, and Windows XP. For more information about this update, see Vulnerabilities in Windows Kernel Could Allow Elevation of Privilege (2393802). In versions of these operating systems that do not have this update, the caller can use the RTL_QUERY_REGISTRY_TYPECHECK flag. However, this flag is ignored by the RtlQueryRegistryValues routine. Starting with Windows Driver Kit (WDK) 8, the RTL_QUERY_REGISTRY_TYPECHECK flag is defined in the Wdm.h header file as follows: If an entry does not specify the RTL_QUERY_REGISTRY_DIRECT flag, RtlQueryRegistryValues uses the specified QueryRoutine function to report the value name, type, data, and data length, in bytes, to the caller. If the Name member of the entry is NULL, RtlQueryRegistryValues reports every direct subkey of the key. If the key type is REG_MULTI_SZ and the RTL_QUERY_REGISTRY_NOEXPAND flag not is specified, the routine calls QueryRoutine separately for each individual string; otherwise the routine reports it as a single value. If an entry specifies the RTL_QUERY_REGISTRY_DIRECT flag, RtlQueryRegistryValues stores the value of the key in the buffer pointed to by the entry's EntryContext member. The format of the returned data is as follows.  If an error occurs at any stage of processing of the query table, RtlQueryRegistryValues stops processing the table and returns the error status. See ZwSetValueKey for a description of the possible REG_XXX values. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlQueryRegistryValues",
    "is_callback": 0,
    "dll": "Ntoskrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RelativeTo",
        "description": "Specifies whether Path is an absolute registry path or is relative to a predefined path as one of the following.  ValueMeaning  RTL_REGISTRY_ABSOLUTE  Path is an absolute registry path.   RTL_REGISTRY_CONTROL  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Control.   RTL_REGISTRY_DEVICEMAP  Path is relative to \\Registry\\Machine\\Hardware\\DeviceMap.   RTL_REGISTRY_SERVICES  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Services.   RTL_REGISTRY_USER  Path is relative to \\Registry\\User\\CurrentUser. (For a system process, this is \\User\\.Default.)   RTL_REGISTRY_WINDOWS_NT  Path is relative to \\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion.     The RelativeTo value can be modified by bitwise-ORing it with one of the following flags.   RTL_REGISTRY_OPTIONAL  Specifies that the key referenced by this parameter and the Path parameter are optional.   RTL_REGISTRY_HANDLE  Specifies that the Path parameter is actually a registry handle to use."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "Path",
        "description": "Pointer to either an absolute registry path or a path relative to the known location specified by the RelativeTo parameter. Note that the names of keys in such a path must be known to the caller, including the last key in the path. If the RTL_REGISTRY_HANDLE flag is specified, this parameter is a registry handle for an already opened key to be queried directly."
      },
      {
        "in_out": "_Inout_",
        "type": "PRTL_QUERY_REGISTRY_TABLE",
        "name": "QueryTable",
        "description": "Pointer to a table of one or more value names and subkey names in which the caller is interested. Each table entry contains the address of a caller-supplied QueryRoutine function that will be called for each value name that exists in the registry. The table must be terminated with a NULL table entry, which is a table entry with a NULL QueryRoutine member and a NULL Name member. The structure for query table entries is defined as follows:       Copy      typedef struct _RTL_QUERY_REGISTRY_TABLE {     PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;     ULONG Flags;     PWSTR Name;     PVOID EntryContext;     ULONG DefaultType;     PVOID DefaultData;     ULONG DefaultLength; } RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;      If the caller allocates storage for the query table pointed to by the QueryTable parameter, the caller is responsible for releasing this storage after the RtlQueryRegistryValues call returns.   QueryRoutine  The address of a QueryRoutine function that is called with the name, type, data, and data length of a registry value. If this member and the Name member are both NULL, it marks the end of the table. A QueryRoutine function is declared as follows:       Copy      NTSTATUS QueryRoutine (     IN PWSTR ValueName,     IN ULONG ValueType,     IN PVOID ValueData,     IN ULONG ValueLength,     IN PVOID Context,     IN PVOID EntryContext     );      For more information, see QueryRoutine.  Flags  Flags to control how the remaining members of the RTL_QUERY_REGISTRY_TABLE structure are to be interpreted. The following flag bits are defined for this member.  ValueMeaning  RTL_QUERY_REGISTRY_SUBKEY  The Name of this table entry is another path to a registry key, and all following table entries are for that key rather than the key specified by the Path parameter. This change in focus lasts until the end of the table or until another RTL_REGISTRY_SUBKEY or RTL_QUERY_REGISTRY_TOPKEY entry is seen. Each such entry must specify a path that is relative to the Path specified in the call to RtlQueryRegistryValues.   RTL_QUERY_REGISTRY_TOPKEY  Resets the current registry key handle to the original one specified by the RelativeTo and Path parameters. This is useful for getting back to the original node after descending into subkeys with the RTL_QUERY_REGISTRY_SUBKEY flag.   RTL_QUERY_REGISTRY_REQUIRED  Specifies that this registry value must exist if DefaultType = REG_NONE; otherwise, if it is not found, RtlQueryRegistryValues immediately exits with a status code of STATUS_OBJECT_NAME_NOT_FOUND. This exit occurs if the Name member is NULL and the current key has no subkeys, or if Name specifies a nonexistent subkey. (If this flag is not specified, then when no match is found for a non-NULL Name, the routine uses the DefaultValue member as the value. When Name  is NULL and the current key has no subkeys, the routine simply skips that table entry.)   RTL_QUERY_REGISTRY_NOVALUE  Specifies that even though there is no Name for this table entry, all the caller wants is a callback: that is, the caller does not want to enumerate all the values under the current key. QueryRoutine is called with NULL for ValueData, REG_NONE for ValueType, and zero for ValueLength.   RTL_QUERY_REGISTRY_NOEXPAND  For a registry value of type REG_EXPAND_SZ or REG_MULTI_SZ, this flag overrides the default behavior, which is to preprocess the registry value before calling the QueryRoutine routine. By default, RtlQueryRegistryValues expands environment variable references in REG_EXPAND_SZ values, and enumerates each null-terminated string in a REG_MULTI_SZ value in a separate QueryRoutine call, so that the strings are presented as REG_SZ values that have the same ValueName. If this flag is set, QueryRoutine receives the raw REG_EXPAND_SZ or REG_MULTI_SZ value from the registry. For more information about the data formats for these values, see KEY_VALUE_BASIC_INFORMATION.   RTL_QUERY_REGISTRY_DIRECT  The QueryRoutine member is not used (and must be NULL), and the EntryContext points to the buffer to store the value. If the caller sets this flag, the caller should additionally set the RTL_QUERY_REGISTRY_TYPECHECK flag to guard against buffer overflow. For more information, see the Remarks section.   RTL_QUERY_REGISTRY_TYPECHECK  Use this flag with the RTL_QUERY_REGISTRY_DIRECT flag to verify that the REG_XXX type of the stored registry value matches the type expected by the caller. If the types do not match, the call fails. For more information, see the Remarks section.   RTL_QUERY_REGISTRY_DELETE  This flag is used to delete value keys after they have been queried.     Starting with Windows 2000, inbox support is provided for all flag bits in the preceding table, with the exception of RTL_QUERY_REGISTRY_TYPECHECK. Inbox support for RTL_QUERY_REGISTRY_TYPECHECK is available starting with Windows 8. For earlier versions of Windows, support for RTL_QUERY_REGISTRY_TYPECHECK is provided through Windows Update. For more information, see Remarks.  Name  This is the name of a Value that the caller queried. If Name is NULL, the QueryRoutine function specified for this table entry is called for all values associated with the current registry key. If the RTL_QUERY_REGISTRY_DIRECT flag is set, a non-NULL value for Name must be provided.  EntryContext  If the RTL_QUERY_REGISTRY_DIRECT flag is set, this is a pointer to the buffer to store the result of the query operation for this key. Otherwise, this value is passed as the EntryContext parameter of QueryRoutine.  DefaultType  The least significant byte of this member specifies the REG_XXX type of the data to be returned, if no matching key is found and the RTL_QUERY_REGISTRY_REQUIRED flag is not specified. Specify REG_NONE for no default type. If the RTL_QUERY_REGISTRY_TYPECHECK flag is set, the most significant byte of this member specifies the REG_XXX type of the stored registry value that the caller expects. Bits 8 to 23 of this member are reserved and should be zero.  DefaultData  A pointer to the default value to be returned if no matching key is found and the RTL_QUERY_REGISTRY_REQUIRED flag is not specified. This member is ignored if DefaultType = REG_NONE. Otherwise, the type of data pointed to by DefaultData should conform to the registry value type specified by the DefaultType member. For more information registry value types, see the definition of the Type parameter in KEY_VALUE_BASIC_INFORMATION.  DefaultLength  Specifies the length, in bytes, of the DefaultData member. If DefaultType is REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, callers can optionally specify zero to indicate RtlQueryRegistryValues should compute the length based on the default data value. If DefaultType = REG_NONE, this member is ignored."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Specifies the value passed as the Context parameter of a QueryRoutine function each time it is called."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Environment",
        "description": "Pointer to the environment used when expanding variable values in REG_EXPAND_SZ registry values, or a NULL pointer (optional)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The RtlWriteRegistryValue routine writes caller-supplied data into the registry along the specified relative path at the given value name.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlWriteRegistryValue returns the status of the operation, either STATUS_SUCCESS or an error status. ",
    "remarks": "If the specified key does not exist, the routine attempts to create the key. For this attempt to succeed, the new key must be a direct subkey of the key that is referred to by the Path parameter, and the key that Path refers to must have been opened for KEY_CREATE_SUB_KEY access. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlWriteRegistryValue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RelativeTo",
        "description": "Specifies whether Path is an absolute registry path or is relative to a predefined path as one of the following.  ValueMeaning  RTL_REGISTRY_ABSOLUTE  Path is an absolute registry path.   RTL_REGISTRY_SERVICES  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Services.   RTL_REGISTRY_CONTROL  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Control.   RTL_REGISTRY_WINDOWS_NT  Path is relative to \\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion.   RTL_REGISTRY_DEVICEMAP  Path is relative to \\Registry\\Machine\\Hardware\\DeviceMap.   RTL_REGISTRY_USER  Path is relative to \\Registry\\User\\CurrentUser. (For a system process, this is \\Users\\.Default.)   RTL_REGISTRY_OPTIONAL  Specifies that the key referenced by this parameter and the Path parameter are optional.   RTL_REGISTRY_HANDLE  Specifies that the Path parameter is actually a registry handle to use. This value is optional."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "Path",
        "description": "Pointer to either an absolute registry path or a path relative to the known location specified by the RelativeTo parameter. If the RTL_REGISTRY_HANDLE flag is specified, this parameter is a registry handle for an already opened key to be used directly."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "ValueName",
        "description": "Pointer to the name of a subkey or value entry to be written into the registry."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ValueType",
        "description": "Specifies a REG_XXX value that determines the type of the ValueName parameter. For a list of the possible values, see the Type parameter of ZwSetValueKey."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ValueData",
        "description": "Pointer to the name of a subkey or values for its value entries (or both) to be written into the registry."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ValueLength",
        "description": "Specifies the number of bytes of ValueData to be written into the registry."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlDeleteRegistryValue routine removes the specified entry name and the associated values from the registry along the given relative path.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlDeleteRegistryValue returns STATUS_SUCCESS if the value entry was deleted. Note that if RelativeTo is set to RTL_REGISTRY_HANDLE, the following occurs: ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlDeleteRegistryValue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RelativeTo",
        "description": "Specifies whether Path is an absolute registry path or is relative to a predefined key path as one of the following.  ValueMeaning  RTL_REGISTRY_ABSOLUTE  Path is an absolute registry path.   RTL_REGISTRY_SERVICES  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Services.   RTL_REGISTRY_CONTROL  Path is relative to \\Registry\\Machine\\System\\CurrentControlSet\\Control.   RTL_REGISTRY_WINDOWS_NT  Path is relative to \\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion.   RTL_REGISTRY_DEVICEMAP  Path is relative to \\Registry\\Machine\\Hardware\\DeviceMap.   RTL_REGISTRY_USER  Path is relative to \\Registry\\User\\CurrentUser. (For a system process, this is \\Users\\.Default.)   RTL_REGISTRY_HANDLE  Specifies that the Path parameter is actually a registry handle to use. This value is optional."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "Path",
        "description": "Specifies the registry path according to the RelativeTo value. If RTL_REGISTRY_HANDLE is set, Path is a handle to be used directly."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "ValueName",
        "description": "Pointer to the value name to be removed from the registry."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ZwCreateKey routine creates a new registry key or opens an existing one.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwCreateKey returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. ",
    "remarks": "ZwCreateKey supplies a handle that the caller can use to manipulate a registry key. For more information, see Using the Registry in a Driver. Once the handle pointed to by KeyHandle is no longer in use, the driver must call ZwClose to close it. There are two alternate ways to specify the name of the file to be created or opened with ZwCreateKey: If the key specified by ObjectAttributes does not exist, the routine attempts to create the key. For this attempt to succeed, the new key must be a direct subkey of the key that is referred to by RootDirectory, and the key that RootDirectory refers to must have been opened for KEY_CREATE_SUB_KEY access. If the specified key already exists, it is opened and its value is not affected in any way. The security attributes specified by ObjectAttributes when a key is created determine whether the specified DesiredAccess is granted on subsequent calls to ZwCreateKey and ZwOpenKey. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. For more information about working with registry keys, see Using the Registry in a Driver. The NtCreateKey routine in the Windows kernel is not directly accessible to kernel-mode drivers. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "KeyHandle",
        "description": "Pointer to a HANDLE variable that receives a handle to the key."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. In addition to the access rights that are defined for all types of objects (see ACCESS_MASK), the caller can specify one or more of the following access rights, which are specific to object directories:  DesiredAccess flagAllows caller to do this  KEY_QUERY_VALUE  Read key values.   KEY_SET_VALUE  Write key values.   KEY_CREATE_SUB_KEY  Create subkeys for the key.   KEY_ENUMERATE_SUB_KEYS  Read the key's subkeys.   KEY_CREATE_LINK  Create a symbolic link to the key. This flag is not used by device and intermediate drivers.   KEY_NOTIFY  Ask to receive notification when the name, value, or attributes of the key change. For more information, see ZwNotifyChangeKey.     The caller can also specify one of the following constants, which combines several ACCESS_MASK flags.  ConstantConsists of these ACCESS_MASK flags  KEY_READ  STANDARD_RIGHTS_READ, KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY   KEY_WRITE  STANDARD_RIGHTS_WRITE, KEY_SET_VALUE, and KEY_CREATE_SUBKEY   KEY_EXECUTE  Same as KEY_READ.   KEY_ALL_ACCESS  STANDARD_RIGHTS_ALL, KEY_QUERY_VALUE, KEY_SET_VALUE, KEY_CREATE_SUB_KEY, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, and KEY_CREATE_LINK"
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      },
      {
        "in_out": "_Reserved_",
        "type": "ULONG",
        "name": "TitleIndex",
        "description": "Device and intermediate drivers set this parameter to zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "Class",
        "description": "Pointer to a Unicode string that contains the key's object class. This information is used by the configuration manager."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CreateOptions",
        "description": "Specifies the options to apply when creating or opening a key, specified as a compatible combination of the following flags.  CreateOptions flagDescription  REG_OPTION_VOLATILE  Key is not preserved when the system is rebooted.   REG_OPTION_NON_VOLATILE  Key is preserved when the system is rebooted.   REG_OPTION_CREATE_LINK  The newly created key is a symbolic link. This flag is not used by device and intermediate drivers.   REG_OPTION_BACKUP_RESTORE  Key should be created or opened with special privileges that allow backup and restore operations. This flag is not used by device and intermediate drivers."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "Disposition",
        "description": "Pointer to a variable that receives a value indicating whether a new key was created or an existing one opened.  Disposition valueDescription  REG_CREATED_NEW_KEY  A new key was created.   REG_OPENED_EXISTING_KEY  An existing key was opened."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwOpenKey routine opens an existing registry key.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwOpenKey returns STATUS_SUCCESS if the given key was opened. Otherwise, it can return an error status, including the following: ",
    "remarks": "ZwOpenKey supplies a handle that the caller can use to manipulate a registry key. The routine provides a subset of the functionality of ZwCreateKey. For more information, see Using the Registry in a Driver. If the specified key does not exist, ZwOpenKey returns an error status and does not return a key handle. Once the handle pointed to by KeyHandle is no longer in use, the driver must call ZwClose to close it. ZwOpenKey ignores the security information in the structure that the ObjectAttributes parameter points to. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. For more information about working with registry keys, see Using the Registry in a Driver. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "KeyHandle",
        "description": "Pointer to the HANDLE variable that receives the handle to the key."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. For more information, see the DesiredAccess parameter of ZwCreateKey."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryKey routine provides information about the class of a registry key, and the number and sizes of its subkeys.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryKey returns STATUS_SUCCESS on success, or the appropriate error code on failure. Possible error code values include:  ",
    "remarks": "The KeyHandle passed to ZwQueryKey must have been opened with KEY_QUERY_VALUE access. This is accomplished by passing KEY_QUERY_VALUE, KEY_READ, or KEY_ALL_ACCESS as the DesiredAccess parameter to ZwCreateKey or ZwOpenKey. ZwQueryKey can be used to obtain information that you can use to allocate buffers to hold registry data, such as the maximum size of a key's value entries or subkey names, or the number of subkeys. For example, you can call ZwQueryKey, use the returned information to allocate a buffer for a subkey, call ZwEnumerateKey to get the name of the subkey, and pass that name to an RtlXxxRegistry routine. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the registry key to obtain information about. This handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      },
      {
        "in_out": "_In_",
        "type": "KEY_INFORMATION_CLASS",
        "name": "KeyInformationClass",
        "description": "Specifies a KEY_INFORMATION_CLASS value that determines the type of information returned in the KeyInformation buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "KeyInformation",
        "description": "Pointer to a caller-allocated buffer that receives the requested information."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the size, in bytes, of the KeyInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ResultLength",
        "description": "Pointer to a variable that receives the size, in bytes, of the requested key information. If ZwQueryKey returns STATUS_SUCCESS, the variable contains the amount of data returned. If ZwQueryKey returns STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL, you can use the value of the variable to determine the required buffer size."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwEnumerateKey routine returns information about a subkey of an open registry key.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwEnumerateKey returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. Possible error code values include:  ",
    "remarks": "The handle must have been opened with KEY_ENUMERATE_SUB_KEYS access. This is accomplished by passing KEY_ENUMERATE_SUB_KEYS, KEY_READ, or KEY_ALL_ACCESS as the DesiredAccess parameter to ZwCreateKey or ZwOpenKey. The Index parameter is simply a way to select among subkeys of the key referred to by the KeyHandle. Two calls to ZwEnumerateKey with the same Index are not guaranteed to return the same result. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwEnumerateKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the registry key that contains the subkeys to be enumerated. The handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Index",
        "description": "The index of the subkey that you want information for. If the key has n subkeys, the subkeys are numbered from 0 to n-1."
      },
      {
        "in_out": "_In_",
        "type": "KEY_INFORMATION_CLASS",
        "name": "KeyInformationClass",
        "description": "Specifies a KEY_INFORMATION_CLASS enumeration value that determines the type of information to be received by the KeyInformation buffer. Set KeyInformationClass to one of the following values:  KeyBasicInformation KeyFullInformation KeyNodeInformation  If any value not in this list is specified, the routine returns error code STATUS_INVALID_PARAMETER."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "KeyInformation",
        "description": "Pointer to a caller-allocated buffer that receives the requested information. The KeyInformationClass parameter determines the type of information provided."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the size, in bytes, of the KeyInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ResultLength",
        "description": "Pointer to a variable that receives the size, in bytes, of the registry-key information. If ZwEnumerateKey returns STATUS_SUCCESS, you can use the value of this variable to determine the amount of data returned. If the routine returns STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL, you can use the value of this variable to determine the size of buffer required to hold the key information."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwEnumerateValueKey routine gets information about the value entries of an open key.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwEnumerateValueKey returns STATUS_SUCCESS on success, or the appropriate error code on failure. Possible error code values include:  ",
    "remarks": "The KeyHandle passed to ZwEnumerateValueKey must have been opened with KEY_QUERY_VALUE access. This is accomplished by passing KEY_QUERY_VALUE, KEY_READ, or KEY_ALL_ACCESS as the DesiredAccess parameter to ZwCreateKey or ZwOpenKey. The Index is simply a way to select among subkeys with value entries. Two calls to ZwEnumerateValueKey with the same Index are not guaranteed to return the same results. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwEnumerateValueKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the registry key that you want to enumerate value entries for. A successful call to ZwCreateKey or ZwOpenKey creates this handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Index",
        "description": "The zero-based index of the subkey that you want value information for."
      },
      {
        "in_out": "_In_",
        "type": "KEY_VALUE_INFORMATION_CLASS",
        "name": "KeyValueInformationClass",
        "description": "Specifies a KEY_VALUE_INFORMATION_CLASS value that determines the type of information returned in the KeyValueInformation buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "KeyValueInformation",
        "description": "Pointer to a caller-allocated buffer that receives the requested information."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the size, in bytes, of the KeyValueInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ResultLength",
        "description": "Pointer to a variable that receives the size, in bytes, of the value information. If this routine returns STATUS_SUCCESS, the variable indicates the amount of data returned. If this routine returns STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL, the variable indicates the buffer size that is required to hold the value information."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwQueryValueKey routine returns a value entry for a registry key.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryValueKey returns STATUS_SUCCESS on success, or the appropriate error code on failure. Possible error code values include:  ",
    "remarks": "The KeyHandle passed to ZwQueryValueKey must have been opened with KEY_QUERY_VALUE access. This is accomplished by passing KEY_QUERY_VALUE, KEY_READ, or KEY_ALL_ACCESS as the DesiredAccess parameter to ZwCreateKey or ZwOpenKey. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryValueKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the key to read value entries from. This handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ValueName",
        "description": "Pointer to the name of the value entry to obtain data for."
      },
      {
        "in_out": "_In_",
        "type": "KEY_VALUE_INFORMATION_CLASS",
        "name": "KeyValueInformationClass",
        "description": "A KEY_VALUE_INFORMATION_CLASS value that determines the type of information returned in the KeyValueInformation buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "KeyValueInformation",
        "description": "Pointer to a caller-allocated buffer that receives the requested information."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the size, in bytes, of the KeyValueInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ResultLength",
        "description": "Pointer to a variable that receives the size, in bytes, of the key information. If the ZwQueryValueKey routine returns STATUS_SUCCESS, callers can use the value of this variable to determine the amount of data returned. If the routine returns STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL, callers can use the value of this variable to determine the size of buffer required to hold the key information."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwSetValueKey routine creates or replaces a registry key's value entry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwSetValueKey returns an NTSTATUS value. Possible return values include: ",
    "remarks": "The KeyHandle passed to ZwSetValueKey must have been opened with the KEY_SET_VALUE DesiredAccess flag set for this call to succeed. For a description of possible values for DesiredAccess, see ZwCreateKey. If the given key has no existing value entry with a name matching the given ValueName, ZwSetValueKey creates a new value entry with the given name. If a matching value entry name exists, this routine overwrites the original value entry for the given ValueName. Thus, ZwSetValueKey preserves a unique name for each value entry of any particular key. While each value entry name must be unique to its containing key, many different keys in the registry can have value entries with the same names. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetValueKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the registry key to write a value entry for. This handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ValueName",
        "description": "Pointer to the name of the value entry for which the data is to be written. This parameter can be a NULL pointer if the value entry has no name. If a name string is specified and the given name is not unique relative to its containing key, the data for an existing value entry is replaced."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "TitleIndex",
        "description": "This parameter is reserved. Device and intermediate drivers should set this parameter to zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Type",
        "description": "One of the following system-defined types of data to write.  Type ValueMeaning  REG_BINARY  Binary data in any form.   REG_DWORD  A 4-byte numerical value.   REG_DWORD_LITTLE_ENDIAN  A 4-byte numerical value with the least significant byte at the lowest address. Identical to REG_DWORD.   REG_DWORD_BIG_ENDIAN  A 4-byte numerical  value with the least significant byte at the highest address.   REG_EXPAND_SZ  A null-terminated Unicode string that contains unexpanded references to environment variables, such as \"%PATH%\".   REG_LINK  A Unicode string that names a symbolic link. This type is irrelevant to device and intermediate drivers.   REG_MULTI_SZ  An array of null-terminated strings, terminated by another zero.   REG_NONE  Data with no particular type.   REG_SZ  A null-terminated Unicode string.   REG_RESOURCE_LIST  A device driver's list of hardware resources, used by the driver or one of the physical devices it controls, in the \\ResourceMap tree   REG_RESOURCE_REQUIREMENTS_LIST  A device driver's list of possible hardware resources it or one of the physical devices it controls can use, from which the system writes a subset into the \\ResourceMap tree   REG_FULL_RESOURCE_DESCRIPTOR  A list of hardware resources that a physical device is using, detected and written into the \\HardwareDescription tree by the system     Note   Device drivers should not attempt to call ZwSetValueKey to explicitly write value entries in a subkey of the \\Registry...\\ResourceMap key. Only the system can write value entries to the \\Registry...\\HardwareDescription tree."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Data",
        "description": "Pointer to a caller-allocated buffer that contains the data for the value entry."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DataSize",
        "description": "Specifies the size, in bytes, of the Data buffer. If Type is REG_XXX_SZ, this value must include space for any terminating zeros."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwFlushKey routine forces a registry key to be committed to disk.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwFlushKey returns STATUS_SUCCESS if the key information was transferred to disk, or the appropriate error code on failure. ",
    "remarks": "You can flush changes made by ZwCreateKey or ZwSetValueKey by calling ZwFlushKey. This routine does not return until all the changed data that is associated with KeyHandle has been written to disk. ZwFlushKey flushes the entire registry hive for the key, which includes every subkey of the key specified. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwFlushKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the registry key to be flushed to disk. This handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwDeleteKey routine deletes an open key from the registry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwDeleteKey returns an NTSTATUS value. Possible return values include: ",
    "remarks": "The handle must have been opened for DELETE access for this routine to succeed. For more information, see the DesiredAccess parameter for ZwCreateKey. A call to ZwDeleteKey causes the handle that is specified in the KeyHandle parameter\u00e2\u0080\u0094and all other handles to the deleted key\u00e2\u0080\u0094to become invalid. After a call to ZwDeleteKey invalidates the key handles, you must call ZwClose to close the key handles. For more information about working with registry keys, see Using the Registry in a Driver. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwDeleteKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the registry key to be deleted. The handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwClose routine closes an object handle.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwClose returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. In particular, it returns STATUS_INVALID_HANDLE if Handle is not a valid handle, or STATUS_HANDLE_NOT_CLOSABLE if the calling thread does not have permission to close the handle. ",
    "remarks": "ZwClose is a generic routine that operates on any type of object. Closing an open object handle causes that handle to become invalid. The system also decrements the handle count for the object and checks whether the object can be deleted. The system does not actually delete the object until all of the object's handles are closed and no referenced pointers remain. A driver must close every handle that it opens as soon as the handle is no longer required. Kernel handles, which are those that are opened by a system thread or by specifying the OBJ_KERNEL_HANDLE flag, can be closed only when the previous processor mode is KernelMode. This requirement applies both to system threads and to dispatch routines for IRPs that were issued from kernel mode. (For more information about the previous processor mode, see ExGetPreviousMode.) For example, a handle that ZwCreateKey returns to a DriverEntry routine cannot subsequently be closed by the same driver's dispatch routines. A DriverEntry routine runs in a system process, whereas dispatch routines usually run either in the context of the thread issuing the current I/O request, or, for lower-level drivers, in an arbitrary thread context. A nonkernel handle can be closed only if one of two conditions is met: The previous processor mode is KernelMode, or the calling thread has sufficient permission to close the handle. An example of the latter occurs when the calling thread is the one that created the handle. Callers of ZwClose should not assume that this routine automatically waits for all I/O to complete prior to returning. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwClose",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "Handle to an object of any type."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The IoCreateDevice routine creates a device object for use by a driver.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoCreateDevice returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. A partial list of the failure codes returned by this function includes: ",
    "remarks": "IoCreateDevice creates a device object and returns a pointer to the object. The caller is responsible for deleting the object when it is no longer needed by calling IoDeleteDevice. IoCreateDevice can only be used to create an unnamed device object, or a named device object for which a security descriptor is set by an INF file. Otherwise, drivers must use IoCreateDeviceSecure to create named device objects. For more information, see Creating a Device Object. The caller is responsible for setting certain members of the returned device object. For more information, see Initializing a Device Object and the device-type-specific documentation for your device. Be careful to specify the DeviceType and DeviceCharacteristics values in the correct parameters. Both parameters use system-defined FILE_XXX constants and some driver writers specify the values in the wrong parameters by mistake. A remote file system that creates a named device object for a network redirector, and that registers using FsRtlRegisterUncProvider, must specify FILE_REMOTE_DEVICE as one of the options in the DeviceCharacteristics parameter of IoCreateDevice. Device objects for disks, tapes, CD-ROMs, and RAM disks are given a Volume Parameter Block (VPB) that is initialized to indicate that the volume has never been mounted on the device. If a driver's call to IoCreateDevice returns an error, the driver should release any resources that it allocated for that device. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoCreateDevice",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDRIVER_OBJECT",
        "name": "DriverObject",
        "description": "Pointer to the driver object for the caller. Each driver receives a pointer to its driver object in a parameter to its DriverEntry routine. WDM function and filter drivers also receive a driver object pointer in their AddDevice routines."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DeviceExtensionSize",
        "description": "Specifies the driver-determined number of bytes to be allocated for the device extension of the device object. The internal structure of the device extension is driver-defined."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "DeviceName",
        "description": "Optionally points to a buffer containing a null-terminated Unicode string that names the device object. The string must be a full path name. WDM filter and function drivers do not name their device objects. For more information, see Named Device Objects.       Note  If a device name is not supplied (that is, DeviceName is NULL), the device object created by IoCreateDevice will not (and cannot) have a discretionary access control list (DACL) associated with it. For additional information, see Security Descriptors."
      },
      {
        "in_out": "_In_",
        "type": "DEVICE_TYPE",
        "name": "DeviceType",
        "description": "Specifies one of the system-defined FILE_DEVICE_XXX constants that indicate the type of device (such as FILE_DEVICE_DISK or FILE_DEVICE_KEYBOARD) or a vendor-defined value for a new type of device. For more information, see Specifying Device Types."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DeviceCharacteristics",
        "description": "Specifies one or more system-defined constants, ORed together, that provide additional information about the driver's device. For a list of possible device characteristics, see DEVICE_OBJECT. For more information about how to specify device characteristics, see Specifying Device Characteristics. Most drivers specify FILE_DEVICE_SECURE_OPEN for this parameter."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Exclusive",
        "description": "Specifies if the device object represents an exclusive device. Most drivers set this value to FALSE. For more information about exclusive access, see Specifying Exclusive Access to Device Objects."
      },
      {
        "in_out": "_Out_",
        "type": "PDEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Pointer to a variable that receives a pointer to the newly created DEVICE_OBJECT structure. The DEVICE_OBJECT structure is allocated from nonpaged pool."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoDeleteDevice routine removes a device object from the system, for example, when the underlying device is removed from the system.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "When handling a PnP IRP_MN_REMOVE_DEVICE request, a PnP driver calls IoDeleteDevice to delete any associated device objects. See Handling an IRP_MN_REMOVE_DEVICE Request for details. A legacy driver should call this routine when it is being unloaded or when its DriverEntry routine encounters a fatal initialization error, such as being unable to properly initialize a physical device. This routine also is called when a driver reconfigures its devices dynamically. For example, a disk driver called to repartition a disk would call IoDeleteDevice to tear down the device objects representing partitions to be replaced. A driver must release certain resources for which the driver supplied storage in its device extension before it calls IoDeleteDevice. For example, if the driver stores the pointer to its interrupt object(s) in the device extension, it must call IoDisconnectInterrupt before calling IoDeleteDevice. A driver can call IoDeleteDevice only once for a given device object. When a driver calls IoDeleteDevice, the I/O manager deletes the target device object if there are no outstanding references to it. However, if any outstanding references remain, the I/O manager marks the device object as \"delete pending\" and deletes the device object when the references are released. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoDeleteDevice",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object to be deleted."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoGetDeviceObjectPointer routine returns a pointer to the top object in the named device object's stack and a pointer to the corresponding file object, if the requested access to the objects can be granted.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetDeviceObjectPointer returns STATUS_SUCCESS if it is successful. Possible error return values include the following status codes: ",
    "remarks": "IoGetDeviceObjectPointer establishes a \"connection\" between the caller and the next-lower-level driver. A successful caller can use the returned device object pointer to initialize its own device objects. It can also be used as an argument to IoAttachDeviceToDeviceStack, IoCallDriver, and any routine that creates IRPs for lower drivers. The returned pointer is a required argument to IoCallDriver. This routine also returns a pointer to the corresponding file object. When unloading, a driver can dereference the file object as a means of indirectly dereferencing the device object. To do so, the driver calls ObDereferenceObject from its Unload routine, passing the file object pointer returned by IoGetDeviceObjectPointer. Failure to dereference the device object in a driver's Unload routine prevents the next-lower driver from being unloaded. However, drivers that close the file object before the unload process must take out an extra reference on the device object before dereferencing the file object. Otherwise, dereferencing the file object can lead to a premature deletion of the device object. To get a pointer to the highest-level driver in the file system driver stack, a driver must ensure that the file system is mounted; if it is not, this routine traverses the storage device stack. To ensure that the file system is mounted on the storage device, the driver must specify an appropriate access mask, such as FILE_READ_DATA or FILE_WRITE_ATTRIBUTES, in the DesiredAccess parameter. Specifying FILE_READ_ATTRIBUTES does not cause the file system to be mounted. After any higher-level driver has chained itself over another driver by successfully calling this routine, the higher-level driver must set the StackSize field in its device object to that of the next-lower-level driver's device object plus one. Callers of IoGetDeviceObjectPointer must be running at IRQL = PASSIVE_LEVEL. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoGetDeviceObjectPointer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ObjectName",
        "description": "Pointer to a buffer that contains a Unicode string that is the name of the device object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies the ACCESS_MASK value that represents the desired access. Usually DesiredAccess is FILE_READ_DATA. Infrequently, the FILE_WRITE_DATA, or FILE_ALL_ACCESS access rights are specified."
      },
      {
        "in_out": "_Out_",
        "type": "PFILE_OBJECT*",
        "name": "FileObject",
        "description": "Pointer to the file object that represents the corresponding device object to user-mode code if the call is successful."
      },
      {
        "in_out": "_Out_",
        "type": "PDEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Pointer to the device object that represents the named logical, virtual, or physical device if the call is successful."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoAttachDeviceToDeviceStack routine attaches the caller's device object to the highest device object in the chain and returns a pointer to the previously highest device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoAttachDeviceToDeviceStack returns a pointer to the device object to which the SourceDevice was attached. The returned device object pointer can differ from TargetDevice if TargetDevice had additional drivers layered on top of it. IoAttachDeviceToDeviceStack returns NULL if it could not attach the device object because, for example, the target device was being unloaded. ",
    "remarks": "IoAttachDeviceToDeviceStack establishes layering between drivers so that the same IRPs are sent to each driver in the chain. An intermediate driver can use this routine during initialization to attach its own device object to another driver's device object. Subsequent I/O requests sent to TargetDevice are sent first to the intermediate driver. This routine sets the AlignmentRequirement in SourceDevice  to the value in the next-lower device object and sets the StackSize to the value in the next-lower-object plus one. A driver writer must take care to call this routine before any drivers that must layer on top of their driver. IoAttachDeviceToDeviceStack attaches SourceDevice to the highest device object currently layered in the chain and has no way to determine whether drivers are being layered in the correct order. A driver that acquired a pointer to the target device by calling IoGetDeviceObjectPointer should call ObDereferenceObject with the file object pointer that was returned by IoGetDeviceObjectPointer to release its reference to the file object before it detaches its own device object, for example, when such a higher-level driver is unloaded. ",
    "return_type": "PDEVICE_OBJECT",
    "category": "Drivers",
    "name": "IoAttachDeviceToDeviceStack",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "SourceDevice",
        "description": "Pointer to the caller-created device object."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "TargetDevice",
        "description": "Pointer to another driver's device object, such as a pointer returned by a preceding call to IoGetDeviceObjectPointer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoGetAttachedDeviceReference routine returns a pointer to the highest level device object in a driver stack and increments the reference count on that object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetAttachedDeviceReference returns a pointer to the highest level device object in a stack of attached device objects after incrementing the reference count on the object. ",
    "remarks": "If the device object at DeviceObject has no device objects attached to it, DeviceObject and the returned pointer are equal. Device driver writers must ensure that when they have completed all operations that required them to make this call, that they call ObDereferenceObject with the device object pointer returned by this routine. Failure to do so will prevent the system from freeing or deleting the device object because of an outstanding reference count. ",
    "return_type": "PDEVICE_OBJECT",
    "category": "Drivers",
    "name": "IoGetAttachedDeviceReference",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object for which the topmost attached device object is retrieved."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoDetachDevice routine releases an attachment between the caller's device object and a lower driver's device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "IoDetachDevice decrements the reference count of the TargetDevice object. If the reference count goes to zero and the lower driver has been marked for an unload operation, the lower driver is unloaded. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoDetachDevice",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PDEVICE_OBJECT",
        "name": "TargetDevice",
        "description": "Pointer to the lower driver's device object. The caller previously called IoAttachDevice or IoAttachDeviceToDeviceStack successfully to get this pointer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoAllocateDriverObjectExtension routine allocates a per-driver context area, called a driver object extension, and assigns a unique identifier to it.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoAllocateDriverObjectExtension returns one of the following NTSTATUS codes:  ",
    "remarks": "Memory allocated by the system for the driver object extension is resident storage and is accessible from any IRQL. The allocated storage is automatically freed by the I/O manager when the driver object is deleted. Callers of this routine must provide a unique identifier for ClientIdentificationAddress. To retrieve a pointer to the context area, a caller passes the ClientIdentificationAddress to IoGetDriverObjectExtension. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoAllocateDriverObjectExtension",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDRIVER_OBJECT",
        "name": "DriverObject",
        "description": "Pointer to a driver object to which the context area will be associated."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientIdentificationAddress",
        "description": "Specifies a unique identifier for the context area to be allocated."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DriverObjectExtensionSize",
        "description": "Specifies the length, in bytes, of the context area to be allocated."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "DriverObjectExtension",
        "description": "Pointer to, on completion, the allocated context area."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoGetDriverObjectExtension routine retrieves a previously allocated per-driver context area.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetDriverObjectExtension returns a pointer to the context area, if any or returns NULL. ",
    "remarks": "Drivers call IoGetDriverObjectExtension to retrieve a pointer to a previously allocated extension area. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "IoGetDriverObjectExtension",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDRIVER_OBJECT",
        "name": "DriverObject",
        "description": "Specifies the driver object with which the context area is associated."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientIdentificationAddress",
        "description": "Specifies the unique identifier, provided when it was allocated, of the context area to be retrieved."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoIsWdmVersionAvailable routine checks whether a given WDM version is supported by the operating system.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoIsWdmVersionAvailable returns TRUE if the version of WDM that the operating system provides is greater than or equal to the version number of WDM being requested. Otherwise, it returns FALSE. ",
    "remarks": "Drivers should use the RtlIsNtDdiVersionAvailable routine instead of the IoIsWdmVersionAvailable routine. Cross-platform drivers should use this routine to check the WDM version before performing any operations that vary by platform or are not supported in all versions of WDM. The WDM_MAJORVERSION and WDM_MINORVERSION constants, which are defined in the Wdm.h header file, specify the WDM major and minor version numbers for the current version of Windows. The following lists the WDM version provided with each operating system.  Note that the minor version number is defined as a hexadecimal value. Later versions of WDM support all the features available in earlier versions of WDM; that is, each version of WDM is a superset of the previous WDM version. The following call returns TRUE on any of the listed operating systems, because all these systems support all the features of WDM 1.0: The following example shows how a driver can dynamically detect the current operating system: As the example shows, calling IoIsWdmVersionAvailable(1, 5) returns TRUE on Windows Me, Windows 2000, and any succeeding operating systems, but FALSE on Windows 98 and Windows 98 SE. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IoIsWdmVersionAvailable",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "MajorVersion",
        "description": "Specifies the major version number of WDM that is requested."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "MinorVersion",
        "description": "Specifies the minor version number of WDM that is requested."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoDeleteSymbolicLink routine removes a symbolic link from the system.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoDeleteSymbolicLink returns STATUS_SUCCESS if the symbolic link object is deleted. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoDeleteSymbolicLink",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "SymbolicLinkName",
        "description": "Pointer to a buffered Unicode string that is the user-visible name for the symbolic link."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoAssignArcName routine creates a symbolic link between the ARC name of a physical device and the name of the corresponding device object when it has been created.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "Drivers of hard disk devices need not call this routine. Drivers of other mass storage devices, including floppy, CD-ROM, and tape devices, should call IoAssignArcName during their initialization. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoAssignArcName",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ArcName",
        "description": "Pointer to a buffer containing the ARC name of the device. The ARC name must be a Unicode string."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "DeviceName",
        "description": "Pointer to a buffer containing the name of the device object, representing the same device. The device object name must be a Unicode string."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoDeassignArcName routine removes a symbolic link between the ARC name for a device and the named device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "IoDeassignArcName is generally called if the driver is deleting the device object, for example, when the driver is unloading. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoDeassignArcName",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ArcName",
        "description": "Pointer to a buffered Unicode string that is the ARC name."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoSetShareAccess routine sets the access rights for sharing the given file object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Only highest-level kernel-mode drivers should call this routine. The call must occur in the context of the first thread that attempts to open the FileObject. This routine sets the access and share access information when the FileObject is first opened. It returns a pointer to the common share-access data structure associated with FileObject. Callers should save this pointer for later use when updating the access or closing the file. Generally, file system drivers (FSDs) are most likely to call this routine. However, other highest-level drivers can call IoSetShareAccess to control the kind of access allowed to a driver-created device object associated with the given FileObject. IoSetShareAccess is not an atomic operation. Therefore, drivers calling this routine must protect the shared file object passed to IoSetShareAccess by means of some kind of lock, such as a mutex or a resource lock, in order to prevent corruption of the shared access counts. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoSetShareAccess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that represents the type of access requested for the FileObject. See IoCreateFile for a complete list of system-defined DesiredAccess flags."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DesiredShareAccess",
        "description": "Specifies the type of share access to be set for the file object. This value can be zero, or any combination of the following:   FILE_SHARE_READ   FILE_SHARE_WRITE   FILE_SHARE_DELETE"
      },
      {
        "in_out": "_Inout_",
        "type": "PFILE_OBJECT",
        "name": "FileObject",
        "description": "Pointer to the file object whose share access is being set or reset."
      },
      {
        "in_out": "_Out_",
        "type": "PSHARE_ACCESS",
        "name": "ShareAccess",
        "description": "Pointer to the SHARE_ACCESS structure associated with FileObject. Drivers should treat this structure as opaque."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 11,
    "description": "The IoConnectInterrupt routine registers a device driver's InterruptService routine (ISR), so that it will be called when a device interrupts on any of a specified set of processors.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoConnectInterrupt can return one of the following NTSTATUS values: ",
    "remarks": "New drivers should use the IoConnectInterruptEx routine, which is easier to use. Drivers for devices that support message-signaled interrupts (MSI) must use IoConnectInterruptEx. A PnP driver should call IoConnectInterrupt as part of device start-up, before it completes the PnP IRP_MN_START_DEVICE request. When a driver receives an IRP_MN_START_DEVICE request, the driver receives raw and translated hardware resources in the Parameters.StartDevice.AllocatedResources and  Parameters.StartDevice.AllocatedResourcesTranslated members of the IRP's IO_STACK_LOCATION structure, respectively. To connect its interrupt, the driver uses the resources at AllocatedResourcesTranslated.List.PartialResourceList.PartialDescriptors[]. The driver must scan the array of partial descriptors for resources of type CmResourceTypeInterrupt. If the driver supplies the storage for the SpinLock, it must call KeInitializeSpinLock before passing its interrupt spin lock to IoConnectInterrupt. On return from a successful call to IoConnectInterrupt, the caller's ISR can be called if interrupts are enabled on the driver's device or if ShareVector was set to TRUE. Drivers must not enable interrupts until after IoConnectInterrupt returns. The KAFFINITY type is an affinity mask that represents a set of logical processors in a group. The KAFFINITY type is 32 bits on a 32-bit version of Windows and is 64 bits on a 64-bit version of Windows. If a group contains n logical processors, the processors are numbered from 0 to n-1. Processor number i in the group is represented by bit i in the affinity mask, where i is in the range 0 to n-1. Affinity mask bits that do not correspond to logical processors are always zero. For example, if a KAFFINITY value identifies the active processors in a group, the mask bit for a processor is one if the processor is active, and is zero if the processor is not active. The number of bits in the affinity mask determines the maximum number of logical processors in a group. For a 64-bit version of Windows, the maximum number of processors per group is 64. For a 32-bit version of Windows, the maximum number of processors per group is 32. Call the KeQueryMaximumProcessorCountEx routine to obtain the maximum number of processors per group. This number depends on the hardware configuration of the multiprocessor system, but can never exceed the fixed 64-processor and 32-processor limits that are set by the 64-bit and 32-bit versions of Windows, respectively. The GROUP_AFFINITY structure contains an affinity mask and a group number. The group number identifies the group to which the affinity mask applies. Kernel routines that use the KAFFINITY type include IoConnectInterrupt, KeQueryActiveProcessorCount, and KeQueryActiveProcessors. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoConnectInterrupt",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKINTERRUPT*",
        "name": "InterruptObject",
        "description": "Pointer to the address of driver-supplied storage for a pointer to a set of interrupt objects. This pointer must be passed in subsequent calls to KeSynchronizeExecution."
      },
      {
        "in_out": "_In_",
        "type": "PKSERVICE_ROUTINE",
        "name": "ServiceRoutine",
        "description": "Pointer to the entry point for the driver-supplied InterruptService routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ServiceContext",
        "description": "Pointer to the driver-determined context that will be supplied to the InterruptService routine when it is called. The ServiceContext area must be in resident memory: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the device driver. See Providing ISR Context Information for details."
      },
      {
        "in_out": "_In_opt_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Pointer to an initialized spin lock, for which the driver supplies the storage, that will be used to synchronize access to driver-determined data shared by other driver routines. This parameter is required if the ISR handles more than one vector or if the driver has more than one ISR. Otherwise, the driver need not allocate storage for an interrupt spin lock and the input pointer is NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Vector",
        "description": "Specifies the interrupt vector passed in the interrupt resource at the u.Interrupt.Vector member of CM_PARTIAL_RESOURCE_DESCRIPTOR."
      },
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "Irql",
        "description": "Specifies the DIRQL passed in the interrupt resource at the u.Interrupt.Level member of CM_PARTIAL_RESOURCE_DESCRIPTOR."
      },
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "SynchronizeIrql",
        "description": "Specifies the DIRQL at which the ISR will run. If the ISR handles more than one interrupt vector or the driver has more than one ISR, this value must be the highest of the Irql values passed at u.Interrupt.Level in each interrupt resource. Otherwise, the Irql and SynchronizeIrql values are identical."
      },
      {
        "in_out": "_In_",
        "type": "KINTERRUPT_MODE",
        "name": "InterruptMode",
        "description": "Specifies whether the device interrupt is LevelSensitive or Latched."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ShareVector",
        "description": "Specifies whether the interrupt vector is sharable."
      },
      {
        "in_out": "_In_",
        "type": "KAFFINITY",
        "name": "ProcessorEnableMask",
        "description": "Specifies a KAFFINITY value representing the set of processors on which device interrupts can occur in this platform. This value is passed in the interrupt resource at u.Interrupt.Affinity."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "FloatingSave",
        "description": "Specifies whether to save the floating-point stack when the driver's device interrupts. For x86-based and Itanium-based platforms, this value must be set to FALSE. For more information about saving floating-point and MMX state, see Using Floating Point or MMX in a WDM Driver."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "For more information, see the WdmlibIoConnectInterruptEx function.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "For more information, see the WdmlibIoConnectInterruptEx function. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoConnectInterruptEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIO_CONNECT_INTERRUPT_PARAMETERS",
        "name": "Parameters",
        "description": "For more information, see the WdmlibIoConnectInterruptEx function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoDisconnectInterrupt routine releases a device driver's set of interrupt object(s) when the device is paused or removed, or when the driver is being unloaded.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None. ",
    "remarks": "The driver should configure the device to issue interrupts only when these interrupts are connected. Failure to prevent a device from issuing interrupts when the interrupts are disconnected might cause system instability. For example, if a device shares a level-triggered interrupt line with other devices, and the device issues an interrupt request when the device's interrupts are disconnected, the other devices on the line will not acknowledge the interrupt and the interrupt will continue to fire. Before calling IoDisconnectInterrupt, the driver should configure the device to stop issuing interrupts. After calling IoConnectInterrupt, the driver should configure the device to start issuing interrupts. If the driver stored the pointer to its interrupt object(s) in the device extension of its device object or in the controller extension of its controller object, it must call IoDisconnectInterrupt before it calls IoDeleteDevice or IoDeleteController. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoDisconnectInterrupt",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKINTERRUPT",
        "name": "InterruptObject",
        "description": "A pointer to a KINTERRUPT structure. The caller obtained this pointer from the IoConnectInterrupt call that previously connected the interrupt or interrupts."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeInitializeSpinLock routine initializes a variable of type KSPIN_LOCK.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine must be called before an initial call to KeAcquireSpinLock, to KeAcquireInStackQueuedSpinLock, or to any other support routine that requires a spin lock as an argument. Storage for a spin lock object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. For more information about spin locks, see Spin Locks. Callers of this routine can be running at any IRQL. Usually, a caller is running at IRQL = PASSIVE_LEVEL in an AddDevice routine. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeSpinLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Pointer to a spin lock, for which the caller must provide the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The InitializeListHead routine initializes a LIST_ENTRY structure that represents the head of a doubly linked list.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The InitializeListHead routine sets the Flink and Blink members of ListHead to point to ListHead. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. Callers of InitializeListHead can be running at any IRQL. If InitializeListHead is called at IRQL >= DISPATCH_LEVEL the storage for ListHead must be resident. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "InitializeListHead",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to a LIST_ENTRY structure that serves as the list header."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExInitializeSListHead routine initializes an SLIST_HEADER structure that represents the head of a sequenced singly linked list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "For more information about using this routine to implement a sequenced singly linked list, see Singly and Doubly Linked Lists. Callers of ExInitializeSListHead can be running at any IRQL. If ExInitializeSListHead is called at IRQL >= DISPATCH_LEVEL the storage for SListHead must be resident. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExInitializeSListHead",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "SListHead",
        "description": "A pointer to the SLIST_HEADER structure to initialize. The structure must be 16-byte aligned on 64-bit platforms."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeInitializeDeviceQueue routine initializes a device queue object to a not-busy state.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "KeInitializeDeviceQueue initializes the specified device queue and sets its state to not-busy. A driver should call KeInitializeDeviceQueue from its AddDevice routine after creating the device object for the associated device. Storage for the device queue object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeDeviceQueue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKDEVICE_QUEUE",
        "name": "DeviceQueue",
        "description": "Pointer to a device queue object for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The IoCsqInitialize routine initializes the driver's cancel-safe IRP queue dispatch table.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. ",
    "remarks": "The IoCsqInitialize routine initializes an IO_CSQ structure that describes a driver's cancel-safe IRP queue. Drivers can also use IoCsqInitializeEx to create an IRP queue with extended capabilities. For more information, see Cancel-Safe IRP Queues. Note that IoCsqXxx routines use the DriverContext[3] member of the IRP to hold IRP context information. Drivers that use these routines to queue IRPs must leave that member unused. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoCsqInitialize",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PIO_CSQ",
        "name": "Csq",
        "description": "Pointer to the IO_CSQ structure to be initialized by IoCsqInitialize."
      },
      {
        "in_out": "_In_",
        "type": "PIO_CSQ_INSERT_IRP",
        "name": "CsqInsertIrp",
        "description": "Pointer to the driver-defined CsqInsertIrp function for the driver's cancel-safe IRP queue."
      },
      {
        "in_out": "_In_",
        "type": "PIO_CSQ_REMOVE_IRP",
        "name": "CsqRemoveIrp",
        "description": "Pointer to the driver-defined CsqRemoveIrp function for the driver's cancel-safe IRP queue."
      },
      {
        "in_out": "_In_",
        "type": "PIO_CSQ_PEEK_NEXT_IRP",
        "name": "CsqPeekNextIrp",
        "description": "Pointer to the driver-defined CsqPeekNextIrp function for the driver's cancel-safe IRP queue."
      },
      {
        "in_out": "_In_",
        "type": "PIO_CSQ_ACQUIRE_LOCK",
        "name": "CsqAcquireLock",
        "description": "Pointer to the driver-defined CsqAcquireLock function for the driver's cancel-safe IRP queue."
      },
      {
        "in_out": "_In_",
        "type": "PIO_CSQ_RELEASE_LOCK",
        "name": "CsqReleaseLock",
        "description": "Pointer to the driver-defined CsqReleaseLock function for the driver's cancel-safe IRP queue."
      },
      {
        "in_out": "_In_",
        "type": "PIO_CSQ_COMPLETE_CANCELED_IRP",
        "name": "CsqCompleteCanceledIrp",
        "description": "Pointer to the driver-defined CsqCompleteCanceledIrp function for the driver's cancel-safe IRP queue."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 11,
    "description": "The ZwCreateFile routine creates a new file or opens an existing file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwCreateFile returns STATUS_SUCCESS on success or an appropriate NTSTATUS error code on failure. In the latter case, the caller can determine the cause of the failure by checking the IoStatusBlock parameter. ",
    "remarks": "ZwCreateFile supplies a handle that the caller can use to manipulate a file's data, or the file object's state and attributes. For more information, see Using Files in a Driver. Once the handle pointed to by FileHandle is no longer in use, the driver must call ZwClose to close it. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. There are two alternate ways to specify the name of the file to be created or opened with ZwCreateFile: Setting certain flags in the DesiredAccess parameter results in the following effects: The ShareAccess parameter determines whether separate threads can access the same file, possibly simultaneously. Provided that both callers have the appropriate access privileges, the file can be successfully opened and shared. If the original caller of ZwCreateFile does not specify FILE_SHARE_READ, FILE_SHARE_WRITE, or FILE_SHARE_DELETE, no other caller can open the file\u00e2\u0080\u0094that is, the original caller is granted exclusive access. To successfully open a shared file, the DesiredAccess flags must be compatible with the DesiredAccess and ShareAccess flags of all the previous open operations that have not yet been released through . That is, the DesiredAccess specified to ZwCreateFile for a given file must not conflict with the accesses that other openers of the file have disallowed. The CreateDisposition value FILE_SUPERSEDE requires that the caller have DELETE access to a existing file object. If so, a successful call to ZwCreateFile with FILE_SUPERSEDE on an existing file effectively deletes that file, and then recreates it. This implies that, if the file has already been opened by another thread, it opened the file by specifying a ShareAccess parameter with the FILE_SHARE_DELETE flag set. Note that this type of disposition is consistent with the POSIX style of overwriting files. The CreateDisposition values FILE_OVERWRITE_IF and FILE_SUPERSEDE are similar. If ZwCreateFile is called with a existing file and either of these CreateDisposition values, the file will be replaced. Overwriting a file is semantically equivalent to a supersede operation, except for the following: The FILE_DIRECTORY_FILE CreateOptions value specifies that the file to be created or opened is a directory. When a directory file is created, the file system creates an appropriate structure on the disk to represent an empty directory for that particular file system's on-disk structure. If this option was specified and the given file to be opened is not a directory file, or if the caller specified an inconsistent CreateOptions or CreateDisposition value, the call to ZwCreateFile will fail. The FILE_NO_INTERMEDIATE_BUFFERING CreateOptions flag prevents the file system from performing any intermediate buffering on behalf of the caller. Specifying this flag places the following restrictions on the caller's parameters to other ZwXxxFile routines. The FILE_SYNCHRONOUS_IO_ALERT and FILE_SYNCHRONOUS_IO_NONALERT CreateOptions flags, which are mutually exclusive as their names suggest, specify that all I/O operations on the file will be synchronous\u00e2\u0080\u0094as long as they occur through the file object referred to by the returned FileHandle. All I/O on such a file is serialized across all threads using the returned handle. If either of these CreateOptions flags is set, the SYNCHRONIZE DesiredAccess flag must also be set\u00e2\u0080\u0094to compel the I/O manager to use the file object as a synchronization object. In these cases, the I/O manager keeps track of the current file-position offset, which you can pass to ZwReadFile and ZwWriteFile. Call ZwQueryInformationFile or ZwSetInformationFile to get or set this position. If the CreateOptions FILE_OPEN_REPARSE_POINT flag is not specified and ZwCreateFile attempts to open a file with a reparse point, normal reparse point processing occurs for the file. If, on the other hand, the FILE_OPEN_REPARSE_POINT flag is specified, normal reparse processing does not occur and ZwCreateFile attempts to directly open the reparse point file. In either case, if the open operation was successful, ZwCreateFile returns STATUS_SUCCESS; otherwise, the routine returns an NTSTATUS error code. ZwCreateFile never returns STATUS_REPARSE. The CreateOptions FILE_OPEN_REQUIRING_OPLOCK flag eliminates the time between when you open the file and request an oplock that could potentially allow a third party to open the file and get a sharing violation. An application can use the FILE_OPEN_REQUIRING_OPLOCK flag on ZwCreateFile and then request any oplock. This ensures that an oplock owner will be notified of any subsequent open request that causes a sharing violation. In Windows 7, if other handles exist on the file when an application uses the FILE_OPEN_REQUIRING_OPLOCK flag, the create operation will fail with STATUS_OPLOCK_NOT_GRANTED. This restriction no longer exists starting with Windows 8. If this create operation would break an oplock that already exists on the file, then setting the FILE_OPEN_REQUIRING_OPLOCK flag will cause the create operation to fail with STATUS_CANNOT_BREAK_OPLOCK. The existing oplock will not be broken by this create operation. An application that uses the FILE_OPEN_REQUIRING_OPLOCK flag must request an oplock after this call succeeds, or all subsequent attempts to open the file will be blocked without the benefit of normal oplock processing. Similarly, if this call succeeds but the subsequent oplock request fails, an application that uses this flag must close its handle after it detects that the oplock request has failed. The CreateOptions flag FILE_RESERVE_OPFILTER allows an application to request a Level 1, Batch, or Filter oplock to prevent other applications from getting share violations. However, FILE_RESERVE_OPFILTER is only practically useful for Filter oplocks. To use it, you must complete the following steps: Step three makes this practical only for Filter oplocks. The handle opened in step 3 can have a DesiredAccess that contains a maximum of FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_EXECUTE | SYNCHRONIZE | READ_CONTROL and still not break a Filter oplock. However, any DesiredAccess greater than FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE will break a Level 1 or Batch oplock and make the FILE_RESERVE_OPFILTER flag useless for those oplock types. NTFS is the only Microsoft file system that implements FILE_RESERVE_OPFILTER. Callers of ZwCreateFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "FileHandle",
        "description": "A pointer to a HANDLE variable that receives a handle to the file."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. In addition to the access rights that are defined for all types of objects, the caller can specify any of the following access rights, which are specific to files.  ACCESS_MASK flagAllows caller to do this  FILE_READ_DATA  Read data from the file.   FILE_READ_ATTRIBUTES  Read the attributes of the file. (For more information, see the description of the FileAttributes parameter.)   FILE_READ_EA  Read the extended attributes (EAs) of the file. This flag is irrelevant for device and intermediate drivers.   FILE_WRITE_DATA  Write data to the file.   FILE_WRITE_ATTRIBUTES  Write the attributes of the file. (For more information, see the description of the FileAttributes parameter.)   FILE_WRITE_EA   Change the extended attributes (EAs) of the file. This flag is irrelevant for device and intermediate drivers.   FILE_APPEND_DATA  Append data to the file.   FILE_EXECUTE  Use system paging I/O to read data from the file into memory. This flag is irrelevant for device and intermediate drivers.     Note    Do not specify FILE_READ_DATA, FILE_WRITE_DATA, FILE_APPEND_DATA, or FILE_EXECUTE when you create or open a directory.   The caller can only specify a generic access right, GENERIC_XXX, for a file, not a directory. Generic access rights correspond to specific access rights as shown in the following table.  Generic access rightSet of specific access rights  GENERIC_READ  STANDARD_RIGHTS_READ, FILE_READ_DATA, FILE_READ_ATTRIBUTES,  FILE_READ_EA, and SYNCHRONIZE.   GENERIC_WRITE  STANDARD_RIGHTS_WRITE, FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, FILE_APPEND_DATA, and SYNCHRONIZE.   GENERIC_EXECUTE  STANDARD_RIGHTS_EXECUTE, FILE_EXECUTE, FILE_READ_ATTRIBUTES, and SYNCHRONIZE. This value is irrelevant for device and intermediate drivers.   GENERIC_ALL  FILE_ALL_ACCESS.     For example, if you specify GENERIC_READ for a file object, the routine maps this value to the FILE_GENERIC_READ bitmask of specific access rights. In the preceding table, the specific access rights that are listed for GENERIC_READ correspond to the access flags that are contained in the FILE_GENERIC_READ bitmask. If the file is actually a directory, the caller can also specify the following generic access rights.  DesiredAccess flagAllows caller to do this  FILE_LIST_DIRECTORY  List the files in the directory.   FILE_TRAVERSE  Traverse the directory, in other words, include the directory in the path of a file.     For more information about access rights, see ACCESS_MASK."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to an IO_STATUS_BLOCK structure that receives the final completion status and other information about the requested operation. In particular, the Information member receives one of the following values:   FILE_CREATED   FILE_OPENED   FILE_OVERWRITTEN   FILE_SUPERSEDED   FILE_EXISTS   FILE_DOES_NOT_EXIST"
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "AllocationSize",
        "description": "A pointer to a LARGE_INTEGER that contains the initial allocation size, in bytes, for a file that is created or overwritten. If AllocationSize is NULL, no allocation size is specified. If no file is created or overwritten, AllocationSize is ignored."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "FileAttributes",
        "description": "Specifies one or more FILE_ATTRIBUTE_XXX flags, which represent the file attributes to set if you create or overwrite a file. The caller usually specifies FILE_ATTRIBUTE_NORMAL, which sets the default attributes. For a list of valid FILE_ATTRIBUTE_XXX flags, see the CreateFile routine in the Microsoft Windows SDK documentation. If no file is created or overwritten, FileAttributes is ignored."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ShareAccess",
        "description": "Type of share access, which is specified as zero or any combination of the following flags.  ShareAccess flagAllows other threads to do this  FILE_SHARE_READ  Read the file   FILE_SHARE_WRITE  Write the file   FILE_SHARE_DELETE  Delete the file     Device and intermediate drivers usually set ShareAccess to zero, which gives the caller exclusive access to the open file."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CreateDisposition",
        "description": "Specifies the action to perform if the file does or does not exist. CreateDisposition can be one of the values in the following table.  CreateDisposition valueAction if file existsAction if file does not exist  FILE_SUPERSEDE  Replace the file.  Create the file.   FILE_CREATE  Return an error.  Create the file.   FILE_OPEN  Open the file.  Return an error.   FILE_OPEN_IF  Open the file.  Create the file.   FILE_OVERWRITE  Open the file, and overwrite it.  Return an error.   FILE_OVERWRITE_IF  Open the file, and overwrite it.  Create the file."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CreateOptions",
        "description": "Specifies the options to apply when the driver creates or opens the file. ..."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "EaBuffer",
        "description": "For device and intermediate drivers, this parameter must be a NULL pointer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EaLength",
        "description": "For device and intermediate drivers, this parameter must be zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryInformationFile routine returns various kinds of information about a file object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryInformationFile returns STATUS_SUCCESS or an appropriate NTSTATUS error code. ",
    "remarks": "ZwQueryInformationFile returns information about the specified file object. Note that it returns zero in any member of a FILE_XXX_INFORMATION structure that is not supported by a particular device or file system. When FileInformationClass = FileNameInformation, the file name is returned in the FILE_NAME_INFORMATION structure. The precise syntax of the file name depends on a number of factors: If ZwQueryInformationFile fails because of a buffer overflow, drivers that implement FileNameInformation should return as many WCHAR characters of the file name as will fit in the buffer and specify the full length that is required in the FileNameLength parameter of the FILE_NAME_INFORMATION structure. You should reissue the query by using the file name length so that you can retrieve the full file name. Drivers that do not follow this pattern might require a gradual increase in length until they retrieve the full file name. For more information about working with files, see Using Files in a Driver. Callers of ZwQueryInformationFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryInformationFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle to a file object. The handle is created by a successful call to ZwCreateFile or ZwOpenFile."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the operation. The Information member receives the number of bytes that this routine actually writes to the FileInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "FileInformation",
        "description": "Pointer to a caller-allocated buffer into which the routine writes the requested information about the file object. The FileInformationClass parameter specifies the type of information that the caller requests."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The size, in bytes, of the buffer pointed to by FileInformation."
      },
      {
        "in_out": "_In_",
        "type": "FILE_INFORMATION_CLASS",
        "name": "FileInformationClass",
        "description": "Specifies the type of information to be returned about the file, in the buffer that FileInformation points to. Device and intermediate drivers can specify any of the following FILE_INFORMATION_CLASS values.  FILE_INFORMATION_CLASS valueType of information returned  FileAccessInformation  A FILE_ACCESS_INFORMATION structure. This structure contains an access mask. For more information about access masks, see ACCESS_MASK.   FileAlignmentInformation  A FILE_ALIGNMENT_INFORMATION structure. The caller can query this information as long as the file is open, without any particular requirements for DesiredAccess. This information is useful if the file was opened with the FILE_NO_INTERMEDIATE_BUFFERING flag specified in the CreateOptions parameter.   FileAllInformation  A FILE_ALL_INFORMATION structure. By combining several file-information structures into a single structure, FILE_ALL_INFORMATION reduces the number of queries required to obtain information about a file.   FileAttributeTagInformation  A FILE_ATTRIBUTE_TAG_INFORMATION structure. The caller must have opened the file with the FILE_READ_ATTRIBUTES flag specified in the DesiredAccess parameter.   FileBasicInformation  A FILE_BASIC_INFORMATION structure. The caller must have opened the file with the FILE_READ_ATTRIBUTES flag specified in the DesiredAccess parameter.   FileEaInformation  A FILE_EA_INFORMATION structure. This structure specifies the size of the extended attributes block that is associated with the file.   FileInternalInformation  A FILE_INTERNAL_INFORMATION structure. This structure specifies a 64-bit file ID that uniquely identifies a file in NTFS. On other file systems, this file ID is not guaranteed to be unique.   FileIoPriorityHintInformation  A FILE_IO_PRIORITY_HINT_INFORMATION structure. The caller must have opened the file with the FILE_READ_DATA flag specified in the DesiredAccess parameter.   FileModeInformation  A FILE_MODE_INFORMATION structure. This structure contains a set of flags that specify the mode in which the file can be accessed. These flags are a subset of the options that can be specified in the CreateOptions parameter of the IoCreateFile routine.   FileNameInformation  A FILE_NAME_INFORMATION structure. The structure can contain the file's full path or only a portion of it. The caller can query this information as long as the file is open, without any particular requirements for DesiredAccess. For more information about the file-name syntax, see the Remarks section later in this topic.   FileNetworkOpenInformation  A FILE_NETWORK_OPEN_INFORMATION structure. The caller must have opened the file with the FILE_READ_ATTRIBUTES flag specified in the DesiredAccess parameter.   FilePositionInformation  A FILE_POSITION_INFORMATION structure. The caller must have opened the file with the DesiredAccess FILE_READ_DATA or FILE_WRITE_DATA flag specified in the DesiredAccess parameter, and with the FILE_SYNCHRONOUS_IO_ALERT or FILE_SYNCHRONOUS_IO_NONALERT flag specified in the CreateOptions parameter.   FileStandardInformation  A FILE_STANDARD_INFORMATION structure. The caller can query this information as long as the file is open, without any particular requirements for DesiredAccess.   FileIsRemoteDeviceInformation  A FILE_IS_REMOTE_DEVICE_INFORMATION structure. The caller can query this information as  long as the file is open, without any particular requirements for DesiredAccess."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The IoGetFileObjectGenericMapping routine returns information about the mapping between each generic access right and the set of specific access rights for file objects.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoGetFileObjectGenericMapping returns a pointer to the GENERIC_MAPPING structure that describes the mapping between each generic access right and the implied set of specific access rights. ",
    "remarks": "",
    "return_type": "PGENERIC_MAPPING",
    "category": "Drivers",
    "name": "IoGetFileObjectGenericMapping",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 9,
    "description": "The ZwReadFile routine reads data from an open file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwReadFile returns either STATUS_SUCCESS or the appropriate NTSTATUS error code. ",
    "remarks": "Callers of ZwReadFile must have already called ZwCreateFile with the FILE_READ_DATA or GENERIC_READ value set in the DesiredAccess parameter. If the preceding call to ZwCreateFile set the FILE_NO_INTERMEDIATE_BUFFERING flag in the CreateOptions parameter to ZwCreateFile, the Length and ByteOffset parameters to ZwReadFile must be multiples of the sector size. For more information, see ZwCreateFile. ZwReadFile begins reading from the given ByteOffset or the current file position into the given Buffer. It terminates the read operation under one of the following conditions: If the caller opened the file with the SYNCHRONIZE flag set in DesiredAccess, the calling thread can synchronize to the completion of the read operation by waiting on the file handle, FileHandle. The handle is signaled each time that an I/O operation that was issued on the handle completes. However, the caller must not wait on a handle that was opened for synchronous file access (FILE_SYNCHRONOUS_IO_NONALERT or FILE_SYNCHRONOUS_IO_ALERT). In this case, ZwReadFile waits on behalf of the caller and does not return until the read operation is complete. The caller can safely wait on the file handle only if all three of the following conditions are met: A driver should call ZwReadFile in the context of the system process if any of the following conditions exist: File and event handles are valid only in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to ZwReadFile in the context of the system process rather than the context of the process that the driver is in. Likewise, ZwReadFile should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread that issues the I/O request. If the driver calls ZwReadFile in the context of a process other than the system one, the APC could be delayed indefinitely, or it might not fire at all. For more information about working with files, see Using Files in a Driver. Callers of ZwReadFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwReadFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle to the file object. This handle is created by a successful call to ZwCreateFile or ZwOpenFile."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "Optionally, a handle to an event object to set to the signaled state after the read operation completes. Device and intermediate drivers should set this parameter to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "This parameter is reserved. Device and intermediate drivers should set this pointer to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "This parameter is reserved. Device and intermediate drivers should set this pointer to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the requested read operation. The Information member receives the number of bytes actually read from the file."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a caller-allocated buffer that receives the data read from the file."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The size, in bytes, of the buffer pointed to by Buffer."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "ByteOffset",
        "description": "Pointer to a variable that specifies the starting byte offset in the file where the read operation will begin. If an attempt is made to read beyond the end of the file, ZwReadFile returns an error. If the call to ZwCreateFile set either of the CreateOptions flags FILE_SYNCHRONOUS_IO_ALERT or FILE_SYNCHRONOUS_IO_NONALERT, the I/O Manager maintains the current file position. If so, the caller of ZwReadFile can specify that the current file position offset be used instead of an explicit ByteOffset value. This specification can be made by using one of the following methods:   Specify a pointer to a LARGE_INTEGER value with the HighPart member set to -1 and the LowPart member set to the system-defined value FILE_USE_FILE_POINTER_POSITION.   Pass a NULL pointer for ByteOffset.   ZwReadFile updates the current file position by adding the number of bytes read when it completes the read operation, if it is using the current file position maintained by the I/O Manager. Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit ByteOffset value to ZwReadFile. Doing this automatically changes the current file position to that ByteOffset value, performs the read operation, and then updates the position according to the number of bytes actually read. This technique gives the caller atomic seek-and-read service."
      },
      {
        "in_out": "_In_opt_",
        "type": "PULONG",
        "name": "Key",
        "description": "Device and intermediate drivers should set this pointer to NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwSetInformationFile routine changes various kinds of information about a file object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwSetInformationFile returns STATUS_SUCCESS or an appropriate error status. ",
    "remarks": "ZwSetInformationFile changes information about a file. It ignores any member of a FILE_XXX_INFORMATION structure that is not supported by a particular device or file system. If you set FileInformationClass to FileDispositionInformation, you can subsequently pass FileHandle to ZwClose but not to any other ZwXxxFile routine. Because FileDispositionInformation causes the file to be marked for deletion, it is a programming error to attempt any subsequent operation on the handle other than closing it. If you set FileInformationClass to FilePositionInformation, and the preceding call to ZwCreateFile included the FILE_NO_INTERMEDIATE_BUFFERING flag in the CreateOptions parameter, certain restrictions on the CurrentByteOffset member of the FILE_POSITION_INFORMATION structure are enforced. For more information, see ZwCreateFile. If you set FileInformationClass to FileEndOfFileInformation, and the EndOfFile member of FILE_END_OF_FILE_INFORMATION specifies an offset beyond the current end-of-file mark, ZwSetInformationFile extends the file and pads the extension with zeros. For more information about working with files, see Using Files in a Driver. Callers of ZwSetInformationFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetInformationFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle to the file object. This handle is created by a successful call to ZwCreateFile or ZwOpenFile."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the requested operation. The Information member receives the number of bytes set on the file."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "FileInformation",
        "description": "Pointer to a buffer that contains the information to set for the file. The particular structure in this buffer is determined by the FileInformationClass parameter. Setting any member of the structure to zero tells ZwSetInformationFile to leave the current information about the file for that member unchanged."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The size, in bytes, of the FileInformation buffer."
      },
      {
        "in_out": "_In_",
        "type": "FILE_INFORMATION_CLASS",
        "name": "FileInformationClass",
        "description": "The type of information, supplied in the buffer pointed to by FileInformation, to set for the file. Device and intermediate drivers can specify any of the following FILE_INFORMATION_CLASS values.  FileInformationClass ValueMeaning  FileBasicInformation  Change the information that is supplied in a FILE_BASIC_INFORMATION structure. The caller must have opened the file with the FILE_WRITE_ATTRIBUTES flag set in the DesiredAccess parameter.   FileDispositionInformation  Usually, sets the DeleteFile member of a FILE_DISPOSITION_INFORMATION to TRUE, so the file can be deleted when ZwClose is called to release the last open handle to the file object. The caller must have opened the file with the DELETE flag set in the DesiredAccess parameter.   FileEndOfFileInformation  Change the current end-of-file information, supplied in a FILE_END_OF_FILE_INFORMATION structure. The operation can either truncate or extend the file. The caller must have opened the file with the FILE_WRITE_DATA flag set in the DesiredAccess parameter.   FileIoPriorityHintInformation  Change the current default IRP priority hint for the file handle. The new value is supplied in a FILE_IO_PRIORITY_HINT_INFORMATION structure. Note    This structure must be 8-byte aligned.     FileLinkInformation  Create a hard link to an existing file, which is specified in a FILE_LINK_INFORMATION structure. Not all file systems support hard links; for example NTFS does while FAT does not.   FilePositionInformation  Change the current file information, which is stored in a FILE_POSITION_INFORMATION structure.   FileRenameInformation  Change the current file name, which is supplied in a FILE_RENAME_INFORMATION structure. The caller must have DELETE access to the file.   FileShortNameInformation  Change the current short file name, which is supplied in a FILE_NAME_INFORMATION structure. The file must be on an NTFS volume, and the caller must have opened the file with the DesiredAccess DELETE flag set in the DesiredAccess parameter.   FileValidDataLengthInformation  Change the current valid data length for the file, which is supplied in a FILE_VALID_DATA_LENGTH_INFORMATION structure. The file must be on an NTFS volume, and the caller must have opened the file with the FILE_WRITE_DATA flag set in the DesiredAccess parameter. Non-administrators and remote users must have the SeManageVolumePrivilege privilege.   FileReplaceCompletionInformation  Change or remove the I/O completion port for the specified file handle. The caller supplies a pointer to a FILE_COMPLETION_INFORMATION structure that specifies a port handle and a completion key. If the port handle is non-NULL, this handle specifies a new I/O completion port to associate with the file handle. To remove the I/O completion port associated with the file handle, set the port handle in the structure to NULL. To get a port handle, a user-mode caller can call the CreateIoCompletionPort function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 9,
    "description": "The ZwWriteFile routine writes data to an open file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwWriteFile returns STATUS_SUCCESS on success or the appropriate NTSTATUS error code on failure. ",
    "remarks": "Callers of ZwWriteFile must have already called ZwCreateFile with the FILE_WRITE_DATA, FILE_APPEND_DATA, or GENERIC_WRITE flag set in the DesiredAccess parameter. Note that having only FILE_APPEND_DATA access to a file does not allow the caller to write anywhere in the file except at the current end-of-file mark, while having FILE_WRITE_DATA access to a file does not preclude the caller from writing to or beyond the end of a file. If the preceding call to ZwCreateFile set the CreateOptions flag FILE_NO_INTERMEDIATE_BUFFERING, the Length and ByteOffset parameters to ZwWriteFile must be an integral of the sector size. For more information, see ZwCreateFile. ZwWriteFile begins the write operation to the file at ByteOffset, at the current file position, or at the end-of-file mark. It terminates the write operation when it has written Length bytes from Buffer. If necessary, it extends the length of the file and resets the end-of-file mark. If the caller opened the file with the DesiredAccess SYNCHRONIZE flag set, the caller can wait for this routine to set the given FileHandle to the signaled state. Drivers should call ZwWriteFile in the context of the system process in three cases: File and event handles are only valid in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to ZwWriteFile in the context of the system process instead of the process context that the driver is in. Likewise, ZwWriteFile should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread issuing the I/O request. If the driver calls ZwWriteFile in the context of a process other than the system process, the APC could be delayed indefinitely, or it might not fire at all as the originating thread may never enter an alertable wait state. For more information about working with files, see Using Files in a Driver. Callers of ZwWriteFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwWriteFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle to the file object. This handle is created by a successful call to ZwCreateFile or ZwOpenFile."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "Optionally, a handle to an event object to set to the signaled state after the write operation completes. Device and intermediate drivers should set this parameter to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "This parameter is reserved. Device and intermediate drivers should set this pointer to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "This parameter is reserved. Device and intermediate drivers should set this pointer to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the requested write operation. The Information member receives the number of bytes actually written to the file."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a caller-allocated buffer that contains the data to write to the file."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The size, in bytes, of the buffer pointed to by Buffer."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "ByteOffset",
        "description": "Pointer to a variable that specifies the starting byte offset in the file for beginning the write operation. If Length and ByteOffset specify a write operation past the current end-of-file mark, ZwWriteFile automatically extends the file and updates the end-of-file mark; any bytes that are not explicitly written between such old and new end-of-file marks are defined to be zero. If the call to ZwCreateFile set only the DesiredAccess flag FILE_APPEND_DATA, ByteOffset is ignored. Data in the given Buffer, for Length bytes, is written starting at the current end of file. If the call to ZwCreateFile set either of the CreateOptions flags, FILE_SYNCHRONOUS_IO_ALERT or FILE_SYNCHRONOUS_IO_NONALERT, the I/O Manager maintains the current file position. If so, the caller of ZwWriteFile can specify that the current file position offset be used instead of an explicit ByteOffset value. This specification can be made by using one of the following methods:   Specify a pointer to a LARGE_INTEGER value with the HighPart member set to -1 and the LowPart member set to the system-defined value FILE_USE_FILE_POINTER_POSITION.   Pass a NULL pointer for ByteOffset.   ZwWriteFile updates the current file position by adding the number of bytes written when it completes the write operation, if it is using the current file position maintained by the I/O Manager. Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit ByteOffset value to ZwWriteFile. Doing this automatically changes the current file position to that ByteOffsetvalue, performs the write operation, and then updates the position according to the number of bytes actually written. This technique gives the caller atomic seek-and-write service. It is also possible to cause a write operation to start at the current end of file by specifying for ByteOffset a pointer to a LARGE_INTEGER value with HighPart set to -1 and LowPart set to FILE_WRITE_TO_END_OF_FILE. This works regardless of whether the I/O Manager is maintaining the current file position."
      },
      {
        "in_out": "_In_opt_",
        "type": "PULONG",
        "name": "Key",
        "description": "Device and intermediate drivers should set this pointer to NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The IoBuildAsynchronousFsdRequest routine allocates and sets up an IRP to be sent to lower-level drivers.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoBuildAsynchronousFsdRequest returns a pointer to an IRP, or a NULL pointer if the IRP cannot be allocated. ",
    "remarks": "Intermediate or highest-level drivers can call IoBuildAsynchronousFsdRequest to set up IRPs for requests sent to lower-level drivers. The calling driver must supply an IoCompletion routine for the IRP, so the IRP can be deallocated with IoFreeIrp. For more information about IRP deallocation, see Examples. The IRP that gets built contains only enough information to get the operation started and to complete the IRP. No other context information is tracked because an asynchronous request is context-independent. Lower-level drivers might impose restrictions on parameters supplied to this routine. For example, disk drivers might require that values supplied for Length and StartingOffset be integer multiples of the device's sector size. An intermediate or highest-level driver also can call IoBuildDeviceIoControlRequest, IoAllocateIrp, or IoBuildSynchronousFsdRequest to set up requests it sends to lower-level drivers. Only a highest-level driver can call IoMakeAssociatedIrp. During an IoBuildAsynchronousFsdRequest call, the I/O manager sets the Tail.Overlay.Thread member of the IRP structure to point to the caller's thread object, but does not take a counted reference to the thread object on behalf of the caller. After the caller sends the IRP to the driver for the target device, this driver might use the Tail.Overlay.Thread member to access the thread object. For example, a storage driver might call the IoSetHardErrorOrVerifyDevice routine and supply a pointer to the IRP as an input parameter. During this call, IoSetHardErrorOrVerifyDevice uses the Tail.Overlay.Thread member to access the thread object. When the thread object is accessed in this way, the driver that called IoBuildAsynchronousFsdRequest to allocate the IRP is responsible for ensuring that the thread object stays valid while the IRP is being handled. To keep the thread object valid, the driver that calls IoBuildAsynchronousFsdRequest can take a counted reference on the thread object before sending the IRP. For example, this driver can call the ObReferenceObjectByPointerWithTag routine and supply, as the Object parameter, the object pointer from the Tail.Overlay.Thread member of the IRP structure. Later, this driver's completion routine can dereference the object by calling a routine such as ObDereferenceObjectWithTag. A driver might call IoBuildAsynchronousFsdRequest in one thread, and send the IRP allocated by this call in another thread. Before sending the IRP, this driver should set the Tail.Overlay.Thread member of the IRP to point to the thread object for the sending thread. Typically, the driver calls the PsGetCurrentThread routine to get the thread object pointer. A driver that calls IoBuildAsynchronousFsdRequest to allocate an IRP does not necessarily need to take a counted reference on the thread object pointed to by the Tail.Overlay.Thread member of the IRP. The driver might instead use another technique to guarantee that this thread object remains valid while the IRP is being handled. For example, if the driver created the thread, the thread can wait until the IRP is completed to terminate itself. Before calling IoFreeIrp, an additional step is required to free the buffer for an IRP built by IoBuildAsynchronousFsdRequest if the following are all true: Before freeing the buffer for this IRP, call the MmUnlockPages routine with Irp->MdlAddress as the parameter value. This call decrements the extra reference count that IoBuildAsynchronousFsdRequest added to the pool pages in the MDL. Otherwise, the subsequent call to IoFreeMdl will bug check because the reference count for these pool pages will be 2, not 1. The following code example shows the MmUnlockPages, IoFreeMdl, and IoFreeIrp calls for this case: ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoBuildAsynchronousFsdRequest",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MajorFunction",
        "description": "The major function code to be set in the IRP. This code can be IRP_MJ_PNP, IRP_MJ_READ, IRP_MJ_WRITE, IRP_MJ_FLUSH_BUFFERS, or IRP_MJ_SHUTDOWN."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the next-lower driver's device object. This object represents the target device for the read, write, flush, or shutdown operation."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "A pointer to a buffer into which data is read or from which data is written. The value of this argument is NULL for flush and shutdown requests."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "Length",
        "description": "The length, in bytes, of the buffer pointed to by Buffer. For devices such as disks, this value must be an integer multiple of the sector size. Starting with Windows 8, the sector size can be 4,096 or 512 bytes. In earlier versions of Windows, the sector size is always 512 bytes. This parameter is required for read and write requests, but must be zero for flush and shutdown requests."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "StartingOffset",
        "description": "A pointer to the starting offset on the input/output media. The value of this argument is zero for flush and shutdown requests."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to the address of an I/O status block in which the to-be-called drivers return final status about the requested operation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoGetCurrentIrpStackLocation routine returns a pointer to the caller's I/O stack location in the specified IRP.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetCurrentIrpStackLocation returns a pointer to an IO_STACK_LOCATION structure that contains the I/O stack location for the driver. ",
    "remarks": "Every driver must call IoGetCurrentIrpStackLocation with each IRP it is sent in order to get any parameters for the current request. Unless a driver supplies a dispatch routine for each IRP_MJ_XXX code that the driver handles, the driver also must check its I/O stack location in the IRP to determine what operation is being requested. If a driver is passing the same parameters that it received to the next-lower driver, it should call IoCopyCurrentIrpStackLocationToNext or IoSkipCurrentIrpStackLocation instead of getting a pointer to the next-lower stack location and copying the parameters manually. ",
    "return_type": "PIO_STACK_LOCATION",
    "category": "Drivers",
    "name": "IoGetCurrentIrpStackLocation",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoGetNextIrpStackLocation routine gives a higher level driver access to the next-lower driver's I/O stack location in an IRP so the caller can set it up for the lower driver.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetNextIrpStackLocation returns a pointer to the next-lower-level driver's I/O stack location in the given IRP. ",
    "remarks": "Each driver that passes IRPs on to lower drivers must set up the stack location for the next lower driver. A driver calls IoGetNextIrpStackLocation to get a pointer to the next-lower driver's I/O stack location. If a driver is passing the same parameters that it received to the next-lower driver, it should call IoCopyCurrentIrpStackLocationToNext or IoSkipCurrentIrpStackLocation instead of getting a pointer to the next-lower stack location and copying the parameters manually. The return value is a pointer to an IO_STACK_LOCATION structure. For more information, see I/O Stack Locations. ",
    "return_type": "PIO_STACK_LOCATION",
    "category": "Drivers",
    "name": "IoGetNextIrpStackLocation",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoCopyCurrentIrpStackLocationToNext routine copies the IRP stack parameters from the current I/O stack location to the stack location of the next-lower driver.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver calls IoCopyCurrentIrpStackLocationToNext to copy the IRP parameters from its stack location to the next-lower driver's stack location. After calling this routine, a driver typically sets an I/O completion routine with IoSetCompletionRoutine before passing the IRP to the next-lower driver with IoCallDriver. Drivers that pass on their IRP parameters but do not set an I/O completion routine should call IoSkipCurrentIrpStackLocation instead of this routine. If your driver calls IoSkipCurrentIrpStackLocation, be careful not to modify the IO_STACK_LOCATION structure in a way that could unintentionally affect the lower driver or the system's behavior with respect to that driver. In particular, your driver should not modify the IO_STACK_LOCATION structure's Parameters union, and should not call the IoMarkIrpPending routine. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoCopyCurrentIrpStackLocationToNext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "Given a file object, the IoGetRelatedDeviceObject routine returns a pointer to the corresponding device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetRelatedDeviceObject returns a pointer to the device object. ",
    "remarks": "When called on a file object that represents the underlying storage device, IoGetRelatedDeviceObject returns the highest-level device object in the storage device stack. To obtain the highest-level device object in the file system driver stack, drivers must call IoGetRelatedDeviceObject on a file object that represents the file system's driver stack, and the file system must currently be mounted. (Otherwise, the storage device stack is traversed instead of the file system stack.) To ensure that the file system is mounted on the storage device, the driver must have specified an appropriate access mask, such as FILE_READ_DATA or FILE_WRITE_ATTRIBUTES, when opening the file or device represented by the file object. Specifying FILE_READ_ATTRIBUTES does not cause the file system to be mounted. The caller must be running at IRQL <= DISPATCH_LEVEL. Usually, callers of this routine are running at IRQL = PASSIVE_LEVEL. ",
    "return_type": "PDEVICE_OBJECT",
    "category": "Drivers",
    "name": "IoGetRelatedDeviceObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PFILE_OBJECT",
        "name": "FileObject",
        "description": "Pointer to the file object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoGetFunctionCodeFromCtlCode macro returns the value of the function code contained in an I/O control code.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetFunctionCodeFromCtlCode returns the value of the Function part of the given IOCTL_XXX code. ",
    "remarks": "For information about the layout of IOCTL codes, see Using I/O Control Codes. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "IoGetFunctionCodeFromCtlCode",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ControlCode",
        "description": "The IOCTL_XXX (or FSCTL_XXX) value, which can be obtained from the driver's I/O stack location of the IRP at Parameters.DeviceIoControl.IoControlCode."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "For more information, see  the WdmlibIoValidateDeviceIoControlAccess function.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "For more information, see  the WdmlibIoValidateDeviceIoControlAccess function. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoValidateDeviceIoControlAccess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "For more information, see  the WdmlibIoValidateDeviceIoControlAccess function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RequiredAccess",
        "description": "For more information, see  the WdmlibIoValidateDeviceIoControlAccess function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The IoSetCompletionRoutine routine registers an IoCompletion routine, which will be called when the next-lower-level driver has completed the requested operation for the given IRP.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine sets the transfer address of the IoCompletion routine in the given IRP. The lowest-level driver in a chain of layered drivers cannot call this routine. IoSetCompletionRoutine registers the specified routine to be called when the next-lower-level driver has completed the requested operation in any or all of the following ways: Usually, the I/O status block is set by the underlying device driver. It is read but not altered by any higher-level drivers' IoCompletion routines. Higher-level drivers that allocate IRP's with IoAllocateIrp or IoBuildAsynchronousFsdRequest must call this routine with all InvokeOnXxx parameters set to TRUE before passing the driver-allocated IRP to IoCallDriver. When the IoCompletion routine is called with such an IRP, it must free the driver-allocated IRP and any other resources that the driver set up for the request, such as MDLs with IoBuildPartialMdl. Such a driver should return STATUS_MORE_PROCESSING_REQUIRED when it calls IoFreeIrp to forestall the I/O manager's completion processing for the driver-allocated IRP. Non-PnP drivers that might be unloaded before their IoCompletion routines run should use IoSetCompletionRoutineEx instead. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoSetCompletionRoutine",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP that the driver is processing."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_COMPLETION_ROUTINE",
        "name": "CompletionRoutine",
        "description": "Specifies the entry point for the driver-supplied IoCompletion routine, which is called when the next-lower driver completes the packet."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to a driver-determined context to pass to the IoCompletion routine. Context information must be stored in nonpaged memory, because the IoCompletion routine is called at IRQL <= DISPATCH_LEVEL."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InvokeOnSuccess",
        "description": "Specifies whether the completion routine is called if the IRP is completed with a success status value in the IRP's IO_STATUS_BLOCK structure, based on results of the NT_SUCCESS macro (see Using NTSTATUS values)."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InvokeOnError",
        "description": "Specifies whether the completion routine is called if the IRP is completed with a nonsuccess status value in the IRP's IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InvokeOnCancel",
        "description": "Specifies whether the completion routine is called if a driver or the kernel has called IoCancelIrp to cancel the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeSynchronizeExecution routine synchronizes the execution of the specified routine with the interrupt service routine (ISR) that is assigned to a set of one or more interrupt objects.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeSynchronizeExecution returns TRUE if the operation succeeds. Otherwise, it returns FALSE. ",
    "remarks": "When this routine is called, the following occurs: If the ISR runs at DIRQL >= DISPATCH_LEVEL, the SynchCritSection routine runs at the same DIRQL and must therefore run for as brief a time as possible to avoid delaying other high-priority tasks. Callers of KeSynchronizeExecution must be running at IRQL <= DIRQL; that is, at an IRQL that is less than or equal to the value of the SynchronizeIrql value that the caller specified when it registered its ISR with IoConnectInterrupt or IoConnectInterruptEx. Starting with Windows 8, a driver can call KeSynchronizeExecution to synchronize execution of a SynchCritSection routine with an ISR that runs at IRQL = PASSIVE_LEVEL. In earlier versions of Windows, KeSynchronizeExecution can synchronize execution only with an ISR that runs at IRQL >= DISPATCH_LEVEL. For more information, see Using Passive-Level Interrupt Service Routines. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeSynchronizeExecution",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKINTERRUPT",
        "name": "Interrupt",
        "description": "A pointer to a set of interrupt objects. The caller obtained this pointer from the IoConnectInterrupt or IoConnectInterruptEx routine."
      },
      {
        "in_out": "_In_",
        "type": "PKSYNCHRONIZE_ROUTINE",
        "name": "SynchronizeRoutine",
        "description": "Specifies a caller-supplied SynchCritSection routine whose execution is to be synchronized with the execution of the ISR assigned to the interrupt objects."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SynchronizeContext",
        "description": "A pointer to a caller-supplied context value to be passed to the SynchCritSection routine when it is called."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeDelayExecutionThread routine puts the current thread into an alertable or nonalertable wait state for a specified interval.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeDelayExecutionThread returns one of the following values that describes how the delay was completed:  Note that the NT_SUCCESS macro recognizes all of these status values as \"success\" values. ",
    "remarks": "The expiration time is computed and the current thread is put in a wait state. When the specified interval has passed, the thread exits the wait state and is put in the ready state, becoming eligible for execution. The Alertable parameter determines when the thread can be alerted and its wait state consequently aborted. For additional information, see Waits and APCs. If the WaitMode parameter is UserMode, the kernel stack can be swapped out during the wait. Consequently, a caller must never attempt to pass parameters on the stack when calling KeDelayExecutionThread using the UserMode argument. It is especially important to check the return value of KeDelayExecutionThread when the WaitMode parameter is UserMode or Alertable is TRUE, because KeDelayExecutionThread might return early with a status of STATUS_USER_APC or STATUS_ALERTED. All long term waits that can be aborted by a user should be UserMode waits and Alertable should be set to FALSE. Where possible, Alertable should be set to FALSE and WaitMode should be set to KernelMode, in order to reduce driver complexity. The principal exception to this guideline is when the wait is a long-term wait. The expiration time of the delay is expressed as either an absolute time at which the delay is to expire, or a time relative to the current system time. If the Interval parameter value is positive, the expiration time is an absolute time. If this value is negative, the expiration time is a relative time. Expiration times are measured relative to the system clock, and the accuracy with which the operating system can detect when a timer expires is limited by the granularity of the system clock. For more information, see Timer Accuracy. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KeDelayExecutionThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "WaitMode",
        "description": "Specifies the processor mode in which the caller is waiting, which can be either KernelMode or UserMode. Lower-level drivers should specify KernelMode."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Alertable",
        "description": "Specifies TRUE if the wait is alertable. Lower-level drivers should specify FALSE."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Interval",
        "description": "Specifies the absolute or relative time, in units of 100 nanoseconds, for which the wait is to occur. A negative value indicates relative time. Absolute expiration times track any changes in system time; relative expiration times are not affected by system time changes."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExInitializeResourceLite routine initializes a resource variable.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInitializeResourceLite returns STATUS_SUCCESS. ",
    "remarks": "The storage for ERESOURCE must be allocated from nonpaged pool. The resource variable can be used for synchronization by a set of threads. Although the caller provides the storage for the resource variable, the ERESOURCE structure is opaque: that is, its members are reserved for system use. Call ExDeleteResourceLite before freeing the memory for the resource. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ExInitializeResourceLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the caller-supplied storage, which must be at least sizeof(ERESOURCE), for the resource variable being initialized. The storage must be 4-byte aligned on 32-bit platforms, and 8-byte aligned on 64-bit platforms."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExReinitializeResourceLite routine reinitializes an existing resource variable.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExReinitializeResourceLite returns STATUS_SUCCESS. ",
    "remarks": "With a single call to ExReinitializeResource, a driver writer can replace three calls: one to ExDeleteResourceLite, another to ExAllocatePool, and a third to ExInitializeResourceLite. As contention for a resource variable increases, memory is dynamically allocated and attached to the resource in order to track this contention. As an optimization, ExReinitializeResourceLite retains and zeros this previously allocated memory. The ERESOURCE structure is opaque; that is, the members are reserved for system use. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ExReinitializeResourceLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the caller-supplied resource variable to be reinitialized."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExAcquireResourceExclusiveLite routine acquires the given resource for exclusive access by the calling thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExAcquireResourceExclusiveLite returns TRUE if the resource is acquired. This routine returns FALSE if the input Wait is FALSE and exclusive access cannot be granted immediately. ",
    "remarks": "The following list describes whether and when a caller is given exclusive access to a given resource: The caller can release the resource by calling either ExReleaseResourceLite or ExReleaseResourceForThreadLite. Normal kernel APC delivery must be disabled before calling this routine. Disable normal kernel APC delivery by calling KeEnterCriticalRegion. Delivery must remain disabled until the resource is released, at which point it can be reenabled by calling KeLeaveCriticalRegion. For more information, see Disabling APCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "ExAcquireResourceExclusiveLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to acquire."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies the routine's behavior whenever the resource cannot be acquired immediately. If TRUE, the caller is put into a wait state until the resource can be acquired. If FALSE, the routine immediately returns, regardless of whether the resource can be acquired."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExAcquireResourceSharedLite routine acquires the given resource for shared access by the calling thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The caller can release the resource by calling either ExReleaseResourceLite or ExReleaseResourceForThreadLite. ExAcquireResourceSharedLite returns TRUE if (or when) the resource is acquired. This routine returns FALSE if the input Wait is FALSE and shared access cannot be granted immediately. ",
    "remarks": "Whether or when the caller is given shared access to the given resource depends on the following: Normal kernel APC delivery must be disabled before calling this routine. Disable normal kernel APC delivery by calling KeEnterCriticalRegion. Delivery must remain disabled until the resource is released, at which point it can be reenabled by calling KeLeaveCriticalRegion. For more information, see Disabling APCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "ExAcquireResourceSharedLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to acquire."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies the routine's behavior whenever the resource cannot be acquired immediately. If TRUE, the caller is put into a wait state until the resource can be acquired. If FALSE, the routine immediately returns, regardless of whether the resource can be acquired."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExAcquireSharedStarveExclusive routine acquires a given resource for shared access without waiting for any pending attempts to acquire exclusive access to the same resource.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The caller can release the resource by calling either ExReleaseResourceLite or ExReleaseResourceForThreadLite. ExAcquireSharedStarveExclusive returns TRUE if the requested access is granted. This routine returns FALSE if the input Wait is FALSE and shared access cannot be granted immediately. ",
    "remarks": "Whether or when the caller is given shared access to the given resource depends on the following: Callers of ExAcquireSharedStarveExclusive usually need quick access to a shared resource in order to save an exclusive accessor from doing redundant work. For example, a file system might call this routine to modify a cached resource, such as a BCB pinned in the cache, before the cache manager can acquire exclusive access to the resource and write the cache out to disk. Normal kernel APC delivery must be disabled before calling this routine. Disable normal kernel APC delivery by calling KeEnterCriticalRegion. Delivery must remain disabled until the resource is released, at which point it can be reenabled by calling KeLeaveCriticalRegion. For more information, see Disabling APCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "ExAcquireSharedStarveExclusive",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to be acquired for shared access."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies the routine's behavior whenever the resource cannot be acquired immediately. If TRUE, the caller is put into a wait state until the resource can be acquired. If FALSE, the routine immediately returns, regardless of whether the resource can be acquired."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExAcquireSharedWaitForExclusive routine acquires the given resource for shared access if shared access can be granted and there are no exclusive waiters.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExAcquireSharedWaitForExclusive returns TRUE if the requested access is granted or an exclusive owner releases the resource. This routine returns FALSE if the input Wait is FALSE and shared access cannot be granted immediately. ",
    "remarks": "Most drivers should use ExAcquireResourceSharedLite instead of ExAcquireSharedWaitForExclusive. The caller can release the resource by calling either ExReleaseResourceLite or ExReleaseResourceForThreadLite. If shared access cannot be granted immediately, the caller can wait for other threads to acquire and release exclusive ownership of the resource. Whether or when the caller is given shared access to the given resource depends on the following: The behavior of ExAcquireSharedWaitForExclusive is identical to that of ExAcquireResourceSharedLite unless the calling thread already owns the resource as shared and there are exclusive waiters. In that case, ExAcquireSharedWaitForExclusive allows the exclusive waiters to acquire exclusive ownership of the resource. If the caller specifies TRUE for the Wait parameter, the caller blocks until another thread frees the resource on behalf of the caller, using ExReleaseResourceForThread. Driver writers must be careful to ensure that another thread actually releases the resource; otherwise the caller is deadlocked. ExAcquireResourceSharedLite does not have this property, so drivers should use that routine unless they require the particular behavior of ExAcquireSharedWaitForExclusive. Normal kernel APC delivery must be disabled before calling this routine. Disable normal kernel APC delivery by calling KeEnterCriticalRegion. Delivery must remain disabled until the resource is released, at which point it can be reenabled by calling KeLeaveCriticalRegion. For more information, see Disabling APCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "ExAcquireSharedWaitForExclusive",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to be acquired for shared access."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies the routine's behavior whenever the resource cannot be acquired immediately. If TRUE, the caller is put into a wait state until the resource can be acquired. If FALSE, the routine immediately returns, regardless of whether the resource can be acquired."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExIsResourceAcquiredExclusiveLite routine returns whether the current thread has exclusive access to a given resource.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExIsResourceAcquiredExclusiveLite returns TRUE if the caller already has exclusive access to the given resource. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "ExIsResourceAcquiredExclusiveLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to be queried."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExIsResourceAcquiredSharedLite routine returns whether the current thread has access (either shared or exclusive) to a given resource.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExIsResourceAcquiredSharedLite returns the number of times the caller has acquired the given resource for shared or exclusive access. ",
    "remarks": "The system considers exclusive access to be a subset of shared access. Therefore, a thread that has exclusive access to a resource also has shared access to the resource. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "ExIsResourceAcquiredSharedLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to be queried."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExGetExclusiveWaiterCount routine returns the number of waiters on exclusive access to a given resource.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExGetExclusiveWaiterCount returns the number of threads currently waiting to acquire the given resource for exclusive access. ",
    "remarks": "ExGetExclusiveWaiterCount can be called to get an estimate of how many other threads might be waiting to modify the data protected by a particular resource variable. The caller cannot assume that the returned value remains constant for any particular interval. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "ExGetExclusiveWaiterCount",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to be tested."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExGetSharedWaiterCount routine returns the number of waiters on shared access to a given resource.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExGetSharedWaiterCount returns the number of threads currently waiting to acquire the given resource for shared access. ",
    "remarks": "ExGetSharedWaiterCount can be called to get an estimate of how many other threads might be waiting to read the data protected by a particular resource variable. The caller cannot assume that the returned value remains constant for any particular interval. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "ExGetSharedWaiterCount",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to be tested."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExConvertExclusiveToSharedLite routine converts a given resource from acquired for exclusive access to acquired for shared access.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The caller must have exclusive access to the given resource. During this conversion, the current thread and any other threads waiting for shared access to the resource are given shared access. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExConvertExclusiveToSharedLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource for which the access should be converted."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The ExGetCurrentResourceThread routine identifies the current thread for a subsequent call to ExReleaseResourceForThreadLite.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExGetCurrentResourceThread returns the thread ID of the current thread. ",
    "remarks": "",
    "return_type": "ERESOURCE_THREAD",
    "category": "Drivers",
    "name": "ExGetCurrentResourceThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExReleaseResourceForThreadLite routine releases the input resource of the indicated thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If this is not the currently executing thread, the caller must have transferred ownership of the resource by calling the ExSetResourceOwnerPointerEx routine first on the thread that originally acquired the resource. This is to ensure that thread A does not get terminated or deleted before thread B has a chance to release the resource. Unless the caller is running in a system thread, the caller must explicitly disable the delivery of normal kernel APCs before calling this routine. This requirement prevents threads from being suspended while they manipulate or hold a resource. The caller can disable normal kernel APC delivery by calling the KeEnterCriticalRegion routine. Delivery must remain disabled until the resource is released, at which point it can be reenabled by calling the KeLeaveCriticalRegion routine. For more information, see Disabling APCs. This requirement does not apply to calls made to ExReleaseResourceForThreadLite from a system thread. A caller running in a system thread does not need to explicitly disable APCs before calling this routine. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExReleaseResourceForThreadLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the resource to release."
      },
      {
        "in_out": "_In_",
        "type": "ERESOURCE_THREAD",
        "name": "ResourceThreadId",
        "description": "Identifies the thread that originally acquired the resource. If this is not the currently executing thread, the caller must have transferred ownership of the resource by calling the ExSetResourceOwnerPointerEx routine first on the thread that originally acquired the resource."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExDeleteResourceLite routine deletes a given resource from the system's resource list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExDeleteResourceLite returns STATUS_SUCCESS if the resource was deleted. ",
    "remarks": "After calling ExDeleteResourceLite, the caller can free the memory it allocated for its resource. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ExDeleteResourceLite",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PERESOURCE",
        "name": "Resource",
        "description": "A pointer to the caller-supplied storage for the initialized resource variable to be deleted."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoQueueWorkItem routine associates a WorkItem routine with a work item, and it inserts the work item into a queue for later processing by a system worker thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None. ",
    "remarks": "For more information about work items, see System Worker Threads. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoQueueWorkItem",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIO_WORKITEM",
        "name": "IoWorkItem",
        "description": "Pointer to an IO_WORKITEM structure that was allocated by IoAllocateWorkItem or initialized by IoInitializeWorkItem."
      },
      {
        "in_out": "_In_",
        "type": "PIO_WORKITEM_ROUTINE",
        "name": "WorkerRoutine",
        "description": "Pointer to a WorkItem routine."
      },
      {
        "in_out": "_In_",
        "type": "WORK_QUEUE_TYPE",
        "name": "QueueType",
        "description": "Specifies a WORK_QUEUE_TYPE value that stipulates the type of system worker thread to handle the work item. Drivers must specify DelayedWorkQueue."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Specifies driver-specific information for the work item. The system passes this value as the Context parameter to WorkItem."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeSetTimer routine sets the absolute or relative interval at which a timer object is to be set to a signaled state and, optionally, supplies a CustomTimerDpc routine to be executed when that interval expires.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the timer object was already in the system timer queue, KeSetTimer returns TRUE. ",
    "remarks": "The KeSetTimer routine does the following: If the timer object was already in the timer queue, it is implicitly canceled before being set to the new expiration time. A call to KeSetTimer before the previously specified DueTime has expired cancels both the timer and the call to the Dpc, if any, associated with the previous call. If the Dpc parameter is specified, a DPC object is associated with the timer object. When the timer expires, the timer object is removed from the system timer queue and its state is set to signaled. If a DPC object was associated with the timer when it was set, the DPC object is inserted in the system DPC queue to be executed as soon as conditions permit after the timer interval expires. Expiration times are measured relative to the system clock, and the accuracy with which the operating system can detect when a timer expires is limited by the granularity of the system clock. For more information, see Timer Accuracy. Only one instantiation of a given DPC object can be queued at any given moment. To avoid potential race conditions, the DPC passed to KeSetTimer should not be passed to KeInsertQueueDpc. Drivers must cancel any active timers in their Unload routines. Use KeCancelTimer to cancel any timers. Callers of KeSetTimer can specify one expiration time for a timer. To set a recurring timer use KeSetTimerEx. For more information about timer objects, see Timer Objects and DPCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeSetTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKTIMER",
        "name": "Timer",
        "description": "Pointer to a timer object that was initialized with KeInitializeTimer or KeInitializeTimerEx."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "DueTime",
        "description": "Specifies the absolute or relative time at which the timer is to expire. If the value of the DueTime parameter is negative, the expiration time is relative to the current system time. Otherwise, the expiration time is absolute. The expiration time is expressed in system time units (100-nanosecond intervals). Absolute expiration times track any changes in the system time; relative expiration times are not affected by system time changes."
      },
      {
        "in_out": "_In_opt_",
        "type": "PKDPC",
        "name": "Dpc",
        "description": "Pointer to a DPC object that was initialized by KeInitializeDpc. This parameter is optional."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The KeSetTimerEx routine sets the absolute or relative interval at which a timer object is to be set to a signaled state, optionally supplies a CustomTimerDpc routine to be executed when that interval expires, and optionally supplies a recurring interval for the timer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the timer object was already in the system timer queue, KeSetTimerEx returns TRUE. ",
    "remarks": "The KeSetTimerEx routine does the following: If the timer object was already in the timer queue, it is implicitly canceled before being set to the new expiration time. A call to KeSetTimerEx before the previously specified DueTime has expired cancels both the timer and the call to the Dpc, if any, associated with the previous call. Expiration times are measured relative to the system clock, and the accuracy with which the operating system can detect when a timer expires is limited by the granularity of the system clock. For more information, see Timer Accuracy. If the Dpc parameter is specified, a DPC object is associated with the timer object. When the timer expires, the timer object is removed from the system timer queue and it is set to a signaled state. If a DPC object was associated with the timer when it was set, the DPC object is inserted in the system DPC queue to be executed as soon as conditions permit after the timer interval expires. A DPC routine cannot deallocate a periodic timer. A DPC routine can deallocate a nonperiodic timer. Note that a periodic timer is automatically restarted as soon as it expires. Thus, on a multiprocessor machine, the DPC for a periodic timer can be running on two processors simultaneously. Only one instantiation of a given DPC object can be queued at any given moment. To avoid potential race conditions, the DPC passed to KeSetTimerEx should not be passed to KeInsertQueueDpc. Drivers must cancel any active timers in their Unload routines. Use KeCancelTimer to cancel any timers. For more information about timer objects, see Timer Objects and DPCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeSetTimerEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKTIMER",
        "name": "Timer",
        "description": "Pointer to a timer object that was initialized with KeInitializeTimer or KeInitializeTimerEx."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "DueTime",
        "description": "Specifies the absolute or relative time at which the timer is to expire. If the value of the DueTime parameter is negative, the expiration time is relative to the current system time. Otherwise, the expiration time is absolute. The expiration time is expressed in system time units (100-nanosecond intervals). Absolute expiration times track any changes in the system time; relative expiration times are not affected by system time changes."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Period",
        "description": "Specifies an optional recurring interval for the timer in milliseconds. Must be a value that is greater than or equal to zero. If the value of this parameter is zero, the timer is a nonperiodic timer that does not automatically re-queue itself."
      },
      {
        "in_out": "_In_opt_",
        "type": "PKDPC",
        "name": "Dpc",
        "description": "Pointer to a DPC object that was initialized by KeInitializeDpc. This parameter is optional."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeCancelTimer routine dequeues a timer object before the timer interval, if any was set, expires.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the specified timer object is in the system timer queue, KeCancelTimer returns TRUE. ",
    "remarks": "If the timer object is currently in the system timer queue, it is removed from the queue. If a DPC object is associated with the timer, it too is canceled. Otherwise, no operation is performed. The routine returns TRUE if the timer is still in the timer queue. A nonperiodic timer is removed from the system queue as soon as it expires. Thus, for nonperiodic timers, KeCancelTimer returns FALSE if the timer DPC has been queued. Periodic timers are always in the timer queue, so KeCancelTimer always returns TRUE for periodic timers. Note that a DPC that is already running runs to completion. The driver must ensure that the DPC has completed before freeing any resources used by the DPC. For a nonperiodic timer, you can use synchronization primitives, such as event objects, to synchronize between the driver and the DPC. The driver can check the return code of KeCancelTimer to determine if the DPC is running. If so, the DPC can signal the event before exiting, and the driver can wait for that event to be reset to the not-signaled state. Since for periodic timers KeCancelTimer always returns TRUE, drivers must use a different technique to wait until the DPC has completed. Use the KeFlushQueuedDpcs routine to block until the DPC executes. Drivers do not need to synchronize for data stored in global variables or driver object extensions. The system automatically calls KeFlushQueuedDpcs before deallocating either of these regions. For more information about timer objects, see Timer Objects and DPCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeCancelTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKTIMER",
        "name": "Timer",
        "description": "Pointer to an initialized timer object, for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReadStateTimer routine reads the current state of a timer object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeReadStateTimer returns TRUE if the current state of the timer object is signaled; otherwise, it returns FALSE. ",
    "remarks": "This routine provides an efficient way to poll the signal state of a timer. KeReadStateTimer reads the state of the timer without synchronizing its access to the timer. Do not assume that accesses of a timer state by KeReadStateTimer are mutually exclusive of accesses by routines, such as KeSetTimer and KeWaitForSingleObject, that do synchronize their access to the timer state. For more information about timer objects, see Timer Objects and DPCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeReadStateTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKTIMER",
        "name": "Timer",
        "description": "A pointer to an initialized timer object, for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeSetEvent routine sets an event object to a signaled state if the event was not already signaled, and returns the previous state of the event object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the previous state of the event object was signaled, a nonzero value is returned. ",
    "remarks": "Calling KeSetEvent causes the event to attain a signaled state. If the event is a notification event, the system attempts to satisfy as many waits as possible on the event object. The event remains signaled until a call to KeClearEvent or KeResetEvent clears it. If the event is a synchronization event, one wait is satisfied before the system automatically clears the event. The KeSetEvent routine might temporarily raise the IRQL. If the Wait parameter is FALSE, the routine, before it returns, restores the IRQL to the original value that it had at the start of the call. If Wait = TRUE, the routine returns without lowering the IRQL. In this case, the KeSetEvent call must be immediately followed by a KeWaitXxx call. By setting Wait = TRUE, the caller can prevent an unnecessary context switch from occurring between the KeSetEvent call and the KeWaitXxx call. The KeWaitXxx routine, before it returns, restores the IRQL to its original value at the start of the KeSetEvent call. Although the IRQL disables context switches between the two calls, these calls cannot reliably be used as the start and end of an atomic operation. For example, between these two calls, a thread that is running at the same time on another processor might change the state of the event object or of the target of the wait. A pageable thread or pageable driver routine that runs at IRQL = PASSIVE_LEVEL should never call KeSetEvent with the Wait parameter set to TRUE. Such a call causes a fatal page fault if the caller happens to be paged out between the calls to KeSetEvent and KeWaitXxx. For more information about event objects, see Event Objects. If Wait is set to FALSE, the caller can be running at IRQL <= DISPATCH_LEVEL. Otherwise, callers of KeSetEvent must be running at IRQL <= APC_LEVEL and in a nonarbitrary thread context. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeSetEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKEVENT",
        "name": "Event",
        "description": "A pointer to an initialized event object for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "KPRIORITY",
        "name": "Increment",
        "description": "Specifies the priority increment to be applied if setting the event causes a wait to be satisfied."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies whether the call to KeSetEvent is to be followed immediately by a call to one of the KeWaitXxx routines. If TRUE, the KeSetEvent call must be followed by a call to KeWaitForMultipleObjects, KeWaitForMutexObject, or KeWaitForSingleObject. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeClearEvent routine sets an event to a not-signaled state.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Event is set to a not-signaled state, meaning its value is set to zero. For better performance, use KeClearEvent unless the caller uses the value returned by KeResetEvent to determine what to do next. For more information about event objects, see Event Objects. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeClearEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKEVENT",
        "name": "Event",
        "description": "Pointer to an initialized dispatcher object of type event for which the caller supplies the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeResetEvent routine resets a specified event object to a not-signaled state and returns the previous state of that event object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeResetEvent returns a value that indicates the previous state of the specified Event, which is nonzero for a signaled state. ",
    "remarks": "Event is reset to a not-signaled state, meaning that its value is set to zero. Unless the caller requires the value that is returned by KeResetEvent, using the KeClearEvent routine is a faster way to set an event object to a not-signaled state. For more information about event objects, see Event Objects. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeResetEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKEVENT",
        "name": "Event",
        "description": "A pointer to an initialized dispatcher object of type event for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReadStateEvent routine returns the current state, signaled or not-signaled, of an event object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Ntddk.h)",
    "return_value": "If the event object is currently set to a signaled state, a nonzero value is returned. Otherwise, zero is returned. ",
    "remarks": "This routine provides an efficient way to poll the signal state of an event. KeReadStateEvent reads the state of the event without synchronizing its access to the event. Do not assume that accesses of an event state by KeReadStateEvent are mutually exclusive of accesses by routines, such as KeSetEvent and KeWaitForSingleObject, that do synchronize their access to the event state. It is also possible to read the state of an event from a driver's interrupt service routine at DIRQL, if the following conditions are met: the driver's event object is resident (probably in its device extension), and any other function that accesses the event synchronizes its access with the ISR. For more information about event objects, see Event Objects. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeReadStateEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PRKEVENT",
        "name": "Event",
        "description": "A pointer to an initialized event object for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExAcquireFastMutex routine acquires the given fast mutex with APCs to the current thread disabled.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExAcquireFastMutex puts the caller into a wait state if the given fast mutex cannot be acquired immediately. Otherwise, the caller is given ownership of the fast mutex with APCs to the current thread disabled until it releases the fast mutex. Use ExTryToAcquireFastMutex if the current thread can do other work before it waits on the acquisition of the given mutex. Any fast mutex that is acquired using ExAcquireFastMutex or ExTryToAcquireFastMutex must be released with ExReleaseFastMutex. For more information about fast mutexes, see Fast Mutexes and Guarded Mutexes. Callers of ExAcquireFastMutex must be running at IRQL <= APC_LEVEL. ExAcquireFastMutex sets the IRQL to APC_LEVEL, and the caller continues to run at APC_LEVEL after ExAcquireFastMutex returns. ExAcquireFastMutex saves the caller's previous IRQL in the mutex, however, and that IRQL is restored when the caller invokes ExReleaseFastMutex. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExAcquireFastMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PFAST_MUTEX",
        "name": "FastMutex",
        "description": "A pointer to an initialized fast mutex for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExTryToAcquireFastMutex routine acquires the given fast mutex, if possible, with APCs to the current thread disabled.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExTryToAcquireFastMutex returns TRUE if the current thread is given ownership of the fast mutex. ",
    "remarks": "If the given fast mutex is currently unowned, ExTryToAcquireFastMutex gives the caller ownership with APCs to the current thread disabled until it releases the fast mutex. Use ExAcquireFastMutex if the current thread must wait for the acquisition of the given mutex before it can do useful work. Any fast mutex that is acquired with ExTryToAcquireFastMutex or ExAcquireFastMutex must be released with ExReleaseFastMutex. For more information about fast mutexes, see Fast Mutexes and Guarded Mutexes. Callers of ExTryToAcquireFastMutex must be running at IRQL <= APC_LEVEL. ExTryToAcquireFastMutex sets the IRQL to APC_LEVEL if the mutex is acquired, and the caller continues to run at APC_LEVEL after ExTryToAcquireFastMutex returns. ExTryToAcquireFastMutex saves the caller's previous IRQL in the mutex if successful, however, and that IRQL is restored when the caller calls ExReleaseFastMutex. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "ExTryToAcquireFastMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PFAST_MUTEX",
        "name": "FastMutex",
        "description": "A pointer to the fast mutex to be acquired if it is not currently owned by another thread."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExReleaseFastMutex routine releases ownership of a fast mutex that was acquired with ExAcquireFastMutex or ExTryToAcquireFastMutex.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExReleaseFastMutex releases ownership of the given fast mutex and sets the IRQL to the value that the caller was running at before it called ExAcquireFastMutex. If the previous IRQL was less than APC_LEVEL, the delivery of APCs to the current thread is reenabled. It is a programming error to call ExReleaseFastMutex with a FastMutex that was acquired using ExAcquireFastMutexUnsafe. Drivers should release a fast mutex from the same thread that acquired it. Fast mutexes should be released in the opposite order from the order they were acquired. For more information about fast mutexes, see Fast Mutexes and Guarded Mutexes. Callers of ExReleaseFastMutex must be running at IRQL = APC_LEVEL. In most cases the IRQL will already be set to APC_LEVEL before ExReleaseFastMutex is called because ExAcquireFastMutex has already set the IRQL to APC_LEVEL automatically. However, if the caller changes the IRQL after ExAcquireFastMutex returns, the caller must explicitly set the IRQL to APC_LEVEL prior to calling ExReleaseFastMutex. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExReleaseFastMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PFAST_MUTEX",
        "name": "FastMutex",
        "description": "A pointer to the fast mutex to be released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExAcquireFastMutexUnsafe routine acquires the specified fast mutex for the calling thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExAcquireFastMutexUnsafe puts the caller into a wait state if the specified fast mutex cannot be acquired immediately. Otherwise, the caller is given ownership of the mutex and exclusive access to the resource that the mutex protects until the caller releases the mutex. Any fast mutex that is acquired by a call to ExAcquireFastMutexUnsafe must be released by a call to the ExReleaseFastMutexUnsafe routine. The ExAcquireFastMutex and ExAcquireFastMutexUnsafe routines cause the calling thread to block until the mutex is available. The ExTryToAcquireFastMutex routine returns immediately with return value FALSE if another thread has already acquired the mutex. Both ExAcquireFastMutex and ExTryToAcquireFastMutex raise the IRQL to APC_LEVEL before acquiring the fast mutex. Drivers should use ExAcquireFastMutexUnsafe, which does not raise the IRQL, only if either of the following is true: For more information about fast mutexes, see the following topics: ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExAcquireFastMutexUnsafe",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PFAST_MUTEX",
        "name": "FastMutex",
        "description": "A pointer to a FAST_MUTEX structure that the caller provides the storage for. The caller previously initialized this structure by a call to the ExInitializeFastMutex routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExReleaseFastMutexUnsafe routine releases ownership of a fast mutex that was acquired by using ExAcquireFastMutexUnsafe.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "It is a programming error to call ExReleaseFastMutexUnsafe with a pointer to a fast mutex that was acquired by using ExAcquireFastMutex or ExTryToAcquireFastMutex. For more information about fast mutexes, see Fast Mutexes and Guarded Mutexes. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExReleaseFastMutexUnsafe",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PFAST_MUTEX",
        "name": "FastMutex",
        "description": "A pointer to the fast mutex to be released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeReleaseMutex routine releases a mutex object, and specifies whether the caller is to call one of the KeWaitXxx routines as soon as KeReleaseMutex returns control.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the return value is zero, the mutex object was released and attained a state of signaled. ",
    "remarks": "For better performance, use fast mutexes or guarded mutexes. For more information, see Alternatives to Mutex Objects. If the mutex object attains a signaled state, an attempt is made to satisfy a wait for the mutex object. A mutex object can be released only by the thread that currently holds the mutex. If an attempt is made to release a mutex that the thread does not hold or if a mutex was acquired at IRQL = DISPATCH_LEVEL and the thread is not running at DISPATCH_LEVEL (and vice versa), the routine raises a STATUS_ABANDONED or STATUS_MUTEX_NOT_OWNED exception. When a mutex object attains a signaled state, it is removed from the list of the mutexes that are held by that thread. If this list contains no more entries, the original priority for the thread is restored. The KeReleaseMutex routine might temporarily raise the IRQL. If the Wait parameter is FALSE, the routine, before it returns, restores the IRQL to the original value that it had at the start of the call. If Wait = TRUE, the routine returns without lowering the IRQL. In this case, the KeReleaseMutex call must be immediately followed by a KeWaitXxx call. By setting Wait = TRUE, the caller can prevent an unnecessary context switch from occurring between the KeReleaseMutex call and the KeWaitXxx call. The KeWaitXxx routine, before it returns, restores the IRQL to its original value at the start of the KeReleaseMutex call. Although the IRQL disables context switches between the two calls, these calls cannot reliably be used as the start and end of an atomic operation. For example, between these two calls, a thread that is running at the same time on another processor might change the state of the event object or of the target of the wait. If the caller is executing at IRQL = DISPATCH_LEVEL or in an arbitrary thread context, the Timeout parameter to KeWaitXxx must be zero. If a mutex is acquired recursively, the holding thread must call KeReleaseMutex as many times as it acquired the mutex to set it to the signaled state. For more information about mutex objects, see Mutex Objects. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeReleaseMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKMUTEX",
        "name": "Mutex",
        "description": "A pointer to an initialized mutex object for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies whether the call to KeReleaseMutex is to be immediately followed by a call to one of the KeWaitXxx routines. If TRUE, the KeReleaseMutex call must be followed by a call to KeWaitForMultipleObjects, KeWaitForMutexObject, or KeWaitForSingleObject. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReadStateMutex routine returns the current state, signaled or not-signaled, of the specified mutex object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the return value is 1, the state of the mutex object is signaled. ",
    "remarks": "This routine provides an efficient way to poll the signal state of a mutex. KeReadStateMutex reads the state of the mutex without synchronizing its access to the mutex. Do not assume that accesses of a mutex state by KeReadStateMutex are mutually exclusive of accesses by routines, such as KeReleaseMutex and KeWaitForSingleObject, that do synchronize their access to the mutex state. For more information about mutex objects, see Mutex Objects. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeReadStateMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PRKMUTEX",
        "name": "Mutex",
        "description": "Pointer to an initialized mutex object for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The KeReleaseSemaphore routine releases the specified semaphore object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the return value is zero, the previous state of the semaphore object is not-signaled. ",
    "remarks": "KeReleaseSemaphore supplies a run-time priority boost for waiting threads. If this call sets the semaphore to the signaled state, the semaphore count is augmented by the specified value. The caller can also specify whether it will call one of the KeWaitXxx routines as soon as KeReleaseSemaphore returns control. Releasing a semaphore object causes the semaphore count to be augmented by the value of the Adjustment parameter. If the resulting value is greater than the limit of the semaphore object, the count is not adjusted and an exception, STATUS_SEMAPHORE_LIMIT_EXCEEDED, is raised. Augmenting the semaphore object count causes the semaphore to attain a signaled state, and an attempt is made to satisfy as many waits as possible on the semaphore object. The KeReleaseSemaphore routine might temporarily raise the IRQL. If the Wait parameter is FALSE, the routine, before it returns, restores the IRQL to the original value that it had at the start of the call. If Wait = TRUE, the routine returns without lowering the IRQL. In this case, the KeReleaseSemaphore call must be immediately followed by a KeWaitXxx call. By setting Wait = TRUE, the caller can prevent an unnecessary context switch from occurring between the KeReleaseSemaphore call and the KeWaitXxx call. The KeWaitXxx routine, before it returns, restores the IRQL to its original value at the start of the KeReleaseSemaphore call. Although the IRQL disables context switches between the two calls, these calls cannot reliably be used as the start and end of an atomic operation. For example, between these two calls, a thread that is running at the same time on another processor might change the state of the semaphore object or of the target of the wait. If the caller is executing at IRQL = DISPATCH_LEVEL or in an arbitrary thread context, the Timeout parameter to KeWaitXxx must be zero. For more information about semaphore objects, see Semaphore Objects. Callers of KeReleaseSemaphore must be running at IRQL <= DISPATCH_LEVEL provided that Wait is set to FALSE. Otherwise, the caller must be running at IRQL = PASSIVE_LEVEL. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeReleaseSemaphore",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKSEMAPHORE",
        "name": "Semaphore",
        "description": "A pointer to an initialized semaphore object for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "KPRIORITY",
        "name": "Increment",
        "description": "Specifies the priority increment to be applied if releasing the semaphore causes a wait to be satisfied."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Adjustment",
        "description": "Specifies a value to be added to the current semaphore count. This value must be positive."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "Specifies whether the call to KeReleaseSemaphore is to be followed immediately by a call to one of the KeWaitXxx routines. If TRUE, the KeReleaseSemaphore call must be followed by a call to KeWaitForMultipleObjects, KeWaitForMutexObject, or KeWaitForSingleObject. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReadStateSemaphore routine returns the current state, signaled or not-signaled, of the specified semaphore object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the return value is zero, the semaphore object is set to a not-signaled state. ",
    "remarks": "This routine provides an efficient way to poll the signal state of a semaphore. KeReadStateSemaphore reads the state of the semaphore without synchronizing its access to the semaphore. Do not assume that accesses of a semaphore state by KeReadStateSemaphore are mutually exclusive of accesses by routines, such as KeReleaseSemaphore and KeWaitForSingleObject, that do synchronize their access to the semaphore state. For more information about semaphore objects, see Semaphore Objects. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeReadStateSemaphore",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PRKSEMAPHORE",
        "name": "Semaphore",
        "description": "Pointer to an initialized semaphore object for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The KeWaitForSingleObject routine puts the current thread into a wait state until the given dispatcher object is set to a signaled state or (optionally) until the wait times out.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeWaitForSingleObject can return one of the following:  Note that the NT_SUCCESS macro recognizes all of these status values as \"success\" values. ",
    "remarks": "The current state of the specified Object is examined to determine whether the wait can be satisfied immediately. If so, the necessary side effects are performed on the object. Otherwise, the current thread is put in a waiting state and a new thread is selected for execution on the current processor. The Alertable parameter determines when the thread can be alerted and its wait state consequently aborted. For additional information, see Waits and APCs. A special consideration applies when the Object parameter passed to KeWaitForSingleObject is a mutex. If the dispatcher object waited on is a mutex, APC delivery is the same as for all other dispatcher objects during the wait. However, after KeWaitForSingleObject returns with STATUS_SUCCESS and the thread actually holds the mutex, only special kernel-mode APCs are delivered. Delivery of all other APCs, both kernel-mode and user-mode, is disabled. This restriction on the delivery of APCs persists until the mutex is released. If the WaitMode parameter is UserMode, the kernel stack can be swapped out during the wait. Consequently, a caller must never attempt to pass parameters on the stack when calling KeWaitForSingleObject using the UserMode argument. If you allocate the event on the stack, you must set the WaitMode parameter to KernelMode. It is especially important to check the return value of KeWaitForSingleObject when the WaitMode parameter is UserMode or Alertable is TRUE, because KeWaitForSingleObject might return early with a status of STATUS_USER_APC or STATUS_ALERTED. All long-term waits that can be aborted by a user should be UserMode waits and Alertable should be set to FALSE. Where possible, Alertable should be set to FALSE and WaitMode should be set to KernelMode, in order to reduce driver complexity. The principal exception to this is when the wait is a long-term wait. If a NULL pointer is supplied for Timeout, the calling thread remains in a wait state until the Object is signaled. A time-out value of zero allows the testing of a set of wait conditions and for the conditional performance of any side effects if the wait can be immediately satisfied, as in the acquisition of a mutex. Time-out intervals are measured relative to the system clock, and the accuracy with which the operating system can detect the end of a time-out interval is limited by the granularity of the system clock. For more information, see Timer Accuracy. A mutex can be recursively acquired only MINLONG times. If this limit is exceeded, the routine raises a STATUS_MUTANT_LIMIT_EXCEEDED exception. Callers of KeWaitForSingleObject must be running at IRQL <= DISPATCH_LEVEL. However, if Timeout = NULL or *Timeout != 0, the caller must be running at IRQL <= APC_LEVEL and in a nonarbitrary thread context. (If Timeout != NULL and *Timeout = 0, the caller must be running at IRQL <= DISPATCH_LEVEL.) ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KeWaitForSingleObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Object",
        "description": "Pointer to an initialized dispatcher object (event, mutex, semaphore, thread, or timer) for which the caller supplies the storage."
      },
      {
        "in_out": "_In_",
        "type": "KWAIT_REASON",
        "name": "WaitReason",
        "description": "Specifies the reason for the wait. A driver should set this value to Executive, unless it is doing work on behalf of a user and is running in the context of a user thread, in which case it should set this value to UserRequest."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "WaitMode",
        "description": "Specifies whether the caller waits in KernelMode or UserMode. Lowest-level and intermediate drivers should specify KernelMode. If the given Object is a mutex, the caller must specify KernelMode."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Alertable",
        "description": "Specifies a Boolean value that is TRUE if the wait is alertable and FALSE otherwise."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "Pointer to a time-out value that specifies the absolute or relative time, in 100-nanosecond units, at which the wait is to be completed. A positive value specifies an absolute time, relative to January 1, 1601. A negative value specifies an interval relative to the current time. Absolute expiration times track any changes in the system time; relative expiration times are not affected by system time changes.  If *Timeout = 0, the routine returns without waiting. If the caller supplies a NULL pointer, the routine waits indefinitely until the dispatcher object is set to the signaled state. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The KeWaitForMutexObject routine puts the current thread into an alertable or nonalertable wait state until the given mutex object is set to a signaled state or (optionally) until the wait times out.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeWaitForMutexObject can return one of the following:  Note that the NT_SUCCESS macro recognizes all of these status values as \"success\" values. ",
    "remarks": "KeWaitForMutexObject is a macro that converts to KeWaitForSingleObject, which can be used instead. For better performance, use fast mutexes or guarded mutexes. For more information, see Alternatives to Mutex Objects. For more information about how to use this routine, see KeWaitForSingleObject. For more information about mutex objects, see Mutex Objects. A mutex can be recursively acquired only MINLONG times. If this limit is exceeded, the routine raises a STATUS_MUTANT_LIMIT_EXCEEDED exception. Callers of KeWaitForMutexObject must be running at IRQL <= DISPATCH_LEVEL. However, if Timeout = NULL or *Timeout != 0, the caller must be running at IRQL <= APC_LEVEL and in a nonarbitrary thread context. (If Timeout != NULL and *Timeout = 0, the caller must be running at IRQL <= DISPATCH_LEVEL.) ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KeWaitForMutexObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Mutex",
        "description": "Pointer to an initialized mutex object for which the caller supplies the storage."
      },
      {
        "in_out": "_In_",
        "type": "KWAIT_REASON",
        "name": "WaitReason",
        "description": "Specifies the reason for the wait, which should be set to Executive. If the driver is doing work on behalf of a user and is running in the context of a user thread, this parameter should be set to UserRequest."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "WaitMode",
        "description": "The caller must specify KernelMode."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Alertable",
        "description": "Specifies a Boolean value that indicates whether the wait is alertable."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "Pointer to a time-out value that specifies the absolute or relative time, in 100-nanosecond units, at which the wait is to be completed.  A positive value specifies an absolute time, relative to January 1, 1601. A negative value specifies an interval relative to the current time. Absolute expiration times track any changes in the system time; relative expiration times are not affected by system time changes.  If *Timeout = 0, the routine returns without waiting. If the caller supplies a NULL pointer, the routine waits indefinitely until the mutex object is set to the signaled state. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 8,
    "description": "The KeWaitForMultipleObjects routine puts the current thread into an alertable or nonalertable wait state until any or all of a number of dispatcher objects are set to a signaled state or (optionally) until the wait times out.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeWaitForMultipleObjects can return one of the following:  Note that the NT_SUCCESS macro recognizes all of these status values as \"success\" values. ",
    "remarks": "Each thread object has a built-in array of wait blocks that can be used to wait for several objects to be set concurrently. Whenever possible, the built-in array of wait blocks should be used in a wait-multiple operation because no additional wait block storage needs to be allocated and later deallocated. However, if the number of objects that must be waited on concurrently is greater than the number of built-in wait blocks, use the WaitBlockArray parameter to specify an alternate set of wait blocks to be used in the wait operation. Drivers only need to allocate a sufficiently large memory buffer for WaitBlockArray. The buffer does not need to be initialized; however, it must be allocated from nonpaged system memory. If the WaitMode parameter is UserMode, the WaitBlockArray buffer must not be allocated on the local stack because the stack might be swapped out of memory. Drivers can treat this buffer as an opaque structure and can free it after the routine returns. If either Count > MAXIMUM_WAIT_OBJECTS or if WaitBlockArray is NULL and Count > THREAD_WAIT_OBJECTS, the system issues Bug Check 0xC (MAXIMUM_WAIT_OBJECTS_EXCEEDED). The current state for each of the specified objects is examined to determine whether the wait can be satisfied immediately. If the necessary side effects are performed on the objects, an appropriate value is returned. If the wait cannot be satisfied immediately and either no time-out value or a nonzero time-out value has been specified, the current thread is put in a waiting state and a new thread is selected for execution on the current processor. If no Timeout is supplied, the calling thread will remain in a wait state until the conditions specified by Object and WaitType are satisfied. If Timeout is specified, the wait will be automatically satisfied if none of the specified wait conditions is met when the given interval expires. A time-out value of zero allows the testing of a set of wait conditions, conditionally performing any side effects if the wait can be immediately satisfied, as in the acquisition of a mutex. Time-out intervals are measured relative to the system clock, and the accuracy with which the operating system can detect the end of a time-out interval is limited by the granularity of the system clock. For more information, see Timer Accuracy. The Alertable parameter determines when the thread can be alerted and its wait state consequently aborted. For additional information, see Waits and APCs. The array pointed to by the Objects parameter must reside in nonpaged system memory. Typically, a driver allocates the storage for the Objects array on the local stack. The Objects array can be allocated on the local stack regardless of the value of the WaitMode parameter. The dispatcher objects pointed to by the elements in the Objects array must reside in nonpaged system memory. If the WaitMode parameter is UserMode, the kernel stack can be swapped out during the wait. Consequently, a caller must never attempt to pass parameters on the stack when calling KeWaitForMultipleObjects with the UserMode argument. If you allocate the event on the stack, you must set the WaitMode parameter to KernelMode. A special consideration applies when the Object parameter passed to KeWaitForMultipleObjects is a mutex. If the dispatcher object waited on is a mutex, APC delivery is the same as for all other dispatcher objects during the wait. However, after KeWaitForMultipleObjects returns with STATUS_SUCCESS and the thread actually holds the mutex, only special kernel-mode APCs are delivered. Delivery of all other APCs, both kernel-mode and user-mode, is disabled. This restriction on the delivery of APCs persists until the mutex is released. It is especially important to check the return value of KeWaitForMultipleObjects when the WaitMode parameter is UserMode or Alertable is TRUE, because KeWaitForMultipleObjects might return early with a status of STATUS_USER_APC or STATUS_ALERTED. All long term waits that can be aborted by a user should be UserMode waits and Alertable should be set to FALSE. Where possible, Alertable should be set to FALSE and WaitMode should be set to KernelMode, in order to reduce driver complexity. The principal exception to this is when the wait is a long-term wait. A mutex can be recursively acquired only MINLONG times. If this limit is exceeded, the routine raises a STATUS_MUTANT_LIMIT_EXCEEDED exception. Callers of KeWaitForMultipleObjects can be running at IRQL <= DISPATCH_LEVEL. However, if Timeout = NULL or *Timeout != 0, the caller must be running at IRQL <= APC_LEVEL and in a nonarbitrary thread context. (If Timeout != NULL and *Timeout = 0, the caller must be running at IRQL <= DISPATCH_LEVEL.) ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KeWaitForMultipleObjects",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "The number of objects to be waited on. This parameter specifies the number of elements in the array pointed to by the Object parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Object[]",
        "description": "A pointer to an array of pointers to dispatcher objects (events, mutexes, semaphores, threads, and timers) for which the caller supplies the storage. Both the pointer array and the dispatcher objects must reside in nonpaged system memory. For more information, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "WAIT_TYPE",
        "name": "WaitType",
        "description": "The type of wait operation to perform. Specify either WaitAll, indicating that all of the specified objects must attain a signaled state before the wait is satisfied; or WaitAny, indicating that any one of the objects must attain a signaled state before the wait is satisfied."
      },
      {
        "in_out": "_In_",
        "type": "KWAIT_REASON",
        "name": "WaitReason",
        "description": "The reason for the wait. Drivers should set this value to Executive or, if the driver is doing work on behalf of a user and is running in the context of a user thread, to UserRequest."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "WaitMode",
        "description": "Whether the caller waits in KernelMode or UserMode. Intermediate and lowest-level drivers should specify KernelMode. If the set of objects waited on includes a mutex, the caller must specify KernelMode."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Alertable",
        "description": "A Boolean value that indicates whether the thread can be alerted while it is in the waiting state."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "A pointer to a time-out value that specifies the absolute or relative time, in 100-nanosecond units, at which the wait is to be completed. A positive value specifies an absolute time, relative to January 1, 1601. A negative value specifies an interval relative to the current time. Absolute expiration times track any changes in the system time; relative expiration times are not affected by system time changes. If *Timeout = 0, the routine returns without waiting. If the caller supplies a NULL pointer, the routine waits indefinitely until any or all of the dispatcher objects are set to the signaled state. For more information, see the following Remarks section."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PKWAIT_BLOCK",
        "name": "WaitBlockArray",
        "description": "A pointer to a caller-allocated KWAIT_BLOCK array. If Count <= THREAD_WAIT_OBJECTS, then WaitBlockArray can be NULL. Otherwise, this parameter must point to a memory buffer of sizeof(KWAIT_BLOCK) * Count bytes. The routine uses this buffer for record-keeping while performing the wait operation. The WaitBlockArray buffer must reside in nonpaged system memory. For more information, see Remarks."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The PsGetCurrentThread routine identifies the current thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PsGetCurrentThread returns a pointer to the executive thread object that represents the currently executing thread. ",
    "remarks": "",
    "return_type": "PETHREAD",
    "category": "Drivers",
    "name": "PsGetCurrentThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeGetCurrentThread routine identifies the current thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeGetCurrentThread returns a pointer to an opaque thread object. ",
    "remarks": "This routine is identical to PsGetCurrentThread. A caller of KeGetCurrentThread can use the returned pointer as an input parameter to KeQueryPriorityThread, KeSetBasePriorityThread, or KeSetPriorityThread. However, the memory containing the thread object is opaque; that is, it is reserved for exclusive use by the operating system. ",
    "return_type": "PKTHREAD",
    "category": "Drivers",
    "name": "KeGetCurrentThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The IoGetCurrentProcess routine returns a pointer to the current process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetCurrentProcess returns a pointer to the current process. ",
    "remarks": "This routine is identical to PsGetCurrentProcess. ",
    "return_type": "PEPROCESS",
    "category": "Drivers",
    "name": "IoGetCurrentProcess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The PsGetCurrentProcess routine returns a pointer to the process of the current thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PsGetCurrentProcess returns a pointer to an opaque process object. ",
    "remarks": "",
    "return_type": "PEPROCESS",
    "category": "Drivers",
    "name": "PsGetCurrentProcess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeEnterCriticalRegion routine temporarily disables the execution of normal kernel APCs, but does not prevent special kernel APCs from running.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver calls this routine to enter a critical region in which the execution of normal kernel APCs is deferred until this driver exits the critical region by calling the KeLeaveCriticalRegion routine. Any caller of KeEnterCriticalRegion should call KeLeaveCriticalRegion as quickly as possible after entering a critical region. Highest-level drivers can call KeEnterCriticalRegion while running in the context of the thread that requested the current I/O operation. A thread that is inside a critical region has both user APCs and normal kernel APCs disabled, but not special kernel APCs. For more information about these APC types, see Types of APCs. Critical regions can be entered recursively and each call to KeEnterCriticalRegion must have a matching call to KeLeaveCriticalRegion. A driver can use a critical region to acquire and release exclusive access to a shared resource. In this case, the ExEnterCriticalRegionAndAcquireResourceExclusive and ExReleaseResourceAndLeaveCriticalRegion routines can be used instead of the KeEnterCriticalRegion and KeLeaveCriticalRegion routines. For more information, see the code example in ExEnterCriticalRegionAndAcquireResourceExclusive. For more information about APCs, see Asynchronous Procedure Calls. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeEnterCriticalRegion",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeLeaveCriticalRegion routine reenables the delivery of normal kernel-mode APCs that were disabled by a preceding call to KeEnterCriticalRegion.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Highest-level drivers can call this routine while running in the context of the thread that requested the current I/O operation. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeLeaveCriticalRegion",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeAreApcsDisabled routine returns whether the calling thread is within a critical region or a guarded region, which disables normal kernel APC delivery.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeAreApcsDisabled returns TRUE if the thread is within a critical region or a guarded region, and FALSE otherwise. ",
    "remarks": "A thread running at IRQL = PASSIVE_LEVEL can use KeAreApcsDisabled to determine if normal kernel APCs are disabled. A thread that is inside a critical region has both user APCs and normal kernel APCs disabled, but not special kernel APCs. A thread that is inside a guarded region has all APCs disabled, including special kernel APCs. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeAreApcsDisabled",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeSaveFloatingPointState routine saves the nonvolatile floating-point context so the caller can carry out floating-point operations.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeSaveFloatingPointState returns STATUS_SUCCESS if it saved the current thread's floating-point context and set up a fresh floating-point context for the caller. Otherwise, it returns one of the following error status codes.  ",
    "remarks": "A successful call to KeSaveFloatingPointState allows the caller to carry out floating-point operations of its own, but such a caller must restore the previous nonvolatile floating-point context as soon as its floating-point operations are done. Any routine that calls KeSaveFloatingPointState must call KeRestoreFloatingPointState before that routine returns control. If the call to KeSaveFloatingPointState is successful, the data at FloatSave is opaque to the caller. The caller should not release the memory that it allocated for this data until after the call to KeRestoreFloatingPointState. In Windows Vista and earlier versions of Windows, a KeSaveFloatingPointState call and the corresponding KeRestoreFloatingPointState call must occur in a guarded region. That is, the KeEnterGuardedRegion routine must be called before KeSaveFloatingPointState is called, and the KeLeaveGuardedRegion routine must be called after KeRestoreFloatingPointState is called. No such requirement exists in Windows 7 and later versions of Windows. For performance reasons, drivers should avoid doing any floating-point operations unless absolutely necessary. The overhead of saving and restoring the current thread's nonvolatile floating-point state degrades the performance of any driver that does floating-point operations. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KeSaveFloatingPointState",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKFLOATING_SAVE",
        "name": "FloatSave",
        "description": "Pointer to a caller-allocated resident buffer, which must be at least sizeof(KFLOATING_SAVE)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeRestoreFloatingPointState routine restores the nonvolatile floating-point context saved by the preceding call to KeSaveFloatingPointState.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeRestoreFloatingPointState returns STATUS_SUCCESS. ",
    "remarks": "KeRestoreFloatingPointState is the reciprocal of KeSaveFloatingPointState. Any routine that calls KeSaveFloatingPointState must call KeRestoreFloatingPointState before that routine returns control, and it must be running at the same IRQL as that from which the preceding call to KeSaveFloatingPointState occurred. Failure to meet either of these conditions causes a system bug check. Kernel-mode driver code must ensure that calls to KeSaveFloatingPointState and KeRestoreFloatingPointState are properly nested. This is required so that, at each nesting level, the state that was restored by the KeRestoreFloatingPointState call is the same state that was saved by the corresponding KeSaveFloatingPointState call. To ensure proper nesting, kernel-mode driver code must follow these rules: ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KeRestoreFloatingPointState",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKFLOATING_SAVE",
        "name": "FloatSave",
        "description": "A pointer to the KFLOATING_SAVE structure that was passed in the preceding call to KeSaveFloatingPointState."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwSetInformationThread routine sets the priority of a thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "ZwSetInformationThread returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. Possible error codes include STATUS_INFO_LENGTH_MISMATCH or STATUS_INVALID_PARAMETER. ",
    "remarks": "ZwSetInformationThread can be called by higher-level drivers to set the priority of a thread for which they have a handle. The caller must have THREAD_SET_INFORMATION access rights for the given thread in order to call this routine. Usually, device and intermediate drivers that set up driver-created threads call KeSetBasePriorityThread or KeSetPriorityThread from their driver-created threads, rather than calling ZwSetInformationThread. However, a driver can call ZwSetInformationThread to raise the priority of a driver-created thread before that thread runs. Kernel mode drivers can call the ZwSetInformationThread function with ThreadPagePriority to specify a thread's page priority. To help improve system performance, drivers should use the  function with ThreadPagePriority to lower the page priority of threads that perform background operations or access files and data that are not expected to be accessed again soon. For example, an anti-malware application might lower the priority of threads involved in scanning files. To determine the page priority for a thread, call ZwQueryInformationThread. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetInformationThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ThreadHandle",
        "description": "Handle to the thread object. To create a new thread and get a handle to it, call PsCreateSystemThread. To specify the current thread, use the ZwCurrentThread macro."
      },
      {
        "in_out": "_In_",
        "type": "THREADINFOCLASS",
        "name": "ThreadInformationClass",
        "description": "One of the system-defined values in the THREADINFOCLASS enumeration (see ntddk.h), ThreadPriority,   ThreadBasePriority, or ThreadPagePriority."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ThreadInformation",
        "description": "Pointer to a variable that specifies the information to set.  If ThreadInformationClass is ThreadPriority, this value must be > LOW_PRIORITY and <= HIGH_PRIORITY.  If ThreadInformationClass is ThreadBasePriority, this value must fall within the system's valid base-priority range and the original priority class for the given thread. That is, if a thread's priority class is variable, that thread's base priority cannot be reset to a real-time priority value, and vice versa. If ThreadInformationClass is ThreadPagePriority, this value is a pointer to a PAGE_PRIORITY_INFORMATION structure, see ntddk.h. The PagePriority member value must be one of these values.   ValueMeaning  MEMORY_PRIORITY_VERY_LOW 1   Very low memory priority.   MEMORY_PRIORITY_LOW 2   Low memory priority.   MEMORY_PRIORITY_MEDIUM 3   Medium memory priority.   MEMORY_PRIORITY_BELOW_NORMAL 4   Below normal memory priority.   MEMORY_PRIORITY_NORMAL 5   Normal memory priority. This is the default priority for all threads and processes on the system."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ThreadInformationLength",
        "description": "The size, in bytes, of ThreadInformation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The PsGetCurrentProcessId routine identifies the current thread's process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "PsGetCurrentProcessId returns the process ID of the current thread's process. ",
    "remarks": "",
    "return_type": "HANDLE",
    "category": "Drivers",
    "name": "PsGetCurrentProcessId",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The PsGetCurrentThreadId routine identifies the current thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "The PsGetCurrentThreadId routine returns the thread ID of the current thread. ",
    "remarks": "",
    "return_type": "HANDLE",
    "category": "Drivers",
    "name": "PsGetCurrentThreadId",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The PsSetCreateProcessNotifyRoutine routine adds a driver-supplied callback routine to, or removes it from, a list of routines to be called whenever a process is created or deleted.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "PsSetCreateProcessNotifyRoutine can return one of the following:  ",
    "remarks": "Highest-level drivers can call PsSetCreateProcessNotifyRoutine to set up their process-creation notify routines implemented as PCREATE_PROCESS_NOTIFY_ROUTINE. An IFS or highest-level system-profiling driver might register a process-creation callback to track the system-wide creation and deletion of processes against the driver's internal state. For Windows Vista and later versions of Windows, the system can register up to 64 process-creation callback routines. A driver must remove any callbacks that it registers before it unloads. You can remove the callback by calling PsSetCreateProcessNotify with Remove = TRUE. After a driver-supplied routine is registered, it is called with Create set to TRUE just after the initial thread is created within the newly created process designated by the input ProcessId handle. The input ParentId handle identifies the parent process of the newly-created process (this is the parent used for priority, affinity, quota, token, and handle inheritance, among others). ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PsSetCreateProcessNotifyRoutine",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCREATE_PROCESS_NOTIFY_ROUTINE",
        "name": "NotifyRoutine",
        "description": "Specifies the entry point of a caller-supplied process-creation callback routine. See PCREATE_PROCESS_NOTIFY_ROUTINE."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Remove",
        "description": "Indicates whether the routine specified by NotifyRoutine should be added to or removed from the system's list of notification routines. If FALSE, the specified routine is added to the list. If TRUE, the specified routine is removed from the list."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The PsSetCreateThreadNotifyRoutine routine registers a driver-supplied callback that is subsequently notified when a new thread is created and when such a thread is deleted.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "PsSetCreateThreadNotifyRoutine either returns STATUS_SUCCESS or it returns STATUS_INSUFFICIENT_RESOURCES if it failed the callback registration. ",
    "remarks": "Highest-level drivers can call PsSetCreateThreadNotifyRoutine to set up their thread-creation notify routines, declared as follows: For example, an IFS or highest-level system-profiling driver might register such a thread-creation callback to track the system-wide creation and deletion of threads against the driver's internal state. A driver must remove any callbacks it registers before it unloads. You can remove the callback by calling the PsRemoveCreateThreadNotifyRoutine routine. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PsSetCreateThreadNotifyRoutine",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCREATE_THREAD_NOTIFY_ROUTINE",
        "name": "NotifyRoutine",
        "description": "A pointer to the driver's implementation of PCREATE_THREAD_NOTIFY_ROUTINE routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The PsSetLoadImageNotifyRoutine routine registers a driver-supplied callback that is subsequently notified whenever an image is loaded (or mapped into memory).",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "PsSetLoadImageNotifyRoutine either returns STATUS_SUCCESS or it returns STATUS_INSUFFICIENT_RESOURCES if it failed the callback registration. ",
    "remarks": "Highest-level system-profiling drivers can call PsSetLoadImageNotifyRoutine to set up their load-image notify routines (see PLOAD_IMAGE_NOTIFY_ROUTINE). The maximum number of drivers that can be simultaneously registered to receive load-image notifications is eight. If the maximum number of load-image notify routines is already registered when a driver calls PsSetLoadImageNotifyRoutine to try to register an additional notify routine, PsSetLoadImageNotifyRoutine fails and returns STATUS_INSUFFICIENT_RESOURCES. Notes A driver must remove any callbacks it registers before it unloads. You can remove the callback by calling the PsRemoveLoadImageNotifyRoutine routine. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PsSetLoadImageNotifyRoutine",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLOAD_IMAGE_NOTIFY_ROUTINE",
        "name": "NotifyRoutine",
        "description": "A pointer to the caller-implemented PLOAD_IMAGE_NOTIFY_ROUTINE callback routine for load-image notifications."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoInitializeTimer routine sets up a driver-supplied IoTimer routine associated with a given device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoInitializeTimer returns STATUS_SUCCESS if the IoTimer routine is set up. ",
    "remarks": "IoInitializeTimer should be called only once per device object. A driver's IoTimer routine is called once per second after the driver enables the timer by calling IoStartTimer. The driver can disable the timer by calling IoStopTimer and can reenable it again with IoStartTimer. The driver's IoTimer routine is called at IRQL = DISPATCH_LEVEL and therefore must not contain pageable code. When the timer is running, the I/O manager calls the driver-supplied IoTimer routine once per second. Drivers whose time-out routines should be called at variable intervals or at intervals of finer granularity can set up a CustomTimerDpc routine and use the KeXxxTimer routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoInitializeTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to a device object representing a device on which I/O operations can time out."
      },
      {
        "in_out": "_In_",
        "type": "PIO_TIMER_ROUTINE",
        "name": "TimerRoutine",
        "description": "Pointer to the driver-supplied IoTimer routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to the driver-determined context with which its IoTimer routine will be called."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoAcquireCancelSpinLock routine synchronizes cancelable-state transitions for IRPs in a multiprocessor-safe way.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver that uses the I/O manager-supplied device queues in the device object must be holding the cancel spin lock whenever it changes the cancelable state of an IRP with IoSetCancelRoutine. A driver that manages its own IRP queue does not need to hold the cancel spin lock when calling IoSetCancelRoutine. The holder of the cancel spin lock should release it promptly by calling IoReleaseCancelSpinLock. A driver-supplied Cancel routine is called with the cancel spin lock held. It must release the cancel spin lock when it has completed the IRP to be canceled. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoAcquireCancelSpinLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKIRQL",
        "name": "Irql",
        "description": "Pointer to a variable in which to save the current IRQL for a subsequent call to IoReleaseCancelSpinLock. Usually, the Irql is saved on the stack as a local variable."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoSetCancelRoutine routine sets up a driver-supplied Cancel routine to be called if a given IRP is canceled.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoSetCancelRoutine returns the previous value of Irp->CancelRoutine. If no Cancel routine was previously set, or if IRP cancellation is already in progress, IoSetCancelRoutine returns NULL. ",
    "remarks": "This routine can disable the Cancel routine currently set in an IRP. A driver must hold the system cancel spin lock when calling this routine if the driver uses the I/O manager-supplied device queue in the device object. The driver runs at IRQL = DISPATCH_LEVEL after calling IoAcquireCancelSpinLock until it releases the cancel spin lock with IoReleaseCancelSpinLock. If the driver manages its own queues of IRPs, then the driver need not hold the cancel spin lock when calling this routine. IoSetCancelRoutine uses an interlocked exchange intrinsic to set the address of the Cancel routine as an atomic operation. Reduced usage of the cancel spin lock can improve driver performance and overall system performance. Driver Cancel routines are called at IRQL = DISPATCH_LEVEL with the cancel spin lock held. The Cancel routine must release the cancel spin lock before it returns control. ",
    "return_type": "PDRIVER_CANCEL",
    "category": "Drivers",
    "name": "IoSetCancelRoutine",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP being put into or removed from a cancelable state."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_CANCEL",
        "name": "CancelRoutine",
        "description": "Specifies the entry point of the caller-supplied Cancel routine to be called if the specified IRP is canceled or is NULL if the given IRP is being removed from the cancelable state. This routine is declared as follows:       Copy      VOID (*PDRIVER_CANCEL)(     IN PDEVICE_OBJECT DeviceObject,     IN PIRP Irp     );"
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeRaiseIrql routine raises the hardware priority to the specified IRQL value, thereby masking off interrupts of equivalent or lower IRQL on the current processor.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If the new IRQL is less than the current IRQL, a bug check occurs. Otherwise, the current IRQL is set to the specified value. Callers of this routine can be running at any IRQL. Any caller should restore the original IRQL with KeLowerIrql as soon as possible. A call to KeLowerIrql is valid if it specifies NewIrql <= CurrentIrql. A call to KeRaiseIrql is valid if the caller specifies NewIrql >= CurrentIrql. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeRaiseIrql",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "NewIrql",
        "description": "Specifies the new IRQL to which the hardware priority is to be raised."
      },
      {
        "in_out": "_Out_",
        "type": "PKIRQL",
        "name": "OldIrql",
        "description": "Pointer to the storage for the original (unraised) IRQL value to be used in a subsequent call to KeLowerIrql."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeRaiseIrqlToDpcLevel routine raises the hardware priority to IRQL = DISPATCH_LEVEL, thereby masking off interrupts of equivalent or lower IRQL on the current processor.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "KeRaiseIrqlToDpcLevel returns the IRQL at which the call occurred. ",
    "remarks": "Any caller of KeRaiseIrqlToDpcLevel should save the returned IRQL value. Every such caller must restore the original IRQL as quickly as possible by passing this returned IRQL in a subsequent call to KeLowerIrql. Callers of KeRaiseIrqlToDpcLevel must be running at IRQL <= DISPATCH_LEVEL. Otherwise, a call to this routine causes a bug check. ",
    "return_type": "KIRQL",
    "category": "Drivers",
    "name": "KeRaiseIrqlToDpcLevel",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeLowerIrql routine restores the IRQL on the current processor to its original value.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "It is a fatal error to call KeLowerIrql using an input NewIrql that was not returned by the immediately preceding call to KeRaiseIrql. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "KeLowerIrql",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "NewIrql",
        "description": "Specifies the IRQL that was returned from KeRaiseIrql."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeGetCurrentIrql routine returns the current IRQL.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeGetCurrentIrql returns the current IRQL. ",
    "remarks": "",
    "return_type": " KIRQL",
    "category": "Drivers",
    "name": "KeGetCurrentIrql",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExAllocatePoolWithTag routine allocates pool memory of the specified type and returns a pointer to the allocated block.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExAllocatePoolWithTag returns NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory. ",
    "remarks": "This routine is used for the general pool allocation of memory. If NumberOfBytes is PAGE_SIZE or greater, a page-aligned buffer is allocated. Memory allocations of PAGE_SIZE or less are allocated within a page and do not cross page boundaries. Memory allocations of less than PAGE_SIZE are not necessarily page-aligned but are aligned to 8-byte boundaries in 32-bit systems and to 16-byte boundaries in 64-bit systems. A successful allocation requesting NumberOfBytes < PAGE_SIZE of nonpaged pool gives the caller exactly the number of requested bytes of memory. If an allocation request for NumberOfBytes > PAGE_SIZE succeeds and NumberOfBytes is not an exact multiple of PAGE_SIZE, the last page in the allocation contains bytes that are not part of the caller's allocation. If possible, the pool allocator uses these bytes. To avoid corrupting data that belongs to other kernel-mode components, drivers must access only storage addresses that they have explicitly allocated. The system associates the pool tag with the allocated memory. Programming tools, such as WinDbg, can display the pool tag associated with each allocated buffer. Gflags, a tool included in Debugging Tools for Windows, turns on a system feature that requests allocation from special pool for a particular pool tag. Poolmon, which is included in the WDK, tracks memory by pool tag. The value of Tag is stored, and sometimes displayed, in reverse (little-endian) order. For example, if a caller passes 'Fred' as a Tag, it appears as \"derF\" in a pool dump and in pool usage tracking in the debugger, and as 0x64657246 in the registry and in tool displays. The allocated buffer can be freed with either ExFreePool or ExFreePoolWithTag. The system automatically sets certain standard event objects when the amount of pool (paged or nonpaged) is high or low. Drivers can wait for these events to tune their pool usage. For more information, see Standard Event Objects. Callers of ExAllocatePoolWithTag must be executing at IRQL <= DISPATCH_LEVEL. A caller executing at DISPATCH_LEVEL must specify a NonPagedXxx value for PoolType. A caller executing at IRQL <= APC_LEVEL can specify any POOL_TYPE value, but the IRQL and environment must also be considered for determining the page type. In a non-uniform memory access (NUMA) multiprocessor architecture, ExAllocatePoolWithTag tries to allocate memory that is local to the processor that is calling ExAllocatePoolWithTag. If no local memory is available, ExAllocatePoolWithTag allocates the closest available memory. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "ExAllocatePoolWithTag",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "POOL_TYPE",
        "name": "PoolType",
        "description": "The type of pool memory to allocate. For a description of the available pool memory types, see POOL_TYPE. You can modify the PoolType value by bitwise-ORing this value with the POOL_RAISE_IF_ALLOCATION_FAILURE flag. This flag causes an exception to be raised if the request cannot be satisfied. Use of the POOL_RAISE_IF_ALLOCATION_FAILURE flag is not recommended because it is costly. Similarly, you can modify the PoolType value by bitwise-ORing this value with the POOL_COLD_ALLOCATION flag as a hint to the kernel to allocate the memory from pages that are likely to be paged out quickly. To reduce the amount of resident pool memory as much as possible, you should not reference these allocations frequently. The POOL_COLD_ALLOCATION flag is only advisory and is supported starting with Windows XP."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "The number of bytes to allocate."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Tag",
        "description": "The pool tag to use for the allocated memory. Specify the pool tag as a character literal of up to four characters delimited by single quotation marks (for example, 'Tag1'). The string is usually specified in reverse order (for example, '1gaT'). Each ASCII character in the tag must be a value in the range 0x20 (space) to 0x126 (tilde). Each allocation code path should use a unique pool tag to help debuggers and verifiers identify the code path."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExAllocatePoolWithQuotaTag routine allocates pool memory, charging the quota against the current process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExAllocatePoolWithQuotaTag returns a pointer to the allocated pool. If the request cannot be satisfied, ExAllocatePoolWithQuotaTag raises an exception unless POOL_QUOTA_FAIL_INSTEAD_OF_RAISE is specified. Using POOL_QUOTA_FAIL_INSTEAD_OF_RAISE is preferred for performance reasons. ",
    "remarks": "This routine is called by highest-level drivers that allocate memory to satisfy a request in the context of the process that originally made the I/O request. Lower-level drivers call ExAllocatePoolWithTag instead. If NumberOfBytes is PAGE_SIZE or greater, a page-aligned buffer is allocated. Memory allocations of PAGE_SIZE or less are allocated within a page and do not cross page boundaries. Memory allocations of less than PAGE_SIZE are not necessarily page-aligned but are aligned to 8-byte boundaries in 32-bit systems and to 16-byte boundaries in 64-bit systems. The system associates the pool tag with the allocated memory. Programming tools, such as WinDbg, can display the pool tag associated with each allocated buffer. The value of Tag is normally displayed in reversed order. For example, if a caller passes 'Fred' as a Tag, it would appear as 'derF' if the pool is dumped or when tracking pool usage in the debugger. The allocated buffer can be freed with either ExFreePool or ExFreePoolWithTag. The system automatically sets certain standard event objects when the amount of pool (paged or nonpaged) is high or low. Drivers can wait for these events to tune their pool usage. For more information, see Standard Event Objects. In a non-uniform memory access (NUMA) multiprocessor architecture, ExAllocatePoolWithQuotaTag tries to allocate memory that is local to the processor that is calling ExAllocatePoolWithQuotaTag. If no local memory is available, ExAllocatePoolWithQuotaTag allocates the closest available memory. Callers of ExAllocatePoolWithQuotaTag must be executing at IRQL <= DISPATCH_LEVEL. A caller executing at DISPATCH_LEVEL must specify a NonPagedXxx value for PoolType. A caller executing at IRQL <= APC_LEVEL can specify any POOL_TYPE value, but the IRQL and environment must also be considered for determining the pool type. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "ExAllocatePoolWithQuotaTag",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "POOL_TYPE",
        "name": "PoolType",
        "description": "Specifies the type of pool memory to allocate. For a description of the available pool memory types, see POOL_TYPE. You can modify the PoolType value by bitwise-ORing this value with the POOL_QUOTA_FAIL_INSTEAD_OF_RAISE flag. This flag causes the routine to return a NULL value if the request cannot be satisfied. Similarly, you can modify the PoolType value by bitwise-ORing this value with the POOL_COLD_ALLOCATION flag as a hint to the kernel to allocate the memory from pages that are likely to be paged out quickly. To reduce the amount of resident pool memory as much as possible, you should not reference these allocations frequently. The POOL_COLD_ALLOCATION flag is only advisory and is supported in Windows XP and later versions of the Windows operating system."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "Specifies the number of bytes to allocate."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Tag",
        "description": "Specifies the pool tag for the allocated memory. For more information, see the Tag parameter of ExAllocatePoolWithTag."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExFreePool routine deallocates a block of pool memory.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine releases memory allocated by ExAllocatePool, ExAllocatePoolWithTag, ExAllocatePoolWithQuota, or ExAllocatePoolWithQuotaTag. The memory block must not be accessed after it is freed. Drivers can also use the ExFreePoolWithTag routine to free buffers allocated by ExAllocatePoolWithTag and ExAllocatePoolWithQuotaTag. Callers of ExFreePool must be running at IRQL <= DISPATCH_LEVEL. A caller at DISPATCH_LEVEL must have specified a NonPagedXxxPoolType when the memory was allocated. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExFreePool",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "P",
        "description": "Specifies the address of the block of pool memory being deallocated."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExFreePoolWithTag routine deallocates a block of pool memory allocated with the specified tag.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of ExFreePoolWithTag must be running at IRQL <= DISPATCH_LEVEL. A caller at DISPATCH_LEVEL must have specified a NonPagedXxxPoolType when the memory was allocated. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExFreePoolWithTag",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "P",
        "description": "Specifies the beginning address of a block of pool memory allocated by either ExAllocatePoolWithTag or ExAllocatePoolWithQuotaTag."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Tag",
        "description": "Specifies the tag value passed to ExAllocatePoolWithTag or ExAllocatePoolWithQuotaTag when the block of memory was originally allocated."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ExInitializeNPagedLookasideList routine initializes a lookaside list for nonpaged entries of the specified size.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "After calling ExInitializeNPagedLookasideList, memory blocks of the caller-specified Size can be allocated from and freed to the lookaside list with calls to ExAllocateFromNPagedLookasideList and ExFreeToNPagedLookasideList, respectively. Such dynamically allocated and freed entries can be any data structure or fixed-size buffer that the caller uses while the system is running, particularly if the caller cannot predetermine how many such entries will be in use at any given moment. The layout and contents of each fixed-size entry are caller-determined. ExInitializeNPagedLookasideList initializes the system state to track usage of the given lookaside list, as follows: The system maintains a set of all lookaside lists currently in use. As demand for lookaside list entries and on available nonpaged memory varies while the system runs, the system adjusts its limits for the number of entries to be held in each nonpaged lookaside list dynamically. Drivers must always use explicitly free any lookaside lists they create before unloading. To do otherwise is a serious programming error. Use ExDeleteNPagedLookasideList to free the list. ExInitializeNPagedLookasideList sets up the opaque list head at the caller-supplied location but preallocates no memory for list entries. Subsequently, the initial entries are allocated dynamically as calls to ExAllocateFromNPagedLookasideList occur, and these initial entries are held in the lookaside list as reciprocal calls to ExFreeToNPagedLookasideList occur. Entries collect in the given lookaside list until the system-determined maximum is reached, whereupon any additional entries are returned to nonpaged pool as they are freed. If the list becomes empty, allocate requests are satisfied by the XxxAllocate function specified at list initialization or by ExAllocatePoolWithTag. It is more efficient to pass NULL pointers for the Allocate and Free parameters of ExInitializeNPagedLookasideList whenever the user of a lookaside list does nothing more than allocate and release fixed-size entries. However, any component that uses a lookaside list might supply these functions to do additional caller-determined processing, such as tracking its own dynamic memory usage by maintaining state about the number of entries it allocates and frees. If the caller of ExInitializeNPagedLookasideList supplies an XxxAllocate function, that routine must allocate entries for the lookaside list using the given input parameters when it calls ExAllocatePoolWithTag. Starting with Windows Vista, a similar routine, ExInitializeLookasideListEx, initializes a lookaside list that is described by a LOOKASIDE_LIST_EX structure. Unlike the XxxAllocate and XxxFree routines for a lookaside list that uses an NPAGED_LOOKASIDE_LIST structure, the allocation and deallocation routines for a lookaside list that uses the LOOKASIDE_LIST_EX structure receive a context pointer as an input parameter. These routines can use this context to store private data for the lookaside list. If your driver is intended to run only in Windows Vista and later versions of Windows, consider using ExInitializeLookasideListEx instead of ExInitializeNPagedLookasideList. For more information, see Using Lookaside Lists. Callers of ExInitializeNPagedLookasideList can be running at IRQL <= DISPATCH_LEVEL, but are typically running at IRQL = PASSIVE_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExInitializeNPagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PNPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the NPAGED_LOOKASIDE_LIST structure to initialize. The caller must use nonpaged system space for the structure. On 64-bit platforms, this structure must be 16-byte aligned."
      },
      {
        "in_out": "_In_opt_",
        "type": "PALLOCATE_FUNCTION",
        "name": "Allocate",
        "description": "A pointer to either a caller-supplied function for allocating an entry when the lookaside list is empty, or to NULL. If non-NULL, the pointer is to a function with the prototype:       Copy      PVOID XxxAllocate(   __in POOL_TYPE  PoolType,           // NonPagedPool    __in SIZE_T  NumberOfBytes,         // value of Size   __in ULONG  Tag                     // value of Tag );      If the Allocate parameter is NULL, subsequent calls to ExAllocateFromNPagedLookasideList automatically allocate entries whenever the lookaside list is empty."
      },
      {
        "in_out": "_In_opt_",
        "type": "PFREE_FUNCTION",
        "name": "Free",
        "description": "A pointer to either a caller-supplied function for freeing an entry whenever the lookaside list is full, or to NULL. If non-NULL, the pointer is to a function with the prototype:       Copy      VOID XxxFree(   __in PVOID  Buffer );      If the Free parameter is NULL, subsequent calls to ExFreeToNPagedLookasideList automatically release the given entry back to nonpaged pool whenever the list is full, that is, currently holding the system-determined maximum number of entries."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Starting in Windows 8, this parameter specifies an optional flag value to modify the default behavior of the ExInitializeNPagedLookasideList routine. Compatible flag bits include the following.  Flag bitMeaning  POOL_NX_ALLOCATION  Allocate non-executable memory.   POOL_RAISE_IF_ALLOCATION_FAILURE  If the allocation fails, raise an exception.     Before Windows 8, this parameter is not used and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "Specifies the size, in bytes, for each nonpaged entry to be allocated subsequently. This parameter must not be less than the required minimum size, LOOKASIDE_MINIMUM_BLOCK_SIZE, which is defined in the Wdm.h header file."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Tag",
        "description": "Specifies the pool tag to use when allocating lookaside list entries. For more information about pool tags, see the Tag parameter of ExAllocatePoolWithTag."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Depth",
        "description": "Reserved. Must be zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExAllocateFromNPagedLookasideList routine returns a pointer to a nonpaged entry from the given lookaside list, or it returns a pointer to a newly allocated nonpaged entry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExAllocateFromNPagedLookasideList returns a pointer to an entry if one can be allocated. Otherwise, it returns NULL. ",
    "remarks": "If the given lookaside list is not empty, ExAllocateFromNPagedLookasideList removes the first entry from the list and returns a pointer to this entry. Otherwise, ExAllocateFromNPagedLookasideList either calls the Allocate routine specified at list initialization or ExAllocatePoolWithTag to return an entry pointer. The caller can then set up the returned entry with any caller-determined data. For example, a driver might use each such fixed-size entry to set up command blocks, like SCSI SRBs, to peripheral devices on a particular type of I/O bus. The caller should release each entry with ExFreeToNPagedLookasideList when it is no longer in use. For more information, see Using Lookaside Lists. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "ExAllocateFromNPagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PNPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the NPAGED_LOOKASIDE_LIST structure for the lookaside list, which the caller already initialized with ExInitializeNPagedLookasideList."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExFreeToNPagedLookasideList routine returns a nonpaged entry to the given lookaside list or to nonpaged pool.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExFreeToNPagedLookasideList is the reciprocal of ExAllocateFromNPagedLookasideList. It releases a caller-allocated entry back to the caller's lookaside list or to nonpaged pool when that entry is no longer in use. The same entry can be reallocated or another entry allocated later with a subsequent call to ExAllocateFromNPagedLookasideList. The user of the lookaside list can allocate and free such entries dynamically on an as-needed basis until it calls ExDeleteNPagedLookasideList, which releases any outstanding entries in the list before it clears the system state for the given lookaside list and returns control. If the specified lookaside list has not yet reached the system-determined maximum number of entries, ExFreeToNPagedLookasideList inserts the given entry at the front of the list. Otherwise, the buffer at Entry is released to nonpaged pool using the caller-supplied Free routine, if any, that was set up when the lookaside list was initialized or ExFreePool. For more information, see Using Lookaside Lists. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "ExFreeToNPagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PNPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the NPAGED_LOOKASIDE_LIST structure for the lookaside list, which the caller already initialized with ExInitializeNPagedLookasideList."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Entry",
        "description": "A pointer to the entry to be freed. The caller obtained this pointer from a preceding call to ExAllocateFromNPagedLookasideList."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExDeleteNPagedLookasideList routine destroys a nonpaged lookaside list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExDeleteNPagedLookasideList is the reciprocal of ExInitializeNPagedLookasideList. It frees any remaining entries in the specified lookaside list and then removes the list from the system-wide set of active lookaside lists. The caller of ExDeleteNPagedLookasideList is responsible for subsequently releasing the memory that the caller provided to contain the list head. For more information, see Using Lookaside Lists. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExDeleteNPagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PNPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the NPAGED_LOOKASIDE_LIST structure for the lookaside list, which the caller originally set up with ExInitializeNPagedLookasideList."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ExInitializePagedLookasideList routine initializes a lookaside list for pageable entries of the specified size.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "After calling ExInitializePagedLookasideList, blocks of the caller-specified Size can be allocated from and freed to the lookaside list with calls to ExAllocateFromPagedLookasideList and ExFreeToPagedLookasideList, respectively. Such dynamically allocated and freed entries can be any data structure or fixed-size buffer that the caller uses while the system is running, particularly if the caller cannot predetermine how many such entries will be in use at any given moment. The layout and contents of each fixed-size entry are caller-determined. ExInitializePagedLookasideList initializes the system state to track usage of the given lookaside list, as follows: The system maintains a set of all lookaside lists in use. As demand for lookaside list entries and on available paged memory varies while the system runs, the system adjusts its limits for the number of entries to be held in each paged lookaside list dynamically. Drivers must always use explicitly free any lookaside lists they create before unloading. To do otherwise is a serious programming error. Use ExDeletePagedLookasideList to free the list. ExInitializePagedLookasideList sets up the opaque list head at the caller-supplied location but preallocates no memory for list entries. Subsequently, the initial entries are allocated dynamically as calls to ExAllocateFromPagedLookasideList occur, and these initial entries are held in the lookaside list as reciprocal calls to ExFreeToPagedLookasideList occur. Entries collect in the given lookaside list until the system-determined maximum is reached, whereupon any additional entries are returned to paged pool as they are freed. If the list becomes empty, allocate requests are satisfied by the XxxAllocate function specified at list initialization or by ExAllocatePoolWithTag. It is more efficient to pass NULL pointers for the Allocate and Free parameters of ExInitializePagedLookasideList whenever the user of a lookaside list does nothing more than allocate and release fixed-size entries. However, any component that uses a lookaside list might supply these functions to do additional caller-determined processing, such as tracking its own dynamic memory usage by maintaining state about the number of entries it allocates and frees. If the caller of ExInitializePagedLookasideList supplies an XxxAllocate function, that function must allocate entries for the lookaside list using the given input parameters when it calls ExAllocatePoolWithTag. Starting with Windows Vista, a similar routine, ExInitializeLookasideListEx, initializes a lookaside list that is described by a LOOKASIDE_LIST_EX structure. Unlike the XxxAllocate and XxxFree routines for a lookaside list that uses a PAGED_LOOKASIDE_LIST structure, the allocation and deallocation routines for a lookaside list that uses the LOOKASIDE_LIST_EX structure receive a context pointer as an input parameter. These routines can use this context to store private data for the lookaside list. If your driver is intended to run only in Windows Vista and later versions of Windows, consider using ExInitializeLookasideListEx instead of ExInitializePagedLookasideList. For more information, see Using Lookaside Lists. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExInitializePagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the PAGED_LOOKASIDE_LIST structure to initialize. The caller must use nonpaged system space for the structure, even though the entries in this lookaside list will be allocated from pageable memory. On 64-bit platforms, this structure must be 16-byte aligned."
      },
      {
        "in_out": "_In_opt_",
        "type": "PALLOCATE_FUNCTION",
        "name": "Allocate",
        "description": "A pointer to either a caller-supplied function for allocating an entry when the lookaside list is empty, or to NULL. If non-NULL, the pointer is to a function with the prototype:       Copy      PVOID XxxAllocate(   __in POOL_TYPE  PoolType,           // PagedPool    __in SIZE_T  NumberOfBytes,         // value of Size   __in ULONG  Tag                     // value of Tag );      If the Allocate parameter is NULL, subsequent calls to ExAllocateFromPagedLookasideList automatically allocate entries whenever the lookaside list is empty."
      },
      {
        "in_out": "_In_opt_",
        "type": "PFREE_FUNCTION",
        "name": "Free",
        "description": "A pointer to either a caller-supplied function for freeing an entry whenever the lookaside list is full, or to NULL. If non-NULL, the pointer is to a function with the prototype:       Copy      VOID XxxFree(   __in PVOID  Buffer );      If the Free parameter is NULL, subsequent calls to ExFreeToPagedLookasideList automatically release the given entry back to paged pool whenever the list is full, that is, currently holding the system-determined maximum number of entries."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Starting in Windows 8, this parameter specifies an optional flag value to modify the default behavior of the ExInitializePagedLookasideList routine. Compatible flag bits include the following.  Flag bitMeaning  POOL_NX_ALLOCATION  Allocate non-executable memory.   POOL_RAISE_IF_ALLOCATION_FAILURE  If the allocation fails, raise an exception.     Before Windows 8, this parameter is not used and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "Specifies the size in bytes of each entry in the lookaside list."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Tag",
        "description": "Specifies the pool tag to use when allocating lookaside list entries. For more information about pool tags, see the Tag parameter of ExAllocatePoolWithTag."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Depth",
        "description": "Reserved. Must be zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExAllocateFromPagedLookasideList routine returns a pointer to a paged entry from the given lookaside list, or it returns a pointer to a newly allocated paged entry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExAllocateFromPagedLookasideList returns a pointer to an entry if one can be allocated. Otherwise, it returns NULL. ",
    "remarks": "If the given lookaside list is not empty, ExAllocateFromPagedLookasideList removes the first entry from the list and returns a pointer to this entry. Otherwise, ExAllocateFromPagedLookasideList either calls the Allocate routine specified at list initialization or ExAllocatePoolWithTag to return an entry pointer. The caller can then set up the returned entry with any caller-determined data. The caller should release each entry with ExFreeToPagedLookasideList when it is no longer in use. Because the entries in a paged lookaside list are allocated from pageable memory, they must not be accessed at an IRQL >= DISPATCH_LEVEL. You can use ExAllocateFromNPagedLookasideList to create a lookaside list with non-pageable entries. On Windows 2000, drivers must use the -D_WIN2K_COMPAT_SLIST_USAGE switch to successfully link code that uses ExAllocateFromPagedLookasideList. For more information, see Using Lookaside Lists. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "ExAllocateFromPagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the PAGED_LOOKASIDE_LIST structure for the lookaside list, which the caller already initialized with ExInitializePagedLookasideList."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExFreeToPagedLookasideList routine returns a pageable entry to the given lookaside list or to paged pool.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExFreeToPagedLookasideList is the reciprocal of ExAllocateFromPagedLookasideList. It releases a caller-allocated entry back to the caller's lookaside list or to paged pool when that entry is no longer in use. The same entry can be reallocated or another entry can be allocated later with a subsequent call to ExAllocateFromPagedLookasideList. The user of a lookaside list can allocate and free such entries dynamically, as needed, until it calls ExDeletePagedLookasideList. ExDeletePagedLookasideList releases any outstanding entries in the list before it clears the system state for the given lookaside list and returns control. If the specified lookaside list has not yet reached the system-determined maximum number of entries, ExFreeToPagedLookasideList inserts the given entry at the front of the list. Otherwise, the buffer at Entry is released back to paged pool using the caller-supplied Free routine, if any, that was set up when the lookaside list was initialized or ExFreePool. On Windows 2000, drivers must use the -D_WIN2K_COMPAT_SLIST_USAGE switch to successfully link code that uses ExFreeToPagedLookasideList. For more information, see Using Lookaside Lists. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExFreeToPagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the PAGED_LOOKASIDE_LIST structure for the lookaside list, which the caller already initialized with ExInitializePagedLookasideList, which the caller already initialized with ExInitializePagedLookasideList."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Entry",
        "description": "A pointer to the entry to be freed. The caller obtained this pointer from a preceding call to ExAllocateFromPagedLookasideList."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExDeletePagedLookasideList routine destroys a paged lookaside list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExDeletePagedLookasideList is the reciprocal of ExInitializePagedLookasideList. It frees any remaining entries in the specified lookaside list and then removes the list from the system-wide set of active lookaside lists. The caller of ExDeletePagedLookasideList is responsible for subsequently releasing the memory that the caller provided to contain the list head. For more information, see Using Lookaside Lists. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExDeletePagedLookasideList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PPAGED_LOOKASIDE_LIST",
        "name": "Lookaside",
        "description": "A pointer to the PAGED_LOOKASIDE_LIST structure for the lookaside list, which the caller already initialized with ExInitializePagedLookasideList, which the caller originally set up with ExInitializePagedLookasideList."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The MmQuerySystemSize routine returns an estimate of the amount of memory in the system.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmQuerySystemSize returns one of MmSmallSystem, MmMediumSystem, or MmLargeSystem. ",
    "remarks": "This routine can be called during driver initialization to determine how much memory it is practical to allocate for an internal buffer. ",
    "return_type": "MM_SYSTEMSIZE",
    "category": "Drivers",
    "name": "MmQuerySystemSize",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The MmIsThisAnNtAsSystem routine is obsolete for Windows XP and later versions of Windows. Use RtlGetVersion or RtlVerifyVersionInfo instead.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "If the current platform is a server, MmIsThisAnNtAsSystem returns TRUE. ",
    "remarks": "Drivers can use this routine during initialization, along with MmQuerySystemSize, for sizing estimates of how many resources to allocate. For example, if MmIsThisAnNtAsSystem returns TRUE, the caller can increase the number of threads or the number of initially allocated entries for a lookaside list that it creates in medium and large systems. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "MmIsThisAnNtAsSystem",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwOpenSection routine opens a handle for an existing section object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwOpenSection returns STATUS_SUCCESS on success, or the appropriate error code on failure. Possible return values include: ",
    "remarks": "If the section does not exist or the system did not grant the requested access, the operation fails. Once the handle pointed to by SectionHandle is no longer in use, the driver must call ZwClose to close it. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "SectionHandle",
        "description": "Pointer to a HANDLE variable that receives a handle to the section object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. For more information, see the DesiredAccess parameter of ZwCreateSection."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The ZwMapViewOfSection routine maps a view of a section into the virtual address space of a subject process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwMapViewOfSection returns an NTSTATUS value. Possible return values include the following:  ",
    "remarks": "Several different views of a section can be concurrently mapped into the virtual address space of one or more processes. If the specified section does not exist or the access requested is not allowed, ZwMapViewOfSection returns an error. Do not use ZwMapViewOfSection to map a memory range from \\Device\\PhysicalMemory into user mode\u00e2\u0080\u0094unless your driver has directly allocated the memory range through MmAllocatePagesForMdl or another method guaranteeing that no other system component has mapped the same memory range with a different MEMORY_CACHING_TYPE value. User applications cannot access \\Device\\PhysicalMemory directly starting with Windows Server 2003 with Service Pack 1 (SP1) and can access it only if the driver passes a handle to the application. For more information about section objects, see Section Objects and Views. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwMapViewOfSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "SectionHandle",
        "description": "Handle to a section object. This handle is created by a successful call to ZwCreateSection or ZwOpenSection."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "Handle to the object that represents the process that the view should be mapped into. Use the ZwCurrentProcess macro to specify the current process. The handle must have been opened with PROCESS_VM_OPERATION access (described in the Microsoft Windows SDK documentation)."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID*",
        "name": "BaseAddress",
        "description": "Pointer to a variable that receives the base address of the view. If the value of this parameter is not NULL, the view is allocated starting at the specified virtual address rounded down to the next 64-kilobyte address boundary."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "ZeroBits",
        "description": "Specifies the number of high-order address bits that must be zero in the base address of the section view. ..."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "CommitSize",
        "description": "Specifies the size, in bytes, of the initially committed region of the view. CommitSize is meaningful only for page-file backed sections and is rounded up to the nearest multiple of PAGE_SIZE. (For sections that map files, both the data and the image are committed at section-creation time.)"
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PLARGE_INTEGER",
        "name": "SectionOffset",
        "description": "A pointer to a variable that receives the offset, in bytes, from the beginning of the section to the view. If this pointer is not NULL, the offset is rounded down to the next allocation-granularity size boundary."
      },
      {
        "in_out": "_Inout_",
        "type": "PSIZE_T",
        "name": "ViewSize",
        "description": "A pointer to a SIZE_T variable. If the initial value of this variable is zero, ZwMapViewOfSection maps a view of the section that starts at SectionOffset and continues to the end of the section. Otherwise, the initial value specifies the view's size, in bytes. ZwMapViewOfSection always rounds this value up to the nearest multiple of PAGE_SIZE before mapping the view. On return, the value receives the actual size, in bytes, of the view."
      },
      {
        "in_out": "_In_",
        "type": "SECTION_INHERIT",
        "name": "InheritDisposition",
        "description": "Specifies how the view is to be shared with child processes. The possible values are:   ViewShare  The view will be mapped into any child processes that are created in the future.  ViewUnmap  The view will not be mapped into child processes.   Drivers should typically specify ViewUnmap for this parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocationType",
        "description": "Specifies a set of flags that describes the type of allocation to be performed for the specified region of pages. The valid flags are MEM_LARGE_PAGES, MEM_RESERVE, and MEM_TOP_DOWN. Although MEM_COMMIT is not allowed, it is implied unless MEM_RESERVE is specified. For more information about the MEM_XXX flags, see the description of the VirtualAlloc routine."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Win32Protect",
        "description": "Specifies the type of protection for the region of initially committed pages. Device and intermediate drivers should set this value to PAGE_READWRITE."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwUnmapViewOfSection routine unmaps a view of a section from the virtual address space of a subject process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwUnmapViewOfSection returns an NTSTATUS value. Possible return values include:  ",
    "remarks": "This routine unmaps the entire view of the section that contains BaseAddress from the virtual address space of the specified process\u00e2\u0080\u0094even if BaseAddress does not point to the beginning of the view. On return from ZwUnmapViewOfSection, the virtual-address region occupied by the view is no longer reserved and is available to map other views or private pages. If the view was also the last reference to the underlying section, all committed pages in the section are decommitted, and the section is deleted. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwUnmapViewOfSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "Handle to a process object that was previously passed to ZwMapViewOfSection."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the base virtual address of the view to unmap. This value can be any virtual address within the view."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmLockPagableCodeSection routine locks a section of driver code, containing a set of driver routines marked with a special compiler directive, into system space.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmLockPagableCodeSection returns an opaque value that the operating system uses to identify this section of the driver code. This opaque value can be passed subsequently to MmLockPagableSectionByHandle (if the driver unlocks and then later relocks the section) or to MmUnlockPagableImageSection. ",
    "remarks": "The MmLockPagableCodeSection routine and MmUnlockPagableImageSection (the routine that performs the opposite action) support drivers that can do the following: MmLockPagableCodeSection, MmLockPagableSectionByHandle and MmUnlockPagableImageSection are intended for use by device and intermediate drivers that have the following characteristics: For example, the system-supplied fault-tolerant disk driver supports the creation of mirror sets, stripe sets, and volume sets. Yet, a particular machine can be configured only with a mirror set, only with a stripe set, only with a volume set, or with any combination of these three possible options. In these circumstances, the system ftdisk driver reduces the size of its loaded image by marking routines that explicitly support mirror, stripe, and volume sets as belonging to pageable code sections. During driver initialization, pageable code sections are made resident only if the user has configured the disks to have mirror, stripe, or volume sets. If the user repartitions the disks dynamically, the ftdisk driver locks down any additional pageable code sections necessary to support any mirror, stripe, or volume sets that the user requests. As other examples, the system-supplied serial and parallel drivers have DispatchCreate and DispatchClose routines that are called when a particular port is opened for exclusive I/O and when the handle for an opened port is released, respectively. Yet, serial and parallel I/O requests are sporadic, determined by which applications the end user is currently running and which application options the end user is currently exercising. In these circumstances, the system serial and parallel drivers reduce the sizes of their loaded images by marking many routines as belonging to a pageable code section that the DispatchCreate routine makes resident only when the first port is opened for I/O. Note that each of the preceding system drivers satisfies both criteria for having pageable sections: the driver has code paths that might not be needed while the system is running, and the driver can determine exactly when its pageable section should be loaded and can be paged out again. Because it is an expensive operation to lock down a section, if a driver locks down a pageable code section in more than one place, use MmLockPagableCodeSection for the first request. Make subsequent lock requests by calling MmLockPagableSectionByHandle passing the handle returned by MmLockPagableCodeSection. Locking by handle significantly improves driver performance because the memory manager uses the opaque return value to quickly locate the relevant section rather than searching a loaded module list. A locked down section is unlocked by calling MmUnlockPagableImageSection. Each driver routine within a pageable code section must be marked with the following compiler directive: where xxxx is an optional four-character, unique identifier for the caller's pageable section and DriverRoutine is an entry point to be included within the pageable code section. The keyword PAGE and the driver-determined suffix, which can be up to four characters, are case-sensitive; that is, PAGE must be capitalized. A single call to MmLockPagableCodeSection in, for example, a driver's DispatchCreate routine, causes the entire section, containing every driver routine marked with the same PAGExxxx identifier, to be locked in system space. Certain types of driver routines cannot be made part of any driver's pageable section, including the following: Note that routines in a pageable section marked with the compiler directive #pragma alloc_text(PAGExxxx, ...) differ from routines marked with the compiler directive #pragma alloc_text(INIT, ...). The routines in the INIT section are not pageable and are discarded as soon as the driver returns from its DriverEntry or its Reinitialize routine, if it has one. The memory manager maintains an internal lock count on any driver's pageable section. Calls to MmLockPagableCodeSection increment this count and the reciprocal MmUnlockPagableImageSection decrements the count. A driver's pageable section is not available to be paged out unless this count is zero. For more information about creating pageable code sections, see Making Drivers Pageable. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmLockPagableCodeSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AddressWithinSection",
        "description": "Specifies a symbolic address. This address is typically the name of a driver function within a section of driver code that has been marked with something like #pragma alloc_text (PAGExxxx, driverfunction). All functions in the PAGExxxx section are then guaranteed to be locked down when this function returns."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmLockPagableDataSection routine locks an entire section of driver data into system space.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmLockPagableDataSection returns an opaque value that identifies the section. This value must be passed subsequently to MmLockPagableSectionByHandle or to MmUnlockPagableImageSection. ",
    "remarks": "Drivers can use this routine, MmLockPagableSectionByHandle, and MmUnlockPagableImageSection to make their private data that is typically pageable locked into memory. Data can be locked down if: For example, drivers for mixer devices use pageable-data sections. Because the driver uses sufficient data to make creating a pageable-data section worthwhile and the driver knows when the data is needed, such a driver uses MmLockPagableDataSection,  MmLockPagableSectionByHandle and MmUnlockPagableImageSection to bring a data section into system space when needed and make it available to be paged out when not needed. A single call to MmLockPagableDataSection causes the entire section, containing the referenced data, to be locked into system space. It is an expensive operation to lock down a section. If a pageable-data section is locked down in more than one place by a driver, use MmLockPagableDataSection for the first request. Make subsequent lock requests by calling MmLockPagableSectionByHandle, passing the handle returned by MmLockPagableDataSection. Locking by handle significantly improves driver performance. A locked down section is unlocked by calling MmUnlockPagableImageSection. The memory manager maintains a reference count on the section. A pageable-data section is only available to be paged out when the reference count is zero. Every lock request increments the count; every unlock request decrements the count. A driver must unlock a section as many times as it locks a section to ensure that such a section will be available to be paged out when the section is not needed. A handle is always valid, no matter what the count. If the count on a handle is zero and a call is made to MmLockPagableSectionByHandle, the count is set to one, and if the section has been paged out, it will be paged in. Data in a pageable-data section is marked by a compiler directive. To create a pageable data section, use #pragma data_seg (\"PAGE\"), at the beginning of the data module, and #pragma data_seg () at the end of the module. The keyword PAGE is case-sensitive, that is, PAGE must be capitalized. Note that there is also a #pragma data_seg(\"INIT\") that is used to make data discardable after system initialization. Except for the use of INIT rather than PAGE, the syntax is the same. However the result is not; use of the PAGE directive makes the data section pageable. When the INIT directive is used, the data in the section is discarded as soon as the driver returns from its driver entry routine or its reinitialization routine if the driver has one. For more information about paging data, see Making Drivers Pageable. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmLockPagableDataSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AddressWithinSection",
        "description": "Specifies the symbolic address of one item of data within the pageable section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmLockPagableSectionByHandle routine locks a pageable code or data section into system memory by incrementing the reference count on the handle to the section.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "A driver initially calls MmLockPagableCodeSection or MmLockPagableDataSection to obtain a handle to a pageable code or data section. Thereafter, the driver can call MmLockPagableSectionByHandle and MmUnlockPagableImageSection to increment and decrement the reference count on the handle. The MmLockPagableCodeSection or MmLockPagableDataSection call locks the pageable section into system memory, returns a handle to the section, and initializes the reference count on the handle to one. MmLockPagableSectionByHandle increments the reference count by one, and MmUnlockPagableImageSection decrements the reference count by one. If the reference count on the handle is nonzero, the pageable section is locked. If the reference count is zero, the section is unlocked. The handle to the pageable section remains valid as long as the driver stays loaded in memory. The driver can use the same handle to repeatedly lock and unlock the section. That is, the driver can reuse a handle whose reference count is zero. MmLockPagableSectionByHandle checks to see if the referenced section is resident in the caller's address space and, if it is, simply increments the reference count on the section. If the section is not resident, MmLockPagableSectionByHandle pages in the section, locks it in system space, and sets the reference count to one. To avoid leaking system memory, the reference count on the handle must be zero when the driver is unloaded from memory. Otherwise, the pageable section will stay locked into system memory after the driver unloads. If the driver is preparing to unload, and the reference count on the handle is nonzero, the driver should call MmUnlockPagableImageSection to decrement the count to zero before the unload occurs. A driver cannot call MmLockPagableSectionByHandle to lock down user buffers passed in IRPs. Use MmProbeAndLockPages instead. For more information about paging code and data, see Making Drivers Pageable. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmLockPagableSectionByHandle",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ImageSectionHandle",
        "description": "The handle to a pageable code or data section. The caller obtained this handle from a previous call to the MmLockPagableCodeSection or MmLockPagableDataSection routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmUnlockPagableImageSection routine releases a section of driver code or driver data, previously locked into system space with MmLockPagableCodeSection, MmLockPagableDataSection or MmLockPagableSectionByHandle, so the section can be paged out again.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The handle for a driver's pageable section must not be released if the driver has any outstanding IRPs in its device queue(s) or internal queue(s). A call to MmUnlockPagableImageSection restores the pageability of that entire section when there are no more references to the handle for that section. The memory manager maintains the reference count on the handle to a section. A pageable section is only available to be paged out when the reference count is zero. Every lock request increments the count; every unlock request decrements the count. A driver must unlock a section as many times as it locks a section to make the section available to be paged out. A handle is always valid, no matter what the count. If the count on a handle is zero and a call is made to MmLockPagableSectionByHandle, the count is set to one, and if the section has been paged out, it will be paged in. In most cases, MmUnlockPagableImageSection is called before a driver's Unload routine. That is, a driver with a pageable section is likely to have its DispatchClose and/or DispatchShutdown routine call MmUnlockPagableImageSection before its Unload routine is called. However, care should be taken in unloadable drivers to release any pageable section before the driver itself is unloaded from the system. For more information about paging code and data, see Making Drivers Pageable. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmUnlockPagableImageSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ImageSectionHandle",
        "description": "Specifies the handle returned by a call to MmLockPagableCodeSection or MmLockPagableDataSection."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmPageEntireDriver routine causes all of a driver's code and data to be made pageable, overriding the attributes of the various sections that make up the driver's image.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmPageEntireDriver returns a pointer to the beginning of the driver image in memory. ",
    "remarks": "Use this routine to force a driver to be completely pageable. Drivers that call MmPageEntireDriver must not have an InterruptService routine (ISR) registered for any interrupts. If the interrupt occurs while the driver is paged out, the system issues a bug check. The effect of a call to MmPageEntireDriver can be undone by calling MmResetDriverPaging. If the driver is already completely pageable, calling MmPageEntireDriver has no effect. For more information about paging an entire driver, see Making Drivers Pageable. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmPageEntireDriver",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AddressWithinSection",
        "description": "Pointer to a virtual address within the driver (for example, the address of the DriverEntry routine)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmResetDriverPaging routine resets the pageable status of a driver's sections to that specified when the driver was compiled.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "MmResetDriverPaging causes those routines that would not normally be pageable, to be locked into memory. Hence, image sections such as .text and .data will be locked in memory if this routine is called. A driver that calls this routine must do so before enabling interrupts on its device. A call to MmPageEntireDriver is not a prerequisite to calling this routine. However, calls to MmResetDriverPaging do nothing if the driver's image-section attributes have never been overridden by a call to MmPageEntireDriver. For more information about paging an entire driver, see Making Drivers Pageable. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmResetDriverPaging",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AddressWithinSection",
        "description": "A pointer to a virtual address in the driver (for example, the address of the DriverEntry routine)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The READ_PORT_UCHAR routine reads a byte from the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "READ_PORT_UCHAR returns the byte that is read from the specified port address. ",
    "remarks": "Callers of READ_PORT_UCHAR can be running at any IRQL, assuming the Port is resident, mapped device memory. ",
    "return_type": "UCHAR",
    "category": "Drivers",
    "name": "READ_PORT_UCHAR",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Port",
        "description": "Specifies the port address, which must be a mapped memory range in I/O space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The READ_PORT_USHORT routine reads a USHORT value from the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "READ_PORT_USHORT returns the USHORT value that is read from the specified port address. ",
    "remarks": "Callers of READ_PORT_USHORT can be running at any IRQL, assuming the Port is resident, mapped device memory. ",
    "return_type": "USHORT",
    "category": "Drivers",
    "name": "READ_PORT_USHORT",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Port",
        "description": "Specifies the port address, which must be a mapped range in I/O space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The READ_PORT_ULONG routine reads a ULONG value from the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "READ_PORT_ULONG returns the ULONG value that is read from the specified port address. ",
    "remarks": "Callers of READ_PORT_ULONG can be running at any IRQL, assuming the Port is resident, mapped device memory. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "READ_PORT_ULONG",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Port",
        "description": "Specifies the port address, which must be a mapped range in I/O space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The READ_PORT_BUFFER_UCHAR routine reads a number of bytes from the specified port address into a buffer.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of bytes. Callers of READ_PORT_BUFFER_UCHAR can be running at any IRQL, assuming the Buffer is resident and the Port is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "READ_PORT_BUFFER_UCHAR",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Port",
        "description": "Specifies the port address, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Buffer",
        "description": "Pointer to a buffer into which an array of UCHAR values is read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of bytes to be read into the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The READ_PORT_BUFFER_USHORT routine reads a number of USHORT values from the specified port address into a buffer.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of USHORT values. Callers of READ_PORT_BUFFER_USHORT can be running at any IRQL, assuming the Buffer is resident and the Port is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "READ_PORT_BUFFER_USHORT",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Port",
        "description": "Specifies the port address, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "Buffer",
        "description": "Pointer to a buffer into which an array of USHORT values is read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of USHORT values to be read into the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The READ_PORT_BUFFER_ULONG routine reads a number of ULONG values from the specified port address into a buffer.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of ULONG values. Callers of READ_PORT_BUFFER_ULONG can be running at any IRQL, assuming the Buffer is resident and the Port is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "READ_PORT_BUFFER_ULONG",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Port",
        "description": "Specifies the port address, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Buffer",
        "description": "Pointer to a buffer into which an array of ULONG values is read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of ULONG values to be read into the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The WRITE_PORT_UCHAR routine writes a byte to the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of WRITE_PORT_UCHAR can be running at any IRQL, assuming the Port is resident, mapped device memory. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "WRITE_PORT_UCHAR",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Port",
        "description": "Pointer to the port, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Value",
        "description": "Specifies a byte to be written to the port."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The WRITE_PORT_USHORT routine writes a USHORT value to the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of WRITE_PORT_USHORT can be running at any IRQL, assuming the Port is resident, mapped device memory. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "WRITE_PORT_USHORT",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Port",
        "description": "Pointer to the port, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Value",
        "description": "Specifies a USHORT value to be written to the port."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The WRITE_PORT_ULONG routine writes a ULONG value to the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of WRITE_PORT_ULONG can be running at any IRQL, assuming the Port is resident, mapped device memory. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "WRITE_PORT_ULONG",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Port",
        "description": "Pointer to the port, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Value",
        "description": "Specifies a ULONG value to be written to the port."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The WRITE_PORT_BUFFER_UCHAR routine writes a number of bytes from a buffer to the specified port.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of bytes. Callers of WRITE_PORT_BUFFER_UCHAR can be running at any IRQL, assuming the Buffer is resident and the Port is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_PORT_BUFFER_UCHAR",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Port",
        "description": "Pointer to the port, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Buffer",
        "description": "Pointer to a buffer from which an array of UCHAR values is to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of bytes to be written to the port."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The WRITE_PORT_BUFFER_USHORT routine writes a number of USHORT values from a buffer to the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of USHORT values. Callers of WRITE_PORT_BUFFER_USHORT can be running at any IRQL, assuming the Buffer is resident and the Port is resident, mapped device memory. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "WRITE_PORT_BUFFER_USHORT",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Port",
        "description": "Pointer to the port, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Buffer",
        "description": "Pointer to a buffer from which an array of USHORT values is to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of USHORT values to be written to the port."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The WRITE_PORT_BUFFER_ULONG routine writes a number of ULONG values from a buffer to the specified port address.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of ULONG values. Callers of WRITE_PORT_BUFFER_ULONG can be running at any IRQL, assuming the Buffer is resident and the Port is resident, mapped device memory. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "WRITE_PORT_BUFFER_ULONG",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Port",
        "description": "Pointer to the port, which must be a mapped memory range in I/O space."
      },
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Buffer",
        "description": "Pointer to a buffer from which an array of ULONG values is to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of ULONG values to be written to the port."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The READ_REGISTER_UCHAR routine reads a byte from the specified register address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "READ_REGISTER_UCHAR returns the byte read from the specified register address. ",
    "remarks": "Callers of READ_REGISTER_UCHAR can be running at any IRQL, assuming the Register is resident, mapped device memory. ",
    "return_type": "UCHAR",
    "category": "Drivers",
    "name": "READ_REGISTER_UCHAR",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Register",
        "description": "Pointer to the register address, which must be a mapped range in memory space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The READ_REGISTER_USHORT routine reads a USHORT value from the specified register address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "READ_REGISTER_USHORT returns the USHORT value read from the specified register address. ",
    "remarks": "Callers of READ_REGISTER_USHORT can be running at any IRQL, assuming the Register is resident, mapped device memory. ",
    "return_type": "USHORT",
    "category": "Drivers",
    "name": "READ_REGISTER_USHORT",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Register",
        "description": "Pointer to the register address, which must be a mapped range in memory space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The READ_REGISTER_ULONG routine reads a ULONG value from the specified register address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "READ_REGISTER_ULONG returns the ULONG value read from the specified register address. ",
    "remarks": "Callers of READ_REGISTER_ULONG can be running at any IRQL, assuming the Register is resident, mapped device memory. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "READ_REGISTER_ULONG",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Register",
        "description": "Pointer to the register address, which must be a mapped range in memory space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The READ_REGISTER_BUFFER_UCHAR routine reads a number of bytes from the specified register address into a buffer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of bytes. Callers of READ_REGISTER_BUFFER_UCHAR can be running at any IRQL, assuming the Buffer is resident and the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "READ_REGISTER_BUFFER_UCHAR",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Buffer",
        "description": "Pointer to a buffer into which an array of UCHAR values is read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of bytes to be read into the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The READ_REGISTER_BUFFER_USHORT routine reads a number of USHORT values from the specified register address into a buffer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of USHORT values. Callers of READ_REGISTER_BUFFER_USHORT can be running at any IRQL, assuming the Buffer is resident and the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "READ_REGISTER_BUFFER_USHORT",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "Buffer",
        "description": "Pointer to a buffer into which an array of USHORT values is read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of USHORT values to be read into the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The READ_REGISTER_BUFFER_ULONG routine reads a number of ULONG values from the specified register address into a buffer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of ULONG values. Callers of READ_REGISTER_BUFFER_ULONG can be running at any IRQL, assuming the Buffer is resident and the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "READ_REGISTER_BUFFER_ULONG",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Buffer",
        "description": "Pointer to a buffer into which an array of ULONG values is read."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of ULONG values to be read into the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The WRITE_REGISTER_UCHAR routine writes a byte to the specified address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of WRITE_REGISTER_UCHAR can be running at any IRQL, assuming the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_REGISTER_UCHAR",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Value",
        "description": "Specifies a byte to be written to the register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The WRITE_REGISTER_USHORT routine writes a USHORT value to the specified address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of WRITE_REGISTER_USHORT can be running at any IRQL, assuming the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_REGISTER_USHORT",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Value",
        "description": "Specifies a USHORT value to be written to the register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The WRITE_REGISTER_ULONG routine writes a ULONG value to the specified address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of WRITE_REGISTER_ULONG can be running at any IRQL, assuming the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_REGISTER_ULONG",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Register",
        "description": "Pointer to the register which must be a mapped range in memory space."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Value",
        "description": "Specifies a ULONG value to be written to the register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The WRITE_REGISTER_BUFFER_UCHAR routine writes a number of bytes from a buffer to the specified register.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of bytes. Callers of WRITE_REGISTER_BUFFER_UCHAR can be running at any IRQL, assuming the Buffer is resident and the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_REGISTER_BUFFER_UCHAR",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Buffer",
        "description": "Pointer to a buffer from which an array of UCHAR values is to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of bytes to be written to the register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The WRITE_REGISTER_BUFFER_USHORT routine writes a number of USHORT values from a buffer to the specified register.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of USHORT values. Callers of WRITE_REGISTER_BUFFER_USHORT can be running at any IRQL, assuming the Buffer is resident and the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_REGISTER_BUFFER_USHORT",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_In_",
        "type": "PUSHORT",
        "name": "Buffer",
        "description": "Pointer to a buffer from which an array of USHORT values is to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of USHORT values to be written to the register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The WRITE_REGISTER_BUFFER_ULONG routine writes a number of ULONG values from a buffer to the specified register.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The size of the buffer must be large enough to contain at least the specified number of ULONG values. Callers of WRITE_REGISTER_BUFFER_ULONG can be running at any IRQL, assuming the Buffer is resident and the Register is resident, mapped device memory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "WRITE_REGISTER_BUFFER_ULONG",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Register",
        "description": "Pointer to the register, which must be a mapped range in memory space."
      },
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "Buffer",
        "description": "Pointer to a buffer from which an array of ULONG values is to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Count",
        "description": "Specifies the number of ULONG values to be written to the register."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The IoAllocateMdl routine allocates a memory descriptor list (MDL) large enough to map a buffer, given the buffer's starting address and length. Optionally, this routine associates the MDL with an IRP.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoAllocateMdl returns a pointer to an MDL, or, if the MDL cannot be allocated, it returns NULL. ",
    "remarks": "IoAllocateMdl can be used by a driver that needs to break a buffer into pieces, each mapped by a separate MDL, or to map a driver-allocated buffer. The driver should call MmBuildMdlForNonPagedPool with the MDL allocated by this call to set up an MDL describing a driver-allocated buffer in nonpaged pool. The Length parameter specifies the size of the buffer that is to be described by the MDL. In Windows Server 2003, Windows XP, and Windows 2000, the maximum buffer size, in bytes, that this routine can allocate is PAGE_SIZE * (65535 - sizeof(MDL)) / sizeof(ULONG_PTR). In Windows Vista and Windows Server 2008, the maximum buffer size is (2 gigabytes - PAGE_SIZE). In Windows 7 and Windows Server 2008 R2, the maximum buffer size is (4 gigabytes - PAGE_SIZE). If the SecondaryBuffer parameter is FALSE, the routine updates Irp->MdlAddress to point to the new MDL. If SecondaryBuffer is TRUE, the routine adds the MDL to the end of the MDL chain that Irp->MdlAddress points to. For more information about MDLs, see Using MDLs. ",
    "return_type": "PMDL",
    "category": "Drivers",
    "name": "IoAllocateMdl",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "Pointer to the base virtual address of the buffer the MDL is to describe."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length, in bytes, of the buffer that the MDL is to describe. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "SecondaryBuffer",
        "description": "Indicates whether the buffer is a primary or secondary buffer. This parameter determines how the MDL is to be linked to the IRP. All buffers except the first buffer described by an MDL in an IRP are considered secondary buffers. This field must be FALSE if no IRP is associated with the MDL. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ChargeQuota",
        "description": "Reserved for system use. Drivers must set this parameter to FALSE."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to an IRP to be associated with the MDL. If the Irp pointer is non-NULL, the allocated MDL is associated with the specified IRP's MDL list, according to the value of SecondaryBuffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoBuildPartialMdl routine builds a new memory descriptor list (MDL) that represents part of a buffer that is described by an existing MDL.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine builds a target MDL that describes a subrange of the buffer that is described by the source MDL. This subrange is specified by the VirtualAddress and Length parameters. The SourceMdl and TargetMdl parameters point to the source MDL and target MDL. A driver can use IoBuildPartialMdl to split a large transfer request into smaller transfer requests. The physical pages that the source MDL describes must be locked before the driver calls IoBuildPartialMdl. Typically, the source MDL describes a buffer in user address space, and the driver calls the MmProbeAndLockPages routine to lock the pages in this buffer. However, the driver can build the source MDL from nonpaged memory by calling the MmBuildMdlForNonPagedPool, MmAllocatePagesForMdlEx, or MmAllocatePagesForMdl routine. A driver can map a partial MDL into the system address space by using the MmGetSystemAddressForMdlSafe macro. If a partial MDL is built from a source MDL that is already mapped into the system address space, MmGetSystemAddressForMdlSafe uses the existing source mapping. Otherwise, MmGetSystemAddressForMdlSafe creates a new mapping. To prevent this new mapping from being leaked, drivers must call MmPrepareMdlForReuse before reusing a partial MDL. In addition, the IoFreeMdl routine releases the system-address-space mapping for a partial MDL, if such a mapping exists. For more information about MDLs, see Using MDLs. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoBuildPartialMdl",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "SourceMdl",
        "description": "A pointer to an MDL that describes the original buffer, of which a subrange is to be mapped."
      },
      {
        "in_out": "_Inout_",
        "type": "PMDL",
        "name": "TargetMdl",
        "description": "A pointer to a caller-allocated MDL. This MDL must be large enough to describe the pages in the subrange that are specified by VirtualAddress and Length."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "A pointer to the base virtual address for the subrange to be described by the TargetMdl."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length, in bytes, to be mapped by the TargetMdl. This value, in combination with VirtualAddress, must specify a buffer that is a proper subrange of the buffer that is described by SourceMdl. If Length is zero, the subrange to be mapped starts at VirtualAddress and includes the remaining range described by the SourceMdl."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoFreeMdl routine releases a caller-allocated memory descriptor list (MDL).",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If a driver allocates an MDL to describe a buffer, it must explicitly release the MDL when operations on the buffer are done. If the MDL is a partial MDL, IoFreeMdl unmaps any pages that have been mapped to the MDL. If the physical pages that are described by the MDL are locked, the driver must unlock the pages before it frees the MDL. This routine frees only the specified MDL. Any MDLs that are chained to this MDL must be explicitly freed through additional calls to this routine. For a code example that shows how to free an MDL chain, see Using MDLs. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoFreeMdl",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "Pointer to the MDL to be released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The MmAllocatePagesForMdlEx routine allocates nonpaged, physical memory pages to an MDL.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmAllocatePagesForMdlEx returns one of the following:  ",
    "remarks": "By default, the physical memory pages that MmAllocatePagesForMdlEx returns are not contiguous pages. Starting with Windows 7, callers can override the default behavior of this routine by setting the MM_ALLOCATE_PREFER_CONTIGUOUS or MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS flag bit in the Flags parameter. MmAllocatePagesForMdlEx is designed for kernel-mode drivers that do not need corresponding virtual addresses (that is, they need physical pages and do not need them to be physically contiguous), and for kernel-mode drivers that can achieve substantial performance gains if physical memory for a device is allocated in a specific physical address range (for example, an AGP graphics card). Depending on how much physical memory is currently available in the requested ranges, MmAllocatePagesForMdlEx might return an MDL that describes less memory than was requested. The routine also might return NULL if no memory was allocated. The caller should check the amount of memory that is actually allocated to the MDL. The caller must use MmFreePagesFromMdl to release the memory pages that are described by an MDL that was created by MmAllocatePagesForMdlEx. After calling MmFreePagesFromMdl, the caller must also call ExFreePool to release the memory that is allocated for the MDL structure. By default, MmAllocatePagesForMdlEx fills the pages that it allocates with zeros. The caller can specify the MM_DONT_ZERO_ALLOCATION flag to override this default and to possibly improve performance. The maximum amount of memory that MmAllocatePagesForMdlEx can allocate in a single call is (4 gigabytes - PAGE_SIZE). The routine can satisfy an allocation request for this amount only if enough pages are available. MmAllocatePagesForMdlEx runs at IRQL <= APC_LEVEL. In Windows Server 2008 and later versions of Windows, callers of MmAllocatePagesForMdlEx are allowed to be at DISPATCH_LEVEL. However, you can improve driver performance by calling at APC_LEVEL or below. ",
    "return_type": "PMDL",
    "category": "Drivers",
    "name": "MmAllocatePagesForMdlEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PHYSICAL_ADDRESS",
        "name": "LowAddress",
        "description": "Specifies the physical address of the start of the first address range from which the allocated pages can come. If MmAllocatePagesForMdlEx cannot allocate the requested number of bytes in the first address range, it iterates through additional address ranges to get more pages. At each iteration, MmAllocatePagesForMdlEx adds the value of SkipBytes to the previous start address to obtain the start of the next address range."
      },
      {
        "in_out": "_In_",
        "type": "PHYSICAL_ADDRESS",
        "name": "HighAddress",
        "description": "Specifies the physical address of the end of the first address range that the allocated pages can come from."
      },
      {
        "in_out": "_In_",
        "type": "PHYSICAL_ADDRESS",
        "name": "SkipBytes",
        "description": "Specifies the number of bytes to skip from the start of the previous address range that the allocated pages can come from. SkipBytes must be an integer multiple of the virtual memory page size, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "TotalBytes",
        "description": "Specifies the total number of bytes to allocate for the MDL."
      },
      {
        "in_out": "_In_",
        "type": "MEMORY_CACHING_TYPE",
        "name": "CacheType",
        "description": "Specifies a MEMORY_CACHING_TYPE value, which indicates the type of caching that is allowed for the requested memory."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Specifies flags for this operation. Set this parameter to zero or to the bitwise OR of one or more of the following MM_ALLOCATE_XXX flag bits: The last four items in the preceding list are supported only in Windows 7 and later versions of Windows.  ValueMeaning  MM_DONT_ZERO_ALLOCATION 0x00000001   Do not fill the allocated pages with zeros. By default, MmAllocatePagesForMdlEx zeros the pages that it allocates. By skipping this operation, you can potentially improve the performance of the MmAllocatePagesForMdlEx call. However, you must not use this flag unless either you never expose the allocated pages to user-mode programs, or you always overwrite the original contents of the pages before you expose the allocated pages to user-mode programs.   MM_ALLOCATE_FROM_LOCAL_NODE_ONLY 0x00000002   Allocate pages only from the ideal node. This flag applies only to multiprocessor systems that have non-uniform memory access (NUMA) architectures. Starting with Windows Vista, this flag indicates that all pages must be allocated from the ideal node of the current thread. No pages are to be allocated from other nodes. In versions of Windows earlier than Windows Vista, this flag indicates that all pages must be allocated from the local node; that is, from the node that the current processor belongs to. For more information about NUMA multiprocessor systems, see NUMA Support.   MM_ALLOCATE_FULLY_REQUIRED 0x00000004   A full allocation is required. Starting with Windows 7, this flag requires MmAllocatePagesForMdlEx to return NULL if it cannot allocate all the requested pages. The routine returns a non-NULL value only if it successfully obtains the entire requested allocation. This flag enables the memory manager to perform the allocation more efficiently in cases in which the caller requires a full allocation.   MM_ALLOCATE_NO_WAIT 0x00000008   Do not wait. Starting with Windows 7, this flag indicates that the MmAllocatePagesForMdlEx call must not block the calling thread. Typically, the caller is a kernel-mode driver that is running at IRQL < DISPATCH_LEVEL but cannot allow its execution to be blocked. For example, the driver might be assisting with paging or power-management operations. Regardless of whether this flag is set, MmAllocatePagesForMdlEx never blocks callers that are running at IRQL = DISPATCH_LEVEL.   MM_ALLOCATE_PREFER_CONTIGUOUS 0x00000010   Allocation is performed in a way that minimizes system memory fragmentation. Starting with Windows 7, this flag indicates that the caller wants to avoid fragmenting physical memory to make more contiguous memory available to other callers. The allocated pages are not guaranteed to be (and usually are not) physically contiguous, even if plenty of contiguous memory is available. Callers that require contiguous memory should specify MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS instead of MM_ALLOCATE_PREFER_CONTIGUOUS.   MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS 0x00000020   Contiguous memory is required. Starting with Windows 7, this flag indicates that the requested pages must be allocated as contiguous blocks of physical memory. If the SkipBytes parameter is zero, MmAllocatePagesForMdlEx either succeeds and returns a single, contiguous block, or it fails and returns NULL. It never returns a partial allocation. For SkipBytes = 0, the allocated pages satisfy the address range requirements that are specified by the LowAddress and HighAddress parameters, but the pages are subject to no special alignment restrictions. If SkipBytes is nonzero, SkipBytes must be a power of two and must be greater than or equal to PAGE_SIZE, and the TotalBytes parameter value must be a multiple of SkipBytes. In this case, the returned MDL can contain multiple blocks of contiguous pages. That is, each block is internally contiguous but the blocks are not necessarily contiguous with each other. Each block of contiguous pages is guaranteed to be exactly SkipBytes long and to be aligned on a SkipBytes boundary. Partial allocations can occur if SkipBytes is nonzero, but each contiguous block in a partial allocation is guaranteed to be SkipBytes long."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmBuildMdlForNonPagedPool routine receives an MDL that specifies a nonpaged virtual memory buffer, and updates it to describe the underlying physical pages.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "At entry, the specified MDL must describe a buffer in nonpaged system memory, such as memory that is allocated by the ExAllocatePoolWithTag routine with PoolType = NonPagedPool or by the MmAllocateContiguousMemorySpecifyCache routine. MmBuildMdlForNonPagedPool updates the MDL to describe the underlying physical pages. Because the pages described by the MDL are already nonpageable and are already mapped to the system address space, drivers must not try to lock them by using the MmProbeAndLockPages routine, or to create additional system-address-space mappings by using the MmMapLockedPagesSpecifyCache routine. Similarly, drivers must not try to unlock the pages by using the MmUnlockPages routine, or to release the existing system-address-space mapping by using the MmUnmapLockedPages routine. If a driver performs any of these illegal operations on an MDL that is built by MmBuildMdlForNonPagedPool, the resulting behavior is undefined. Passing an MDL built by MmBuildMdlForNonPagedPool to the MmGetSystemAddressForMdlSafe routine is allowed. The MmGetSystemAddressForMdlSafe call, in this case, simply returns the starting virtual address of the buffer that is described by the MDL. A driver can use the MmMapLockedPagesSpecifyCache routine to map an MDL that is built by MmBuildMdlForNonPagedPool into user virtual address space. However, the driver must perform this operation in a way that avoids certain security issues. For more information, see MmMapLockedPagesSpecifyCache. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmBuildMdlForNonPagedPool",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMDLX",
        "name": "MemoryDescriptorList",
        "description": "A pointer to an MDL that specifies a virtual memory buffer in nonpaged memory. The caller used the IoAllocateMdl routine to create the MDL for this buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The MapTransfer routine sets up map registers for an adapter object to map a DMA transfer from a locked-down buffer.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MapTransfer returns the logical address of the region mapped, which the driver of a bus-master adapter can use. Drivers of devices that use a system DMA controller cannot use this value and should ignore it. ",
    "remarks": "MapTransfer is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. The DmaAdapter must have already been allocated as a result of the driver's preceding call to AllocateAdapterChannel. The number of map registers that can be set up cannot exceed the maximum returned when the driver called IoGetDmaAdapter. A driver can get the initial CurrentVa for the start of a packet-based DMA transfer by calling MmGetMdlVirtualAddress. However, the value returned is an index into the Mdl, rather than a valid virtual address. If the driver must split a large transfer request into more than one DMA operation, it must update CurrentVa and Length for each DMA operation. The driver of a bus-master device with scatter/gather support can use the returned logical address and updated Length value to build a scatter/gather list, calling MapTransfer repeatedly until it has used all available map registers for the transfer operation. However, such a driver could more simply use the GetScatterGatherList routine. ",
    "return_type": "PHYSICAL_ADDRESS",
    "category": "Drivers",
    "name": "MapTransfer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA adapter object returned by IoGetDmaAdapter and previously passed to AllocateAdapterChannel for the current IRP's transfer request."
      },
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "Pointer to one of the following: the MDL that describes the buffer at MdlAddress in the current IRP or the MDL that describes the common buffer set up by the driver of a subordinate device (auto-initialize mode)."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "MapRegisterBase",
        "description": "Specifies the map registers allocated for the DMA operation.  The system passes this value  to the driver's AdapterControl routine."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CurrentVa",
        "description": "Pointer to the current virtual address of the data to be transferred for a DMA transfer operation."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "Length",
        "description": "Specifies the length, in bytes, to be mapped. If the driver indicated that its device was a bus master with scatter/gather support when it called IoGetDmaAdapter, the value of Length on return from MapTransfer indicates how many bytes were mapped. Otherwise, the input and output values of Length are identical."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "WriteToDevice",
        "description": "Indicates the direction of the transfer operation: TRUE for a transfer from the locked-down buffer to the device."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmGetPhysicalAddress routine returns the physical address corresponding to a valid nonpaged virtual address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "MmGetPhysicalAddress returns the physical address that corresponds to the given virtual address. Do not use this routine to obtain physical addresses for use with DMA operations. For information about the proper techniques for performing DMA operations, see Adapter Objects and DMA. ",
    "remarks": "Callers of MmGetPhysicalAddress can be running at any IRQL, provided that the BaseAddress value is valid. ",
    "return_type": "PHYSICAL_ADDRESS",
    "category": "Drivers",
    "name": "MmGetPhysicalAddress",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the virtual address for which to return the physical address."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmIsAddressValid routine checks whether a page fault will occur for a read or write operation at a given virtual address.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "If no page fault would occur from reading or writing at the given virtual address, MmIsAddressValid returns TRUE. ",
    "remarks": "Even if MmIsAddressValid returns TRUE, accessing the address can cause page faults unless the memory has been locked down or the address is a valid nonpaged pool address. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "MmIsAddressValid",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "A pointer to the nonpaged virtual address to check. The caller must ensure that this address cannot be paged out or deleted for the duration of this call. Even after the return from the call, you must not page out or delete this address. If you do page out or delete this address, the return value might be unreliable. Paging out or deleting this address might cause the computer to stop responding (that is, crash)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The MmMapIoSpace routine maps the given physical address range to nonpaged system space.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmMapIoSpace returns the base virtual address that maps the base physical address for the range. If space for mapping the range is insufficient, it returns NULL. ",
    "remarks": "A driver must call this routine during device start-up if it receives translated resources of type CmResourceTypeMemory in a CM_PARTIAL_RESOURCE_DESCRIPTOR structure. MmMapIoSpace maps the physical address returned in the resource list to a logical address through which the driver can access device registers. For example, drivers of PIO devices that allocate long-term I/O buffers can call this routine to make such buffers accessible or to make device memory accessible. For more information about using this routine, see Mapping Bus-Relative Addresses to Virtual Addresses. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmMapIoSpace",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PHYSICAL_ADDRESS",
        "name": "PhysicalAddress",
        "description": "Specifies the starting physical address of the I/O range to be mapped."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "Specifies a value greater than zero, indicating the number of bytes to be mapped."
      },
      {
        "in_out": "_In_",
        "type": "MEMORY_CACHING_TYPE",
        "name": "CacheType",
        "description": "Specifies a MEMORY_CACHING_TYPE value, which indicates the cache attribute to use to map the physical address range."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmMapLockedPages routine is obsolete for Windows 2000 and later versions of Windows, and for Windows Me. It is supported only for WDM drivers that must run on Windows 98. Otherwise, use MmMapLockedPagesSpecifyCache.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmMapLockedPages returns the starting address of the mapped pages. (For NT-based operating systems prior to Windows NT 4.0 Service Pack 4 (SP4), MmMapLockedPages returns the beginning address of the first page of the mapped pages.) ",
    "remarks": "Use MmUnmapLockedPages to unmap the physical pages that were mapped by MmMapLockedPages. If AccessMode is KernelMode and MmMapLockedPages cannot map the specified pages, the system issues a bug check. (For this reason, drivers should use MmMapLockedPagesSpecifyCache when available; that routine returns NULL on failure, rather than causing a bug check.) If AccessMode is UserMode and the specified pages cannot be mapped, the routine raises an exception. Callers that specify UserMode must wrap the call to MmMapLockedPages in a try/except block. For more information, see Handling Exceptions. Callers of MmMapLockedPages must be running at IRQL <= DISPATCH_LEVEL if AccessMode is KernelMode. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmMapLockedPages",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "MemoryDescriptorList",
        "description": "Pointer to an MDL that was updated by MmProbeAndLockPages."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "AccessMode",
        "description": "Specifies the access mode in which to map the MDL, either KernelMode or UserMode. Almost all drivers should use KernelMode."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The MmMapLockedPagesWithReservedMapping routine maps all or part of an address range that was previously reserved by the MmAllocateMappingAddress routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmMapLockedPagesWithReservedMapping returns a pointer to the beginning of the mapped memory, or NULL if the system could not map the memory. This routine returns NULL only if there is an error in the function parameters (for example, the driver's mapping address is not large enough to span the supplied MDL). This function is intended to enable drivers to make forward progress even in low-resource scenarios. ",
    "remarks": "The caller can use MmMapLockedPagesWithReservedMapping to map a subrange of the virtual memory range reserved by MmAllocateMappingAddress as follows: Once the caller does not need to access the memory, it unmaps the memory with MmUnmapReservedMapping. The caller can map and unmap the memory buffer as needed, and must unmap it prior to freeing the mapping range with MmFreeMappingAddress. Note that the MappingAddress parameter specifies the beginning of the range of memory previously reserved by the caller, not the beginning of the memory subrange to be mapped. The caller specifies the starting address and length of the buffer when it allocates the MDL with IoAllocateMdl. The buffer must fit inside the reserved memory range, but it can be a strict subset. The routine uses the CacheType parameter only if the pages that are described by the MDL do not already have a cache type associated with them. However, in nearly all cases, the pages already have an associated cache type, and this cache type is used by the new mapping. An exception to this rule is for pages that are allocated by MmAllocatePagesForMdl, which do not have a specific cache type associated with them. For such pages, the CacheType parameter determines the cache type of the mapping. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmMapLockedPagesWithReservedMapping",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "MappingAddress",
        "description": "Pointer to the beginning of the reserved virtual memory range. This must be an address previously returned by MmAllocateMappingAddress."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PoolTag",
        "description": "Specifies the pool tag for the reserved memory buffer. This must be identical to the value specified in the PoolTag parameter of the call to MmAllocateMappingAddress that reserved the buffer."
      },
      {
        "in_out": "_In_",
        "type": "PMDLX",
        "name": "MemoryDescriptorList",
        "description": "A pointer to the MDL that is to be mapped. This MDL must describe physical pages that are locked down. A locked-down MDL can be built by the MmProbeAndLockPages or MmAllocatePagesForMdlEx routine."
      },
      {
        "in_out": "_In_",
        "type": "MEMORY_CACHING_TYPE",
        "name": "CacheType",
        "description": "Specifies the MEMORY_CACHING_TYPE value to use to create the mapping."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmAllocateMappingAddress routine reserves a range of system virtual address space of the specified size.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmAllocateMappingAddress returns a pointer to the beginning of the reserved memory buffer. ",
    "remarks": "MmAllocateMappingAddress reserves a system virtual address range for the caller to use. No physical memory is allocated for the virtual address range and the virtual memory cannot be accessed until it is mapped by the MmMapLockedPagesWithReservedMapping routine. The caller unmaps the reserved memory range by calling the MmUnmapReservedMapping routine. Finally, the caller can free the reserved range by calling MmFreeMappingAddress. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmAllocateMappingAddress",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "Specifies the number of bytes to reserve."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PoolTag",
        "description": "Specifies a four-character tag used to identify the buffer. Use a distinct PoolTag tag for each allocation code path. For a description of pool tags, see ExAllocatePoolWithTag."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The MmProbeAndLockPages routine probes the specified virtual memory pages, makes them resident, and locks them in memory.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The highest-level driver in a chain of layered drivers that use direct I/O calls this routine. Drivers that use buffered I/O never call MmProbeAndLockPages. MmProbeAndLockPages performs the following operations: A successful call to MmProbeAndLockPages locks the pages in an MDL and sets the MDL structure to the locked state. Every such call must be matched by a corresponding call to MmUnlockPages that unlocks the pages and sets the MDL to the unlocked state. After an MmProbeAndLockPages call sets an MDL to the locked state, a second call to MmProbeAndLockPages to lock the same MDL is not allowed until MmUnlockPages is first called to unlock the MDL. If two or more MDLs describe the same physical page, the page can be locked multiple times\u00e2\u0080\u0094once for each MDL. The page is unlocked when the last MDL is set to the unlocked state. A routine such as MmBuildMdlForNonPagedPool or IoBuildPartialMdl updates an MDL to describe pages that are either nonpageable or already locked. A call to MmProbeAndLockPages or MmUnlockPages to lock or unlock such an MDL is not allowed. Calls to MmProbeAndLockPages must be enclosed in a try/except block. If the pages do not support the specified operation, the routine raises the STATUS_ACCESS_VIOLATION or other exceptions. For more information, see Handling Exceptions. Callers of MmProbeAndLockPages must be running at IRQL <= APC_LEVEL for pageable addresses, or at IRQL <= DISPATCH_LEVEL for nonpageable addresses. This routine does not provide any guarantees about the virtual address that describes these pages (that is, the virtual address might be unmapped, reused, and so on). However, the physical pages are guaranteed to be locked on successful return. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmProbeAndLockPages",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMDLX",
        "name": "MemoryDescriptorList",
        "description": "A pointer to an MDL that specifies a virtual memory buffer. If the routine successfully locks the pages in memory, the MDL is updated to describe the underlying physical pages."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "AccessMode",
        "description": "The access mode in which to probe the arguments, either KernelMode or UserMode."
      },
      {
        "in_out": "_In_",
        "type": "LOCK_OPERATION",
        "name": "Operation",
        "description": "The type of operation for which the caller wants the access rights probed and the pages locked. Set this parameter to IoReadAccess, IoWriteAccess, or IoModifyAccess. IoReadAccess indicates that the driver can examine the contents of the buffer but cannot change the contents. IoWriteAccess and IoModifyAccess, which are equivalent, indicate that the driver has both read and write access to the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmProtectMdlSystemAddress routine sets the protection type for a memory address range.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmProtectMdlSystemAddress returns an NTSTATUS code. The possible return values include:  ",
    "remarks": "The MmProtectMdlSystemAddress routine can only be called on an MDL that has already been mapped. For example, the routine can be called on an MDL mapped by MmMapLockedPagesSpecifyCache. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "MmProtectMdlSystemAddress",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMDLX",
        "name": "MemoryDescriptorList",
        "description": "Specifies the memory address range to set the protection type for."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NewProtect",
        "description": "Specifies the new protection setting for the memory pages. Drivers should specify one of the following values:   PAGE_NOACCESS  The underlying memory pages cannot be read or written.   PAGE_READONLY  The underlying memory pages can only be read, not written.   PAGE_READWRITE  The underlying memory pages can be read or written.   PAGE_EXECUTE  The underlying memory pages can be executed, but not read or written.  PAGE_EXECUTE_READ  The underlying memory pages can be executed or read, but not written.  PAGE_EXECUTE_READWRITE  The underlying memory pages can be executed, read, or written."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The MmSecureVirtualMemory routine secures a user-space memory address range so that it cannot be freed and its protection type cannot be made more restrictive.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "On success, MmSecureVirtualMemory returns an opaque pointer value that the driver passes to the MmUnsecureVirtualMemory routine to unsecure the memory address range. If the routine is unable to secure the memory address range, it returns NULL. ",
    "remarks": "MmSecureVirtualMemory can be used to avoid certain race conditions on user-mode buffers. For example, if a driver checks to see if the buffer is writable, but then the originating user-mode process changes the buffer to be read-only before the driver can write to the buffer, then a race condition can result. A driver that uses MmSecureVirtualMemory is guaranteed that if the requested protection mode is available, it cannot be changed until the driver calls MmUnsecureVirtualMemory. The routine also protects against the originating user-mode process freeing the buffer. Here are a few guidelines about calling those routines: While calling MmSecureVirtualMemory on an address range prevents the address range from being freed or from having its protection changed, it does not protect against other types of raised exceptions. (For example, it does not protect against an exception raised when the system finds a bad disk block in the page file.)  Therefore, drivers must still wrap any memory accesses in a try/except block. Therefore, we recommend that drivers do not use this function. For more information, see Handling Exceptions. ",
    "return_type": "HANDLE",
    "category": "Drivers",
    "name": "MmSecureVirtualMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Address",
        "description": "The beginning of the user virtual address range to secure."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Size",
        "description": "The size, in bytes, of the virtual address range to secure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ProbeMode",
        "description": "The most restrictive protection type that is allowed. Use PAGE_READWRITE to specify that address range must remain both readable and writable, or use PAGE_READONLY to specify the address range must only remain readable."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmSizeOfMdl routine returns the number of bytes to allocate for an MDL describing a given address range.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "MmSizeOfMdl returns the number of bytes required to contain the MDL. ",
    "remarks": "Memory for the MDL itself must be allocated from nonpaged pool. ",
    "return_type": "SIZE_T",
    "category": "Drivers",
    "name": "MmSizeOfMdl",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Base",
        "description": "Pointer to the base virtual address for the range."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "Supplies the size, in bytes, of the range."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmUnlockPages routine unlocks the physical pages that are described by the specified memory descriptor list (MDL).",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The memory described by the specified MDL must have been locked previously by a call to MmProbeAndLockPages. If the specified MDL is mapped to system address space, MmUnlockPages releases this mapping before it unlocks the pages. For more information, see Using MDLs. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmUnlockPages",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMDL",
        "name": "MemoryDescriptorList",
        "description": "A pointer to an MDL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmUnmapIoSpace routine unmaps a specified range of physical addresses previously mapped by MmMapIoSpace.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If a driver calls MmMapIoSpace during device start-up, it must call MmUnmapIoSpace when it receives a PnP stop-device or remove-device IRP for the same device object. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmUnmapIoSpace",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the base virtual address to which the physical pages were mapped."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "Specifies the number of bytes that were mapped."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmUnmapLockedPages routine releases a mapping that was set up by a preceding call to the MmMapLockedPages or MmMapLockedPagesSpecifyCache routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of MmUnmapLockedPages must be running at IRQL <= DISPATCH_LEVEL if the pages were mapped to system space. Otherwise, the caller must be running at IRQL <= APC_LEVEL. Note that if the call to MmMapLockedPages or MmMapLockedPagesSpecifyCache specified user mode, the caller must be in the context of the original process before calling MmUnmapLockedPages. This is because the unmapping operation occurs in the context of the calling process, and, if the context is incorrect, the unmapping operation could delete the address range of a random process. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmUnmapLockedPages",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the base virtual address to which the physical pages were mapped."
      },
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "MemoryDescriptorList",
        "description": "Pointer to an MDL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The MmUnmapReservedMapping routine unmaps a memory buffer that was mapped by the MmMapLockedPagesWithReservedMapping routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmUnmapReservedMapping",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the beginning of the reserved virtual memory range. This must be an address returned by MmMapLockedPagesWithReservedMapping."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PoolTag",
        "description": "Specifies the pool tag for the reserved memory buffer. This must be identical to the value specified in the PoolTag parameter of the call to MmAllocateMappingAddress that initially reserved the buffer."
      },
      {
        "in_out": "_In_",
        "type": "PMDLX",
        "name": "MemoryDescriptorList",
        "description": "Pointer to the MDL that describes the physical memory mapping."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmUnsecureVirtualMemory routine unsecures a memory address range secured by the MmSecureVirtualMemory routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmUnsecureVirtualMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "SecureHandle",
        "description": "Specifies the value returned by MmSecureVirtualMemory for the memory address range."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlCompareMemory routine compares two blocks of memory and returns the number of bytes that match.",
    "library": "NtosKrnl.lib;  OneCoreUAP.lib on Windows 10",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlCompareMemory returns the number of bytes in the two blocks that match. If all bytes match up to the specified Length value, the Length value is returned. ",
    "remarks": "The routine starts by comparing the first byte in the first block to the first byte in the second block, and continues to compare successive bytes in the two blocks while the bytes match. The routine stops comparing bytes when it encounters the first pair of bytes that are not equal, or when the number of matching bytes equals the Length parameter value, whichever occurs first. Callers of RtlCompareMemory can be running at any IRQL if both blocks of memory are resident. ",
    "return_type": "SIZE_T",
    "category": "Drivers",
    "name": "RtlCompareMemory",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  Kernel32.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "Source1",
        "description": "A pointer to the first block of memory."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "Source2",
        "description": "A pointer to the second block of memory."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The number of bytes to compare."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlCopyMemory routine copies the contents of a source memory block to a destination memory block.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "RtlCopyMemory runs faster than RtlMoveMemory. However, RtlCopyMemory requires that the source memory block, which is defined by Source and Length, cannot overlap the destination memory block, which is defined by Destination and Length. In contrast, RtlMoveMemory correctly handles the case in which the source and destination memory blocks overlap. Callers of RtlCopyMemory can be running at any IRQL if the source and destination memory blocks are in nonpaged system memory. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlCopyMemory",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "VOID UNALIGNED*",
        "name": "Destination",
        "description": "A pointer to the destination memory block to copy the bytes to."
      },
      {
        "in_out": "_In_",
        "type": "const VOID UNALIGNED*",
        "name": "Source",
        "description": "A pointer to the source memory block to copy the bytes from."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The number of bytes to copy from the source to the destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlMoveMemory routine copies the contents of a source memory block to a destination memory block, and supports overlapping source and destination memory blocks.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The source memory block, which is defined by Source and Length, can overlap the destination memory block, which is defined by Destination and Length. The RtlCopyMemory routine runs faster than RtlMoveMemory, but RtlCopyMemory requires that the source and destination memory blocks do not overlap. Callers of RtlMoveMemory can be running at any IRQL if the source and destination memory blocks are in nonpaged system memory. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlMoveMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "VOID UNALIGNED*",
        "name": "Destination",
        "description": "A pointer to the destination memory block to copy the bytes to."
      },
      {
        "in_out": "_In_",
        "type": "const VOID UNALIGNED*",
        "name": "Source",
        "description": "A pointer to the source memory block to copy the bytes from."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The number of bytes to copy from the source to the destination."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlFillMemory routine fills a block of memory with the specified fill value.",
    "library": "NtDll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of RtlFillMemory can be running at any IRQL if the destination memory block is in nonpaged system memory. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlFillMemory",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "VOID UNALIGNED*",
        "name": "Destination",
        "description": "A pointer to the block of memory to be filled."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The number of bytes in the block of memory to be filled."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "Fill",
        "description": "The value to fill the destination memory block with. This value is copied to every byte in the memory block that is defined by Destination and Length."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlZeroMemory routine fills a block of memory with zeros, given a pointer to the block and the length, in bytes, to be filled.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "To zero out a memory buffer to erase security-sensitive data, use RtlSecureZeroMemory instead. Callers of RtlZeroMemory can be running at any IRQL if the destination memory block is in nonpaged system memory. Otherwise, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlZeroMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "VOID UNALIGNED*",
        "name": "Destination",
        "description": "A pointer to the memory block to be filled with zeros."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The number of bytes to fill with zeros."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmAllocateContiguousMemory routine allocates a range of contiguous, nonpaged physical memory and maps it to the system address space.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "MmAllocateContiguousMemory returns the base virtual address for the allocated memory. If the request cannot be satisfied, the routine returns NULL. ",
    "remarks": "MmAllocateContiguousMemory allocates a block of nonpaged memory that is contiguous in physical address space. The routine maps this block to a contiguous block of virtual memory in the system address space and returns the virtual address of the base of this block. The routine aligns the starting address of a contiguous memory allocation to a memory page boundary. Drivers must not access memory beyond the requested allocation size. For example, developers should not assume that their drivers can safely use memory between the end of their requested allocation and the next page boundary. Because contiguous physical memory is usually in short supply, it should be used sparingly and only when necessary. A driver that must use contiguous memory should allocate this memory during driver initialization because physical memory is likely to become fragmented over time as the operating system allocates and frees memory. Typically, a driver calls MmAllocateContiguousMemory from its DriverEntry routine to allocate an internal buffer for long-term use, and frees the buffer just before the driver is unloaded. Memory allocated by MmAllocateContiguousMemory must be freed when the memory is no longer needed. Call the MmFreeContiguousMemory routine to free memory that is allocated by MmAllocateContiguousMemory. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmAllocateContiguousMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "The size, in bytes, of the block of contiguous memory to allocate. For more information, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "PHYSICAL_ADDRESS",
        "name": "HighestAcceptableAddress",
        "description": "The highest valid physical address the caller can use. For example, if a device can address only locations in the first 16 megabytes of the processor's physical memory address range, the driver for this device should set HighestAcceptableAddress to 0x0000000000FFFFFF."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmFreeContiguousMemory routine releases a range of physically contiguous memory that was allocated by an MmAllocateContiguousMemoryXxx routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "The MmFreeContiguousMemory routine frees a block of physically contiguous memory that was allocated by a previous call to the MmAllocateContiguousMemory, MmAllocateContiguousMemorySpecifyCache, or MmAllocateContiguousMemorySpecifyCacheNode routine. The BaseAddress parameter must be the base address that was obtained from the previous call to the MmAllocateContiguousMemoryXxx routine. A device driver that must use contiguous memory should allocate only what it needs during driver initialization because physical memory is likely to become fragmented as the system runs. Such a driver must deallocate the memory when the driver is done using the memory. Callers of MmFreeContiguousMemory must be running at IRQL = APC_LEVEL. For Windows Server 2008 and later versions of the Windows operating system, you can also call MmFreeContiguousMemory with IRQL <= DISPATCH_LEVEL. However, you can improve driver performance by calling at APC_LEVEL or below. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmFreeContiguousMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the virtual address of the memory to be freed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The MmAllocateNonCachedMemory routine allocates a virtual address range of noncached and cache-aligned memory.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "If the requested memory cannot be allocated, the return value is NULL. Otherwise, it is the base virtual address of the allocated range. ",
    "remarks": "MmAllocateNonCachedMemory can be called from a DriverEntry routine to allocate a noncached block of virtual memory for various device-specific buffers. The function always returns a full multiple of the virtual memory page size, of nonpaged system-address-space memory, regardless of the requested allocation size. Noncached allocations are aligned on an integral multiple of the processor's data-cache-line size to prevent cache and coherency problems. The physical memory pages that MmAllocateNonCachedMemory returns are typically not contiguous pages. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "MmAllocateNonCachedMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "Specifies the size in bytes of the range to be allocated."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmFreeNonCachedMemory routine releases a range of noncached memory that was allocated by the MmAllocateNonCachedMemory routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "The MmFreeNonCachedMemory routine performs the opposite action of MmAllocateNonCachedMemory. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmFreeNonCachedMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the virtual address of the memory to be freed."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "NumberOfBytes",
        "description": "Specifies the size of the range to be freed. This value must match the size passed in a preceding call to MmAllocateNonCachedMemory."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The MmFreeMappingAddress routine frees a range of virtual memory reserved by the MmAllocateMappingAddress routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "MmFreeMappingAddress frees a range of memory reserved by MmAllocateMappingAddress. If the memory range has already been mapped by MmMapLockedPagesWithReservedMapping, it must first be unmapped with MmUnmapReservedMapping before the memory range can be freed. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "MmFreeMappingAddress",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "Pointer to the beginning of the reserved memory buffer to free. This must be an address previously returned by MmAllocateMappingAddress."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PoolTag",
        "description": "Specifies the pool tag for the reserved memory buffer. This must be identical to the value specified in the PoolTag parameter of the call to MmAllocateMappingAddress that reserved the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The AllocateCommonBuffer routine allocates memory and maps it so that it is simultaneously accessible from both the processor and a device for DMA operations.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "AllocateCommonBuffer returns the base virtual address of the allocated range. If the buffer cannot be allocated, it returns NULL. ",
    "remarks": "AllocateCommonBuffer            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. AllocateCommonBuffer supports DMA in which the device and the processor continuously communicate through system memory, as in a control structure for a bus-master DMA device. AllocateCommonBuffer also supports subordinate devices whose drivers use a system DMA controller's autoinitialize mode. AllocateCommonBuffer does the following: To use resident system memory economically, drivers should allocate as few of these buffers per device as possible. AllocateCommonBuffer allocates at least a page of memory, regardless of the requested Length. After a successful allocation requesting fewer than PAGE_SIZE bytes, the caller can access only the requested Length. After a successful allocation requesting more than an integral multiple of PAGE_SIZE bytes, any remaining bytes on the last allocated page are inaccessible to the caller. If a driver needs several pages of common buffer space, but the pages need not be contiguous, the driver should make several one-page requests to AllocateCommonBuffer instead of one large request. This approach conserves contiguous memory. Drivers typically call AllocateCommonBuffer as part of device start-up, during their response to a PnP IRP_MN_START_DEVICE request. After startup, it is possible that only one-page requests will succeed, if any. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "AllocateCommonBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the number of bytes of memory to allocate."
      },
      {
        "in_out": "_Out_",
        "type": "PPHYSICAL_ADDRESS",
        "name": "LogicalAddress",
        "description": "Pointer to a variable that receives the logical address the device can use to access the allocated buffer. Use this address rather than calling MmGetPhysicalAddress because the system can take into account any platform-specific memory restrictions."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CacheEnabled",
        "description": "Specifies whether the allocated memory can be cached. This parameter is ignored on computers with x86-based, x64-based, and Itanium-based processors, because the operating system assumes that DMA is always coherent with the caches of these processors. For these processors, the operating system always allocates common buffers that are cache-enabled, and a driver can use common buffers only if DMA operations for the device are coherent with the contents of the processor caches."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The FreeCommonBuffer routine frees a common buffer allocated by AllocateCommonBuffer, along with all resources the buffer uses.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "FreeCommonBuffer            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. To release a common buffer, a driver calls FreeCommonBuffer to unmap both its logical and virtual addresses. The parameters passed to FreeCommonBuffer must match exactly those passed to and returned from AllocateCommonBuffer. A driver cannot free part of an allocated common buffer. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "FreeCommonBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the number of bytes to deallocate."
      },
      {
        "in_out": "_In_",
        "type": "PHYSICAL_ADDRESS",
        "name": "LogicalAddress",
        "description": "Specifies the logical address of the allocated memory range."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "VirtualAddress",
        "description": "Pointer to the corresponding virtual address of the allocated memory range."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CacheEnabled",
        "description": "Indicates whether the allocated memory is cached."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoAdjustPagingPathCount routine increments or decrements a caller-supplied page-file counter as an atomic operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine is useful for maintaining a count of paging files on a device. The operating system notifies a driver that a paging file has been created on, or removed from, one of the driver's devices by sending an IRP. The IRP has the major code IRP_MJ_PNP and the minor code IRP_MN_DEVICE_USAGE_NOTIFICATION. This routine can be used for other counters, such as counters for hibernation files or crash-dump files. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoAdjustPagingPathCount",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLONG",
        "name": "Count",
        "description": "Pointer to a caller-supplied variable that contains a counter. A driver typically stores a page-file counter in the device extension for the device."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Increment",
        "description": "Specifies whether the counter is to be incremented or decremented. A value of TRUE specifies an increment operation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoInitializeRemoveLock routine initializes a remove lock for a device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver can use a remove lock to track outstanding I/O operations on a device and to determine when the driver can delete its device object in response to an IRP_MN_REMOVE_DEVICE request. Before calling IoInitializeRemoveLock, a driver should allocate an IO_REMOVE_LOCK structure in its device extension. A driver typically calls IoInitializeRemoveLock in its AddDevice routine, when the driver initializes the rest of the device extension for a device object. After the IoReleaseRemoveLockAndWait routine returns, the driver should consider the device to be in a state in which it is ready to be removed and cannot perform I/O operations. Therefore, the driver must not call IoInitializeRemoveLock to re-initialize the remove lock. Violation of this rule while the driver is being verified by Driver Verifier will result in a bug check. Because the driver stores the IO_REMOVE_LOCK structure in the device extension of a device object, the remove lock is deleted when the driver deletes the device extension as part of processing an IRP_MN_REMOVE_DEVICE request. For more information, see Using Remove Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoInitializeRemoveLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIO_REMOVE_LOCK",
        "name": "Lock",
        "description": "Pointer to a caller-supplied IO_REMOVE_LOCK structure that this routine initializes with information about the lock, including a counter and a synchronization event. A driver writer must allocate this structure as part of the device object's device extension."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocateTag",
        "description": "Specifies a tag to identify the creator of the lock. Driver writers typically use a 4-character string, specified in reverse order, like the tags used for ExAllocatePoolWithTag. The I/O system uses this parameter if Driver Verifier is enabled, and on checked builds regardless of whether Driver Verifier is enabled. The caller should always supply a nonzero tag value for this parameter, for both free and checked builds."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxLockedMinutes",
        "description": "Specifies the maximum number of minutes that this lock should be held. A value of zero means there is no limit. This value is typically used during debugging to identify a driver routine that holds the lock longer than expected. The I/O system uses this parameter if Driver Verifier is enabled, and on checked builds regardless of whether Driver Verifier is enabled. If the lock is held for more than MaxLockedMinutes on a checked build, the operating system asserts."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "HighWatermark",
        "description": "Specifies the maximum number of outstanding acquisitions allowed on the lock. Use 0 to specify no maximum. HighWatermark must be <= 0x7FFFFFFF. The I/O system uses this parameter if Driver Verifier is enabled, and on checked builds regardless of whether Driver Verifier is enabled. If the lock is acquired HighWatermark times on a checked build, the operating system asserts."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoAcquireRemoveLock routine increments the count for a remove lock,     indicating that the associated device object should not be detached from the device stack or deleted.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoAcquireRemoveLock returns STATUS_SUCCESS if the call was successful. One         possible error return value is the following:  If the routine returns any value besides STATUS_SUCCESS, do not start any new operations on the device. ",
    "remarks": "A driver must initialize a remove lock with a call to       IoInitializeRemoveLock before using the       lock. A driver must call IoReleaseRemoveLock to       release the lock when it is no longer needed. For more information, see Using Remove Locks. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoAcquireRemoveLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIO_REMOVE_LOCK",
        "name": "RemoveLock",
        "description": "Pointer to an IO_REMOVE_LOCK structure that the caller initialized with a        previous call to        IoInitializeRemoveLock."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Tag",
        "description": "Optionally points to a caller-supplied tag that identifies this instance of acquiring the remove lock. For         example, a driver Dispatch routine typically sets this parameter to a pointer to the IRP the routine is         processing. If a driver specifies a Tag on a call to         IoAcquireRemoveLock, the driver must supply the same         Tag in the corresponding call to         IoReleaseRemoveLock. The Tag does not have to be unique, but should be something meaningful during         debugging. The I/O system uses this parameter on checked builds only."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoReleaseRemoveLock routine releases a remove lock acquired with a previous call to IoAcquireRemoveLock.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver calls IoReleaseRemoveLock when it has completed the I/O operation for which it called IoAcquireRemoveLock. Each call to IoAcquireRemoveLock must have a corresponding call to IoReleaseRemoveLock. IoReleaseRemoveLock decrements the count of outstanding acquisitions of the remove lock. If the count goes to zero and the driver has received an IRP_MN_REMOVE_DEVICE request, IoReleaseRemoveLock sets an internal event. When a driver is ready to delete a device object, it calls a similar routine, IoReleaseRemoveLockAndWait. The driver makes this call only in its dispatch code for an IRP_MN_REMOVE_DEVICE request. The IoReleaseRemoveLockAndWait routine does not return until IoReleaseRemoveLock sets the event that indicates the acquisition count is zero. After IoReleaseRemoveLockAndWait returns, the driver can safely detach and delete the device object. For more information, see Using Remove Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoReleaseRemoveLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIO_REMOVE_LOCK",
        "name": "RemoveLock",
        "description": "Pointer to an IO_REMOVE_LOCK structure that the caller passed to a previous call to IoAcquireRemoveLock."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Tag",
        "description": "Pointer to a caller-supplied tag that was passed to a previous call to IoAcquireRemoveLock.  If a driver specified a Tag when it acquired the lock, the driver must specify the same Tag when releasing the lock. If the tags do not match, this routine asserts on a checked build. If the call to IoAcquireRemoveLock did not specify a Tag, then this parameter is NULL. The I/O system only uses this parameter on checked builds."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoReleaseRemoveLockAndWait routine releases a remove lock that the driver acquired in a previous call to IoAcquireRemoveLock, and waits until all acquisitions of the lock have been released.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver typically calls this routine in its dispatch code for an IRP_MN_REMOVE_DEVICE request. To allow queued I/O requests to complete, each driver should call IoReleaseRemoveLockAndWait after it passes the remove IRP to the next-lower driver, and before it releases memory, calls IoDetachDevice, or calls IoDeleteDevice. The IoReleaseRemoveLockAndWait routine waits for the bus driver to cancel any IRPs that might be outstanding (for example, an IRP_MN_WAIT_WAKE IRP). A driver must acquire the remove lock before calling IoReleaseRemoveLockAndWait. Typically, a driver calls IoAcquireRemoveLock early in its DispatchPnp routine, before the switch statement. As a result, the lock is acquired for each PnP operation, including the acquisition that is required before calling IoReleaseRemoveLockAndWait in the code that handles IRP_MN_REMOVE_DEVICE. To release a lock from code other than the IRP_MN_REMOVE_DEVICE dispatch code, use IoReleaseRemoveLock. After IoReleaseRemoveLockAndWait has been called for a particular remove lock, subsequent calls to IoAcquireRemoveLock for the same remove lock will fail. IoReleaseRemoveLockAndWait does not return until all outstanding acquisitions of the remove lock have been released. After IoReleaseRemoveLockAndWait returns, the driver should consider the device to be in a state in which it is ready to be removed and cannot perform I/O operations. Therefore, the driver must not call the IoInitializeRemoveLock routine to re-initialize the remove lock. Violation of this rule while the driver is being verified by Driver Verifier will result in a bug check. For more information, see Using Remove Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoReleaseRemoveLockAndWait",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIO_REMOVE_LOCK",
        "name": "RemoveLock",
        "description": "Pointer to an IO_REMOVE_LOCK structure that the caller passed in a previous call to IoAcquireRemoveLock."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Tag",
        "description": "Pointer to a caller-supplied tag that was passed in a previous call to IoAcquireRemoveLock.  If a driver specified a Tag when it acquired the lock, the driver must specify the same Tag when releasing the lock. If the tags do not match, this routine asserts on a checked build. If the call to IoAcquireRemoveLock did not specify a Tag, then this parameter is NULL. The I/O system only uses this parameter on checked builds."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoReportTargetDeviceChangeAsynchronous routine notifies the PnP manager that a custom event has occurred on a device.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoReportTargetDeviceChangeAsynchronous returns STATUS_SUCCESS or an appropriate error status. Possible error status values include the following.  ",
    "remarks": "After the IoReportTargetDeviceChangeAsynchronous routine notifies the PnP manager that a custom event has occurred on a device, the routine returns immediately; it does not wait while the PnP manager sends notification of the event to drivers that registered for notification on the device. Do not use this routine to report system PnP events, such as GUID_TARGET_DEVICE_REMOVE_COMPLETE. A driver that defines a custom device event calls IoReportTargetDeviceChangeAsynchronous to inform the PnP manager that the custom event has occurred. Custom notification can be used for events like a volume label change. The custom notification structure contains a driver-defined event with its own GUID. Driver writers can generate GUIDs with Uuidgen.exe or Guidgen.exe (which are included in the Microsoft Windows SDK). When a driver calls this routine while handling an event, an IRP_MN_REMOVE_DEVICE, or an IRP_MN_SURPRISE_REMOVAL, the PnP manager calls the driver's Callback routine after the driver returns and the stack unwinds. Callers of IoReportTargetDeviceChangeAsynchronous must be running at IRQL <= DISPATCH_LEVEL. If a driver writer calls this routine at IRQL = DISPATCH_LEVEL, the NotificationStructure must be allocated from nonpaged memory. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoReportTargetDeviceChangeAsynchronous",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "Pointer to the PDO of the device being reported."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "NotificationStructure",
        "description": "Pointer to a caller-supplied TARGET_DEVICE_CUSTOM_NOTIFICATION structure describing the custom event. The PnP manager sends this structure to drivers that registered for notification of the event. NotificationStructure.FileObject must be NULL. NotificationStructure.Event must contain the custom GUID for the event. The other fields of the NotificationStructure must be filled in as appropriate for the custom event. The PnP manager fills in the NotificationStructure.FileObject field when it sends notifications to registrants."
      },
      {
        "in_out": "_In_opt_",
        "type": "PDEVICE_CHANGE_COMPLETE_CALLBACK",
        "name": "Callback",
        "description": "Optionally points to a caller-supplied routine that the PnP manager calls after it finishes notifying drivers that registered for this custom event. The callback routine has the following type:       Copy      typedef VOID (*PDEVICE_CHANGE_COMPLETE_CALLBACK)(     IN PVOID Context     );      A device-change-complete callback routine should not block and must not call synchronous routines that generate PnP events. The PnP manager calls device-change-complete callback routines at IRQL = PASSIVE_LEVEL."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "Context",
        "description": "Optionally points to a caller-supplied context structure that the PnP manager passes to the Callback routine. The caller must allocate this structure from nonpaged memory."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoGetDeviceInterfaces routine returns a list of device interface instances of a particular device interface class (such as all devices on the system that support a HID interface).",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetDeviceInterfaces returns STATUS_SUCCESS if the call was successful. Possible error return values include the following.  ",
    "remarks": "IoGetDeviceInterfaces returns a list of device interface instances that match the search criteria. A kernel-mode component typically calls this routine to get a list of all enabled device interface instances of a particular device interface class. Such a component can get a pointer to the file object and/or the device object for an interface by calling the IoGetDeviceObjectPointer or ZwCreateFile routine. The device object pointer returned by IoGetDeviceObjectPointer points to the top of the device stack for the device and can be used in calls to the IoCallDriver routine. If there is a default interface for the requested device interface class, it is listed first in SymbolicLinkList. Default interfaces can be set by user mode, but not by kernel mode. The format of a symbolic link name is opaque; the caller should not attempt to parse a symbolic link name. Symbolic links for device interface instances can be used across system boots. To be notified when additional device interface instances of a particular class are enabled on the system, register for notification of a device class change by calling the IoRegisterPlugPlayNotification routine. Callers of IoGetDeviceInterfaces must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoGetDeviceInterfaces",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const GUID*",
        "name": "InterfaceClassGuid",
        "description": "Pointer to a class GUID specifying the device interface class. The GUIDs for a class should be in a device-specific header file."
      },
      {
        "in_out": "_In_opt_",
        "type": "PDEVICE_OBJECT",
        "name": "PhysicalDeviceObject",
        "description": "Pointer to an optional PDO that narrows the search to only the device interface instances of the device represented by the PDO."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Specifies flags that modify the search for device interfaces. Only one flag is currently defined, and is described in the following table.  FlagMeaning  DEVICE_INTERFACE_INCLUDE_NONACTIVE  Return disabled device interface instances in addition to enabled interface instances.     When searching for a device that supports a particular interface class, the caller requires an enabled interface instance and thus does not set the DEVICE_INTERFACE_INCLUDE_NONACTIVE flag. A driver typically sets the DEVICE_INTERFACE_INCLUDE_NONACTIVE flag to locate disabled interface instances that the driver must enable. For example, the class installer for the device might have been directed by the INF file to register one or more interface instances for the device. The interface instances would be registered but are not usable until they are enabled by the driver (using IoSetDeviceInterfaceState). To narrow the list of interface instances returned to only those exposed by a given device, a driver can specify a PhysicalDeviceObject."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR*",
        "name": "SymbolicLinkList",
        "description": "A pointer to a wide character pointer to which the routine, if successful, writes the base address of a buffer that contains a list of Unicode strings. These strings are symbolic link names that identify the device interface instances that match the search criteria. Each Unicode string in the list is null-terminated; the end of the whole list is marked by an additional null character. The routine allocates the buffer for these strings from paged system memory. The caller is responsible for freeing the buffer (by calling the ExFreePool routine) when it is no longer needed. If no device interface instances match the search criteria, this routine returns STATUS_SUCCESS and the string contains a single NULL character."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoGetDeviceInterfaceAlias routine returns the alias device interface of the specified device interface instance, if the alias exists.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetDeviceInterfaceAlias returns STATUS_SUCCESS if the call was successful. Possible error return values are described following.  ",
    "remarks": "Device interfaces are considered aliases if they are exposed by the same underlying device and have identical interface reference strings, but are of different interface classes. The SymbolicLinkName parameter specifies a device interface instance for a particular device, belonging to a particular interface class, with a particular reference string. IoGetDeviceInterfaceAlias returns another device interface instance for the same device and reference string, but of a different interface class, if it exists. For example, the function driver for a fault-tolerant volume could register and set two device interfaces, one of the fault-tolerant-volume interface class and one of the volume interface class. Another driver could call IoGetDeviceInterfaceAlias with the symbolic link for one of the interfaces and ask whether the other interface exists by specifying its interface class. Two device interfaces with NULL reference strings are aliases if they are exposed by the same underlying device and have different interface class GUIDs. Callers of IoGetDeviceInterfaceAlias must be running at IRQL = PASSIVE_LEVEL in the context of a system thread. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoGetDeviceInterfaceAlias",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "SymbolicLinkName",
        "description": "Pointer to the name of the device interface instance for which to retrieve an alias. The caller typically received this string from a call to IoGetDeviceInterfaces or in a PnP notification structure."
      },
      {
        "in_out": "_In_",
        "type": "const GUID*",
        "name": "AliasInterfaceClassGuid",
        "description": "Pointer to a GUID specifying the interface class of the alias to retrieve."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "AliasSymbolicLinkName",
        "description": "Specifies a pointer to a NULL Unicode string. On successful return, AliasSymbolicLinkName.Buffer points to a string containing the name of the alias. The caller must free the Unicode string with RtlFreeUnicodeString when it is no longer needed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoWMIAllocateInstanceIds routine allocates one or more instance IDs that are unique to the GUID.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoWMIAllocateInstanceIds returns a status code from the following list:  ",
    "remarks": "If greater than one instance was requested in InstanceCount and the routine completed successfully, FirstInstanceId points to the first instance that the caller should use. For each instance requested beyond one, the caller should increment the value returned in *FirstInstanceId. For example, if the caller requested six instances and one was returned as the value of FirstInstanceId, the caller should use the values 1-6 as his unique instance identifiers. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIAllocateInstanceIds",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GUID*",
        "name": "Guid",
        "description": "Pointer to the GUID for which to generate instance identifiers."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InstanceCount",
        "description": "Specifies how many instance identifiers should be provided."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "FirstInstanceId",
        "description": "Pointer to the first instance identifier that the driver should use."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoWMIDeviceObjectToInstanceName routine determines the instance name for the WMI class instance implemented by the driver that is specified by a device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIDeviceObjectToInstanceName",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with IoWMIOpenBlock."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Specifies a device object. The routine returns the instance name for the driver corresponding to the device object."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "InstanceName",
        "description": "Pointer to the UNICODE_STRING structure that the routine uses to return the instance name. The caller frees the returned buffer within UNICODE_STRING."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The IoWMIExecuteMethod routine runs a WMI class method on the specified WMI data block instance.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMIExecuteMethod determines which drivers might support the specified WMI class and instance name. It issues an IRP_MN_EXECUTE_METHOD request to each such driver. The driver that exports the data block instance with matching InstanceName property then runs the specified WMI method. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIExecuteMethod",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with IoWMIOpenBlock. The object must be opened with the WMIGUID_EXECUTE access right."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "InstanceName",
        "description": "Specifies the name of the instance of the data block. This value corresponds to the value of the InstanceName property for the block."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MethodId",
        "description": "Specifies the method item ID for the method to be set. The value of this parameter corresponds to the value declared in the WmiMethodId qualifier for the method."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InBufferSize",
        "description": "Specifies the size, in bytes, of input data for the method. The actual input data is passed in the buffer pointed to by the InOutBuffer parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "OutBufferSize",
        "description": "Pointer to a ULONG that specifies the expected size, bytes, of the data output by the method. The actual output data is returned in the buffer pointed to by the InOutBuffer parameter. If the routine succeeds, it updates the memory location to specify the number of bytes actually stored in InOutBuffer. If the routine fails with STATUS_BUFFER_TOO_SMALL, it returns the number of bytes required to return the data."
      },
      {
        "in_out": "_Inout_",
        "type": "PUCHAR",
        "name": "InOutBuffer",
        "description": "Pointer to the buffer where the caller passes the WMI method's input data, and receives the WMI method's output data."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoWMIHandleToInstanceName routine determines the instance name for the WMI class instance implemented by the driver that is specified by a file handle.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIHandleToInstanceName",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with the IoWMIOpenBlock routine."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Specifies a file handle. The routine returns the instance name corresponding to the driver that is represented by the file handle."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "InstanceName",
        "description": "Pointer to the UNICODE_STRING structure that the routine uses to return the instance name. The caller frees the returned buffer within UNICODE_STRING."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoWMIOpenBlock routine opens the WMI data block object for the specified WMI class.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (Include Wdm.h, Ntddk.h, or Ntifs.h. The WMIGUID_XXX values are declared in Wmistr.h. To use them, include Wmistr.h.)",
    "return_value": "Returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. ",
    "remarks": "The caller uses IoWMIOpenBlock to create a data block object for the specified WMI class GUID. Subsequently, the caller can use the data block object to read or write WMI class properties, run WMI class methods, and register callbacks for WMI events. Use the IoWMIQueryXxx and IoWMISetXxx routines to read and write WMI class properties. Use IoWMIExecuteMethod to run WMI class methods, and use IoWMISetNotificationCallback to register a WMI event notification callback. Use ObDereferenceObject to close the data block object once it is no longer needed. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIOpenBlock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "GUID*",
        "name": "DataBlockGuid",
        "description": "Specifies the GUID for WMI class."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DesiredAccess",
        "description": "Specifies the desired access rights to the data block object. The caller must have particular access rights to perform certain operations.  The following is a description of each access right bit and the operations it allows:   WMIGUID_EXECUTE  The data block object can be used to run WMI class methods. This flag must be set to use IoWMIExecuteMethod on the data block object.   WMIGUID_NOTIFICATION  The data block object can be used to register event notification callbacks. This flag must be set to use IoWMISetNotificationCallback, and can only be used for WMI event blocks. Callers that specify this flag must also specify the SYNCHRONIZE flag.  WMIGUID_QUERY  The data block object can be used to query WMI class properties. This flag must be set to use any of the IoWMIQueryXxx routines on the data block object.   WMIGUID_SET  The data block object can be used to set WMI class properties. This flag must be set to use any of the IoWMISetXxx routines on the data block object."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "DataBlockObject",
        "description": "Pointer to a memory location where the routine returns a pointer to the data block object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoWMIQueryAllData routine returns all WMI data blocks that implement a given WMI class.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMIQueryAllData determines which drivers support the specified WMI class, and issues an IRP_MN_QUERY_ALL_DATA request to every such driver. To query for multiple WMI classes, use IoWMIQueryAllDataMultiple. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIQueryAllData",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with the IoWMIOpenBlock routine. The object must be opened with the WMIGUID_QUERY access right."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "InOutBufferSize",
        "description": "Pointer to a memory location that specifies the size of the buffer passed in the OutBuffer parameter. If the routine succeeds, it updates the memory location to specify the number of bytes actually stored in OutBuffer. If the routine fails with status code of STATUS_BUFFER_TOO_SMALL, it returns the number of bytes required to return the data."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutBuffer",
        "description": "Pointer to the buffer where the routine returns the WMI data. The routine returns a sequence of variable-sized WNODE_ALL_DATA structures, one for each set of returned data blocks. The WnodeHeader.Linkage member of each WNODE_ALL_DATA structure contains the offset from the beginning of the current WNODE_ALL_DATA to the beginning of the next WNODE_ALL_DATA. The final block in the chain has WnodeHeader.Linkage set to zero. OutBuffer must point to a buffer allocated from nonpaged pool."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoWMIQueryAllDataMultiple routine returns all WMI data blocks that implement one of a set of WMI classes.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMIQueryAllDataMultiple determines which drivers support the specified WMI classes, and issues an IRP_MN_QUERY_ALL_DATA request to every such driver. If no drivers implement any of the specified WMI classes, the routine returns STATUS_SUCCESS It also returns a value of zero in the memory location pointed to by the InOutBufferSize parameter. To query a single WMI class, use IoWMIQueryAllData. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIQueryAllDataMultiple",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID*",
        "name": "DataBlockObjectList",
        "description": "Pointer to an array of pointers to WMI data block objects. The caller opens a data block object for each WMI class with the IoWMIOpenBlock routine. Each object must be opened with the WMIGUID_QUERY access right."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ObjectCount",
        "description": "Specifies the number of entries in the array passed in the DataBlockObjectList parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "InOutBufferSize",
        "description": "Pointer to a memory location that specifies the size of the buffer passed in the OutBuffer parameter. If the routine succeeds, it updates the memory location to specify the number of bytes actually stored in OutBuffer. If the routine fails with status code of STATUS_BUFFER_TOO_SMALL, it returns the number of bytes required to return the data."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutBuffer",
        "description": "Pointer to the buffer where the routine returns the WMI data. The routine returns a sequence of variable-sized WNODE_ALL_DATA structures, one for each set of returned data blocks. The WnodeHeader.Linkage member of each WNODE_ALL_DATA structure contains the offset from the beginning of the current WNODE_ALL_DATA to the beginning of the next WNODE_ALL_DATA. The final block in the chain has WnodeHeader.Linkage set to zero. OutBuffer must point to a buffer allocated from nonpaged pool."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoWMIQuerySingleInstance routine returns the specified instance of a WMI data block.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMIQuerySingleInstance determines which drivers might support the specified WMI class with the specified instance name, and issues an IRP_MN_QUERY_SINGLE_INSTANCE request to each such driver. The driver that exports the data block instance with matching InstanceName property returns the appropriate data. To query for multiple WMI classes and instance names, use the IoWMIQuerySingleInstanceMultiple routine. Drivers can use the IoWMISetSingleInstance routine to update the class instance. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIQuerySingleInstance",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with the IoWMIOpenBlock routine. The object must be opened with the WMIGUID_QUERY access right."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "InstanceName",
        "description": "Specifies the name of the instance of the data block. This value corresponds to the value of the InstanceName property for the block."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "InOutBufferSize",
        "description": "Pointer to a memory location that specifies the size of the buffer passed in the OutBuffer parameter. If the routine succeeds, it updates the memory location to specify the number of bytes actually stored in OutBuffer. If the routine fails with status code of STATUS_BUFFER_TOO_SMALL, it returns the number of bytes required to return the data."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutBuffer",
        "description": "Pointer to the buffer where the routine returns the WMI data. The routine returns a variable-sized WNODE_SINGLE_INSTANCE structure. OutBuffer must point to a buffer allocated from nonpaged pool."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The IoWMIQuerySingleInstanceMultiple routine returns all WMI data block instances that implement the specified WMI classes with the specified instance names.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMIQuerySingleInstanceMultiple determines which drivers might support the specified WMI classes and instance names, and issues an IRP_MN_QUERY_SINGLE_INSTANCE request to each such driver. Each driver that exports the data block instance with matching InstanceName property returns the appropriate data. If no drivers implement any of the specified WMI classes and instance names, the routine returns STATUS_SUCCESS. It also returns a value of zero in the memory location pointed to by the InOutBufferSize parameter. To query for a single WMI class and instance name, use the IoWMIQuerySingleInstance routine. Drivers can use the IoWMISetSingleInstance routine to update a class instance. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMIQuerySingleInstanceMultiple",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID*",
        "name": "DataBlockObjectList",
        "description": "Pointer to an array of pointers of WMI data block objects. The caller opens a data block object for each WMI class with the IoWMIOpenBlock routine. Each object must be opened with the WMIGUID_QUERY access right."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "InstanceNames",
        "description": "Pointer to an array of UNICODE_STRING structures containing instance names. The nth instance name in the array corresponds to the value of the InstanceName property for the nth WMI class specified in the array pointed to by the DataBlockObjectList parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ObjectCount",
        "description": "Specifies the number of entries in the arrays passed in the DataBlockObjectList and InstanceNames parameters."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "InOutBufferSize",
        "description": "Pointer to a memory location that specifies the size of the buffer passed in the OutBuffer parameter. If the routine succeeds, it updates the memory location to specify the number of bytes actually stored in OutBuffer. If the routine fails with STATUS_BUFFER_TOO_SMALL, it returns the number of bytes required to return the data."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutBuffer",
        "description": "Pointer to the buffer where the routine returns the WMI data. The routine returns a sequence of variable-sized WNODE_SINGLE_INSTANCE structures, one for each data block instance. The WnodeHeader.Linkage member of each WNODE_SINGLE_INSTANCE structure contains the offset from the beginning of the current WNODE_SINGLE_INSTANCE to the beginning of the next WNODE_SINGLE_INSTANCE. The final block in the chain has WnodeHeader.Linkage set to zero. Each distinct data block instance corresponds to a single matching WMI class and instance name. OutBuffer must point to a buffer allocated from nonpaged pool."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoWMISetNotificationCallback routine registers a notification callback for a WMI event.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine returns STATUS_SUCCESS on success, and the appropriate NTSTATUS error code on failure. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMISetNotificationCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "Object",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI event with the IoWMIOpenBlock routine. The object must be opened with the WMIGUID_NOTIFICATION access right."
      },
      {
        "in_out": "_In_",
        "type": "WMI_NOTIFICATION_CALLBACK",
        "name": "Callback",
        "description": "Pointer to a function of the form:       Copy       XxxWmiNotificationCallback(PVOID Wnode, PVOID Context);      WMI calls this function to notify the caller that the specified event has occurred. The Wnode parameter of the callback routine points to the WNODE_EVENT_ITEM structure returned by the driver triggering the event. The Context parameter of the callback routine points to the value specified in the Context parameter of the IoWMISetNotificationCallback routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Specifies the value that WMI passes to the callback routine when the event occurs."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The IoWMISetSingleInstance routine sets the values for properties within the data block instance that matches the specified WMI class and instance name.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMISetSingleInstance determines which drivers might support the specified WMI class and instance name, and issues an IRP_MN_CHANGE_SINGLE_INSTANCE request to each such driver. The driver that exports the data block instance with matching InstanceName property updates its data block instance. Note that a data block might have both read-only and read/write properties. In this case, only the read/write properties will be updated and STATUS_SUCCESS is returned. Drivers can also use the IoWMISetSingleItem routine to update a single property within the class instance. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMISetSingleInstance",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with the IoWMIOpenBlock routine. The object must be opened with the WMIGUID_SET access right."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "InstanceName",
        "description": "Specifies the name of the instance of the data block. This value corresponds to the value of the InstanceName property for the block."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Version",
        "description": "Reserved for future use. Callers must set this parameter to zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ValueBufferSize",
        "description": "Specifies the size, in bytes, of the buffer passed in the ValueBuffer parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ValueBuffer",
        "description": "Pointer to the buffer that contains the new values for the properties within the data block."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The IoWMISetSingleItem routine sets a single property in the data block instance that matches the specified WMI class and instance name.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine returns an NTSTATUS code. Possible return values include:  ",
    "remarks": "IoWMISetSingleItem determines which drivers might support the specified WMI class and instance name. It issues an IRP_MN_CHANGE_SINGLE_ITEM request to each such driver. The driver that exports the data block instance with matching InstanceName property updates the specified property in the data block instance. Drivers can also use IoWMISetSingleInstance to update every property of the WMI class instance simultaneously. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoWMISetSingleItem",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBlockObject",
        "description": "Pointer to a WMI data block object. The caller opens the data block object for the WMI class with the IoWMIOpenBlock routine. The object must be opened with the WMIGUID_SET access right."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "InstanceName",
        "description": "Specifies the name of the instance of the data block. This value corresponds to the value of the InstanceName property for the block."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DataItemId",
        "description": "Specifies the data item ID for the property to be set. The value of this parameter corresponds to the value declared in the WmiDataId qualifier for the property."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Version",
        "description": "Reserved for future use. Callers must set this parameter to zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ValueBufferSize",
        "description": "Specifies the size, in bytes, of the buffer passed in the ValueBuffer parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ValueBuffer",
        "description": "Pointer to the buffer that contains the new value for the property specified by the DataItemId parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The WmiCompleteRequest routine indicates that a driver has finished processing a WMI request in a DpWmiXxx routine.",
    "library": "Wmilib.lib",
    "min_server": "",
    "header": "Wmilib.h (include Wmilib.h)",
    "return_value": "WmiCompleteRequest returns the value that was passed to it in the Status parameter unless Status was set to STATUS_BUFFER_TOO_SMALL.  If the driver set Status equal to STATUS_BUFFER_TOO_SMALL, WmiCompleteRequest builds a WNODE_TOO_SMALL structure and returns STATUS_SUCCESS. The return value from WmiCompleteRequest should be returned by the driver in its DpWmiXxx routine. ",
    "remarks": "A driver calls WmiCompleteRequest from a DpWmiXxx routine after it finishes all other processing in that routine, or after the driver finishes all processing for a pending IRP. WmiCompleteRequest fills in a WNODE_XXX with any data returned by the driver and calls IoCompleteRequest to complete the IRP. A driver should always return the return value from WmiCompleteRequest in its DpWmiXxx routine. A driver must not call WmiCompleteRequest from its DpWmiQueryRegInfo routine. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "WmiCompleteRequest",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the driver's DEVICE_OBJECT."
      },
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to the IRP."
      },
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "Status",
        "description": "Specifies the status to return for the IRP."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BufferUsed",
        "description": "Specifies the number of bytes needed in the buffer passed to the driver's DpWmiXxx routine. If the buffer is too small, the driver sets Status to STATUS_BUFFER_TOO_SMALL and sets BufferUsed to the number of bytes needed for the data to be returned. If the buffer passed is large enough, the driver sets BufferUsed to the number of bytes actually used."
      },
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "PriorityBoost",
        "description": "Specifies a system-defined constant by which to increment the run-time priority of the original thread that requested the operation. WMI calls IoCompleteRequest with PriorityBoost when it completes the IRP. See IoCompleteRequest for more information on PriorityBoost."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The WmiSystemControl routine is a dispatch routine for drivers that use WMI library support routines to handle WMI IRPs.",
    "library": "Wmilib.lib",
    "min_server": "",
    "header": "Wmilib.h (include Wmilib.h)",
    "return_value": "WmiSystemControl returns STATUS_SUCCESS or one of the following error codes: ",
    "remarks": "When a driver receives an IRP_MJ_SYSTEM_CONTROL request with a WMI IRP minor code, it calls WmiSystemControl with a pointer to the driver's WMILIB_CONTEXT structure, a pointer to its device object, and a pointer to the IRP. The WMILIB_CONTEXT structure contains registration information for the driver's data blocks and event blocks and defines entry points for its WMI library callback routines. WmiSystemControl confirms that the IRP is a WMI request and determines whether the block specified by the request is valid for the driver. If so, it processes the IRP by calling the appropriate DpWmiXxx entry point in the driver's WMILIB_CONTEXT structure. WMI is running at IRQL PASSIVE_LEVEL when it calls the driver's DpWmiXxx routine. A driver must be running at IRQL PASSIVE_LEVEL when it forwards an IRP_MJ_SYSTEM_CONTROL request to the next-lower driver. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "WmiSystemControl",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PWMILIB_CONTEXT",
        "name": "WmiLibInfo",
        "description": "A pointer to a WMILIB_CONTEXT structure that contains registration information for a driver's data blocks and event blocks and defines entry points for the driver's WMI library callback routines."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the driver's DEVICE_OBJECT."
      },
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to the IRP."
      },
      {
        "in_out": "_Out_",
        "type": "PSYSCTL_IRP_DISPOSITION",
        "name": "IrpDisposition",
        "description": "A pointer to an enumeration value of type SYSCTL_IRP_DISPOSITION that indicates how the IRP was handled. WmiSystemControl always sets this value, even when it returns a non-success NTSTATUS code. SYSCTL_IRP_DISPOSITION is an enumeration in Wmilib.h and contains the following values:   IrpProcessed  The IRP was processed and possibly completed. If the driver's DpWmiXxx routine called by WmiSystemControl did not complete the IRP, the driver must call WmiCompleteRequest to complete the IRP after WmiSystemControl returns.  IrpNotCompleted  The IRP was processed but not completed, either because WMI detected an error and set up the IRP with an appropriate error code, or processed an IRP_MN_REGINFO or IRP_MN_REGINFO_EX request. The driver must complete the IRP by calling IoCompleteRequest.  IrpNotWmi  The IRP is not a WMI request (that is, WMI does not recognize the IRP's minor code). If the driver handles IRP_MJ_SYSTEM_CONTROL requests with this IRP_MN_XXX, it should handle the IRP; otherwise, the driver should forward the IRP to the next lower driver. If the driver is the lowest-level driver, then it must complete the IRP.  IrpForward  The IRP is targeted to another device object (that is, the device object pointer at Parameters.WMI.ProviderId in the IRP does not match the pointer passed by the driver in its call to IoWMIRegistrationControl). The driver must forward the IRP to the next lower driver. If the driver is the lowest-level driver, then it must complete the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The AllocateAdapterChannel routine prepares the system for a DMA operation on behalf of the target device object, and then calls the driver-supplied AdapterControl routine to carry out the DMA operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine can return one of the following NTSTATUS values.  ",
    "remarks": "AllocateAdapterChannel            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. A driver calls the AllocateAdapterControl routine to register an AdapterControl routine that performs a DMA operation for the driver. The AdapterControl routine carries out a DMA operation using either the system DMA controller or a bus-master adapter. If the DMA operation can be performed immediately, the system immediately calls AdapterControl. If the system DMA controller or bus-master adapter is currently in use, AllocateAdapterChannel queues the AdapterControl until the adapter becomes available. In either case, AllocateAdapterChannel returns STATUS_SUCCESS. If the system lacks the resources to perform the DMA operation, AllocateAdapterChannel returns STATUS_INSUFFICIENT_RESOURCES. In that case, AdapterControl is not queued, and the driver should complete the current IRP with the appropriate error code (such as STATUS_INSUFFICIENT_RESOURCES). This routine reserves exclusive access to a DMA controller channel and map registers for the one or more DMA operations that are required to satisfy the current IRP's transfer request for the specified device. Only one DMA request can be queued for a device object at any one time. Therefore, the driver should not call AllocateAdapterChannel again for another DMA operation on the same device object until the AdapterControl routine has completed execution. In addition, a driver must not call AllocateAdapterChannel from within its AdapterControl routine. The system passes the value of the CurrentIrp member of DeviceObject as the Irp parameter of AdapterControl. If AllocateAdapterChannel is called from a driver's StartIo routine, this is guaranteed to point to the IRP that StartIo was called to process. Otherwise, to use the Irp parameter of AdapterControl, the driver must set CurrentIrp to point to the current IRP before calling AllocateAdapterChannel. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "AllocateAdapterChannel",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object that represents the target device for a requested DMA operation."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NumberOfMapRegisters",
        "description": "Specifies the number of map registers to be used in the transfer. This value is the lesser of the number of map registers needed to satisfy the current transfer request, and the number of available map registers returned by IoGetDmaAdapter."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_CONTROL",
        "name": "ExecutionRoutine",
        "description": "Pointer to a driver-supplied AdapterControl routine. The routine is called when the system DMA controller or bus-master adapter becomes available."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to the driver-determined context to be passed to the AdapterControl routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeFlushIoBuffers routine flushes the memory region described by an MDL from caches of all processors.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers call KeFlushIoBuffers to maintain data integrity during DMA or PIO device transfer operations. Calling this routine affects all processors in the machine. If ReadOperation is TRUE, the driver is reading information from the device to system memory, so valid data still might be in the processor instruction and data caches. KeFlushIoBuffers flushes data from all processors' caches to system memory, including the processor on which the caller is running. If ReadOperation is FALSE, the driver is writing data from system memory to a device, so valid data might be in the processor's data cache but not yet transferred to the device. KeFlushIoBuffers flushes all processors' data caches, including that of the processor on which the caller is running. As a general rule, drivers should call KeFlushIoBuffers just before beginning a DMA transfer operation or immediately following any PIO read operation. KeFlushIoBuffers flushes only the memory region that is described by the MDL that the Mdl parameter points to. To flush all the memory regions that are described by an MDL chain requires a separate KeFlushIoBuffers call for each MDL in the chain. For more information, see the following topics: ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeFlushIoBuffers",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "A pointer to an MDL that describes the range for the I/O buffer."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ReadOperation",
        "description": "Specifies TRUE if the flush is being performed for a read operation, and FALSE for a write operation. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "DmaOperation",
        "description": "Specifies TRUE for a DMA transfer, FALSE for PIO."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExInterlockedInsertTailList routine atomically inserts an entry at the end of a doubly linked list of LIST_ENTRY structures.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedInsertTailList returns a pointer to the last entry of the list before the new entry was inserted. If the list was empty, the routine returns NULL. ",
    "remarks": "ExInterlockedInsertTailList performs the same operation as InsertTailList, but atomically. Do not mix atomic and non-atomic calls on the same list. For more information about using this routine to implement a doubly linked list, see Singly and Doubly Linked Lists. The ExInterlockedInsertTailList routine can be called at any IRQL. The storage for the ListHead parameter and the list entries must be resident at all IRQLs. ",
    "return_type": "PLIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedInsertTailList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "A pointer to the LIST_ENTRY structure that serves as the list header."
      },
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListEntry",
        "description": "A pointer to the LIST_ENTRY structure that represents the entry to be inserted into the list."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExInterlockedInsertHeadList routine atomically inserts an entry at the beginning of a doubly linked list of LIST_ENTRY structures.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedInsertHeadList returns a pointer to the first entry of the list before the new entry was inserted. If the list was empty, the routine returns NULL. ",
    "remarks": "ExInterlockedInsertHeadList performs the same operation as InsertHeadList, but atomically. Do not mix atomic and non-atomic calls on the same list. For more information about using this routine to implement a doubly linked list, see Singly and Doubly Linked Lists. The ExInterlockedInsertHeadList routine can be called at any IRQL. The storage for the ListHead parameter and the list entries must be resident at all IRQLs. ",
    "return_type": "PLIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedInsertHeadList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "A pointer to the LIST_ENTRY structure that serves as the list header."
      },
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListEntry",
        "description": "A pointer to the LIST_ENTRY structure that represents the entry to be inserted into the list."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExInterlockedRemoveHeadList routine removes an entry from the beginning of a doubly linked list of LIST_ENTRY structures.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedRemoveHeadList returns a pointer to the LIST_ENTRY structure removed from the list. If the list was empty, the routine returns NULL. ",
    "remarks": "ExInterlockedRemoveHeadList performs a similar operation as RemoveHeadList, but atomically. Do not mix atomic and non-atomic calls on the same list. For more information about using this routine to implement a doubly linked list, see Singly and Doubly Linked Lists. The ExInterlockedRemoveHeadList routine can be called at any IRQL. The storage for the ListHead parameter must be resident at all IRQLs. ",
    "return_type": "PLIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedRemoveHeadList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "A pointer to the LIST_ENTRY structure that serves as the list header."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExInterlockedPopEntryList routine atomically removes an entry from the beginning of a singly linked list of SINGLE_LIST_ENTRY structures.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedPopEntryList returns a pointer to the SINGLE_LIST_ENTRY structure removed from the list. If the list was empty, the routine returns NULL. ",
    "remarks": "ExInterlockedPopEntryList performs the same operation as PopEntryList, but atomically. Do not mix atomic and non-atomic calls on the same list. For more information about using this routine to implement a singly linked list, see Singly and Doubly Linked Lists. The ExInterlockedPopEntryList routine can be called at any IRQL. The storage for the ListHead parameter must be resident at all IRQLs. ",
    "return_type": "PSINGLE_LIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedPopEntryList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSINGLE_LIST_ENTRY",
        "name": "ListHead",
        "description": "A pointer to the SINGLE_LIST_ENTRY structure that serves as the list header."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExInterlockedPushEntryList routine atomically inserts an entry at the beginning of a singly linked list of SINGLE_LIST_ENTRY structures.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedPushEntryList returns a pointer to the first entry of the list before the new entry was inserted. If the list was empty, the routine returns NULL. ",
    "remarks": "ExInterlockedPushEntryList performs the same operation as PushEntryList, but atomically. Do not mix atomic and non-atomic calls on the same list. For more information about using this routine to implement a singly linked list, see Singly and Doubly Linked Lists. The ExInterlockedPushEntryList routine can be called at any IRQL. The storage for the ListHead parameter and the list entries must be resident at all IRQLs. ",
    "return_type": "PSINGLE_LIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedPushEntryList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSINGLE_LIST_ENTRY",
        "name": "ListHead",
        "description": "A pointer to the SINGLE_LIST_ENTRY structure that serves as the list header."
      },
      {
        "in_out": "_Inout_",
        "type": "PSINGLE_LIST_ENTRY",
        "name": "ListEntry",
        "description": "A pointer to the SINGLE_LIST_ENTRY structure that represents the entry to be inserted into the list."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IsListEmpty routine indicates whether a doubly linked list of LIST_ENTRY structures is empty.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IsListEmpty returns TRUE if there are currently no entries in the list and FALSE otherwise. ",
    "remarks": "IsListEmpty returns TRUE if ListHead->Flink refers back to ListHead. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. Callers of IsListEmpty can be running at any IRQL. If IsListEmpty is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead must be resident. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IsListEmpty",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LIST_ENTRY*",
        "name": "ListHead",
        "description": "Pointer to a LIST_ENTRY structure that represents the head of the list."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The InsertTailList routine inserts an entry at the tail of a doubly linked list of LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "InsertTailList updates ListHead->Blink to point to Entry. It updates Entry->Blink to point to the old last entry in the list, and sets Entry->Flink to ListHead. The Flink of the previous last entry is updated to point to Entry as well. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. Callers of InsertTailList can be running at any IRQL. If InsertTailList is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead and the list entries must be resident. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "InsertTailList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to the LIST_ENTRY structure that represents the head of the list."
      },
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "Entry",
        "description": "Pointer to a LIST_ENTRY structure that represents the entry to be inserted in the list."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The InsertHeadList routine inserts an entry at the head of a doubly linked list of LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "InsertHeadList updates ListHead->Flink to point to Entry. It updates Entry->Flink to point to the old first entry in the list, and sets Entry->Blink to ListHead. The Blink field of the original first entry is also updated to point to Entry. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. Callers of InsertHeadList can be running at any IRQL. If InsertHeadList is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead and the list entries must be resident. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "InsertHeadList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to the LIST_ENTRY structure that represents the head of the list."
      },
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "Entry",
        "description": "Pointer to a LIST_ENTRY structure that represents the entry to be inserted into the list."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RemoveHeadList routine removes an entry from the beginning of a doubly linked list of LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RemoveHeadList returns a pointer to the entry removed from the list. If the list is empty, RemoveHeadList returns ListHead. ",
    "remarks": "RemoveHeadList removes the first entry from the list by setting ListHead->Flink to point to the second entry in the list. The routine sets the Blink member of the second entry to ListHead. In the event the list is empty, this is effectively a no-op. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. Callers of RemoveHeadList can be running at any IRQL. If RemoveHeadList is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead and the list entries must be resident. ",
    "return_type": "PLIST_ENTRY",
    "category": "Drivers",
    "name": "RemoveHeadList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to the LIST_ENTRY structure that serves as the list header."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RemoveTailList routine removes an entry from the end of a doubly linked list of LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RemoveTailList returns a pointer to the entry that was at the tail of the list. If the list is empty, RemoveTailList returns ListHead. ",
    "remarks": "RemoveTailList removes the last entry from the list by setting ListHead->Blink to point to the second-to-last entry in the list. The routine sets the Flink member of the new first entry to ListHead. In the event the list is empty, this is effectively a no-op. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. Callers of InsertHeadList can be running at any IRQL. If InsertHeadList is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead and the list entries must be resident. ",
    "return_type": "PLIST_ENTRY",
    "category": "Drivers",
    "name": "RemoveTailList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to the LIST_ENTRY structure that serves as the list header."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RemoveEntryList routine removes an entry from a doubly linked list of LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RemoveEntryList returns TRUE if, after removal of the designated entry, the list is empty. Otherwise, the routine returns FALSE to indicate that the resulting list still contains one or more entries. For information, see Remarks. ",
    "remarks": "RemoveEntryList removes the entry by setting the Flink member of the entry before Entry to point to the entry after Entry, and the Blink member of the entry after Entry to point to the entry before Entry. The return value can be used to detect when the last entry is removed from the list. An empty list consists of a list head only and no list entries. For information about using this routine when implementing a doubly linked list, see Singly and Doubly Linked Lists. In Windows XP and Windows 2000, RemoveEntryList did not return a value. Starting with Windows Server 2003, RemoveEntryList returns a BOOLEAN value. Callers of RemoveEntryList can be running at any IRQL. If RemoveEntryList is called at IRQL >= DISPATCH_LEVEL, the storage for the list entries must be resident. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "RemoveEntryList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLIST_ENTRY",
        "name": "Entry",
        "description": "Pointer to the LIST_ENTRY structure that represents the entry to be removed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The PushEntryList routine inserts an entry at the beginning of a singly linked list of SINGLE_LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "PushEntryList sets ListHead->Next to Entry, and Entry->Next to point to the old first entry of the list. For information about using this routine when implementing a singly linked list, see Singly and Doubly Linked Lists. Callers of PushEntryList can be running at any IRQL. If PushEntryList is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead and the list entries must be resident. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "PushEntryList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSINGLE_LIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to the SINGLE_LIST_ENTRY structure that serves as the list header."
      },
      {
        "in_out": "_Inout_",
        "type": "PSINGLE_LIST_ENTRY",
        "name": "Entry",
        "description": "Pointer to SINGLE_LIST_ENTRY structure that represents the entry to be inserted on the list."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The PopEntryList routine removes the first entry from a singly linked list of SINGLE_LIST_ENTRY structures.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PopEntryList returns a pointer to the entry removed from the list, or NULL if the list is currently empty. ",
    "remarks": "PopEntryList removes the first entry from the list by setting ListHead->Next to point to the second entry in the list. For information about using this routine when implementing a singly linked list, see Singly and Doubly Linked Lists. Callers of PopEntryList can be running at any IRQL. If PopEntryList is called at IRQL >= DISPATCH_LEVEL, the storage for ListHead and the list entries must be resident. ",
    "return_type": "PSINGLE_LIST_ENTRY",
    "category": "Drivers",
    "name": "PopEntryList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSINGLE_LIST_ENTRY",
        "name": "ListHead",
        "description": "Pointer to the SINGLE_LIST_ENTRY structure that represents the head of the list. On return, ListHead->Next points to the beginning of the list with the first entry removed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExInterlockedPopEntrySList routine atomically removes the first entry from a sequenced singly linked list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedPopEntrySList returns a pointer to the first SLIST_ENTRY structure on the list. If the list was empty, the routine returns NULL. ",
    "remarks": "For more information about using this routine to implement a sequenced singly linked list, see Singly and Doubly Linked Lists. On Windows 2000, drivers must use the -D_WIN2K_COMPAT_SLIST_USAGE switch to successfully link code that uses ExInterlockedPopEntrySList. ExInterlockedPopEntrySList can be called at any IRQL. The storage for the ListHead parameter must be resident at all IRQLs. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedPopEntrySList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to the SLIST_HEADER structure that serves as the header for the sequenced singly linked list. ListHead must have been initialized by calling ExInitializeSListHead."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExInterlockedPushEntrySList routine atomically inserts an entry at the beginning of a sequenced singly linked list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedPushEntrySList returns a pointer to the first entry of the list before the new entry was inserted. If the list was empty, the routine returns NULL. ",
    "remarks": "For more information about using this routine to implement a sequenced singly linked list, see Singly and Doubly Linked Lists. On Windows 2000, drivers must use the -D_WIN2K_COMPAT_SLIST_USAGE switch to successfully link code that uses ExInterlockedPushEntrySList. The ExInterlockedPushEntrySList routine can be called at any IRQL. The storage for the ListHead parameter and the list entries must be resident at all IRQLs. ",
    "return_type": "PSLIST_ENTRY",
    "category": "Drivers",
    "name": "ExInterlockedPushEntrySList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSLIST_HEADER",
        "name": "ListHead",
        "description": "A pointer to the SLIST_HEADER structure that serves as the header for the sequenced singly linked list. ListHead must have been initialized by calling ExInitializeSListHead."
      },
      {
        "in_out": "_Inout_",
        "type": "PSLIST_ENTRY",
        "name": "ListEntry",
        "description": "A pointer to the caller-allocated entry to be inserted."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a KSPIN_LOCK structure that serves as the spin lock used to synchronize access to the list. The storage for the spin lock must be resident and must have been initialized by calling KeInitializeSpinLock. You must use this spin lock only with the ExInterlockedXxxList routines."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExQueryDepthSList routine returns the number of entries currently in a given sequenced singly linked list.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExQueryDepthSList returns the current number of entries in the list. ",
    "remarks": "For more information about using this routine to implement a sequenced singly linked list, see Singly and Doubly Linked Lists. ",
    "return_type": "USHORT",
    "category": "Drivers",
    "name": "ExQueryDepthSList",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSLIST_HEADER",
        "name": "SListHead",
        "description": "A pointer to the SLIST_HEADER structure that serves as the header for the sequenced singly linked list. SListHead must have been initialized by calling ExInitializeSListHead."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeInsertDeviceQueue routine acquires the spin lock for the specified device queue object and, if the device queue is set to a busy state, queues the specified entry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the device queue is empty, FALSE is returned and the DeviceQueueEntry is not inserted in the device queue. ",
    "remarks": "If the device queue is set to a busy state, the specified DeviceQueueEntry is inserted at the tail of the device queue and the device queue spin lock is released. If KeInsertDeviceQueue returns FALSE, the entry was not queued and the caller must begin processing the IRP. A call to KeInsertDeviceQueue or KeInsertByKeyDeviceQueue when the queue is empty causes the device queue to change from a not-busy state to a busy state. This routine is for code that queues an I/O request to a device driver. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeInsertDeviceQueue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE",
        "name": "DeviceQueue",
        "description": "Pointer to a control object of type device queue for which the caller provides the storage."
      },
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE_ENTRY",
        "name": "DeviceQueueEntry",
        "description": "Pointer to the device queue entry that is to be inserted."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeInsertByKeyDeviceQueue routine acquires the spin lock for the specified DeviceQueue and queues an entry according to the specified sort-key value if the device queue is set to a busy state.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the device queue is empty, FALSE is returned, meaning the DeviceQueueEntry is not inserted in the device queue. ",
    "remarks": "The specified device queue spin lock is acquired and the state of the device queue is checked. If the device queue is set to a busy state, the IRP specified by the DeviceQueueEntry is inserted into the device queue according to its sort key value and the device queue spin lock is released. The new entry is positioned in the device queue after any entries in the queue with sort key values less than or equal to its sort key value and preceding any entries with sort key values that are greater. If KeInsertByKeyDeviceQueue returns FALSE, the caller must begin processing the IRP. A call to KeInsertDeviceQueue or KeInsertByKeyDeviceQueue when the queue is empty causes the device queue to transition from a not-busy state to a busy state. This routine is for code that queues an I/O request to a device driver. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeInsertByKeyDeviceQueue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE",
        "name": "DeviceQueue",
        "description": "Pointer to a control object of the device queue type for which the caller provides the storage."
      },
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE_ENTRY",
        "name": "DeviceQueueEntry",
        "description": "Pointer to the device queue entry to be inserted into the device queue according to the specific key value."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SortKey",
        "description": "Specifies the sort-key value that determines the position in the device queue in which to insert the entry."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeRemoveDeviceQueue routine removes an entry from the head of a specified device queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the device queue is empty but is set to a busy state, KeRemoveDeviceQueue returns NULL. ",
    "remarks": "The specified device queue spin lock is acquired and the state of the device queue is checked. If the device queue is set to a busy state and an IRP is queued, this routine dequeues the entry and returns a pointer to the IRP. A call to KeRemoveDeviceQueue when the device queue object is set to a busy state but no IRPs are queued causes a state change to not-busy. The specified device queue's spin lock is released. It is an error to call KeRemoveDeviceQueue when the device queue object is set to a not-busy state. ",
    "return_type": "PKDEVICE_QUEUE_ENTRY",
    "category": "Drivers",
    "name": "KeRemoveDeviceQueue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE",
        "name": "DeviceQueue",
        "description": "Pointer to an initialized device queue object for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeRemoveByKeyDeviceQueue routine removes an entry, selected according to a sort key value, from the specified device queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeRemoveByKeyDeviceQueue returns the device queue entry that was removed; returns NULL if the queue was empty. ",
    "remarks": "This routine searches for the first entry in the device queue that has a value greater than or equal to the SortKey. After this entry is found, this routine removes the entry from the device queue and returns it. If no such entry is found, then the first entry in the queue is returned. If the device queue is empty, then the device is set to a not-busy state and a NULL pointer is returned. It is an error to call KeRemoveByKeyDeviceQueue when the device queue object is set to a not-busy state. ",
    "return_type": "PKDEVICE_QUEUE_ENTRY",
    "category": "Drivers",
    "name": "KeRemoveByKeyDeviceQueue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE",
        "name": "DeviceQueue",
        "description": "Pointer to an initialized device queue object for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SortKey",
        "description": "Specifies the key to be used when searching the DeviceQueue."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeRemoveEntryDeviceQueue routine returns whether the specified entry is in the device queue and removes it, if it was queued, from the device queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the DeviceQueueEntry is queued, it is removed and KeRemoveEntryDeviceQueue returns TRUE. ",
    "remarks": "The IRQL is set to DISPATCH_LEVEL and the DeviceQueue spin lock is acquired. If the specified DeviceQueueEntry is not in the queue, the IRP either is already being processed, or the IRP has been canceled. In this case, KeRemoveEntryDeviceQueue simply returns FALSE. The specified DeviceQueue spin lock is released and IRQL is restored to its previous value. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeRemoveEntryDeviceQueue",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE",
        "name": "DeviceQueue",
        "description": "Pointer to an initialized device queue object for which the caller provides the storage."
      },
      {
        "in_out": "_Inout_",
        "type": "PKDEVICE_QUEUE_ENTRY",
        "name": "DeviceQueueEntry",
        "description": "Pointer to the entry to be removed from the specified DeviceQueue."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The PsCreateSystemThread routine creates a system thread that executes in kernel mode and returns a handle for the thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PsCreateSystemThread returns STATUS_SUCCESS if the thread was created. ",
    "remarks": "Drivers that create device-dedicated threads call this routine, either when they initialize or when I/O requests begin to come in to such a driver's Dispatch routines. For example, a driver might create such a thread when it receives an asynchronous device control request. PsCreateSystemThread creates a kernel-mode thread that begins a separate thread of execution within the system. Such a system thread has no TEB or user-mode context and runs only in kernel mode. If the input ProcessHandle is NULL, the created thread is associated with the system process. Such a thread continues running until either the system is shut down or the thread terminates itself by calling PsTerminateSystemThread. Starting with Windows XP, driver routines that run in a process context other than that of the system process must set the OBJ_KERNEL_HANDLE attribute for the ObjectAttributes parameter of PsCreateSystemThread. This restricts the use of the handle returned by PsCreateSystemThread to processes running in kernel mode. Otherwise, the thread handle can be accessed by the process in whose context the driver is running. Drivers can set the OBJ_KERNEL_HANDLE attribute as follows. Drivers for Windows 2000 and Windows 98/Me must call PsCreateSystemThread only from the system process context. For more information about the StartContext parameter, see ThreadStart. The newly created system thread runs at PASSIVE_LEVEL inside a critical region with normal kernel APCs disabled. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PsCreateSystemThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "ThreadHandle",
        "description": "Points to a variable that will receive the handle. The driver must close the handle with ZwClose once the handle is no longer in use. This handle is a kernel handle for Windows Vista and later versions of Windows. In earlier versions of Windows, the handle might not be a kernel handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DesiredAccess",
        "description": "Specifies the ACCESS_MASK value that represents the requested types of access to the created thread."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Points to a structure that specifies the object's attributes. OBJ_PERMANENT, OBJ_EXCLUSIVE, and OBJ_OPENIF are not valid attributes for a thread object. On Windows XP and later versions of Windows, if the caller is not running in the system process context, it must set the OBJ_KERNEL_HANDLE attribute for ObjectAttributes. Drivers for Microsoft Windows 2000 and Windows 98/Me must only call PsCreateSystemThread from the system process context. For Windows Vista and later versions of Windows, the handle will be a kernel handle."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "Specifies an open handle for the process in whose address space the thread is to be run. The caller's thread must have PROCESS_CREATE_THREAD access to this process. If this parameter is not supplied, the thread will be created in the initial system process. This value should be NULL for a driver-created thread. Use the NtCurrentProcess macro, defined in Ntddk.h, to specify the current process."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PCLIENT_ID",
        "name": "ClientId",
        "description": "Points to a structure that receives the client identifier of the new thread. This value should be NULL for a driver-created thread."
      },
      {
        "in_out": "_In_",
        "type": "PKSTART_ROUTINE",
        "name": "StartRoutine",
        "description": "The entry point for the newly created system thread. This parameter is a function pointer to a ThreadStart routine that receives a single argument, which is the StartContext parameter value supplied by the caller."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "StartContext",
        "description": "Supplies a single argument that is passed to the thread when it begins execution."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The PsTerminateSystemThread routine terminates the current system thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PsTerminateSystemThread does not return if it successfully terminates the calling thread. If the routine cannot terminate the thread (for example, if the thread is not a system thread), the routine returns an error NTSTATUS value. ",
    "remarks": "A system thread calls PsTerminateSystemThread to terminate itself. A driver that creates its own threads must ensure that each such thread terminates. The driver must not terminate any threads that the system or other drivers created. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PsTerminateSystemThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "ExitStatus",
        "description": "Specifies the status of the terminating system thread."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeQueryPriorityThread routine returns the current priority of a particular thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeQueryPriorityThread returns the current priority of the specified thread. ",
    "remarks": "Thread priorities range from 0 to 31, where 0 is the lowest priority and 31 is the highest. ",
    "return_type": "KPRIORITY",
    "category": "Drivers",
    "name": "KeQueryPriorityThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKTHREAD",
        "name": "Thread",
        "description": "Pointer to a dispatcher object of type KTHREAD."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeSetBasePriorityThread routine sets the run-time priority, relative to the current process, for a given thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "KeSetBasePriorityThread returns the previous base priority increment of the given thread. The previous base priority increment is defined as the difference between the specified thread's old base priority and the base priority of the thread's process. ",
    "remarks": "The new base priority is computed by adding the given Increment, which can be a negative value, to the base priority of the specified thread's process. The resultant value is stored as the base priority of the specified thread. Drivers that set up device-dedicated threads with variable priority attributes can call this routine to set such a thread's priority relative to the system process in which the thread is created. The new base priority is restricted to the priority class of the given thread's process. Therefore, the base priority is not allowed to cross over from a variable priority class to a real-time priority class or vice versa. ",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "KeSetBasePriorityThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKTHREAD",
        "name": "Thread",
        "description": "Pointer to a dispatcher object of type KTHREAD."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Increment",
        "description": "Specifies the value to be added to the base priority of the process for the Thread."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeSetPriorityThread routine sets the run-time priority of a driver-created thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeSetPriorityThread returns the old priority of the thread. ",
    "remarks": "If a call to KeSetPriorityThread resets the thread's priority to a lower value, execution of the thread can be rescheduled even if it is currently running or is about to be dispatched for execution. ",
    "return_type": "KPRIORITY",
    "category": "Drivers",
    "name": "KeSetPriorityThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKTHREAD",
        "name": "Thread",
        "description": "Pointer to the driver-created thread."
      },
      {
        "in_out": "_In_",
        "type": "KPRIORITY",
        "name": "Priority",
        "description": "Specifies the priority of the driver-created thread, usually to the real-time priority value, LOW_REALTIME_PRIORITY. The value LOW_PRIORITY is reserved for system use."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlInitString routine initializes a counted string of 8-bit characters.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine initializes a counted character string. The routine copies the SourceString pointer value to the Buffer member of the STRING structure pointed to by DestinationString. The Length member of this structure is set to the length, in bytes, of the source string, excluding the terminating null. The MaximumLength member of the structure is set to the length, in bytes, of the source string, including the terminating null. If SourceString is NULL, Length and MaximumLength are both set to zero. RtlInitString does not alter the source string pointed to by SourceString. Callers of RtlInitString can be running at IRQL <= DISPATCH_LEVEL if the DestinationString buffer is nonpageable. Usually, callers run at IRQL = PASSIVE_LEVEL because most other RtlXxxString routines cannot be called at IRQL > PASSIVE_LEVEL. The RTL_CONSTANT_STRING macro creates a string or Unicode string structure to hold a counted string.   RTL_CONSTANT_STRING returns either a string structure or Unicode string structure. The RTL_CONSTANT_STRING macro replaces the RtlInitAnsiString, RtlInitString, and RtlInitUnicodeString routines when passing a constant string. You can use RTL_CONSTANT_STRING to initialize global variables. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlInitString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSTRING",
        "name": "DestinationString",
        "description": "A pointer to the STRING structure to be initialized. The Ntdef.h header file defines this structure to be identical to the ANSI_STRING structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCSZ",
        "name": "SourceString",
        "description": "A pointer to a null-terminated character string. This string is used to initialize the counted string pointed to by DestinationString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlInitAnsiString routine initializes a counted string of ANSI characters.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine initializes a counted character string. The routine copies the SourceString pointer value to the Buffer member of the ANSI_STRING structure pointed to by DestinationString. The Length member of this structure is set to the length, in bytes, of the source string, excluding the terminating null. The MaximumLength member of the structure is set to the length, in bytes, of the source string, including the terminating null. If SourceString is NULL, Length and MaximumLength are both set to zero. RtlInitAnsiString does not alter the source string pointed to by SourceString. Callers of RtlInitAnsiString can be running at IRQL <= DISPATCH_LEVEL if the DestinationString buffer is nonpageable. Usually, callers run at IRQL = PASSIVE_LEVEL because most other RtlXxxString routines cannot be called at IRQL > PASSIVE_LEVEL. The RTL_CONSTANT_STRING macro creates a string or Unicode string structure to hold a counted string.   RTL_CONSTANT_STRING returns either a string structure or Unicode string structure. The RTL_CONSTANT_STRING macro replaces the RtlInitAnsiString, RtlInitString, and RtlInitUnicodeString routines when passing a constant string. You can use RTL_CONSTANT_STRING to initialize global variables. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlInitAnsiString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PANSI_STRING",
        "name": "DestinationString",
        "description": "A pointer to the ANSI_STRING structure to be initialized."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCSZ",
        "name": "SourceString",
        "description": "A pointer to a null-terminated character string. This string is used to initialize the counted string pointed to by DestinationString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "For more information, see  the WdmlibRtlInitUnicodeStringEx function.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "For more information, see  the WdmlibRtlInitUnicodeStringEx function. ",
    "remarks": "The RTL_CONSTANT_STRING macro creates a string or Unicode string structure to hold a counted string.   RTL_CONSTANT_STRING returns either a string structure or Unicode string structure. The RTL_CONSTANT_STRING macro replaces the RtlInitAnsiString, RtlInitString, and RtlInitUnicodeString routines when passing a constant string. You can use RTL_CONSTANT_STRING to initialize global variables. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlInitUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "DestinationString",
        "description": "For more information, see  the WdmlibRtlInitUnicodeStringEx function."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "SourceString",
        "description": "For more information, see  the WdmlibRtlInitUnicodeStringEx function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlAnsiStringToUnicodeSize routine returns the number of bytes required to hold an ANSI string converted into a Unicode string.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlAnsiStringToUnicodeSize returns the necessary size in bytes for a Unicode string buffer. ",
    "remarks": "Callers of RtlAnsiStringToUnicodeSize must be running at IRQL = PASSIVE_LEVEL. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "RtlAnsiStringToUnicodeSize",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PANSI_STRING",
        "name": "AnsiString",
        "description": "Pointer to a buffer containing the ANSI string."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "RtlAnsiStringToUnicodeString converts the given ANSI source string into a Unicode string.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the conversion succeeds, RtlAnsiStringToUnicodeString returns STATUS_SUCCESS. On failure, the routine does not allocate any memory. ",
    "remarks": "The translation conforms to the current system locale information. If caller sets AllocateDestinationString to TRUE, the routine replaces the Buffer member of DestinationString with a pointer to the buffer it allocates. The old value can be overwritten even when the routine returns an error status code. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlAnsiStringToUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "DestinationString",
        "description": "Pointer to a UNICODE_STRING structure to hold the converted Unicode string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data, and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently-specified buffer to hold the string."
      },
      {
        "in_out": "_In_",
        "type": "PCANSI_STRING",
        "name": "SourceString",
        "description": "Pointer to the ANSI string to be converted to Unicode."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "AllocateDestinationString",
        "description": "Specifies if this routine should allocate the buffer space for the destination string. If it does, the caller must deallocate the buffer by calling RtlFreeUnicodeString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlFreeUnicodeString routine releases storage that was allocated by RtlAnsiStringToUnicodeString or RtlUpcaseUnicodeString.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine does not release the ANSI string buffer passed to RtlAnsiStringToUnicodeString. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlFreeUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "UnicodeString",
        "description": "Pointer to the Unicode string buffer previously allocated by RtlAnsiStringToUnicodeString or RtlUpcaseUnicodeString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlUnicodeStringToAnsiString routine converts a given Unicode string into an ANSI string.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the conversion succeeds, RtlUnicodeStringToAnsiString returns STATUS_SUCCESS. Otherwise, no storage was allocated, and no conversion was done. ",
    "remarks": "The translation is done in accord with the current system-locale information. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlUnicodeStringToAnsiString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PANSI_STRING",
        "name": "DestinationString",
        "description": "Pointer to an ANSI_STRING structure to hold the converted ANSI string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data, and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string."
      },
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "SourceString",
        "description": "Pointer to the Unicode source string to be converted to ANSI."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "AllocateDestinationString",
        "description": "TRUE if this routine is to allocate the buffer space for the DestinationString. If it does, the buffer must be deallocated by calling RtlFreeAnsiString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlFreeAnsiString routine releases storage that was allocated by RtlUnicodeStringToAnsiString.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine does not release the Unicode string buffer passed to RtlUnicodeStringToAnsiString. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlFreeAnsiString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PANSI_STRING",
        "name": "AnsiString",
        "description": "Pointer to the ANSI string buffer previously allocated by RtlUnicodeStringToAnsiString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlAppendUnicodeStringToString routine concatenates two Unicode strings.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlAppendUnicodeStringToString can return one of the following:  ",
    "remarks": "RtlAppendUnicodeStringToString copies bytes from the source up to the length of the destination buffer. The Destination and Source buffers must be resident if the caller is running at IRQL >= DISPATCH_LEVEL. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlAppendUnicodeStringToString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "Destination",
        "description": "Pointer to a buffered Unicode string."
      },
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "Source",
        "description": "Pointer to the buffered string to be concatenated."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlAppendUnicodeToString routine concatenates the supplied Unicode string to a buffered Unicode string.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlAppendUnicodeToString can return one of the following:  ",
    "remarks": "RtlAppendUnicodeToString appends the source string to the end of the destination string. If the destination buffer is not large enough to contain the string that would result from concatenating the source and destination strings (not including the null character that terminates the source string), the routine returns STATUS_BUFFER_TOO_SMALL and leaves the destination string unchanged. The Destination buffer must be resident if the caller is running at IRQL >= DISPATCH_LEVEL. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlAppendUnicodeToString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "Destination",
        "description": "A pointer to the buffered string."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "Source",
        "description": "A pointer to the null-terminated string to append to the Destination string."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlCopyString routine copies a source string to a destination string.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The DestinationString Length is set to zero if no source string is supplied. The MaximumLength and Buffer members of the DestinationString are not modified by this routine. The number of bytes copied from the SourceString is either the length of SourceString or the maximum length of DestinationString, whichever is smaller. The DestinationString and SourceString buffers must be resident if the caller is running at IRQL >= DISPATCH_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlCopyString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSTRING",
        "name": "DestinationString",
        "description": "A pointer to the destination string buffer."
      },
      {
        "in_out": "_In_opt_",
        "type": "const STRING*",
        "name": "SourceString",
        "description": "A pointer to the source string buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlCopyUnicodeString routine copies a source string to a destination string.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If SourceString is NULL, this routine sets the Length field of the structure pointed to by DestinationString to zero. This routine does not modify the MaximumLength and Buffer fields of the structure pointed to by DestinationString. The number of bytes copied from the source string is either the source string length (specified by the Length member of the structure pointed to by SourceString) or the maximum length of the destination string (specified by the MaximumLength member of the structure pointed to by DestinationString), whichever is smaller. The caller must properly initialize all members of the structure pointed to by DestinationString before calling RtlCopyUnicodeString. Failure to initialize the Length or the MaximumLength member before calling this routine can cause a buffer overrun. The DestinationString and SourceString buffers must be resident if the caller is running at IRQL >= DISPATCH_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlCopyUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "DestinationString",
        "description": "A pointer to the destination string buffer. This parameter points to a UNICODE_STRING structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCUNICODE_STRING",
        "name": "SourceString",
        "description": "A pointer to the source string buffer. This parameter points to a UNICODE_STRING structure."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlEqualString routine compares two counted strings to determine whether they are equal.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h or Ntifs.h)",
    "return_value": "RtlEqualString returns TRUE if the two strings are equal, otherwise it returns FALSE. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "RtlEqualString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const STRING*",
        "name": "String1",
        "description": "Pointer to the first string."
      },
      {
        "in_out": "_In_",
        "type": "const STRING*",
        "name": "String2",
        "description": "Pointer to the second string."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CaseInSensitive",
        "description": "If TRUE, case should be ignored when doing the comparison."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlEqualUnicodeString routine compares two Unicode strings to determine whether they are equal.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlEqualUnicodeString returns TRUE if the two Unicode strings are equal; otherwise, it returns FALSE. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "RtlEqualUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "String1",
        "description": "Pointer to the first Unicode string."
      },
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "String2",
        "description": "Pointer to the second Unicode string."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CaseInSensitive",
        "description": "If TRUE, case should be ignored when doing the comparison."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlCompareString routine compares two counted strings.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h or Ntifs.h)",
    "return_value": "RtlCompareString returns a signed value that gives the results of the comparison:  ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "RtlCompareString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const STRING*",
        "name": "String1",
        "description": "Pointer to the first string."
      },
      {
        "in_out": "_In_",
        "type": "const STRING*",
        "name": "String2",
        "description": "Pointer to the second string."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CaseInSensitive",
        "description": "If TRUE, case should be ignored when doing the comparison."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlCompareUnicodeString routine compares two Unicode strings.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlCompareUnicodeString returns a signed value that gives the results of the comparison:  ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Drivers",
    "name": "RtlCompareUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "String1",
        "description": "Pointer to the first string."
      },
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "String2",
        "description": "Pointer to the second string."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CaseInSensitive",
        "description": "If TRUE, case should be ignored when doing the comparison."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlUpperString routine copies the given SourceString to the DestinationString buffer, converting it to uppercase.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "The MaximumLength and Buffer members of DestinationString are not modified by this routine. The number of bytes copied from SourceString is either the Length of SourceString or the MaximumLength of DestinationString, whichever is smaller. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlUpperString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSTRING",
        "name": "DestinationString",
        "description": "Pointer to the buffer for the converted destination string."
      },
      {
        "in_out": "_In_",
        "type": "const STRING*",
        "name": "SourceString",
        "description": "Pointer to the source string to be converted to uppercase."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlUpcaseUnicodeString routine converts a copy of the source string to uppercase and writes the converted string in the destination buffer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "If the operation succeeds, RtlUpcaseUnicodeString returns STATUS_SUCCESS. Otherwise, no storage was allocated, and no conversion was done. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlUpcaseUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "DestinationString",
        "description": "Pointer to a caller-allocated buffer for the converted Unicode string."
      },
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "SourceString",
        "description": "Pointer to the source Unicode string to be converted to uppercase."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "AllocateDestinationString",
        "description": "Specifies if RtlUpcaseUnicodeString is to allocate the buffer space for the DestinationString. If it does, the buffer must be deallocated by calling RtlFreeUnicodeString."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlIntegerToUnicodeString routine converts an unsigned integer value to a null-terminated string of one or more Unicode characters in the specified base.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlIntegerToUnicodeString returns an NTSTATUS value. Possible return values include:  ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlIntegerToUnicodeString",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Value",
        "description": "Specifies the ULONG value to convert."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "Base",
        "description": "Specifies the base to use when converting Value to a string. The possible values are:  ValueBase  16  Hexadecimal   8  Octal   2  Binary   0 or 10  Decimal"
      },
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "String",
        "description": "Pointer to a UNICODE_STRING structure that receives the string representation of Value. The buffer specified by the Buffer  of String must be large enough to hold the result."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlUnicodeStringToInteger routine converts a Unicode string representation of a number to the equivalent integer value.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the conversion is successful, the RtlUnicodeStringToInteger routine returns STATUS_SUCCESS and sets *Value to the integer value represented by the number in the Unicode string. If the string is not empty, but does not start with a valid number representation, the routine returns STATUS_SUCCESS and sets *Value to zero. If the string is empty, the routine fails and returns STATUS_INVALID_PARAMETER. ",
    "remarks": "This routine skips any white space at the start of the input string to find the start of the number. If the first non-white space character in the string is a hyphen (-), the integer value written to *Value is negative; otherwise, if the first character is a \"+\" or there is no sign character, the integer value written to *Value is positive. If the string does not contain a valid number, or if the first digit in the string is preceded by a non-white space character other than '+' or '-', the routine sets the output value to zero and returns STATUS_SUCCESS. A substring that contains one or more valid digits is terminated by any character that is not a valid digit. For example, if Base = 2, valid digits are '0' and '1'. If Base = 8, valid digits are '0' to '7'. If Base = 10, valid digits are '0' to '9'. If Base = 16, valid digits are '0' to '9', 'a' to 'f', and 'A' to 'F'. The following table contains examples of output values that result from various combinations of input strings and Base parameter values.  A related routine, RtlIntegerToUnicodeString, converts an integer value to the equivalent Unicode string representation. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlUnicodeStringToInteger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCUNICODE_STRING",
        "name": "String",
        "description": "A pointer to a UNICODE_STRING structure that contains the number representation to convert to the equivalent integer value."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "Base",
        "description": "A numeric value that indicates the base (or radix) of the number that the Unicode string represents. This parameter value is optional and can be set to zero. If Base is zero, RtlUnicodeStringToInteger checks the prefix of the Unicode string to determine the base of the number:   If the prefix is \"0x\", RtlUnicodeStringToInteger interprets the number in the string as a hexadecimal integer.   If the prefix is \"0o\", RtlUnicodeStringToInteger interprets the number in the string as an octal integer.   If the prefix is \"0b\", RtlUnicodeStringToInteger interprets the number in the string as a binary integer.   If the Unicode string does not contain any of these prefixes, RtlUnicodeStringToInteger treats the string as a base-10 integer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Value",
        "description": "A pointer to a ULONG variable to which RtlUnicodeStringToInteger writes the integer value that results from conversion of the Unicode string."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlConvertLongToLargeInteger routine converts the input signed integer to a signed large integer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlConvertLongToLargeInteger returns the large integer result. ",
    "remarks": "This routine is not supported in Windows XP. Use native support for __int64 instead. ",
    "return_type": "LARGE_INTEGER",
    "category": "Drivers",
    "name": "RtlConvertLongToLargeInteger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "SignedInteger",
        "description": "Specifies an integer of type LONG."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlConvertUlongToLargeInteger routine converts the input unsigned integer to a signed large integer. For Windows XP and later versions of Windows, do not use this routine; use the native support for __int64.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlConvertUlongToLargeInteger returns the converted large integer. ",
    "remarks": "",
    "return_type": "LARGE_INTEGER",
    "category": "Drivers",
    "name": "RtlConvertUlongToLargeInteger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UnsignedInteger",
        "description": "Specifies a value of type ULONG."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlTimeFieldsToTime routine converts TIME_FIELDS information to a system time value.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlTimeFieldsToTime returns TRUE if the input TimeFields data was successfully converted. ",
    "remarks": "RtlTimeFieldsToTime ignores the Weekday value in TimeFields. Callers of RtlTimeFieldsToTime can be running at any IRQL if both input buffers are resident. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "RtlTimeFieldsToTime",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTIME_FIELDS",
        "name": "TimeFields",
        "description": "Pointer to the following structure, containing the time information to be converted:       Copy      typedef struct TIME_FIELDS {     CSHORT Year;     CSHORT Month;     CSHORT Day;     CSHORT Hour;     CSHORT Minute;     CSHORT Second;     CSHORT Milliseconds;     CSHORT Weekday; } TIME_FIELDS;        Year  Specifies a value from 1601 on.  Month  Specifies a value from 1 to 12.  Day  Specifies a value from 1 to 31.  Hour  Specifies a value from 0 to 23.  Minute  Specifies a value from 0 to 59.  Second  Specifies a value from 0 to 59.  Milliseconds  Specifies a value from 0 to 999.  Weekday  Specifies a value from 0 to 6 (Sunday to Saturday)."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "Time",
        "description": "Pointer to a buffer, which is to contain the converted system time value as a large integer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlTimeToTimeFields routine converts system time into a TIME_FIELDS structure.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of RtlTimeToTimeFields can be running at any IRQL if both input buffers are resident. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "RtlTimeToTimeFields",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Time",
        "description": "Pointer to a buffer containing the absolute system time as a large integer, accurate to 100-nanosecond resolution."
      },
      {
        "in_out": "_Out_",
        "type": "PTIME_FIELDS",
        "name": "TimeFields",
        "description": "Pointer to a caller-allocated buffer, which must be at least sizeof(TIME_FIELDS), to contain the returned information."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExSystemTimeToLocalTime routine converts a GMT system time value to the local system time for the current time zone.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExSystemTimeToLocalTime subtracts the time-zone bias from the GMT system time value to compute the corresponding time at the current locale. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExSystemTimeToLocalTime",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "SystemTime",
        "description": "A pointer to a variable set to the unbiased, GMT system time."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "LocalTime",
        "description": "A pointer to the returned value for the current locale."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ExLocalTimeToSystemTime routine converts a system time value for the current time zone to an unbiased, GreenGMT value.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExLocalTimeToSystemTime adds the time-zone bias at the current locale to compute the corresponding GMT system time value. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExLocalTimeToSystemTime",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "LocalTime",
        "description": "A pointer to a variable set to the locale-specific time."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "SystemTime",
        "description": "A pointer to the returned value for GMT system time."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The RtlCharToInteger routine converts a single-byte character string to an integer value in the specified base.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "RtlCharToInteger returns STATUS_SUCCESS if the given character string is converted. Otherwise, it can return STATUS_INVALID_PARAMETER. ",
    "remarks": "RtlCharToInteger converts ANSI alphanumeric characters. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlCharToInteger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCSZ",
        "name": "String",
        "description": "Pointer to a null-terminated, single-byte character string."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "Base",
        "description": "Specifies decimal, binary, octal, or hexadecimal base. If this parameter is not given, the routine will look for 0x, 0o, and 0b prefixes in the input string to determine if the base should be decimal (default), binary, octal, or hexadecimal."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Value",
        "description": "Pointer to a location to which the converted value is returned."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ExCreateCallback routine either creates a new callback object or opens an existing callback object on behalf of the caller.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExCreateCallback returns STATUS_SUCCESS if a callback object was opened or created. Otherwise, it returns an NTSTATUS error code to indicate the nature of the failure. ",
    "remarks": "A driver calls ExCreateCallback to create a new callback object or to open an existing callback object. After the object has been created or opened, other components can call the ExRegisterCallback routine to register callback routines with the callback object. Before calling ExCreateCallback, the driver must call InitializeObjectAttributes to initialize the OBJECT_ATTRIBUTES structure for the callback object. Unnamed callback objects are not permitted. The caller must specify a name for the object; otherwise, the call fails with STATUS_UNSUCCESSFUL. The caller should specify the OBJ_PERMANENT attribute in the callback object to prevent the object from being deleted before it can be registered with the object manager. The caller should also specify any other attributes, such as OBJ_CASE_INSENSITIVE, that might be needed. When all operations have been completed with the callback object, the driver must delete the object to prevent a memory leak. For information about deleting an object  that was created with the OBJ_PERMANENT object attribute, see ObDereferenceObject. The following table shows the callback objects that the operating system creates for use by drivers.  For more information about callback objects, see Callback Objects. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ExCreateCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PCALLBACK_OBJECT*",
        "name": "CallbackObject",
        "description": "A pointer to a location that receives a pointer to a callback object, which is an opaque, system structure. If the ExCreateCallback call succeeds, the routine writes the address of the newly created or opened callback object to this location. The callback object pointer obtained from this routine can be supplied as a parameter to the ExRegisterCallback or ExNotifyCallback routine."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that contains the callback object's attributes. This structure was previously initialized by the InitializeObjectAttributes routine."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Create",
        "description": "Whether to create a callback object. Set to TRUE to create a new callback object if the requested object cannot be opened. Otherwise, set to FALSE."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "AllowMultipleCallbacks",
        "description": "Whether a newly created callback object should allow multiple registered callback routines. Set to TRUE to allow multiple registered callback routines. Otherwise, set to FALSE. This parameter is ignored when Create is FALSE or when opening an existing object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExNotifyCallback routine causes all callback routines registered for the given object to be called.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Driver writers must not call ExNotifyCallback for any of the system-defined callback objects listed in ExCreateCallback. The system calls callback routines in order of their registration. For more information about callback objects, see Callback Objects. Callers of this routine must be running at IRQL <= DISPATCH_LEVEL. The system calls all registered callback routines at the caller's IRQL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExNotifyCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CallbackObject",
        "description": "A pointer to the callback object for which all registered callback routines will be called."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Argument1",
        "description": "Specifies the parameter that is passed as Argument1 of the callback routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Argument2",
        "description": "Specifies the parameter that is passed as Argument2 of the callback routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExRegisterCallback routine registers a given callback routine with a given callback object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExRegisterCallback returns a pointer to a callback registration handle that should be treated as opaque and reserved for system use. This pointer is NULL if ExRegisterCallback completes with an error. ",
    "remarks": "A driver calls ExRegisterCallback to register a callback routine with a specified callback object. If the object allows only one registered callback routine, and such a routine is already registered, ExRegisterCallback returns NULL. Callers of ExRegisterCallback must save the returned pointer for use later in a call to ExUnregisterCallback. The pointer is required when removing the callback routine from the list of registered callback routines for the callback object. The meanings of Argument1 and Argument2 of the registered callback routine depend on the callback object and are defined by the component that created it. The following are the parameters for the system-defined callback objects:  Starting with Windows Vista, the \\Callback\\ProcessorAdd callback object is available to dynamically track changes in the processor population. The KeRegisterProcessorChangeCallback routine provides similar information, but additionally supports a KE_PROCESSOR_CHANGE_ADD_EXISTING flag that a driver can use to enumerate the processors in the initial multiprocessor system configuration. For drivers that run in Windows Server 2008 and later versions of Windows, use KeRegisterProcessorChangeCallback instead of the \\Callback\\ProcessorAdd callback object, if possible. For more information about callback objects, see Callback Objects. The operating system calls registered callback routines at the same IRQL at which the driver that created the callback called the ExNotifyCallback routine. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "ExRegisterCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PCALLBACK_OBJECT",
        "name": "CallbackObject",
        "description": "A pointer to a callback object obtained from the ExCreateCallback routine."
      },
      {
        "in_out": "_In_",
        "type": "PCALLBACK_FUNCTION",
        "name": "CallbackFunction",
        "description": "A pointer to a driver-implemented callback routine, which must be nonpageable. The callback routine must conform to the following prototype:       Copy      VOID (*PCALLBACK_FUNCTION ) (     IN PVOID CallbackContext,     IN PVOID Argument1,     IN PVOID Argument2     );      The callback routine parameters are as follows:   CallbackContext  A pointer to a driver-supplied context area as specified in the CallbackContext parameter of ExRegisterCallback.  Argument1  A pointer to a parameter defined by the callback object.  Argument2  A pointer to a parameter defined by the callback object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "CallbackContext",
        "description": "A pointer to a caller-defined structure of data items to be passed as the context parameter of the callback routine each time it is called. Typically the context is part of the caller's device object extension."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExUnregisterCallback routine removes a callback routine previously registered with a callback object from the list of routines to be called during the notification process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "For more information about callback objects, see Callback Objects. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExUnregisterCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "CbRegistration",
        "description": "Specifies the callback routine to unregister. This must be the value returned by ExRegisterCallback when the callback was registered."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The IoCheckShareAccess routine is called by file system drivers (FSDs) or other highest-level drivers to check whether shared access to a file object is permitted.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoCheckShareAccess returns STATUS_SUCCESS if the requester's access to the file object is compatible with the way in which it is currently open. If the request is denied because of a sharing violation, then STATUS_SHARING_VIOLATION is returned. ",
    "remarks": "IoCheckShareAccess checks a file object open request to determine whether the types of desired and shared accesses specified are compatible with the way in which the file object is currently being accessed by other opens. File systems maintain state about files through structures called file control blocks (FCBs). The SHARE_ACCESS is a structure describing how the file is currently accessed by all opens. This state is contained in the FCB as part of the open state for each file object. Each file object should have only one share access structure. Other highest-level drivers might call this routine to check the access requested when a file object representing such a driver's device object is opened. IoCheckShareAccess is not an atomic operation. Therefore, drivers calling this routine must protect the shared file object passed to IoCheckShareAccess by means of some kind of lock, such as a mutex or a resource lock, in order to prevent corruption of the shared access counts. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoCheckShareAccess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that indicates the desired type of access to the given FileObject for the current open request. Drivers compute the value of this parameter by taking the requested access in the IRP_MJ_CREATE request and then applying SeAccessCheck for each security descriptor to determine the actual access granted. If the granted access is more restrictive than the desired access, then that is an error, and the driver should complete the current IRP with a status of STATUS_ACCESS_DENIED. (Note that SeAccessCheck clears the MAXIMUM_ALLOWED bit in the granted access; be sure to not use that bit when comparing desired access to granted access.) The driver then passes the granted access as the value of DesiredAccess."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DesiredShareAccess",
        "description": "Specifies the desired type of shared access to FileObject for the current open request. The value of this parameter is usually the same as the ShareAccess passed to the file system or highest-level driver by the I/O manager when the open request was made. This value can be zero, or any combination of the following:   FILE_SHARE_READ   FILE_SHARE_WRITE   FILE_SHARE_DELETE"
      },
      {
        "in_out": "_Inout_",
        "type": "PFILE_OBJECT",
        "name": "FileObject",
        "description": "Pointer to the file object for which to check access for the current open request."
      },
      {
        "in_out": "_Inout_",
        "type": "PSHARE_ACCESS",
        "name": "ShareAccess",
        "description": "Pointer to the common share-access data structure associated with FileObject. Drivers should treat this structure as opaque."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Update",
        "description": "Specifies whether to update the share-access status for FileObject. A Boolean value of TRUE means this routine will update the share access information for the file object if the open request is permitted."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoUpdateShareAccess routine updates the share access for the given file object, usually when the file is being opened.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "IoUpdateShareAccess is not an atomic operation. Therefore, drivers calling this routine must protect the shared file object passed to IoUpdateShareAccess by means of some kind of lock, such as a mutex or a resource lock, in order to prevent corruption of the shared access counts. Before calling IoUpdateShareAccess, the caller must successfully call IoCheckShareAccess with Update set to False. Such a call to IoCheckShareAccess determines whether the requested shared access is compatible with the way the file object is currently being accessed by other opens, but it does not update the SHARE_ACCESS structure. IoUpdateShareAccess actually updates the SHARE_ACCESS structure associated with the file object. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoUpdateShareAccess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PFILE_OBJECT",
        "name": "FileObject",
        "description": "Pointer to a referenced file object representing the file or associated device object for which to update the share access."
      },
      {
        "in_out": "_Inout_",
        "type": "PSHARE_ACCESS",
        "name": "ShareAccess",
        "description": "Pointer to the common SHARE_ACCESS structure associated with the FileObject. Drivers should treat this structure as opaque."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoRemoveShareAccess routine removes the access and share-access information for a given open instance of a file object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine is a reciprocal to IoUpdateShareAccess. IoRemoveShareAccess is not an atomic operation. Therefore, drivers calling this routine must protect the shared file object passed to IoRemoveShareAccess by means of some kind of lock, such as a mutex or a resource lock, in order to prevent corruption of the shared access counts. Callers of IoRemoveShareAccess must be running at IRQL = PASSIVE_LEVEL and in the context of the thread that requested that the FileObject be closed. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoRemoveShareAccess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PFILE_OBJECT",
        "name": "FileObject",
        "description": "Pointer to the file object, which usually is being closed by the current thread."
      },
      {
        "in_out": "_Inout_",
        "type": "PSHARE_ACCESS",
        "name": "ShareAccess",
        "description": "Pointer to the share-access structure that describes how the open file object is currently being accessed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlLengthSecurityDescriptor routine returns the size of a given security descriptor.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlLengthSecurityDescriptor returns the size in bytes of the descriptor. ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "RtlLengthSecurityDescriptor",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to a SECURITY_DESCRIPTOR."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The RtlValidSecurityDescriptor routine checks a given security descriptor's validity.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlValidSecurityDescriptor returns TRUE if the given descriptor is valid. ",
    "remarks": "The routine checks the validity of an absolute-format security descriptor. To check the validity of a self-relative security descriptor, use the RtlValidRelativeSecurityDescriptor routine instead. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "RtlValidSecurityDescriptor",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to the SECURITY_DESCRIPTOR to be checked."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The RtlCreateSecurityDescriptor routine initializes a new absolute-format security descriptor. On return, the security descriptor is initialized with no system ACL, no discretionary ACL, no owner, no primary group, and all control flags set to zero.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlCreateSecurityDescriptor can return one of the following.  ",
    "remarks": "A successful call to this routine initializes a security descriptor. The fields in this descriptor are set to initial values that indicate that there are no security constraints. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlCreateSecurityDescriptor",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to the buffer for the SECURITY_DESCRIPTOR to be initialized."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Revision",
        "description": "Specifies the revision level to assign to the security descriptor. Set this parameter to SECURITY_DESCRIPTOR_REVISION."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The RtlSetDaclSecurityDescriptor routine sets the DACL information of an absolute-format security descriptor, or if there is already a DACL present in the security descriptor, it is superseded.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "RtlSetDaclSecurityDescriptor can return one of the following status values.  ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "RtlSetDaclSecurityDescriptor",
    "is_callback": 0,
    "dll": "NtosKrnl.exe (kernel mode);  Ntdll.dll (user mode)",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "A pointer to a SECURITY_DESCRIPTOR structure. This structure is the security descriptor to which the DACL is to be applied."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "DaclPresent",
        "description": "Whether to indicate that a DACL is present in the security descriptor. If this parameter is FALSE, RtlSetDaclSecurityDescriptor sets the SE_DACL_PRESENT control flag in the security descriptor to FALSE. In this case, the remaining optional parameters (Dacl and DaclDefaulted) are ignored. If DaclPresent is TRUE, the SE_DACL_PRESENT flag in the security descriptor is set to TRUE and the remaining optional parameters are not ignored. For more information about the SE_DACL_PRESENT flag, see SECURITY_DESCRIPTOR_CONTROL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PACL",
        "name": "Dacl",
        "description": "A pointer to the DACL for the security descriptor. If this parameter is NULL, the DACL pointer in the security descriptor is set to NULL. A NULL DACL pointer unconditionally grants all access to an object and is not the same as an empty DACL. An empty DACL denies all access to an object. If Dacl is non-NULL, the ACL structure supplied by the caller is referenced by, but not copied into, the security descriptor. The caller can allocate the ACL structure from paged system memory, and can call the RtlCreateAcl routine to initialize the structure."
      },
      {
        "in_out": "_In_opt_",
        "type": "BOOLEAN",
        "name": "DaclDefaulted",
        "description": "Whether the DACL was supplied by some default mechanism, or was explicitly specified by the caller. If this parameter is TRUE, the DACL was supplied by a default mechanism. If DaclDefaulted is FALSE, the caller explicitly specified the DACL. RtlSetDaclSecurityDescriptor copies the value specified for this parameter to the SE_DACL_DEFAULTED control flag in the security descriptor. For more information about the SE_DACL_DEFAULTED flag, see SECURITY_DESCRIPTOR_CONTROL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The     SeAssignSecurity routine builds a self-relative security descriptor for a new object, given the security descriptor of its parent directory and any originally requested security for the object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "SeAssignSecurity can return one of the following:  ",
    "remarks": "The final security descriptor returned to the caller may contain a mix of information, some explicitly provided from the new object's parent. SeAssignSecurity assumes privilege checking has not been performed. This routine performs privilege checking. The assignment of system and discretionary ACLs is governed by the logic illustrated in the following table:  An explicitly specified ACL, whether a default ACL or not, can be empty or null. The caller must be a kernel-mode client or be appropriately privileged to explicitly assign a default or nondefault system ACL. The assignment of the new object's owner and group is governed by the following logic: ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "SeAssignSecurity",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "ParentDescriptor",
        "description": "Pointer to a buffer containing the SECURITY_DESCRIPTOR for the parent directory, if any, containing the new object being created. ParentDescriptor can be NULL, or have a NULL system access control list (SACL) or a NULL discretionary access control list (DACL)."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "ExplicitDescriptor",
        "description": "Pointer to a buffer containing the SECURITY_DESCRIPTOR specified by the user that is applied to the new object. ExplicitDescriptor can be NULL, or have a NULL SACL or a NULL DACL."
      },
      {
        "in_out": "_Out_",
        "type": "PSECURITY_DESCRIPTOR*",
        "name": "NewDescriptor",
        "description": "Receives a pointer to the returned SECURITY_DESCRIPTOR. SeAssignSecurity allocates the buffer from the paged memory pool."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "IsDirectoryObject",
        "description": "Specifies whether the new object is a directory object. TRUE indicates the object contains other objects."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_SUBJECT_CONTEXT",
        "name": "SubjectContext",
        "description": "Pointer to a buffer containing the security context of the subject creating the object. This is used to retrieve default security information for the new object, such as the default owner, the primary group, and discretionary access control."
      },
      {
        "in_out": "_In_",
        "type": "PGENERIC_MAPPING",
        "name": "GenericMapping",
        "description": "Pointer to the GENERIC_MAPPING structure that describes the mapping from each generic right to the implied nongeneric rights."
      },
      {
        "in_out": "_In_",
        "type": "POOL_TYPE",
        "name": "PoolType",
        "description": "This parameter is unused.  The buffer to hold the new security descriptor is always allocated from paged pool."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The      SeDeassignSecurity routine deallocates the memory associated with a security descriptor that was assigned using SeAssignSecurity.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the deallocation succeeds, SeDeassignSecurity returns STATUS_SUCCESS. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "SeDeassignSecurity",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSECURITY_DESCRIPTOR*",
        "name": "SecurityDescriptor",
        "description": "Pointer to the buffered SECURITY_DESCRIPTOR being released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The SeValidSecurityDescriptor routine returns whether a given security descriptor is structurally valid.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "SeValidSecurityDescriptor returns TRUE if the buffered security descriptor is structurally valid. ",
    "remarks": "SeValidSecurityDescriptor does not enforce policy. It simply checks that the given security descriptor data is formatted correctly. In particular, it checks the revision information, self relativity, owner, alignment, and, if available, SID, group, DACL, ACL, and/or SACL do not overflow the given Length. Consequently, callers of SeValidSecurityDescriptor cannot assume that a returned TRUE implies that the given security descriptor necessarily has valid contents. If SeValidSecurityDescriptor returns TRUE, the given security descriptor can be passed on to another kernel-mode component because it is structurally valid. Otherwise, passing a structurally invalid security descriptor to be manipulated by another kernel-mode component can cause undefined results or even a system bug check. To validate a security descriptor that was passed in from user mode, call RtlValidSecurityDescriptor rather than SeValidSecurityDescriptor. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "SeValidSecurityDescriptor",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the size in bytes of the given security descriptor."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to the self-relative SECURITY_DESCRIPTOR, which must be buffered somewhere in system space."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The SeAccessCheck routine determines whether the requested access rights can be granted to an object protected by a security descriptor and an object owner.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If access is allowed, SeAccessCheck returns TRUE. ",
    "remarks": "SeAccessCheck might perform privilege tests for SeTakeOwnershipPrivilege and SeSecurityPrivilege, depending on the accesses being requested. It might perform additional privilege testing in future releases of the operating system. This routine also might check whether the caller is the owner of the object in order to grant WRITE_DAC or READ_CONTROL access. If this routine returns FALSE, the caller should use the returned AccessStatus as its return value. That is, the caller should avoid hardcoding a return value of STATUS_ACCESS_DENIED or any other specific STATUS_XXX value. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "SeAccessCheck",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to the SECURITY_DESCRIPTOR structure that describes the security descriptor protecting the object being accessed."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_SUBJECT_CONTEXT",
        "name": "SubjectSecurityContext",
        "description": "Pointer to the SECURITY_SUBJECT_CONTEXT structure that specifies the subject's captured security context."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "SubjectContextLocked",
        "description": "Indicates whether the user's subject context is locked, so that it does not have to be locked again."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies the ACCESS_MASK bitmask for the access rights that the caller is attempting to acquire.  If the caller sets the MAXIMUM_ALLOWED bit, the routine performs all DACL checks. However, the routine does not do any privilege checks, unless the caller specifically requests them by setting the ACCESS_SYSTEM_SECURITY or WRITE_OWNER bits."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "PreviouslyGrantedAccess",
        "description": "Specifies the ACCESS_MASK bitmask of access rights already granted, such as access rights granted as a result of holding a privilege."
      },
      {
        "in_out": "_Out_",
        "type": "PPRIVILEGE_SET*",
        "name": "Privileges",
        "description": "Pointer to a caller-supplied variable to be set to the address of the PRIVILEGE_SET structure that will be used as part of the access validation, or this parameter can be NULL. The returned buffer, if any, must be released by the caller with SeFreePrivileges."
      },
      {
        "in_out": "_In_",
        "type": "PGENERIC_MAPPING",
        "name": "GenericMapping",
        "description": "Pointer to the GENERIC_MAPPING structure associated with this object type. This value specifies the specific access rights implied by each GENERIC_XXX access right."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "AccessMode",
        "description": "Specifies the access mode to be used in the check, either UserMode or KernelMode."
      },
      {
        "in_out": "_Out_",
        "type": "PACCESS_MASK",
        "name": "GrantedAccess",
        "description": "Pointer to a returned access mask indicating the granted access. If the caller specifies MAXIMUM_ALLOWED, and the DACL in SecurityDescriptor is NULL, then the routine returns GENERIC_ALL plus any additional access the caller explicitly requests."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "AccessStatus",
        "description": "Pointer to the status value indicating why access was denied."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The     SeSinglePrivilegeCheck routine checks for the passed privilege value in the context of the current thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "SeSinglePrivilegeCheck returns TRUE if the current subject has the required privilege. ",
    "remarks": "If PreviousMode is KernelMode, the privilege check always succeeds. Otherwise, this routine uses the token of the user-mode thread to determine whether the current (user-mode) thread has been granted the given privilege. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "SeSinglePrivilegeCheck",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LUID",
        "name": "PrivilegeValue",
        "description": "Specifies the LUID value of the privilege being checked."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "PreviousMode",
        "description": "Specifies the previous execution mode, one of UserMode or KernelMode."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoAllocateErrorLogEntry routine allocates an error log entry, and returns a pointer to the packet that the caller uses to supply information about an I/O error.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoAllocateErrorLogEntry returns a pointer to the error log entry, or NULL if a log entry could not be allocated. ",
    "remarks": "The driver must first fill in the packet with information about the error, then call IoWriteErrorLogEntry to post the entry to the error log. The error log entry buffer is automatically freed once the log entry is recorded. Entry buffers that are not going to be written to the log can be freed by using IoFreeErrorLogEntry. An error log entry consists of a variable-length IO_ERROR_LOG_PACKET structure, possibly followed by one or more zero-counted Unicode strings. The Event Viewer inserts these strings into the error message it displays for the entry. IO_ERROR_LOG_PACKET contains one variable-length member, the DumpData member. Thus, the value for EntrySize must be sizeof(IO_ERROR_LOG_PACKET) + size of the DumpData member + combined size of any driver-supplied insertion strings. Drivers should check that the value for EntrySize is less than ERROR_LOG_MAXIMUM_SIZE before calling IoAllocateErrorLogEntry. Since EntrySize  is declared as a UCHAR, and the compiler will silently truncate any value too big to fit into a UCHAR, the routine itself cannot reliably detect if the passed value is too large. Drivers must not treat IoAllocateErrorLogEntry returning NULL as a fatal error. The driver must continue to function normally, regardless of whether it can log errors. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "IoAllocateErrorLogEntry",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "IoObject",
        "description": "Pointer to a device object representing the device on which an I/O error occurred, or to a driver object representing the driver that found an error."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "EntrySize",
        "description": "Specifies the size, in bytes, of the error log entry to be allocated. This value cannot exceed ERROR_LOG_MAXIMUM_SIZE.  Warning  EntrySize is a UCHAR value. If you specify a larger value, the compiler will silently truncate that value to a (wrong) UCHAR."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoFreeErrorLogEntry routine frees an unused error log entry.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers use IoFreeErrorLogEntry to free an error log entry allocated by IoAllocateErrorLogEntry. IoWriteErrorLogEntry also frees any error log entries passed to it, so drivers must not call both on the same log entry. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoFreeErrorLogEntry",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ElEntry",
        "description": "Pointer to an error log packet allocated by IoAllocateErrorLogEntry."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoWriteErrorLogEntry routine queues a given error log packet to the system error logging thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "IoWriteErrorLogEntry frees the error log entry. Drivers must not call IoFreeErrorLogEntry on a log entry that they have already passed to IoWriteErrorLogEntry. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoWriteErrorLogEntry",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ElEntry",
        "description": "Pointer to the error log packet the driver has allocated with IoAllocateErrorLogEntry and filled in by the caller."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoIsErrorUserInduced routine determines whether an I/O error encountered while processing a request to a removable-media device was caused by the user.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoIsErrorUserInduced returns TRUE if an I/O request failed because of a user-induced error. ",
    "remarks": "This routine indicates whether an I/O request failed for one of the following user-correctable conditions: If IoIsErrorUserInduced returns TRUE, the removable-media driver must call IoSetHardErrorOrVerifyDevice before completing the IRP. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IoIsErrorUserInduced",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "Status",
        "description": "Specifies the current NTSTATUS value, usually within the driver's DpcForIsr routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "Lower-level drivers call the IoSetHardErrorOrVerifyDevice routine to identify a removable media device that has encountered an error, so that a file system driver can prompt the user to verify that the medium is valid.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "Lower-level drivers for removal media devices must call IoSetHardErrorOrVerifyDevice before completing an IRP, if a call to IoIsErrorUserInduced returns TRUE. For more information, see Supporting Removable Media. Subsequently, a file system driver will use information supplied in the specified device object to send a dialog box to the user, who can correct the error and retry the operation or cancel it. The IRP passed to IoSetHardErrorOrVerifyDevice must be associated with a thread. Therefore, before a driver calls IoSetHardErrorOrVerifyDevice, it must verify that irp->Tail.Overlay.Thread is not NULL. If the value is NULL, IoSetHardErrorOrVerifyDevice must not be called using the current IRP. Instead, the driver should check all IRPs subsequently received and processed, until one is received for which irp->Tail.Overlay.Thread is not NULL. At that point, IoSetHardErrorOrVerifyDevice can be called. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoSetHardErrorOrVerifyDevice",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP for which the driver encountered a user-induced error."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the target device to be verified for the I/O operation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoSetThreadHardErrorMode routine enables or disables hard error reporting for the current thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoSetThreadHardErrorMode returns TRUE if hard errors were enabled from this thread before this routine completed execution. Otherwise, this routine returns FALSE. ",
    "remarks": "If hard errors are disabled for a given thread, calls to IoRaiseHardError will not display a message to the user indicating that a serious error has occurred. In addition, the IRP that is passed to IoRaiseHardError is completed without any data being copied into user buffers. Calling IoRaiseInformationalHardError after disabling hard errors causes that routine to always return FALSE for this thread. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IoSetThreadHardErrorMode",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "EnableHardErrors",
        "description": "Specifies whether hard error reporting to the user should be enabled or disabled for this thread. A value of TRUE enables hard error reporting. FALSE disables it."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoRaiseHardError routine causes a dialog box to appears that warns the user that a device I/O error has occurred, which might indicate that a physical device is failing.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "Highest-level drivers, particularly file system drivers, call IoRaiseHardError. The behavior of this routine is dependent of the current state of hard errors for the running thread. If hard errors have been disabled by calling IoSetThreadHardErrorMode, this routine completes the IRP specified by Irp without transferring any data into user buffers. In addition, no message is sent to notify the user of this failure. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoRaiseHardError",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP that failed because of a device I/O error."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVPB",
        "name": "Vpb",
        "description": "Pointer to the volume parameter block (VPB), if any, for the mounted file object. This parameter is NULL if no VPB is associated with the device object."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "RealDeviceObject",
        "description": "Pointer to the device object that represents the physical device on which the I/O operation failed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoRaiseInformationalHardError routine sends a dialog box to the user, warning about a device I/O error that indicates why a user I/O request failed.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoRaiseInformationalHardError returns TRUE if the dialog box was successfully queued. This routine returns FALSE if dialog boxes are disabled for Thread, a pool allocation failed, too many dialog boxes are already queued, or an equivalent dialog box is already pending a user response (such as waiting for the user to press RETURN). ",
    "remarks": "IoRaiseInformationalHardError takes a system-defined NT error value as a parameter. Driver writers can use the event log APIs to communicate driver-defined event strings to the user. IoRaiseInformationalHardError behaves as follows: If a previous call to the IoSetThreadHardErrorMode routine disabled hard errors for the specified thread, IoRaiseInformationalHardError returns FALSE. Starting with Windows Vista, if the routine is called from a thread in session 0 (that is, from any system thread), no dialog box appears when the routine succeeds and returns TRUE. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IoRaiseInformationalHardError",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "ErrorStatus",
        "description": "The error status code (IO_ERR_XXX)."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "String",
        "description": "A pointer to a Unicode string, which provides additional information about the error. Some NT status codes require a string parameter, such as a file or directory name. If the specified ErrorStatus value does not require a string parameter, set String to NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PKTHREAD",
        "name": "Thread",
        "description": "A pointer to the thread whose IRP was failed due to the error specified by the ErrorStatus parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExRaiseStatus routine is called by drivers that supply structured exception handlers to handle particular errors that occur while they are processing I/O requests.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Highest-level drivers, particularly file systems, can call ExRaiseStatus. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExRaiseStatus",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "Status",
        "description": "Specifies one of the system-defined STATUS_XXX values."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The KeBugCheckEx routine brings down the system in a controlled manner when the caller discovers an unrecoverable inconsistency that would corrupt the system if the caller continued to run.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A bug check is a system-detected error that causes an immediate, controlled shutdown of the system. Various kernel-mode components perform run-time consistency checking. When such a component discovers an unrecoverable inconsistency, it causes a bug check to be generated. Whenever possible, all kernel-mode components should log an error and continue to run, rather than calling KeBugCheckEx. For example, if a driver is unable to allocate required resources, it should log an error so that the system continues to run; it must not generate a bug check. A driver or other kernel-mode component should call this routine only in cases of a fatal, unrecoverable error that could corrupt the system itself. KeBugCheckEx can be useful in the early stages of developing a driver, or while it is undergoing testing. In these circumstances, the BugCheckCode passed to this routine should be distinct from those codes already in use by Windows or its drivers. For a list of these codes, see Bug Check Codes. However, even during driver development, this routine is of only limited utility, since it results in a complete system shutdown. A more effective debugging method is to attach a kernel debugger to the system and then use routines that send messages to the debugger or break into the debugger. For further information, see Using Debugging Code in a Driver. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeBugCheckEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BugCheckCode",
        "description": "Specifies a value that indicates the reason for the bug check."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "BugCheckParameter1",
        "description": ""
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "BugCheckParameter2",
        "description": ""
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "BugCheckParameter3",
        "description": ""
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "BugCheckParameter4",
        "description": "The four BugCheckParameterX values supply additional information, such as the address and data where a memory-corruption error occurred, depending on the value of BugCheckCode."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeBugCheck routine brings down the system in a controlled manner when the caller discovers an unrecoverable inconsistency that would corrupt the system if the caller continued to run.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "A bug check is a system-detected error that causes an immediate, controlled shutdown of the system. Various kernel-mode components perform run-time consistency checking. When such a component discovers an unrecoverable inconsistency, it causes a bug check to be generated. Whenever possible, all kernel-mode components should log an error and continue to run, rather than calling KeBugCheck. For example, if a driver is unable to allocate required resources, it should log an error so that the system continues to run; it must not generate a bug check. A driver or other kernel-mode component should call this routine only in cases of a fatal, unrecoverable error that could corrupt the system itself. KeBugCheck can be useful in the early stages of developing a driver, or while it is undergoing testing. In these circumstances, the BugCheckCode passed to this routine should be distinct from those codes already in use by Windows or its drivers. For a list of these codes, see Bug Check Codes. However, even during driver development, this routine is of only limited utility, since it results in a complete system shutdown. A more effective debugging method is to attach a kernel debugger to the system and then use routines that send messages to the debugger or break into the debugger. For further information, see Using Debugging Code in a Driver. When a bug check is unavoidable, most system components call KeBugCheckEx, which provides more information about the cause of such an inconsistency than KeBugCheck. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeBugCheck",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BugCheckCode",
        "description": "Specifies a value that indicates the reason for the bug check."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The KeRegisterBugCheckCallback routine registers a BugCheckCallback routine, which executes when the operating system issues a bug check.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeRegisterBugCheckCallback returns TRUE if the caller-supplied routine is successfully added to the set of registered bug-check callbacks; otherwise, it returns FALSE. ",
    "remarks": "The KeRegisterBugCheckCallback routine registers a BugCheckCallback routine, the simplest kind of bug-check callback routine. To register other kinds of bug-check callbacks, such as BugCheckDumpIoCallback and BugCheckAddPagesCallback routines, use the KeRegisterBugCheckReasonCallback routine instead. The BugCheckCallback routine is executed when the system issues a bug check. A driver can use the routine to reset the device to a known state. For more information, see BugCheckCallback. Drivers can use the KeDeregisterBugCheckCallback routine to remove the callback. Any driver that can be unloaded must remove all of its callbacks in its Unload routine. The Component string is used to identify the driver during crash-dump debugging. To display the crash dump data corresponding to any specified Component string, you can use the !bugdump debugger extension. It is also possible to debug the bug check callback routine itself. For information about debuggers and debugger extensions, see Windows Debugging. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeRegisterBugCheckCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKBUGCHECK_CALLBACK_RECORD",
        "name": "CallbackRecord",
        "description": "Pointer to a callback record that was previously initialized by KeInitializeCallbackRecord, for which the caller provides nonpaged storage."
      },
      {
        "in_out": "_In_",
        "type": "PKBUGCHECK_CALLBACK_ROUTINE",
        "name": "CallbackRoutine",
        "description": "Pointer to the driver-supplied BugCheckCallback routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a caller-supplied buffer, which must be in resident memory, such as nonpaged pool."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the size in bytes of the caller-allocated buffer."
      },
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Component",
        "description": "Pointer to a null-terminated ANSI string that identifies the caller. This string usually contains the name of the device driver, or possibly of its device."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeDeregisterBugCheckCallback routine removes a callback routine that was registered by KeRegisterBugCheckCallback.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeDeregisterBugCheckCallback returns TRUE if the specified callback is successfully removed. It returns FALSE if the specified callback is not registered. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeDeregisterBugCheckCallback",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKBUGCHECK_CALLBACK_RECORD",
        "name": "CallbackRecord",
        "description": "Pointer to a KBUGCHECK_CALLBACK_RECORD structure. CallbackRecord must be the same value that was passed to KeRegisterBugCheckCallback when the callback was registered."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwAllocateVirtualMemory routine reserves, commits, or both, a region of pages within the user-mode virtual address space of a specified process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwAllocateVirtualMemory returns either STATUS_SUCCESS or an error status code. Possible error status codes include the following: ",
    "remarks": "ZwAllocateVirtualMemory can perform the following operations: Kernel-mode drivers can use ZwAllocateVirtualMemory to reserve a range of application-accessible virtual addresses in the specified process and then make additional calls to ZwAllocateVirtualMemory to commit individual pages from the reserved range. This enables a process to reserve a range of its virtual address space without consuming physical storage until it is needed. Each page in the process's virtual address space is in one of the three states described in the following table.  Memory allocated by calling ZwAllocateVirtualMemory must be freed by calling ZwFreeVirtualMemory. For more information about memory management, see Memory Management for Windows Drivers. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwAllocateVirtualMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle for the process for which the mapping should be done. Use the NtCurrentProcess macro, defined in Ntddk.h, to specify the current process."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID*",
        "name": "BaseAddress",
        "description": "A pointer to a variable that will receive the base address of the allocated region of pages. If the initial value of this parameter is non-NULL, the region is allocated starting at the specified virtual address rounded down to the next host page size address boundary. If the initial value of this parameter is NULL, the operating system will determine where to allocate the region."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "ZeroBits",
        "description": "The number of high-order address bits that must be zero in the base address of the section view. This value must be less than 21 and is used only when the operating system determines where to allocate the region, as when BaseAddress is NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "PSIZE_T",
        "name": "RegionSize",
        "description": "A pointer to a variable that will receive the actual size, in bytes, of the allocated region of pages. The initial value of this parameter specifies the size, in bytes, of the region and is rounded up to the next host page size boundary. *RegionSize cannot be zero on input."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocationType",
        "description": "A bitmask containing flags that specify the type of allocation to be performed. The following table describes these flags.  FlagMeaning  MEM_COMMIT  The specified region of pages is to be committed. One of MEM_COMMIT, MEM_RESET, or MEM_RESERVE must be set.   MEM_PHYSICAL  Allocate physical memory. This flag is solely for use with Address Windowing Extensions (AWE) memory.  If MEM_PHYSICAL is set, MEM_RESERVE must also be set. No other flags may be set. If MEM_PHYSICAL is set, Protect must be set to PAGE_READWRITE.   MEM_RESERVE  The specified region of pages is to be reserved. One of MEM_COMMIT, MEM_RESET, or MEM_RESERVE must be set.   MEM_RESET  Reset the state of the specified region so that if the pages are in paging file, they are discarded and pages of zeros are brought in. If the pages are in memory and modified, they are marked as not modified so that they will not be written out to the paging file. The contents are not zeroed. The Protect parameter is not used, but it must be set to a valid value.  One of MEM_COMMIT, MEM_RESET, or MEM_RESERVE must be set. If MEM_RESET is set, no other flag may be set.   MEM_TOP_DOWN  The specified region should be created at the highest virtual address possible based on ZeroBits."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Protect",
        "description": "A bitmask containing page protection flags that specify the protection desired for the committed region of pages. The following table describes these flags.  FlagMeaning  PAGE_NOACCESS  No access to the committed region of pages is allowed. An attempt to read, write, or execute the committed region results in an access violation exception, called a general protection (GP) fault.   PAGE_READONLY  Read-only and execute access to the committed region of pages is allowed.  An attempt to write the committed region results in an access violation.   PAGE_READWRITE  Read, write, and execute access to the committed region of pages is allowed.  If write access to the underlying section is allowed, then a single copy of the pages is shared. Otherwise the pages are shared read only/copy on write.   PAGE_EXECUTE  Execute access to the committed region of pages is allowed. An attempt to read or write to the committed region results in an access violation.   PAGE_EXECUTE_READ  Execute and read access to the committed region of pages are allowed. An attempt to write to the committed region results in an access violation.   PAGE_EXECUTE_READWRITE  Execute, read, and write access to the committed region of pages are allowed.   PAGE_GUARD  Pages in the region become guard pages. Any attempt to read from or write to a guard page causes the system to raise a STATUS_GUARD_PAGE exception. Guard pages thus act as a one-shot access alarm.  This flag is a page protection modifier, valid only when used with one of the page protection flags other than PAGE_NOACCESS. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page exception occurs during a system service, the service typically returns a failure status indicator.   PAGE_NOCACHE  The region of pages should be allocated as noncacheable. PAGE_NOCACHE is not allowed for sections.   PAGE_WRITECOMBINE  Enables write combining, that is, coalescing writes from cache to main memory, where the hardware supports it. This flag is used primarily for frame buffer memory so that writes to the same cache line are combined where possible before being written to the device. This can greatly reduce writes across the bus to (for example) video memory. If the hardware does not support write combining, the flag is ignored. This flag is a page protection modifier, valid only when used with one of the page protection flags other than PAGE_NOACCESS."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwCommitComplete routine notifies KTM that the calling resource manager has finished committing a transaction's data.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwCommitComplete returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might  return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager must call ZwCommitComplete after it has finished servicing a TRANSACTION_NOTIFY_COMMIT notification. For more information about ZwCommitComplete, see Handling Commit Operations. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCommitComplete",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwCommitEnlistment routine initiates the commit operation for a specified enlistment's transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwCommitEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Only superior transaction managers can call ZwCommitEnlistment. Callers of ZwCommitEnlistment must register to receive TRANSACTION_NOTIFY_COMMIT_COMPLETE notifications. The ZwCommitEnlistment routine causes KTM to send TRANSACTION_NOTIFY_COMMIT notifications to all resource managers that have enlisted in the transaction. For more information about ZwCommitEnlistment, see Creating a Superior Transaction Manager and Handling Commit Operations. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCommitEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The object must represent a superior enlistment and the handle must have ENLISTMENT_SUPERIOR_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwCommitTransaction routine initiates a commit operation for a specified transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwCommitTransaction returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "For more information about how transaction clients should use the ZwCommitTransaction routine, see Creating a Transactional Client. For more information about commit operations, see Handling Commit Operations. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCommitTransaction",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionHandle",
        "description": "A handle to a transaction object. Your component receives this handle from ZwCreateTransaction or ZwOpenTransaction. The handle must have TRANSACTION_COMMIT access to the object."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "A Boolean value that the caller sets to TRUE for synchronous operation or FALSE for asynchronous operation. If this parameter is TRUE, the call returns after the commit operation is complete."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwCreateDirectoryObject routine creates or opens an object-directory object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwCreateDirectoryObject returns an NTSTATUS value. Possible return values include: ",
    "remarks": "Once the handle pointed to by DirectoryHandle is no longer in use, the driver must call ZwClose to close it. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. The system uses object directories to organize other types of objects, such as device objects. For more information, see Object Directories. Note that the system does not use object directory objects to represent file-system directories, which are represented instead as file objects. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateDirectoryObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "DirectoryHandle",
        "description": "Pointer to a HANDLE variable that receives a handle to the object directory."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. In addition to the access rights that are defined for all types of objects (see ACCESS_MASK), the caller can specify one or more of the following access rights, which are specific to object directories:  ACCESS_MASK flagType of access  DIRECTORY_QUERY  Query   DIRECTORY_TRAVERSE  Name lookup   DIRECTORY_CREATE_OBJECT  Name creation   DIRECTORY_CREATE_SUBDIRECTORY  Subdirectory creation   DIRECTORY_ALL_ACCESS  All of the preceding types"
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that contains the object's attributes, which you must have already initialized by calling InitializeObjectAttributes."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 8,
    "description": "The ZwCreateEnlistment routine creates a new enlistment object for a transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwCreateEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager calls ZwCreateEnlistment to enlist in a transaction. Resource managers that are not superior must include the ENLISTMENT_SUBORDINATE_RIGHTS flag in their access mask. Superior transaction managers must include the ENLISTMENT_SUPERIOR_RIGHTS flag in their access masks. Typically, a superior transaction manager includes code that calls ZwRollbackEnlistment, so it must also include the ENLISTMENT_SUBORDINATE_RIGHTS flag. A resource manager that calls ZwCreateEnlistment must eventually call ZwClose to close the object handle. Your resource manager can use the EnlistmentKey parameter to assign a unique value to each enlistment, such as a pointer to a data structure that contains information about the enlistment. For example, if the resource manager stores the enlistment object's handle in the structure, the resource manager can do the following: For more information about ZwCreateEnlistment, see Creating a Resource Manager and Creating a Superior Transaction Manager. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "EnlistmentHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to the new enlistment object if the call to ZwCreateEnlistment succeeds."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the enlistment object. In addition to the access rights that are defined for all kinds of objects (see ACCESS_MASK), the caller can specify any of the following access right flags for enlistment objects:  ACCESS_MASK flagAllows the caller to  ENLISTMENT_QUERY_INFORMATION  Query information about the enlistment (see ZwQueryInformationEnlistment).    ENLISTMENT_SET_INFORMATION  Set information for the enlistment (see ZwSetInformationEnlistment).    ENLISTMENT_RECOVER  Recover the enlistment (see ZwRecoverEnlistment).    ENLISTMENT_SUBORDINATE_RIGHTS  Perform operations that a resource manager that is not superior performs (see ZwRollbackEnlistment, ZwPrePrepareComplete, ZwPrepareComplete, ZwCommitComplete, ZwRollbackComplete, ZwSinglePhaseReject, ZwReadOnlyEnlistment).    ENLISTMENT_SUPERIOR_RIGHTS  Perform operations that a superior transaction manager must perform (see ZwPrepareEnlistment, ZwPrePrepareEnlistment, ZwCommitEnlistment).      Alternatively, you can specify one or more of the following ACCESS_MASK bitmaps. These bitmaps combine the flags from the previous table with the STANDARD_RIGHTS_XXX flags that are described on the ACCESS_MASK reference page. You can also combine these bitmaps together with additional flags from the previous table. The following table shows how the bitmaps correspond to specific access rights.   Generic access rightSet of specific access rights  ENLISTMENT_GENERIC_READ  STANDARD_RIGHTS_READ and ENLISTMENT_QUERY_INFORMATION   ENLISTMENT_GENERIC_WRITE  STANDARD_RIGHTS_WRITE, ENLISTMENT_SET_INFORMATION, ENLISTMENT_RECOVER, ENLISTMENT_REFERENCE, ENLISTMENT_SUBORDINATE_RIGHTS, and ENLISTMENT_SUPERIOR_RIGHTS   ENLISTMENT_GENERIC_EXECUTE  STANDARD_RIGHTS_EXECUTE, ENLISTMENT_RECOVER, ENLISTMENT_SUBORDINATE_RIGHTS, and ENLISTMENT_SUPERIOR_RIGHTS   ENLISTMENT_ALL_ACCESS  STANDARD_RIGHTS_REQUIRED, ENLISTMENT_GENERIC_READ, ENLISTMENT_GENERIC_WRITE, and ENLISTMENT_GENERIC_EXECUTE"
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ResourceManagerHandle",
        "description": "A handle to the caller's resource manager object that was obtained by a previous call to ZwCreateResourceManager or ZwOpenResourceManager."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionHandle",
        "description": "A handle to a transaction object that was obtained by a previous call to ZwCreateTransaction or ZwOpenTransaction. KTM adds this transaction to the list of transactions that the calling resource manager is handling."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use the InitializeObjectAttributes routine to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes. This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "CreateOptions",
        "description": "Enlistment option flags. The following table contains the only available flag.   CreateOptions flagMeaning  ENLISTMENT_SUPERIOR  The caller is enlisting as a superior transaction manager for the specified transaction.     This parameter is optional and can be zero."
      },
      {
        "in_out": "_In_",
        "type": "NOTIFICATION_MASK",
        "name": "NotificationMask",
        "description": "A bitwise OR of TRANSACTION_NOTIFY_XXX values that are defined in Ktmtypes.h. This mask specifies the types of transaction notifications that KTM sends to the caller."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "EnlistmentKey",
        "description": "A pointer to caller-defined information that uniquely identifies the enlistment. The resource manager receives this pointer when it calls ZwGetNotificationResourceManager or when KTM calls the ResourceManagerNotification callback routine. The resource manager can maintain a reference count for this key by calling TmReferenceEnlistmentKey and TmDereferenceEnlistmentKey. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwCreateEvent routine creates an event object, sets the initial state of the event to the specified value, and opens a handle to the object with the specified desired access.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwCreateEvent returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "ZwCreateEvent creates an event object, sets it initial state to the specified value, and opens a handle to the object with the specified desired access. ZwCreateEvent can create either notification or synchronization events. Events are used to coordinate execution. Events can be used by file system drivers to allow a caller to wait for completion of the requested operation until the given event is set to the Signaled state. Notification events can be used to notify one or more threads of execution that an event has occurred. Synchonization events can be used in the serialization of access to hardware between two otherwise unrelated drivers. A synchonization event is auto-resetting. When a synchronization event is set to the Signaled state, a single thread of execution that was waiting for the event to be signaled is released, and the event is automatically reset to the Not-Signaled state. Unlike a synchronization event, a notification event is not auto-resetting. Once a notification event is in the Signaled state, it remains in that state until it is explicitly reset. To synchronize on a notification event: The ZwCreateEvent function is called after the InitializeObjectAttributes macro is used to set attributes in the OBJECT_ATTRIBUTES structure for the object. There are two alternate ways to specify the name of the object passed to ZwCreateEvent: To release the event, a driver calls ZwClose with the event handle. For more information about events, see Event Objects. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "EventHandle",
        "description": "A pointer to a variable that will receive the event object handle. The handle includes bookkeeping information, such as a reference count and security context."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "The ACCESS_MASK value that represents the desired types of access for the event object. The following table contains the event-specific ACCESS_MASK values.  ValueDesired access EVENT_QUERY_STATEQuery the state of the event object. EVENT_MODIFY_STATEModify the state of the event object. EVENT_ALL_ACCESSAll possible access rights to the event object."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to the object attributes structure supplied by the caller to be used for the specified object. These attributes would include the ObjectName and the SECURITY_DESCRIPTOR, for example. This parameter is initialized by calling the InitializeObjectAttributes macro."
      },
      {
        "in_out": "_In_",
        "type": "EVENT_TYPE",
        "name": "EventType",
        "description": "The type of the event, which can be SynchronizationEvent or a NotificationEvent. These values belong to the EVENT_TYPE enumeration, which is defined in the Ntdef.h header file.  The event type can be modified with the REALTIME_OBJECT_FLAG modifier to provide priority-ordered queuing of wait requests."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InitialState",
        "description": "The initial state of the event object. Set to TRUE to initialize the event object to the Signaled state. Set to FALSE to initialize the event object to the not-Signaled state."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ZwCreateResourceManager routine creates a resource manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwCreateResourceManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager that calls ZwCreateResourceManager must eventually call ZwClose to close the object handle. For more information about ZwCreateResourceManager, see Creating a Resource Manager. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateResourceManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "ResourceManagerHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to the new resource manager object if the call to ZwCreateResourceManager is successful."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the resource manager object. In addition to the access rights that are defined for all kinds of objects (see ACCESS_MASK), the caller can specify any of the following access right flags for resource manager objects:  ACCESS_MASK flagAllows the caller to  RESOURCEMANAGER_ENLIST  Enlist in transactions (see ZwCreateEnlistment).    RESOURCEMANAGER_GET_NOTIFICATION  Receive notifications about the transactions that are associated with this resource manager (see ZwGetNotificationResourceManager).    RESOURCEMANAGER_REGISTER_PROTOCOL  Not used.    RESOURCEMANAGER_QUERY_INFORMATION  Query information about the resource manager (see ZwQueryInformationResourceManager).    RESOURCEMANAGER_SET_INFORMATION  Not used.    RESOURCEMANAGER_RECOVER  Recover the resource manager (see ZwRecoverResourceManager).    RESOURCEMANAGER_COMPLETE_PROPAGATION  Not used.      Alternatively, you can specify one or more of the following generic ACCESS_MASK flags. (The STANDARD_RIGHTS_Xxx flags are predefined system values that are used to enforce security on system objects.) You can also combine these generic flags with additional flags from the preceding table. The following table shows how generic access rights correspond to specific access rights.   Generic access rightSet of specific access rights  RESOURCEMANAGER_GENERIC_READ  STANDARD_RIGHTS_READ, RESOURCEMANAGER_QUERY_INFORMATION, and SYNCHRONIZE   RESOURCEMANAGER_GENERIC_WRITE  STANDARD_RIGHTS_WRITE, RESOURCEMANAGER_SET_INFORMATION, RESOURCEMANAGER_RECOVER, RESOURCEMANAGER_ENLIST, RESOURCEMANAGER_GET_NOTIFICATION, RESOURCEMANAGER_REGISTER_PROTOCOL, RESOURCEMANAGER_COMPLETE_PROPAGATION, and SYNCHRONIZE   RESOURCEMANAGER_GENERIC_EXECUTE  STANDARD_RIGHTS_EXECUTE, RESOURCEMANAGER_RECOVER, RESOURCEMANAGER_ENLIST, RESOURCEMANAGER_GET_NOTIFICATION, RESOURCEMANAGER_COMPLETE_PROPAGATION, and SYNCHRONIZE   RESOURCEMANAGER_ALL_ACCESS  STANDARD_RIGHTS_REQUIRED, RESOURCEMANAGER_GENERIC_READ, RESOURCEMANAGER_GENERIC_WRITE, and RESOURCEMANAGER_GENERIC_EXECUTE"
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TmHandle",
        "description": "A handle to a transaction manager object that was obtained by a previous all to ZwCreateTransactionManager or ZwOpenTransactionManager."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPGUID",
        "name": "ResourceManagerGuid",
        "description": "A pointer to a GUID that KTM will use to identify the resource manager. If this pointer is NULL, KTM generates a GUID."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use the InitializeObjectAttributes routine to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes. This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "CreateOptions",
        "description": "Optional object creation flags. The following table contains the available flags, which are defined in Ktmtypes.h.   CreateOptions flagMeaning  RESOURCE_MANAGER_COMMUNICATION  For internal use only.    RESOURCE_MANAGER_VOLATILE  The caller will manage volatile resources. It will be non-persistent and will not perform recovery.      This parameter is optional and can be zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "Description",
        "description": "A pointer to a caller-supplied UNICODE_STRING structure that contains a NULL-terminated string. The string provides a description of the resource manager. KTM stores a copy of the string and includes the string in messages that it writes to the log stream. The maximum string length is MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ZwCreateSection routine creates a section object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "ZwCreateSection returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. Possible error status codes include the following:  ",
    "remarks": "Once the handle pointed to by SectionHandle is no longer in use, the driver must call ZwClose to close it. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. For more information about setting up mapped sections and views of memory, see Sections and Views. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateSection",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "SectionHandle",
        "description": "Pointer to a HANDLE variable that receives a handle to the section object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. In addition to the access rights that are defined for all types of objects (see ACCESS_MASK), the caller can specify any of the following access rights, which are specific to section objects:  DesiredAccess flagAllows caller to do this  SECTION_EXTEND_SIZE  Dynamically extend the size of the section.   SECTION_MAP_EXECUTE  Execute views of the section.   SECTION_MAP_READ  Read views of the section.   SECTION_MAP_WRITE  Write views of the section.   SECTION_QUERY  Query the section object for information about the section. Drivers should set this flag.   SECTION_ALL_ACCESS  All of the previous flags combined with STANDARD_RIGHTS_REQUIRED."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "MaximumSize",
        "description": "Specifies the maximum size, in bytes, of the section. ZwCreateSection rounds this value up to the nearest multiple of PAGE_SIZE. If the section is backed by the paging file, MaximumSize specifies the actual size of the section. If the section is backed by an ordinary file, MaximumSize specifies the maximum size that the file can be extended or mapped to."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SectionPageProtection",
        "description": "Specifies the protection to place on each page in the section. Use one of the following four values: PAGE_READONLY, PAGE_READWRITE, PAGE_EXECUTE, or PAGE_WRITECOPY. For a description of these values, see CreateFileMapping."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AllocationAttributes",
        "description": "Specifies a bitmask of SEC_XXX flags that determines the allocation attributes of the section. For a description of these flags, see CreateFileMapping."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Optionally specifies a handle for an open file object. If the value of FileHandle is NULL, the section is backed by the paging file. Otherwise, the section is backed by the specified file."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The ZwCreateTransaction routine creates a transaction object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwCreateTransaction returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "The caller can use the Uow parameter to specify a UOW identifier for the transaction object. If the caller does not specify a UOW identifier, KTM generates a GUID and assigns it to the transaction object. The caller can later obtain this GUID by calling ZwQueryInformationTransaction. Typically, you should let KTM generate a GUID for the transaction object, unless your component communicates with another TPS component that has already generated a UOW identifier for the transaction. To close the transaction handle, the component that called ZwCreateTransaction must call ZwClose. If the last transaction handle closes before any component calls ZwCommitTransaction for the transaction, KTM rolls back the transaction. For more information about how transaction clients should use ZwCreateTransaction, see Creating a Transactional Client. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateTransaction",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "TransactionHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to the new transaction object, if the call to ZwCreateTransaction succeeds."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the transaction object. In addition to the access rights that are defined for all kinds of objects (see ACCESS_MASK), the caller can specify any of the following flags for transaction objects.  Access maskAllows the caller to  TRANSACTION_COMMIT  Commit the transaction (see ZwCommitTransaction).   TRANSACTION_ENLIST  Create an enlistment for the transaction (see ZwCreateEnlistment).   TRANSACTION_PROPAGATE  Do not use.    TRANSACTION_QUERY_INFORMATION  Obtain information about the transaction (see ZwQueryInformationTransaction).   TRANSACTION_ROLLBACK  Roll back the transaction (see ZwRollbackTransaction).   TRANSACTION_SET_INFORMATION  Set information for the transaction (see ZwSetInformationTransaction).     Alternatively, you can specify one or more of the following ACCESS_MASK bitmaps. These bitmaps combine the flags from the previous table with the STANDARD_RIGHTS_XXX flags that are described on the ACCESS_MASK reference page. You can also combine these bitmaps with additional flags from the preceding table. The following table shows how the bitmaps correspond to specific access rights.  Rights bitmapSet of specific access rights  TRANSACTION_GENERIC_READ  STANDARD_RIGHTS_READ, TRANSACTION_QUERY_INFORMATION, and SYNCHRONIZE   TRANSACTION_GENERIC_WRITE  STANDARD_RIGHTS_WRITE, TRANSACTION_SET_INFORMATION, TRANSACTION_COMMIT, TRANSACTION_ENLIST, TRANSACTION_ROLLBACK, TRANSACTION_PROPAGATE, TRANSACTION_SAVEPOINT, and SYNCHRONIZE   TRANSACTION_GENERIC_EXECUTE  STANDARD_RIGHTS_EXECUTE, TRANSACTION_COMMIT, TRANSACTION_ROLLBACK, and SYNCHRONIZE   TRANSACTION_ALL_ACCESS  STANDARD_RIGHTS_REQUIRED, TRANSACTION_GENERIC_READ, TRANSACTION_GENERIC_WRITE, and TRANSACTION_GENERIC_EXECUTE   TRANSACTION_RESOURCE_MANAGER_RIGHTS  STANDARD_RIGHTS_WRITE, TRANSACTION_GENERIC_READ, TRANSACTION_SET_INFORMATION, TRANSACTION_ENLIST, TRANSACTION_ROLLBACK, TRANSACTION_PROPAGATE, and SYNCHRONIZE     Typically, a resource manager specifies TRANSACTION_RESOURCE_MANAGER_RIGHTS. The DesiredAccess value cannot be zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use the InitializeObjectAttributes routine to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes. This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPGUID",
        "name": "Uow",
        "description": "A pointer to a GUID that KTM uses as the new transaction object's unit of work (UOW) identifier. This parameter is optional and can be NULL. If this parameter is NULL, KTM generates a GUID and assigns it to the transaction object. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "TmHandle",
        "description": "A handle to a transaction manager object that was obtained by a previous call to ZwCreateTransactionManager or ZwOpenTransactionManager. KTM assigns the new transaction object to the specified transaction manager object. If this parameter is NULL, KTM assigns the new transaction object to a transaction manager later, when a resource manager creates an enlistment for the transaction."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "CreateOptions",
        "description": "Optional object creation flags. The following table contains the available flags, which are defined in Ktmtypes.h.  Option flagMeaning  TRANSACTION_DO_NOT_PROMOTE  Reserved for future use."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "IsolationLevel",
        "description": "Reserved for future use. Callers must set this parameter to zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "IsolationFlags",
        "description": "Reserved for future use. Callers should set this parameter to zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "A pointer to a time-out value. If the transaction has not been committed by the time specified by this parameter, KTM rolls back the transaction. The time-out value is expressed in system time units (100-nanosecond intervals), and can specify either an absolute time or a relative time. If the value pointed to by Timeout is negative, the expiration time is relative to the current system time. Otherwise, the expiration time is absolute. This pointer is optional and can be NULL if you do not want the transaction to have a time-out value. If Timeout = NULL or *Timeout = 0, the transaction never times out. (You can also use ZwSetInformationTransaction to set a time-out value.)"
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "Description",
        "description": "A pointer to a caller-supplied UNICODE_STRING structure that contains a NULL-terminated string. The string provides a description of the transaction. KTM stores a copy of the string and includes the string in messages that it writes to the log stream. The maximum string length is MAX_TRANSACTION_DESCRIPTION_LENGTH. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwCreateTransactionManager routine creates a new transaction manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwCreateTransactionManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "If the log file stream that the LogFileName parameter specifies does not exist, KTM calls CLFS to create the stream. If the stream already exists, KTM calls CLFS to open the stream. Your TPS component must call ZwRecoverTransactionManager after it has called ZwCreateTransactionManager If your TPS component specifies the TRANSACTION_MANAGER_VOLATILE flag in the CreateOptions parameter, all resource managers that are associated with the transaction manager object must specify the RESOURCE_MANAGER_VOLATILE flag when they call ZwCreateResourceManager. A TPS component that calls ZwCreateTransactionManager must eventually call ZwClose to close the object handle. For more information about how use ZwCreateTransactionManager, see Creating a Resource Manager. NtCreateTransactionManager and ZwCreateTransactionManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwCreateTransactionManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "TmHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to the new transaction manager object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the transaction manager object. In addition to the access rights that are defined for all kinds of objects (see ACCESS_MASK), the caller can specify any of the following access right flags for transaction manager objects.   ACCESS_MASK flagAllows the caller to  TRANSACTIONMANAGER_CREATE_RM  Create a resource manager (see ZwCreateResourceManager).   TRANSACTIONMANAGER_QUERY_INFORMATION  Obtain information about the transaction manager (see ZwQueryInformationTransactionManager and ZwEnumerateTransactionObject). Also required for ZwOpenResourceManager, ZwCreateTransaction, and ZwOpenTransaction.)    TRANSACTIONMANAGER_RECOVER  Recover the transaction manager (see ZwRecoverTransactionManager and ZwRollforwardTransactionManager).   TRANSACTIONMANAGER_RENAME  Not used.   TRANSACTIONMANAGER_SET_INFORMATION  Not used.     Alternatively, you can specify one or more of the following ACCESS_MASK bitmaps. These bitmaps combine the flags from the previous table with the STANDARD_RIGHTS_XXX flags that are described on the ACCESS_MASK reference page. You can also combine these bitmaps with additional flags from the preceding table. The following table shows how the bitmaps correspond to specific access rights.  Rights bitmapSet of specific access rights  TRANSACTIONMANAGER_GENERIC_READ  STANDARD_RIGHTS_READ and TRANSACTIONMANAGER_QUERY_INFORMATION   TRANSACTIONMANAGER_GENERIC_WRITE  STANDARD_RIGHTS_WRITE, TRANSACTIONMANAGER_SET_INFORMATION, TRANSACTIONMANAGER_RECOVER, TRANSACTIONMANAGER_RENAME, and TRANSACTIONMANAGER_CREATE_RM   TRANSACTIONMANAGER_GENERIC_EXECUTE  STANDARD_RIGHTS_EXECUTE   TRANSACTIONMANAGER_ALL_ACCESS  STANDARD_RIGHTS_REQUIRED, TRANSACTIONMANAGER_GENERIC_READ, TRANSACTIONMANAGER_GENERIC_WRITE, and TRANSACTIONMANAGER_GENERIC_EXECUTE"
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use the InitializeObjectAttributes routine to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes. This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "LogFileName",
        "description": "A pointer to a UNICODE_STRING structure that contains the path and file name of a CLFS log file stream to be associated with the transaction manager object. This parameter must be NULL if the CreateOptions parameter is TRANSACTION_MANAGER_VOLATILE. Otherwise, this parameter must be non-NULL. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "CreateOptions",
        "description": "Optional object creation flags. The following table contains the available flags, which are defined in Ktmtypes.h.  Option flagMeaning  TRANSACTION_MANAGER_VOLATILE  The transaction manager object will be volatile. Therefore, it will not use a log file.   TRANSACTION_MANAGER_COMMIT_DEFAULT  For internal use only.   TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME  For internal use only.   TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES  For internal use only.   TRANSACTION_MANAGER_COMMIT_LOWEST  For internal use only.   TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY  For internal use only.   TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS  For internal use only."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "CommitStrength",
        "description": "Reserved for future use. This parameter must be zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwDeleteFile routine deletes the specified file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwDeleteFile returns STATUS_SUCCESS or an appropriate error status representing the final completion status of the operation. Possible error status codes include the following:  ",
    "remarks": "ZwDeleteFile deletes the specified file object. The ZwDeleteFile function is called after the InitializeAttributes macro is used to set attributes in the OBJECT_ATTRIBUTES structure for the file object to be deleted. There are two alternate ways to specify the name of the file to be deleted with ZwDeleteFile: Callers of ZwDeleteFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwDeleteFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that contains the attributes supplied by the caller to be used for the file object. These attributes would include the ObjectName and the SECURITY_DESCRIPTOR, for example. This parameter is initialized by calling the InitializeObjectAttributes macro."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwDeleteValueKey routine deletes a value entry matching a name from an open key in the registry. If no such entry exists, an error is returned.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, Ntifs.h, or Fltkernel.h)",
    "return_value": "ZwDeleteValueKey returns STATUS_SUCCESS or an appropriate error status representing the final completion status of the operation. Possible error status codes include the following:  ",
    "remarks": "The KeyHandle passed to ZwDeleteValueKey must have been opened for delete access to succeed. The DesiredAccess values of KEY_SET_VALUE, KEY_WRITE, and KEY_ALL_ACCESS include the KEY_SET_VALUE access mask required for delete access. For a description of possible values for DesiredAccess, see ZwCreateKey. If callback functions are registered for this registry key, then these callback functions will be called. Device drivers should not attempt to call ZwDeleteValueKey directly to delete value entries in a subkey of the \\Registry..\\ResourceMap key. Only the system can write or delete value entries in the \\Registry..\\HardwareDescription tree. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwDeleteValueKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "The handle to the registry key containing the value entry of interest. This key must have been opened with KEY_SET_VALUE set for the desired access. This handle is created by a successful call to ZwCreateKey or ZwOpenKey."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ValueName",
        "description": "Pointer to a UNICODE_STRING structure that contains the name of the value entry to delete. This parameter can be an empty string if the value entry has no name."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The ZwDeviceIoControlFile routine sends a control code directly to a specified device driver, causing the corresponding driver to perform the specified operation.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwDeviceIoControlFile returns STATUS_SUCCESS if the underlying driver(s) successfully carried out the requested operation. Otherwise, the return value can be an error status code propagated from an underlying driver. Possible error status codes include the following: ",
    "remarks": "ZwDeviceIoControlFile provides a consistent view of the input and output data to the system and to kernel-mode drivers, while providing applications and underlying drivers with a device-dependent method of specifying a communications interface. For more information about system-defined IOCTL_XXX codes, and about defining driver-specific IOCTL_XXX or FSCTL_XXX values, see Using I/O Control Codes in the Kernel Mode Architecture Guide and Device Input and Output Control Codes in the Microsoft Windows SDK documentation. If the caller opened the file for asynchronous I/O (with neither FILE_SYNCHRONOUS_XXX create/open option set), the specified event, if any, will be set to the signaled state when the device control operation completes. Otherwise, the file object specified by FileHandle will be set to the signaled state. If an ApcRoutine was specified, it is called with the ApcContext and IoStatusBlock pointers. Minifilters should use FltDeviceIoControlFile instead of ZwDeviceIoControlFile. Callers of ZwDeviceIoControlFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwDeviceIoControlFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle returned by ZwCreateFile or ZwOpenFile for the file object representing the device to which the control information should be given or from which information should be returned. The file object must have been opened for asynchronous I/O if the caller specifies an Event, ApcRoutine, and an APC context (in ApcContext), or a completion context (in ApcContext). For I/O to an underlying mass-storage device, the file object must have been opened for Direct Access to Storage Device (DASD) access."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "Handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the Signaled state. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the FileHandle to be set to the Signaled state."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "Address of an optional, caller-supplied APC routine to be called when the requested operation completes. This parameter can be NULL. It must be NULL if there is an I/O completion object associated with the file object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object. When the operation completes, either the APC context is passed to the APC, if one was specified, or the completion context is included as part of the completion message that the I/O Manager posts to the associated I/O completion object. This parameter is optional and can be NULL. It must be NULL if ApcRoutine is NULL and there is no I/O completion object associated with the file object."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to a variable that receives the final completion status and information about the operation. For successful calls that return data, the number of bytes written to the OutputBuffer is returned in the Information member."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "IoControlCode",
        "description": "IOCTL_XXX code that indicates which device I/O control operation is to be carried out on, usually by the underlying device driver. The value of this parameter determines the format and required length of the InputBuffer and OutputBuffer, as well as which of the following parameter pairs are required. For detailed information about the system-defined, device-type-specific IOCTL_XXX codes, see the device technology-specific section of the Microsoft Windows Driver Kit (WDK) documentation and Device Input and Output Control Codes in the Microsoft Windows SDK documentation."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "InputBuffer",
        "description": "Pointer to a caller-allocated input buffer that contains device-specific information to be given to the target device. If IoControlCode specifies an operation that does not require input data, this pointer can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InputBufferLength",
        "description": "Size, in bytes, of the buffer at InputBuffer. If InputBuffer is NULL, set InputBufferLength to zero."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutputBuffer",
        "description": "Pointer to a caller-allocated output buffer in which information is returned from the target device. If IoControlCode specifies an operation that does not produce output data, this pointer can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "OutputBufferLength",
        "description": "Size, in bytes, of the buffer at OutputBuffer. If OutputBuffer is NULL, set OutputBufferLength to zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ZwDuplicateObject routine creates a handle that is a duplicate of the specified source handle.",
    "library": "Ntoskrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntdef.h, Ntifs.h, or Fltkernel.h)",
    "return_value": "ZwDuplicateObject returns STATUS_SUCCESS if the call is successful. Otherwise, it returns an appropriate error status code. ",
    "remarks": "The source handle is evaluated in the context of the specified source process. The calling process must have PROCESS_DUP_HANDLE access to the source process. The duplicate handle is created in the handle table of the specified target process. The calling process must have PROCESS_DUP_HANDLE access to the target process. By default, the duplicate handle is created with the attributes specified by the HandleAttributes parameter, and with the access rights specified by the DesiredAccess parameter. If necessary, the caller can override one or both defaults by setting the DUPLICATE_SAME_ATTRIBUTES and DUPLICATE_SAME_ACCESS flags in the Options parameter. If the call to this function occurs in user mode, you should use the name \"NtDuplicateObject\" instead of \"ZwDuplicateObject\". For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwDuplicateObject",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "SourceProcessHandle",
        "description": "A handle to the source process for the handle being duplicated."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "SourceHandle",
        "description": "The handle to duplicate."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "TargetProcessHandle",
        "description": "A handle to the target process that is to receive the new handle. This parameter is optional and can be specified as NULL if the DUPLICATE_CLOSE_SOURCE flag is set in Options."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PHANDLE",
        "name": "TargetHandle",
        "description": "A pointer to a HANDLE variable into which the routine writes the new duplicated handle. The duplicated handle is valid in the specified target process. This parameter is optional and can be specified as NULL if no duplicate handle is to be created."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the desired access for the new handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "HandleAttributes",
        "description": "A ULONG that specifies the desired attributes for the new handle. For more information about attributes, see the description of the Attributes member in OBJECT_ATTRIBUTES."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Options",
        "description": "A set of flags to control the behavior of the duplication operation. Set this parameter to zero or to the bitwise OR of one or more of the following flags.  Flag nameDescription DUPLICATE_SAME_ATTRIBUTESInstead of using the HandleAttributes parameter, copy the attributes from the source handle to the target handle. DUPLICATE_SAME_ACCESSInstead of using the DesiredAccess parameter, copy the access rights from the source handle to the target handle. DUPLICATE_CLOSE_SOURCEClose the source handle."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwDuplicateToken function creates a handle to a new access token that duplicates an existing token. This function can create either a primary token or an impersonation token.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "ZwDuplicateToken returns STATUS_SUCCESS if the call is successfull. Possible error return codes include the following:  ",
    "remarks": "If no impersonation level information was provided by the ObjectAttributes parameter, the existing token's impersonation level will be used for the new token. With regard to the structure pointed to by the optional ObjectAttributes parameter, the SecurityQualityOfService member of OBJECT_ATTRIBUTES points to a structure of type SECURITY_QUALITY_OF_SERVICE. See SECURITY_QUALITY_OF_SERVICE in the Microsoft Windows SDK documentation for information on the members of this structure. For information on the user-mode analog of ZwDuplicateToken, see DuplicateTokenEx in the Windows SDK documentation. When you have finished using the new token, call the ZwClose function to close the token handle. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwDuplicateToken",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ExistingTokenHandle",
        "description": "A handle to an existing access token that was opened with the TOKEN_DUPLICATE access right. This parameter is required and cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Bitmask that specifies the requested access rights for the new token. ZwDuplicateToken compares the requested access rights with the existing token's discretionary access control list (DACL) to determine which rights are granted or denied to the new token. To request the same access rights as the existing token, specify zero. To request all access rights that are valid for the caller, specify MAXIMUM_ALLOWED. This parameter is optional and can either be zero, MAXIMUM_ALLOWED, or a bitwise OR combination of one or more of the following values:  ValueMeaning  DELETE  Required to delete the object.   READ_CONTROL  Required to read the DACL and ownership information for the object. For access to the system access control list (SACL), see ACCESS_SYSTEM_SECURITY later in this table.   WRITE_DAC  Required to change the DACL information for the object.   WRITE_OWNER  Required to change the ownership information in the object's security descriptor (SECURITY_DESCRIPTOR).   ACCESS_SYSTEM_SECURITY  Required to get or set the SACL in an object's ACL. The operating system grants this right to the new token only if the SE_SECURITY_NAME privilege is enabled in the access token of the calling thread.   STANDARD_RIGHTS_READ  Currently defined to equal READ_CONTROL.   STANDARD_RIGHTS_WRITE  Currently defined to equal READ_CONTROL.   STANDARD_RIGHTS_EXECUTE  Currently defined to equal READ_CONTROL.   STANDARD_RIGHTS_REQUIRED  Combines DELETE, READ_CONTROL, WRITE_DAC, and WRITE_OWNER access.   STANDARD_RIGHTS_ALL  Combines DELETE, READ_CONTROL, WRITE_DAC, WRITE_OWNER, and SYNCHRONIZE access. However, the SYNCHRONIZE value is not applicable to token objects. Thus, STANDARD_RIGHTS_ALL has a  functionally equivalent to STANDARD_RIGHTS_REQUIRED.   TOKEN_ADJUST_DEFAULT  Required to change the default owner, primary group, or DACL of an access token.   TOKEN_ADJUST_GROUPS  Required to adjust the attributes of the groups in an access token.   TOKEN_ADJUST_PRIVILEGES  Required to enable or disable the privileges in an access token.   TOKEN_ADJUST_SESSIONID  Required to adjust the session ID (SID) of an access token. The operating system grants this right to the new token only if the SE_TCB_NAME privilege is enabled in the access token of the calling thread.   TOKEN_ASSIGN_PRIMARY  Required to attach a primary token to a process. The operating system grants this right to the new token only if the SE_ASSIGNPRIMARYTOKEN_NAME privilege is enabled in the access token of the calling thread.   TOKEN_DUPLICATE  Required to duplicate an access token. Note that the given ExistingTokenHandle token must contain this right in order to successfully use this routine.   TOKEN_EXECUTE  Combines STANDARD_RIGHTS_EXECUTE and TOKEN_IMPERSONATE.   TOKEN_IMPERSONATE  Required to attach an impersonation access token to a process.   TOKEN_QUERY  Required to query an access token.   TOKEN_QUERY_SOURCE  Required to query the source of an access token.   TOKEN_READ  Combines STANDARD_RIGHTS_READ and TOKEN_QUERY.   TOKEN_WRITE  Combines STANDARD_RIGHTS_WRITE, TOKEN_ADJUST_PRIVILEGES, TOKEN_ADJUST_GROUPS, and TOKEN_ADJUST_DEFAULT.   TOKEN_ALL_ACCESS  Combines all possible token access permissions for a token.     For additional information, see Access Rights for Access-Token Objects in the Microsoft Windows SDK. Note that access tokens do not support the SYNCHRONIZE right."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that describes the requested properties for the new token. The ObjectAttributes parameter is optional and can be NULL. If the ObjectAttributes parameter is NULL or if the SecurityDescriptor member of the structure pointed to by the ObjectAttributes parameter is NULL, the new token receives a default security descriptor and the new token handle cannot be inherited. In that case, this default security descriptor is created from the user group, primary group, and DACL information that is stored in the caller's token. When the TokenType parameter is set to TokenImpersonation:   The ObjectAttributes parameter may be used to specify the impersonation level of the new token. This can be accomplished by setting ObjectAttributes->SecurityQualityOfService.ImpersonationLevel to an appropriate SECURITY_IMPERSONATION_LEVEL enumeration value. For more information, see SECURITY_QUALITY_OF_SERVICE in the Microsoft Windows SDK documentation.   If the existing token is an impersonation token and the ObjectAttributes parameter provides no impersonation information, the new token's impersonation level is set to the existing token's impersonation level.   If the existing token is a primary token and no impersonation level information is provided, the new impersonation token will have a SECURITY_IMPERSONATION_LEVEL impersonation level."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "EffectiveOnly",
        "description": "A Boolean value that indicates whether the entire existing token should be duplicated into the new token or just the effective (currently enabled) part of the token. If set to TRUE, only the currently enabled parts of the source token will be duplicated. If set to FALSE, the entire existing token will be duplicated. This provides a means for a caller of a protected subsystem to limit which optional groups and privileges are made available to the protected subsystem. For example, if EffectiveOnly is TRUE, the caller could duplicate a token but remove the Administrators group and the SeTcbPrivilege right. The resulting token could then be passed to a child process (CreateProcessAsUser), which would restrict what the child process can do. This parameter is required."
      },
      {
        "in_out": "_In_",
        "type": "TOKEN_TYPE",
        "name": "TokenType",
        "description": "Specifies one of the following values from the TOKEN_TYPE enumeration.  ValueMeaning  TokenPrimary  The new token is a primary token. If the existing token is an impersonation token, the existing impersonation token must have an impersonation level (as provided by the ObjectAttributes parameter) of SecurityImpersonation or SecurityDelegation. Otherwise, ZwDuplicateToken returns STATUS_BAD_IMPERSONATION_LEVEL is returned.   TokenImpersonation  The new token is an impersonation token. If the existing token is an impersonation token, the requested impersonation level (as provided by the ObjectAttributes parameter) of the new token must not be greater than the impersonation level of the existing token. Otherwise, ZwDuplicateToken returns STATUS_BAD_IMPERSONATION_LEVEL.     The TokenType parameter is required and cannot be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "NewTokenHandle",
        "description": "A pointer to a caller-allocated variable, of type HANDLE, that receives a handle to the new token. This parameter is required and cannot be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwEnumerateTransactionObject routine enumerates the KTM objects on a computer.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwEnumerateTransactionObject returns STATUS_SUCCESS if the operation succeeds but the routine has not enumerated all the objects. If there are no more objects to enumerate, the routine returns STATUS_NO_MORE_ENTRIES. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "The following table contains the valid values for the RootObjectHandle and QueryType parameters.  Most TPS components do not have to call ZwEnumerateTransactionObject, but the routine might be useful if you have to write a debugging utility. Before your component calls ZwEnumerateTransactionObject, it must allocate and zero the buffer that ObjectCursor points to. The buffer's GUID array can be large enough to receive one or more elements. To enumerate all of the KTM objects of the specified type, your component must call ZwEnumerateTransactionObject repeatedly until it returns STATUS_NO_MORE_ENTRIES. Every time that the routine is called, it fills the buffer's GUID array with as many object GUIDs that will fit. After each call, your component can use the KTMOBJECT_CURSOR structure's ObjectIdCount member to determine the number of object GUIDs that the routine stored in the array. NtEnumerateTransactionObject and ZwEnumerateTransactionObject are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. The following code example shows how to enumerate all of the transaction objects on a computer. In this example, the KTMOBJECT_CURSOR structure's GUID array contains only one element, so each call to ZwEnumerateTransactionObject returns one GUID. The routine creates a Unicode string from the GUID and displays the string. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwEnumerateTransactionObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "RootObjectHandle",
        "description": "A handle to a KTM object. The routine enumerates the child objects of the specified object. This parameter is optional and can be NULL. For more information about valid values for this parameter, see the table in the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "KTMOBJECT_TYPE",
        "name": "QueryType",
        "description": "A KTMOBJECT_TYPE-typed value that identifies the object type to enumerate. For more information about valid values for this parameter, see the table in the following Remarks section."
      },
      {
        "in_out": "_Inout_",
        "type": "PKTMOBJECT_CURSOR",
        "name": "ObjectCursor",
        "description": "A pointer to a caller-allocated buffer that begins with a KTMOBJECT_CURSOR structure. ZwEnumerateTransactionObject uses the buffer to store the GUIDs of objects that it finds."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ObjectCursorLength",
        "description": "The length, in bytes, of the buffer that ObjectCursor points to."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a caller-allocated location that receives the number of bytes that ZwEnumerateTransactionObject returns in the ObjectCursor buffer, including the length of the KTMOBJECT_CURSOR structure and the length of all returned GUIDs."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwFlushBuffersFile routine is called by a file system filter driver to send a flush request for the specified file to the file system.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwFlushBuffersFile returns STATUS_SUCCESS or an appropriate NTSTATUS value, such as one of the following:  ",
    "remarks": "A file system filter driver can call ZwFlushBuffersFile to issue an IRP_MJ_FLUSH_BUFFERS request to the file system for a given file. The flush operation is synchronous. Minifilter drivers should call FltFlushBuffers instead of calling ZwFlushBuffersFile. Callers of ZwFlushBuffersFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwFlushBuffersFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle returned by ZwCreateFile or ZwOpenFile for the file whose buffers will be flushed. This parameter is required and cannot be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Address of the caller's I/O status block. This parameter is required and cannot be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwFlushBuffersFileEx routine is called by a file system filter driver to send a flush request for a given file to the file system. An optional flush operation flag can be set to control how file data is written to storage.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwFlushBuffersFileEx returns STATUS_SUCCESS or an appropriate NTSTATUS value, such as one of the following:  ",
    "remarks": "A file system filter driver can call ZwFlushBuffersFileEx to issue an IRP_MJ_FLUSH_BUFFERS request to the file system for a given file. The flush operation is synchronous. Minifilter drivers should call FltFlushBuffers instead of calling ZwFlushBuffersFileEx. Callers of ZwFlushBuffersFileEx must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwFlushBuffersFileEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle returned by ZwCreateFile or ZwOpenFile for the file whose buffers will be flushed. This parameter is required and cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Flush operation flags. Flags can be 0 or one of the following values.  ValueMeaning  FLUSH_FLAGS_FILE_DATA_ONLY   If the file is on an NTFS file system, file data in the file cache will be written. No metadata is written and the underlying storage is not synchronized to flush its cache. This flag is not valid with volume handles.   FLUSH_FLAGS_NO_SYNC   If the file is on an NTFS file system, file data and metadata in the file cache will be written. The underlying storage is not synchronized to flush its cache. This flag is not valid with volume handles."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Address of the caller's I/O status block. This parameter is required and cannot be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwFlushVirtualMemory routine flushes a range of virtual addresses within the virtual address space of a specified process which map to a data file back out to the data file if they have been modified.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwFlushVirtualMemory returns either STATUS_SUCCESS or an error status code. Possible error status codes include the following:  ",
    "remarks": "This routine accepts, as input parameters, a range of addresses in virtual memory that map a data file. If any memory in this range has been modified since the file was copied to memory, the routine flushes this memory back to the data file. For more information about memory management support for kernel-mode drivers, see Memory Management for Windows Drivers. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwFlushVirtualMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "An open handle for the process in whose context the pages to be flushed reside. Use the NtCurrentProcess macro, defined in Ntddk.h, to specify the current process."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID*",
        "name": "BaseAddress",
        "description": "A pointer to the base address of the virtual address range. On entry, this parameter specifies a pointer to the initial value of the base address of the region of pages to flush. On return, this parameter provides a pointer to a variable that will receive the base address of the flushed region."
      },
      {
        "in_out": "_Inout_",
        "type": "PSIZE_T",
        "name": "RegionSize",
        "description": "The size, in bytes, of the virtual address range. On entry, this parameter specifies a pointer to the initial value of the size in bytes of the region of pages to flush to disk. This argument is rounded up to the next host-page-size boundary by the ZwFlushVirtualMemory. If this value is specified as zero, the mapped range from the base address to the end of the range is flushed. On return, this parameter specifies a pointer to a variable that will receive the actual size in bytes of the flushed region of pages."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatus",
        "description": "A pointer to an IO_STATUS_BLOCK structure. This structure is where the value of the I/O status for the last attempted I/O operation is stored on output."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwFreeVirtualMemory routine releases, decommits, or both, a region of pages within the virtual address space of a specified process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or Fltkernel.h)",
    "return_value": "ZwFreeVirtualMemory returns either STATUS_SUCCESS or an error status code. Possible error status codes include the following.  ",
    "remarks": "Each page in the process's virtual address space is in one of the three states described in the following table.  ZwFreeVirtualMemory can perform the following operations: ZwFreeVirtualMemory can decommit a range of pages that are in different states, some committed and some uncommitted. This means that you can decommit a range of pages without first determining the current commitment state of each page. Decommitting a page releases its physical storage, either in memory or in the paging file on disk. If a page is decommitted but not released, its state changes to reserved. You can subsequently call ZwAllocateVirtualMemory to commit it, or ZwFreeVirtualMemory to release it. Attempting to read from or write to a reserved page results in an access violation exception. ZwFreeVirtualMemory can release a range of pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state of each page. The entire range of pages originally reserved by ZwAllocateVirtualMemory must be released at the same time. If a page is released, its state changes to free, and it is available for subsequent allocation operations. After memory has been released or decommitted, you can never refer to the memory again. Any information that may have been in that memory is gone forever. Attempting to read from or write to a free page results in an access violation exception. If you require information, do not decommit or free memory that contains that information. For more information about memory management support for kernel-mode drivers, see Memory Management for Windows Drivers. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwFreeVirtualMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle for the process in whose context the pages to be freed reside. Use the NtCurrentProcess macro, defined in Ntddk.h, to specify the current process."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID*",
        "name": "BaseAddress",
        "description": "A pointer to a variable that will receive the virtual address of the freed region of pages.  If the MEM_RELEASE flag is set in the FreeType parameter, BaseAddress must be the base address returned by ZwAllocateVirtualMemory when the region was reserved."
      },
      {
        "in_out": "_Inout_",
        "type": "PSIZE_T",
        "name": "RegionSize",
        "description": "A pointer to a variable that will receive the actual size, in bytes, of the freed region of pages. The routine rounds the initial value of this variable up to the next host page size boundary and writes the rounded value back to this variable. If the MEM_RELEASE flag is set in the FreeType parameter, the variable pointed to by RegionSize must be zero. ZwFreeVirtualMemory frees the entire region that was reserved in the initial allocation call to ZwAllocateVirtualMemory. If the MEM_DECOMMIT flag is set in the FreeType parameter, ZwFreeVirtualMemory decommits all memory pages that contain one or more bytes in the range from the BaseAddress parameter to (BaseAddress + *RegionSize). This means, for example, that if a two-byte region of memory straddles a page boundary, both pages are decommitted. ZwFreeVirtualMemory decommits the entire region that was reserved by ZwAllocateVirtualMemory. If the following three conditions are met, the entire region enters the reserved state:   The MEM_DECOMMIT flag is set.   BaseAddress is the base address returned by ZwAllocateVirtualMemory when the region was reserved.             *RegionSize is zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "FreeType",
        "description": "A bitmask that contains flags that describe the type of free operation that ZwFreeVirtualMemory will perform for the specified region of pages. The possible values are listed in the following table.  FreeType flagsDescription  MEM_DECOMMIT  ZwFreeVirtualMemory will decommit the specified region of pages. The pages enter the reserved state. ZwFreeVirtualMemory does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining their current commitment state.   MEM_RELEASE  ZwFreeVirtualMemory will release the specified region of pages. The pages enter the free state. If you specify this flag, *RegionSize must be zero, and BaseAddress must point to the base address returned by ZwAllocateVirtualMemory when the region was reserved. ZwFreeVirtualMemory fails if either of these conditions is not met. If any pages in the region are currently committed, ZwFreeVirtualMemory first decommits and then releases them. ZwFreeVirtualMemory does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining their current commitment state."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The ZwFsControlFile routine sends a control code directly to a specified file system or file system filter driver, causing the corresponding driver to perform the specified action.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwFsControlFile returns STATUS_SUCCESS or an appropriate NTSTATUS value such as one of the following: ",
    "remarks": "ZwFsControlFile provides a consistent view of the input and output data to the system and to kernel-mode drivers, while providing applications and underlying drivers with a driver-dependent method of specifying a communications interface. If the caller opened the file for asynchronous I/O (with neither FILE_SYNCHRONOUS_XXX create/open option set), the specified event, if any, will be set to the signaled state when the device control operation completes. Otherwise, the file object specified by FileHandle will be set to the signaled state. If an ApcRoutine was specified, it is called with the ApcContext and IoStatusBlock pointers. The following FSCTL codes are currently documented for kernel-mode drivers: For more information about system-defined FSCTL_XXX codes, see the \"Remarks\" section of the reference entry for DeviceIoControl in the Microsoft Windows SDK documentation. For more information about system-defined IOCTL_XXX codes, and about defining driver-specific IOCTL_XXX or FSCTL_XXX values, see Using I/O Control Codes in the Kernel Mode Architecture Guide and Device Input and Output Control Codes in the Windows SDK documentation. Minifilters should use FltFsControlFile instead of ZwFsControlFile. Callers of ZwFsControlFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwFsControlFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle returned by ZwCreateFile or ZwOpenFile for the file object representing the file or directory on which the specified action is to be performed. The file object must have been opened for asynchronous I/O if the caller specifies an Event, ApcRoutine, and an APC context (in ApcContext), or a completion context (in ApcContext)."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "Handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the Signaled state. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the FileHandle to be set to the Signaled state."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "Address of a caller-supplied APC routine to be called when the requested operation completes. This parameter is optional and can be NULL. It must be NULL if there is an I/O completion object associated with the file object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object. When the operation completes, either the APC context is passed to the APC, if one was specified, or the completion context is included as part of the completion message that the I/O Manager posts to the associated I/O completion object. This parameter is optional and can be NULL. It must be NULL if ApcRoutine is NULL and there is no I/O completion object associated with the file object."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the operation. For successful calls that return data, the number of bytes written to the OutputBuffer is returned in the Information member of this structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "FsControlCode",
        "description": "FSCTL_XXX code that indicates which file system control operation is to be carried out. The value of this parameter determines the formats and required lengths of the InputBuffer and OutputBuffer, as well as which of the following parameter pairs are required. For detailed information about the system-defined FSCTL_XXX codes, see the \"Remarks\" section of the reference entry for DeviceIoControl in the Microsoft Windows SDK documentation."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "InputBuffer",
        "description": "Pointer to a caller-allocated input buffer that contains device-specific information to be given to the target driver. If FsControlCode specifies an operation that does not require input data, this pointer is optional and can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InputBufferLength",
        "description": "Size, in bytes, of the buffer at InputBuffer. This value is ignored if InputBuffer is NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutputBuffer",
        "description": "Pointer to a caller-allocated output buffer in which information is returned from the target driver. If FsControlCode specifies an operation that does not produce output data, this pointer is optional and can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "OutputBufferLength",
        "description": "Size, in bytes, of the buffer at OutputBuffer. This value is ignored if OutputBuffer is NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The ZwGetNotificationResourceManager routine retrieves the next transaction notification from a specified resource manager's notification queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwGetNotificationResourceManager returns STATUS_SUCCESS if the operation succeeds and a notification is available. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Use the ZwGetNotificationResourceManager routine to obtain notifications synchronously. Use the TmEnableCallbacks routine to enable asynchronous notifications. The received TRANSACTION_NOTIFICATION structure contains the enlistment key that the resource manager specified when it called ZwCreateEnlistment. You can use the enlistment key to identify the enlistment that the notification applies to. For more information about the ZwGetNotificationResourceManager routine, see Creating a Resource Manager. NtGetNotificationResourceManager and ZwGetNotificationResourceManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwGetNotificationResourceManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ResourceManagerHandle",
        "description": "A handle to a resource manager object that was obtained by a previous call to ZwCreateResourceManager or ZwOpenResourceManager. The handle must have RESOURCEMANAGER_GET_NOTIFICATION access to the object."
      },
      {
        "in_out": "_Out_",
        "type": "PTRANSACTION_NOTIFICATION",
        "name": "TransactionNotification",
        "description": "A pointer to a caller-allocated buffer that receives information about the retrieved notification. The buffer must be large enough to contain a TRANSACTION_NOTIFICATION structure plus additional notification-specific arguments."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NotificationLength",
        "description": "The length, in bytes, of the buffer that the TransactionNotification parameter points to."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "A pointer to a value that specifies a relative or absolute time, in units of 100 nanoseconds. This pointer is optional and can be NULL. If the pointer is NULL, ZwGetNotificationResourceManager does not return until a transaction notification is available. If a time value is specified, ZwGetNotificationResourceManager returns when a notification is available or after the specified time elapses, whichever comes first. A negative value specifies a time that is relative to the current system time. For example, a relative time value of five seconds causes ZwGetNotificationResourceManager to time out five seconds after it is called.  A positive value specifies an absolute time, which is actually relative to 00:00, January 1, 1601. If an absolute time value is specified, the operating system adds the absolute time value to the time value that represents 00:00, January 1, 1601. If the caller specifies a zero value (instead of a NULL pointer), ZwGetNotificationResourceManager returns immediately, whether a notification is available or not."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "An optional pointer to a variable. If this pointer is not NULL, and if the NotificationLength parameter's value is too small, ZwGetNotificationResourceManager supplies the required length in the variable and returns STATUS_BUFFER_TOO_SMALL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Asynchronous",
        "description": "A ULONG value that must be zero. ZwGetNotificationResourceManager does not support asynchronous notifications. Use TmEnableCallbacks to enable asynchronous notifications."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG_PTR",
        "name": "AsynchronousContext",
        "description": "A pointer to a ULONG value. This pointer must be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwLoadDriver routine loads a driver into the system.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwLoadDriver returns STATUS_SUCCESS or an appropriate error NTSTATUS value. ",
    "remarks": "ZwLoadDriver dynamically loads a device or file system driver into the currently running system. A minifilter should use FltLoadFilter instead of ZwLoadDriver to load a supporting minifilter. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwLoadDriver",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "DriverServiceName",
        "description": "Pointer to a counted Unicode string that specifies a path to the driver's registry key, \\Registry\\Machine\\System\\CurrentControlSet\\Services\\DriverName, where DriverName is the name of the driver."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The ZwLockFile routine requests a byte-range lock for the specified file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "The ZwLockFile routine returns STATUS_SUCCESS or an appropriate error NTSTATUS value. Possible NTSTATUS values include the following:  ",
    "remarks": "Callers of ZwLockFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwLockFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle for the file on which a byte-range lock is requested."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "A handle to a caller-created event. If not NULL, the caller is placed into a wait state until the operation succeeds, at which time the event is set into the Signaled state."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "A pointer to a caller-supplied APC routine that is executed after the operation completes. Can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "A pointer to a caller-specified context for the APC routine. This value is passed to the APC routine when it is executed. Can be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to an IO_STATUS_BLOCK structure that contains the final status."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "ByteOffset",
        "description": "A pointer to a variable that specifies the starting byte offset of the range to lock."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Length",
        "description": "A pointer to a variable that specifies the length in bytes of the range to lock."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Key",
        "description": "A caller-assigned value used to describe groups of related locks. This value should be set to zero."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "FailImmediately",
        "description": "If TRUE, immediately return if the file cannot be locked. If FALSE, wait for the lock request to be granted."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ExclusiveLock",
        "description": "If TRUE, byte-range lock is exclusive; otherwise, shared lock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwMakeTemporaryObject routine changes the attributes of an object to make it temporary.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwMakeTemporaryObject returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. ",
    "remarks": "ZwMakeTemporaryObject is a generic routine that operates on any type of object. An object is permanent if it was created with the OBJ_PERMANENT object attribute specified. (For more information about object attributes, see InitializeObjectAttributes.) A permanent object is created with a reference count of 1, so it is not deleted when a driver dereferences it. An object is temporary if it is not permanent. ZwMakeTemporaryObject turns the specified object into a temporary object. If the object is already temporary, this routine does nothing. A temporary object has a name only as long as its handle count is greater than zero. When the handle count reaches zero, the system deletes the object name and appropriately adjusts the object's pointer count. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwMakeTemporaryObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "Handle to an object of any type."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The ZwNotifyChangeKey routine allows a driver to request notification when a registry key changes.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "The ZwNotifyChangeKey routine returns STATUS_SUCCESS on success, or the appropriate NTSTATUS value otherwise. If the caller specifies TRUE for the Asynchronous parameter, and the event has not yet occurred, the routine returns STATUS_PENDING. ",
    "remarks": "If the call to the ZwNotifyChangeKey function occurs in user mode, you should use the name \"NtNotifyChangeKey\" instead of \"ZwNotifyChangeKey\". For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwNotifyChangeKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "KeyHandle",
        "description": "Handle to the key to register a notification routine for. This handle is created by a successful call to ZwCreateKey or ZwOpenKey. The caller must have specified KEY_NOTIFY access."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "Handle to a caller-created event. If not NULL, the caller is placed into a wait state until the operation succeeds, at which time the event is set to the Signaled state."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "For a user-mode call, this parameter points to a caller-supplied APC routine that is run after the operation is completed. This parameter is optional and can be NULL.   For a kernel-mode call, this parameter must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "The meaning of this parameter depends on whether the routine is called from kernel mode or from user mode. For a kernel-mode call, set this parameter to one of the following WORK_QUEUE_TYPE enumeration values:   CriticalWorkQueue   DelayedWorkQueue   The parameter value must be cast to type PVOID. For a user-mode call, this parameter points to a caller-specified context for the APC routine. This value is passed to the APC routine when it is run."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that contains the final status and information about the operation. For successful calls that return data, the number of bytes written to Buffer is supplied in IoStatusBlock->Information."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CompletionFilter",
        "description": "Bitmask of operations that cause the driver to be notified. Specify one or more of the following flags:   REG_NOTIFY_CHANGE_NAME  Notify the caller if a subkey is added or deleted.  REG_NOTIFY_CHANGE_ATTRIBUTES  Notify the caller of changes to the attributes of the key, such as the security descriptor information.  REG_NOTIFY_CHANGE_LAST_SET  Notify the caller of changes to a value of the key. This can include adding or deleting a value, or changing an existing value. (The caller receives no notification if the new value written to the key matches the previous value of the key.)  REG_NOTIFY_CHANGE_SECURITY  Notify the caller of changes to the security descriptor of the key."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "WatchTree",
        "description": "If TRUE, the driver is notified about changes to all subkeys of the specified key. If FALSE, the driver is only notified for changes to the specified key."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Reserved. Specify NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "BufferSize",
        "description": "Reserved. Specify zero."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Asynchronous",
        "description": "If FALSE, the routine does not return until the specified event occurs. If TRUE, the routine returns immediately."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwOpenDirectoryObject routine opens an existing directory object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntdef.h, Ntifs.h, or Fltkernel.h)",
    "return_value": "ZwOpenDirectoryObject returns STATUS_SUCCESS or an appropriate error status. The most common error status codes include the following:  The ZwOpenDirectoryObject routine throws an exception if the DirectoryHandle parameter is an illegal pointer. ",
    "remarks": "ZwOpenDirectoryObject opens an existing directory object and returns a handle to the object. The ZwOpenDirectoryObject routine is called after the InitializeObjectAttributes macro is used to initialize specific attributes of the OBJECT_ATTRIBUTES structure for the object to be opened. A directory object is created using the ZwCreateDirectoryObject routine. Any handle obtained by calling ZwOpenDirectoryObject must eventually be released by calling ZwClose. For more information about security and access control, see the documentation on these topics in the Windows SDK. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenDirectoryObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "DirectoryHandle",
        "description": "Handle for the newly opened directory object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK structure specifying the requested types of access being requested for this directory object. A caller can specify one or a combination of the following.  DesiredAccess FlagsMeaning  DIRECTORY_QUERY  Query access to the directory object   DIRECTORY_TRAVERSE  Name-lookup access to the directory object   DIRECTORY_CREATE_OBJECT  Name-creation access to the directory object   DIRECTORY_CREATE_SUBDIRECTORY  Subdirectory-creation access to the directory object   DIRECTORY_ALL_ACCESS  All of the preceding rights plus STANDARD_RIGHTS_REQUIRED.     These requested access types are compared with the object's discretionary access-control list (DACL) to determine which accesses are granted or denied."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Specified attributes for the directory object supplied by the caller. This parameter is initialized by calling the InitializeObjectAttributes macro."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwOpenEnlistment routine obtains a handle to an existing enlistment object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwOpenEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Typically, a TPS component calls ZwOpenEnlistment after it receives an enlistment GUID from another TPS component that had previously called ZwCreateEnlistment. Most TPS designs do not require calling ZwOpenEnlistment. A resource manager that calls ZwOpenEnlistment must eventually call ZwClose to close the object handle. For more information about ZwOpenEnlistment, see Enlistment Objects. NtOpenEnlistment and ZwOpenEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "EnlistmentHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to an enlistment object if the call to ZwOpenEnlistment succeeds."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK-typed value that specifies the requested access to the enlistment object. For more information about how to specify this parameter, see the DesiredAccess parameter of ZwCreateEnlistment. This parameter cannot be zero."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "RmHandle",
        "description": "A handle to a resource manager object that was obtained by a previous call to ZwCreateResourceManager or ZwOpenResourceManager."
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "EnlistmentGuid",
        "description": "A pointer to a GUID that identifies the enlistment. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object's attributes. Use the InitializeObjectAttributes routine to initialize this structure, but specify only that routine's InitializedAttributes and Attributes parameters. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE flag in the Attributes parameter. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwOpenEvent routine opens a handle to an existing named event object with the specified desired access.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "ZwOpenEvent returns STATUS_SUCCESS or an appropriate error status. This routine might return one of the following error status codes:  ",
    "remarks": "ZwOpenEvent opens an existing named event object and creates a handle to the object with the specified desired access. ZwOpenEvent can open either notification or synchronization events. Events are used to coordinate execution. File system drivers can use events to enable a caller to wait for completion of the requested operation until the given event is set to the Signaled state. Notification events can be used to notify one or more threads of execution that an event has occurred. Synchonization events can be used in the serialization of access to hardware between two otherwise unrelated drivers. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "EventHandle",
        "description": "A pointer to a variable that will receive the event object handle. The handle includes bookkeeping information, such as a reference count and security context."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "The ACCESS_MASK value that represents the desired types of access for the event object. The following table contains the event-specific ACCESS_MASK values.  ValueDesired access EVENT_QUERY_STATEQuery the state of the event object. EVENT_MODIFY_STATEModify the state of the event object. EVENT_ALL_ACCESSAll possible access rights to the event object."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to the object attributes structure that the caller supplied to be used for the specified object. These attributes would include the ObjectName and the handle attributes, for example. This parameter is initialized by calling the InitializeObjectAttributes macro."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwOpenFile routine opens an existing file, directory, device, or volume.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwOpenFile returns STATUS_SUCCESS or the appropriate NTSTATUS error code. In the latter case, the caller can find more information about the cause of the failure by checking the IoStatusBlock parameter. ",
    "remarks": "ZwOpenFile supplies a handle that the caller can use to manipulate a file's data, or the file object's state and attributes. ZwOpenFile provides a subset of the functionality provided by ZwCreateFile. For more information, see Using Files in a Driver. Once the handle pointed to by FileHandle is no longer in use, the driver must call ZwClose to close it. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. Callers of ZwOpenFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "FileHandle",
        "description": "Pointer to a HANDLE variable that receives a handle to the file."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. For more information, see the DesiredAccess parameter of ZwCreateFile."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the requested operation."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ShareAccess",
        "description": "Specifies the type of share access for the file. For more information, see the ShareAccess parameter of ZwCreateFile."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "OpenOptions",
        "description": "Specifies the options to apply when opening the file. For more information, see the CreateOptions parameter of ZwCreateFile."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwOpenProcess routine opens a handle to a process object and sets the access rights to this object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h or Ntifs.h)",
    "return_value": "ZwOpenProcess returns STATUS_SUCCESS if the call is successful. Possible return values include the following error status codes.  ",
    "remarks": "In Windows Vista and later versions of Windows, the ClientId parameter must point to a client ID that identifies the thread whose process is to be opened. In addition, the ObjectName field of the structure pointed to by ObjectAttributes must be set to NULL. In Windows Server 2003, Windows XP, and Windows 2000, the caller has the option of supplying either a client ID or an object name (but not both). If the ObjectName field of the structure pointed to by ObjectAttributes contains a non-NULL pointer to an object name, ClientId must be NULL. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenProcess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "ProcessHandle",
        "description": "A pointer to a variable of type HANDLE. The ZwOpenProcess routine writes the process handle to the variable that this parameter points to."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that contains the access rights that the caller has requested to the process object."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes to apply to the process object handle. In Windows Vista and later versions of Windows, the ObjectName field of this structure must be set to NULL. In Windows Server 2003, Windows XP, and Windows 2000, this field can, as an option, point to an object name. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCLIENT_ID",
        "name": "ClientId",
        "description": "A pointer to a client ID that identifies the thread whose process is to be opened. In Windows Vista and later versions of Windows, this parameter must be a non-NULL pointer to a valid client ID. In Windows Server 2003, Windows XP, and Windows 2000, this parameter is optional and can be set to NULL if the OBJECT_ATTRIBUTES structure that ObjectAttributes points to specifies an object name. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwOpenProcessTokenEx routine opens the access token associated with a process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwOpenProcessTokenEx returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "ZwOpenProcessTokenEx opens the access token associated with a process and returns a handle for that token. Any handle obtained by calling ZwOpenProcessTokenEx must eventually be released by calling ZwClose. Driver routines that run in a process context other than that of the system process must set the OBJ_KERNEL_HANDLE attribute for the HandleAttributes parameter of ZwOpenProcessTokenEx. This restricts the use of the handle returned by ZwOpenProcessTokenEx to processes running in kernel mode. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information about security and access control, see the documentation on these topics in the Windows SDK. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenProcessTokenEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "Handle to the process whose access token is to be opened. The handle must have PROCESS_QUERY_INFORMATION access. Use the NtCurrentProcess macro, defined in Ntddk.h, to specify the current process."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "ACCESS_MASK structure specifying the requested types of access to the access token. These requested access types are compared with the token's discretionary access-control list (DACL) to determine which accesses are granted or denied."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "HandleAttributes",
        "description": "Attributes for the access token handle. Only OBJ_KERNEL_HANDLE is currently supported. If the caller is not running in the system process context, it must specify OBJ_KERNEL_HANDLE for this parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "TokenHandle",
        "description": "Pointer to a caller-allocated variable that receives a handle to the newly opened access token."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwOpenResourceManager routine returns a handle to an existing resource manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwOpenResourceManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Typically, a TPS component calls ZwOpenResourceManager after it receives an enlistment GUID from another TPS component that had previously called ZwCreateResourceManager. Most TPS designs do not require calling ZwOpenResourceManager. A resource manager that calls ZwOpenResourceManager must eventually call ZwClose to close the object handle. For more information about ZwOpenResourceManager, see KTM Objects. NtOpenResourceManager and ZwOpenResourceManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenResourceManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "ResourceManagerHandle",
        "description": "A pointer to a caller-allocated variable that receives the resource manager handle if the call to ZwOpenResourceManager succeeds."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the resource manager object. For more information about how to specify this parameter, see the DesiredAccess parameter of ZwCreateResourceManager. This parameter cannot be zero."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TmHandle",
        "description": "A handle to a transaction manager object that was obtained by a previous call to ZwCreateTransactionManager or ZwOpenTransactionManager."
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "ResourceManagerGuid",
        "description": "A pointer to the GUID that identifies the resource manager to open."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object's attributes. Use the InitializeObjectAttributes routine to initialize this structure, but specify only that routine's InitializedAttributes and Attributes parameters. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE flag in the Attributes parameter. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwOpenSymbolicLinkObject routine opens an existing symbolic link.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwOpenSymbolicLinkObject returns STATUS_SUCCESS on success or the appropriate error status. ",
    "remarks": "Once the handle pointed to by LinkHandle is no longer in use, the driver must call ZwClose to close it. If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see Object Handles. NtOpenSymbolicLinkObject and ZwOpenSymbolicLinkObject are two versions of the same Windows Native System Services routine. The NtOpenSymbolicLinkObject routine in the Windows kernel is not directly accessible to kernel-mode drivers. However, kernel-mode drivers can access this routine indirectly by calling the ZwOpenSymbolicLinkObject routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenSymbolicLinkObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "LinkHandle",
        "description": "Pointer to a HANDLE variable that receives a handle to the symbolic link object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies an ACCESS_MASK value that determines the requested access to the object. The caller usually specified GENERIC_READ, so that the handle can be passed to ZwQuerySymbolicLinkObject."
      },
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwOpenThreadTokenEx routine opens the access token associated with a thread.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwOpenThreadTokenEx returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "ZwOpenThreadTokenEx opens the access token associated with a thread and returns a handle for that token. The OpenAsSelf parameter allows a server process to open the access token for a client process when the client process has specified the SecurityIdentification impersonation level for the SECURITY_IMPERSONATION_LEVEL enumerated type. Without this parameter, the calling process is not be able to open the client's access token using the client's security context because it is impossible to open executive-level objects using the SecurityIdentification impersonation level. Any handle obtained by calling ZwOpenThreadTokenEx must eventually be released by calling ZwClose. Driver routines that run in a process context other than that of the system process must set the OBJ_KERNEL_HANDLE attribute for the HandleAttributes parameter of ZwOpenThreadTokenEx. This restricts the use of the handle returned by ZwOpenThreadTokenEx to processes running in kernel mode. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information about security and access control, see the documentation on these topics in the Windows SDK. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenThreadTokenEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ThreadHandle",
        "description": "Handle to the thread whose access token is to be opened. The handle must have THREAD_QUERY_INFORMATION access. Use the NtCurrentThread macro to specify the current thread."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "ACCESS_MASK structure specifying the requested types of access to the access token. These requested access types are compared with the token's discretionary access-control list (DACL) to determine which access rights are granted or denied."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "OpenAsSelf",
        "description": "Boolean value specifying whether the access check is to be made against the security context of the thread calling ZwOpenThreadTokenEx or against the security context of the process for the calling thread.  If this parameter is FALSE, the access check is performed using the security context for the calling thread. If the thread is impersonating a client, this security context can be that of a client process. If this parameter is TRUE, the access check is made using the security context of the process for the calling thread."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "HandleAttributes",
        "description": "Attributes for the created handle. Only OBJ_KERNEL_HANDLE is currently supported. If the caller is not running in the system process context, it must specify OBJ_KERNEL_HANDLE for this parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "TokenHandle",
        "description": "Pointer to a caller-allocated variable that receives a handle to the newly opened access token."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwOpenTransaction routine obtains a handle to an existing transaction object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwCreateTransaction returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Typically, a resource manager calls ZwOpenTransaction after it receives a transaction UOW from a transactional client that had previously called ZwCreateTransaction. For more information about ZwOpenTransaction, see Creating a Resource Manager. NtOpenTransaction and ZwOpenTransaction are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenTransaction",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "TransactionHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to the transaction object if ZwOpenTransaction returns STATUS_SUCCESS."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the transaction object. For information about how to specify this parameter, see the DesiredAccess parameter of ZwCreateTransaction."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object's attributes. Use the InitializeObjectAttributes routine to initialize this structure, but specify only that routine's InitializedAttributes and Attributes parameters. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE flag in the Attributes parameter. The ObjectAttributes parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "Uow",
        "description": "A pointer to a GUID that is a transaction object's unit of work (UOW) identifier. This GUID identifies the transaction object to open."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "TmHandle",
        "description": "A handle to a transaction manager object. If this parameter is not NULL, KTM searches only for transaction objects that belong to the specified transaction manager object. If this parameter is NULL, KTM searches all transaction objects."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwOpenTransactionManager routine obtains a handle to an existing transaction manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwOpenTransactionManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "The caller can identify which transaction manager object to open by using one of the following three techniques: You must specify only one of the above-listed parameters (an object name, a log file name, or a GUID) and set the other two parameters to NULL. Your TPS component must call ZwRecoverTransactionManager after it has called ZwOpenTransactionManager. A TPS component that calls ZwOpenTransactionManager must eventually call ZwClose to close the object handle. For more information about how to use ZwOpenTransactionManager, see Transaction Manager Objects and Creating a Resource Manager. NtOpenTransactionManager and ZwOpenTransactionManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwOpenTransactionManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "TmHandle",
        "description": "A pointer to a caller-allocated variable that receives a handle to the transaction manager object if ZwOpenTransactionManager returns STATUS_SUCCESS."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK value that specifies the caller's requested access to the transaction manager object. For information about how to specify this parameter, see the DesiredAccess parameter of ZwCreateTransactionManager."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use the InitializeObjectAttributes routine to initialize this structure. If the caller is not running in a system thread context, it must set the OBJ_KERNEL_HANDLE attribute when it calls InitializeObjectAttributes. This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "LogFileName",
        "description": "A pointer to a UNICODE_STRING structure that contains the path and file name of the log file stream that was created when the transaction manager object was created. For more information, see the LogFileName parameter of ZwCreateTransactionManager. This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPGUID",
        "name": "TmIdentity",
        "description": "A pointer to a GUID that identifies the transaction manager object.  This parameter is optional and can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "OpenOptions",
        "description": "This parameter is not used and must be zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwPowerInformation routine sets or retrieves system power information.",
    "library": "Ntoskrnl.lib",
    "min_server": "Windows Server 2012",
    "header": "Ntddk.h",
    "return_value": "Returns STATUS_SUCCESS if the call is successful. If the call fails, possible error codes include the following:  ",
    "remarks": "NtPowerInformation and ZwPowerInformation are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. This example illustrates a valid function call. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwPowerInformation",
    "is_callback": 0,
    "dll": "Ntoskrnl.lib",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "POWER_INFORMATION_LEVEL",
        "name": "InformationLevel",
        "description": "Specifies the requested information level, which indicates the specific power information to be set or retrieved. Currently, the only supported POWER_INFORMATION_LEVEL value is PlatformInformation.  ValueMeaning  PlatformInformation   Information represents the currently supported power capabilities of the system. Information may change as drivers are installed. For example, the installation of legacy device drivers that do not support power management might modify the capabilities of the system."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "InputBuffer",
        "description": "Pointer to a caller-allocated input buffer. This parameter must be NULL, otherwise ERROR_INVALID_PARAMETER is returned."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InputBufferLength",
        "description": "Size, in bytes, of the buffer at InputBuffer. The parameter must be set to zero."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutputBuffer",
        "description": "A pointer to an output buffer. The data type of this buffer depends on the information level requested in the InformationLevel parameter. For the PlatformInformation level, the only currently supported value, the OutputBuffer  parameter is required and should be of the POWER_PLATFORM_INFORMATION type."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "OutputBufferLength",
        "description": "Size, in bytes, of the output buffer. Depending on the information level requested, the buffer may be variably sized. PlatformInformation, the only currently supported value, requires a buffer that is the size of a POWER_PLATFORM_INFORMATION structure."
      }
    ],
    "min_client": "Windows 8"
  },
  {
    "n_arguments": 2,
    "description": "The ZwPrepareComplete routine notifies KTM that the calling resource manager has finished preparing a transaction's data.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwPrepareComplete returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager must call ZwPrepareComplete after it has finished servicing a TRANSACTION_NOTIFY_PREPARE notification. After a resource manager has called ZwPrepareComplete, it cannot roll back the transaction. For more information about ZwPrepareComplete, see Handling Commit Operations. NtPrepareComplete and ZwPrepareComplete are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwPrepareComplete",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwPrepareEnlistment routine initiates the prepare operation for a specified enlistment's transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwPrepareEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Only superior transaction managers can call ZwPrepareEnlistment. The ZwPrepareEnlistment routine causes KTM to send TRANSACTION_NOTIFY_PREPARE notifications to all resource managers that have enlisted in the transaction. Callers of ZwPrepareEnlistment must register to receive TRANSACTION_NOTIFY_PREPARE_COMPLETE notifications. For more information about ZwPrepareEnlistment, see Creating a Superior Transaction Manager and Handling Commit Operations. NtPrePrepareEnlistment and ZwPrePrepareEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwPrepareEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The object must represent a superior enlistment and the handle must have ENLISTMENT_SUPERIOR_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwPrePrepareComplete routine notifies KTM that the calling resource manager has finished preliminary preparation of a transaction's data.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwPrePrepareComplete returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager must call ZwPrePrepareComplete after it has finished servicing a TRANSACTION_NOTIFY_PREPREPARE notification. For more information about ZwPrePrepareComplete, see Handling Commit Operations. NtPrePrepareComplete and ZwPrePrepareComplete are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwPrePrepareComplete",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwPrePrepareEnlistment routine initiates the pre-prepare operation for a specified enlistment's transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwPrePrepareEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Only superior transaction managers can call ZwPrePrepareEnlistment. Callers of ZwPrePrepareEnlistment must register to receive TRANSACTION_NOTIFY_PREPREPARE_COMPLETE notifications. The ZwPrePrepareEnlistment routine causes KTM to send TRANSACTION_NOTIFY_PREPREPARE notifications to all resource managers that have enlisted in the transaction. For more information about ZwPrePrepareEnlistment, see Creating a Superior Transaction Manager and Handling Commit Operations. NtPrepareEnlistment and ZwPrepareEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwPrePrepareEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The object must represent a superior enlistment and the handle must have ENLISTMENT_SUPERIOR_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 11,
    "description": "The ZwQueryDirectoryFile routine returns various kinds of information about files in the directory specified by a given file handle.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "The ZwQueryDirectoryFileroutine returns STATUS_SUCCESS or an appropriate error status. Note that the set of error status values that can be returned is file-system-specific. ZwQueryDirectoryFilealso returns the number of bytes actually written to the given FileInformation buffer in the Information member of IoStatusBlock. ",
    "remarks": "The ZwQueryDirectoryFile routine returns information about files that are contained in the directory represented by FileHandle. If provided, the value of the FileName parameter determines the entries that are included in the directory scan for all subsequent calls to ZwQueryDirectoryFile for a given FileHandle. If there is at least one matching entry, ZwQueryDirectoryFile creates a FILE_XXX_INFORMATION structure for each entry and stores them in the buffer. Assuming that at least one matching directory entry is found, the number of entries for which information is returned is the smallest of the following: On the first call to ZwQueryDirectoryFile, if the structure created for the first entry found is too large to fit into the output buffer, the routine writes the fixed portion of the structure to the output buffer. The routine then writes to the output buffer as much of the FileName string as will fit. (The fixed portion of the structure consists of all fields except the final FileName string. On the first call, but not on subsequent calls, the I/O system ensures that the buffer is large enough to hold the fixed portion of the appropriate FILE_XXX_INFORMATION structure.) When this happens, ZwQueryDirectoryFile returns an appropriate status value such as STATUS_BUFFER_OVERFLOW. On each call, ZwQueryDirectoryFile returns as many FILE_XXX_INFORMATION structures (one per directory entry) as can be contained entirely in the buffer pointed to by FileInformation. On the first call, ZwQueryDirectoryFile returns STATUS_SUCCESS only if the output buffer contains at least one complete structure. On subsequent calls, if the output buffer contains no structures, ZwQueryDirectoryFile returns STATUS_SUCCESS but sets IoStatusBlock->Information = 0 to notify the caller of this condition. In this case, the caller should allocate a larger buffer and call ZwQueryDirectoryFile again. No information about any remaining entries is reported. Thus, except in the cases listed above where only one entry is returned, ZwQueryDirectoryFile must be called at least twice to enumerate the contents of an entire directory. When calling ZwQueryDirectoryFile, you may see changes made to the directory that occur in parallel with ZwQueryDirectoryFile calls.  This behavior is dependent on the implementation of the underlying file system. The final call to ZwQueryDirectoryFile returns an empty output buffer and reports an appropriate status value such as STATUS_NO_MORE_FILES. If ZwQueryDirectoryFile is called multiple times on the same directory and some other operation changes the contents of that directory, any changes may or may not be seen, depending on the timing of the operations. ZwQueryDirectoryFilereturns zero in any member of a FILE_XXX_INFORMATION structure that is not supported by the file system. Callers of ZwQueryDirectoryFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For information about other file information query routines, see File Objects. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryDirectoryFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle returned by ZwCreateFile or ZwOpenFile for the file object that represents the directory for which information is being requested. The file object must have been opened for asynchronous I/O if the caller specifies a non-NULL value for Event or ApcRoutine."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "An optional handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the Signaled state. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the FileHandle to be set to the Signaled state."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "An address of an optional, caller-supplied APC routine to be called when the requested operation completes. This parameter is optional and can be NULL. If there is an I/O completion object associated with the file object, this parameter must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "An optional pointer to a caller-determined context area if the caller supplies an APC or if an I/O completion object is associated with the file object. When the operation completes, this context is passed to the APC, if one was specified, or is included as part of the completion message that the I/O Manager posts to the associated I/O completion object.  This parameter is optional and can be NULL. It must be NULL if ApcRoutine is NULL and there is no I/O completion object associated with the file object."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the operation. For successful calls that return data, the number of bytes written to the FileInformation buffer is returned in the structure's Information member."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "FileInformation",
        "description": "A pointer to a buffer that receives the desired information about the file. The structure of the information returned in the buffer is defined by the FileInformationClass parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The size, in bytes, of the buffer pointed to by FileInformation. The caller should set this parameter according to the given FileInformationClass."
      },
      {
        "in_out": "_In_",
        "type": "FILE_INFORMATION_CLASS",
        "name": "FileInformationClass",
        "description": "The type of information to be returned about files in the directory. One of the following.   ValueMeaning  FileBothDirectoryInformation  Return a FILE_BOTH_DIR_INFORMATION structure for each file.   FileDirectoryInformation  Return a FILE_DIRECTORY_INFORMATION structure for each file.   FileFullDirectoryInformation  Return a FILE_FULL_DIR_INFORMATION structure for each file.   FileIdBothDirectoryInformation  Return a FILE_ID_BOTH_DIR_INFORMATION structure for each file.   FileIdFullDirectoryInformation  Return a FILE_ID_FULL_DIR_INFORMATION structure for each file.   FileNamesInformation  Return a FILE_NAMES_INFORMATION structure for each file.   FileObjectIdInformation  Return a FILE_OBJECTID_INFORMATION structure for each file. This information class is valid only for NTFS volumes on Windows 2000 and later versions of Windows.   FileReparsePointInformation  Return a single FILE_REPARSE_POINT_INFORMATION structure for the directory."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ReturnSingleEntry",
        "description": "Set to TRUE if only a single entry should be returned, FALSE otherwise. If this parameter is TRUE, ZwQueryDirectoryFile returns only the first entry that is found."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "FileName",
        "description": "An optional pointer to a caller-allocated Unicode string containing the name of a file (or multiple files, if wildcards are used) within the directory specified by FileHandle. This parameter is optional and can be NULL.  If FileName is not NULL, only files whose names match the FileName string are included in the directory scan. If FileName is NULL, all files are included.  The FileName is used as a search expression and is captured on the very first call to ZwQueryDirectoryFile for a given handle. Subsequent calls to ZwQueryDirectoryFile will use the search expression set in the first call. The FileName parameter passed to subsequent calls will be ignored."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "RestartScan",
        "description": "Set to TRUE if the scan is to start at the first entry in the directory. Set to FALSE if resuming the scan from a previous call. When the ZwQueryDirectoryFile routine is called for a particular handle, the RestartScan parameter is treated as if it were set to TRUE, regardless of its value. On subsequent ZwQueryDirectoryFile calls, the value of the RestartScan parameter is honored."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwQueryFullAttributesFile routine supplies network open information for the specified file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryFullAttributesFile returns STATUS_SUCCESS on success, or the appropriate error status. ",
    "remarks": "Callers of ZwQueryFullAttributesFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. NtQueryFullAttributesFile and ZwQueryFullAttributesFile are two versions of the same Windows Native System Services routine. The NtQueryFullAttributesFile routine in the Windows kernel is not directly accessible to kernel-mode drivers. However, kernel-mode drivers can access this routine indirectly by calling the ZwQueryFullAttributesFile routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryFullAttributesFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "POBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an OBJECT_ATTRIBUTES structure that supplies the attributes to be used for the file object."
      },
      {
        "in_out": "_Out_",
        "type": "PFILE_NETWORK_OPEN_INFORMATION",
        "name": "FileInformation",
        "description": "A pointer to a FILE_NETWORK_OPEN_INFORMATION structure that receives the returned file attributes information."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryInformationEnlistment routine retrieves information about a specified enlistment object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryInformationEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager can call ZwSetInformationEnlistment to set enlistment-specific recovery information for an enlistment object and then call ZwQueryInformationEnlistment to retrieve the recovery information. For more information about ZwQueryInformationEnlistment, see Handling Recovery Operations. Callers of ZwQueryInformationEnlistment must be running at IRQL = PASSIVE_LEVEL. NtQueryInformationEnlistment and ZwQueryInformationEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryInformationEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_QUERY_INFORMATION access to the object."
      },
      {
        "in_out": "_In_",
        "type": "ENLISTMENT_INFORMATION_CLASS",
        "name": "EnlistmentInformationClass",
        "description": "An ENLISTMENT_INFORMATION_CLASS-typed enumeration value that specifies the information to be obtained. This value must be one of the following values:   EnlistmentBasicInformation   EnlistmentRecoveryInformation   The enumeration's EnlistmentFullInformation value is not used with ZwQueryInformationEnlistment."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "EnlistmentInformation",
        "description": "A pointer to a caller-allocated buffer that receives the information that the EnlistmentInformationClass parameter specifies. If the EnlistmentInformationClass parameter's value is EnlistmentBasicInformation, this buffer's structure type must be ENLISTMENT_BASIC_INFORMATION. If the EnlistmentInformationClass parameter's value is EnlistmentRecoveryInformation, this buffer's type must match the caller-defined type that the caller used when it called ZwSetInformationEnlistment."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EnlistmentInformationLength",
        "description": "The length, in bytes, of the buffer that the EnlistmentInformation parameter points to."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a caller-allocated variable that receives the length, in bytes, of the information that KTM writes to the EnlistmentInformation buffer. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryInformationResourceManager routine retrieves information about a specified resource manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryInformationResourceManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "For more information about the ZwQueryInformationResourceManager routine, see Creating a Resource Manager. NtQueryInformationResourceManager and ZwQueryInformationResourceManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryInformationResourceManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ResourceManagerHandle",
        "description": "A handle to a resource manager object that was obtained by a previous call to ZwCreateResourceManager or ZwOpenResourceManager. The handle must have RESOURCEMANAGER_QUERY_INFORMATION access to the object."
      },
      {
        "in_out": "_In_",
        "type": "RESOURCEMANAGER_INFORMATION_CLASS",
        "name": "ResourceManagerInformationClass",
        "description": "A RESOURCEMANAGER_INFORMATION_CLASS-typed value that specifies the information to retrieve. This value must be ResourceManagerBasicInformation."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "ResourceManagerInformation",
        "description": "A pointer to a caller-allocated RESOURCEMANAGER_BASIC_INFORMATION structure that receives information from ZwQueryInformationResourceManager."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ResourceManagerInformationLength",
        "description": "The length, in bytes, of the buffer that the ResourceManagerInformation parameter points to."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a caller-allocated variable that receives the length, in bytes, of the information that KTM writes to the ResourceManagerInformation buffer. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryInformationToken routine retrieves a specified type of information about an access token. The calling process must have appropriate access rights to obtain the information.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwQueryInformationToken returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "The ZwQueryInformationToken routine can be used by a file system or file system filter driver to determine the SID of the caller that initiated the request during IRP_MJ_CREATE processing. If TokenUser is specified for the TokenInformationClass parameter passed to ZwQueryInformationToken, a TOKEN_USER structure is returned in the buffer pointed to by the TokenInformation parameter. This returned buffer contains an SID_AND_ATTRIBUTES structure with the user SID. For more information about security and access control, see the documentation on these topics in the Windows SDK. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryInformationToken",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TokenHandle",
        "description": "Handle for an access token from which information is to be retrieved. If TokenInformationClass is set to TokenSource, the handle must have TOKEN_QUERY_SOURCE access. For all other TokenInformationClass values, the handle must have TOKEN_QUERY access. For more information about access rights for access-token objects, see the Security section of the Windows SDK documentation."
      },
      {
        "in_out": "_In_",
        "type": "TOKEN_INFORMATION_CLASS",
        "name": "TokenInformationClass",
        "description": "A value from the TOKEN_INFORMATION_CLASS enumerated type identifying the type of information to be retrieved. The possible values for this parameter are listed in the TokenInformationClass Value column of the table shown in the description of the TokenInformation parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "TokenInformation",
        "description": "Pointer to a caller-allocated buffer that receives the requested information about the token. The structure put into this buffer depends upon the value of TokenInformationClass, as shown in the following table. All structures must be aligned on a 32-bit boundary.  TokenInformationClass ValueEffect on TokenInformation Buffer  TokenDefaultDacl  The buffer receives a TOKEN_DEFAULT_DACL structure containing the default DACL for newly created objects.    TokenGroups  The buffer receives a TOKEN_GROUPS structure containing the group accounts associated with the token.   TokenImpersonationLevel  The buffer receives a SECURITY_IMPERSONATION_LEVEL value indicating the impersonation level of the token. If the access token is not an impersonation token, the call to ZwQueryInformationToken fails.    TokenOwner  The buffer receives a TOKEN_OWNER structure containing the default owner SID for newly created objects.   TokenPrimaryGroup  The buffer receives a TOKEN_PRIMARY_GROUP structure containing the default primary group SID for newly created objects.    TokenPrivileges  The buffer receives a TOKEN_PRIVILEGES structure containing the token's privileges.   TokenSessionId  The buffer receives a 32-bit value specifying the Terminal Services session identifier associated with the token. If the token is associated with the Terminal Server console session, the session identifier is zero. A nonzero session identifier indicates a Terminal Services client session. In a non-Terminal Services environment, the session identifier is zero.   TokenSource  The buffer receives a TOKEN_SOURCE structure containing the source of the token. TOKEN_QUERY_SOURCE access is needed to retrieve this information.   TokenStatistics  The buffer receives a TOKEN_STATISTICS structure containing various token statistics.   TokenType  The buffer receives a TOKEN_TYPE value indicating whether the token is a primary or impersonation token.    TokenUser  The buffer receives a TOKEN_USER structure containing the token's user account."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TokenInformationLength",
        "description": "Length, in bytes, of the caller-allocated TokenInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "Pointer to a caller-allocated variable that receives the actual length, in bytes, of the information returned in the TokenInformation buffer. If either of the following conditions is true, no data is returned in the TokenInformation buffer:    The size of the requested token information structure is greater than TokenInformationLength. In this case, ReturnLength receives the actual number of bytes needed to store the requested information.    The value of TokenInformationClass is TokenDefaultDacl, and there is no default DACL established for the token. In this case, ReturnLength receives zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryInformationTransaction routine retrieves information about a specified transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryInformationTransaction returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "For more information about how to use ZwQueryInformationTransaction, see Creating a Transactional Client. NtQueryInformationTransaction and ZwQueryInformationTransaction are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryInformationTransaction",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionHandle",
        "description": "A handle to a transaction object that was obtained by a previous call to ZwCreateTransaction or ZwOpenTransaction. The handle must have TRANSACTION_QUERY_INFORMATION access to the object."
      },
      {
        "in_out": "_In_",
        "type": "TRANSACTION_INFORMATION_CLASS",
        "name": "TransactionInformationClass",
        "description": "A TRANSACTION_INFORMATION_CLASS-typed value that specifies the information to obtain. The value must be one of the following values:   TransactionBasicInformation   TransactionPropertiesInformation   TransactionEnlistmentInformation   The TransactionFullInformation value is not used with ZwQueryInformationTransaction."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "TransactionInformation",
        "description": "A pointer to a caller-allocated buffer that receives the information that the TransactionInformationClass parameter specifies. The buffer's structure type must be TRANSACTION_BASIC_INFORMATION, TRANSACTION_PROPERTIES_INFORMATION, or TRANSACTION_ENLISTMENTS_INFORMATION."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TransactionInformationLength",
        "description": "The length, in bytes, of the buffer that the TransactionInformation parameter points to, including the length of any additional array elements that the caller has allocated to receive information."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a caller-allocated variable that receives the length, in bytes, of the information that KTM writes to the TransactionInformation buffer. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryInformationTransactionManager routine retrieves information about a specified transaction manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQueryInformationTransactionManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "For more information about how to use ZwQueryInformationTransactionManager, see Using Log Streams with KTM. NtQueryInformationTransactionManager and ZwQueryInformationTransactionManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryInformationTransactionManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionManagerHandle",
        "description": "A handle to a transaction manager object that was obtained by a previous call to ZwCreateTransactionManager or ZwOpenTransactionManager. The handle must have TRANSACTIONMANAGER_QUERY_INFORMATION access to the object."
      },
      {
        "in_out": "_In_",
        "type": "TRANSACTIONMANAGER_INFORMATION_CLASS",
        "name": "TransactionManagerInformationClass",
        "description": "A TRANSACTIONMANAGER_INFORMATION_CLASS-typed enumeration value that specifies the information to be obtained. This value must be one of the following:   TransactionManagerBasicInformation   TransactionManagerLogInformation   TransactionManagerLogPathInformation   The enumeration's TransactionManagerOnlineProbeInformation value is not used with ZwQueryInformationTransactionManager."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "TransactionManagerInformation",
        "description": "A pointer to a caller-allocated buffer that receives the information that the TransactionManagerInformationClass parameter specifies. The buffer's structure type must be TRANSACTIONMANAGER_BASIC_INFORMATION, TRANSACTIONMANAGER_LOG_INFORMATION, TRANSACTIONMANAGER_LOGPATH_INFORMATION, or TRANSACTIONMANAGER_RECOVERY_INFORMATION."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TransactionManagerInformationLength",
        "description": "The length, in bytes, of the buffer that the TransactionManagerInformation parameter points to, including the length of any additional array elements that the caller has allocated to receive information."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a caller-allocated variable that receives the length, in bytes, of the information that KTM writes to the TransactionManagerInformation buffer. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryObject routine provides information about a supplied object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "ZwQueryObject returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "If the call to the ZwQueryObject function occurs in user mode, you should use the name \"NtQueryObject\" instead of \"ZwQueryObject\". For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "A handle to the object to obtain information about."
      },
      {
        "in_out": "_In_",
        "type": "OBJECT_INFORMATION_CLASS",
        "name": "ObjectInformationClass",
        "description": "Specifies an OBJECT_INFORMATION_CLASS value that determines the type of information returned in the ObjectInformation buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "ObjectInformation",
        "description": "A pointer to a caller-allocated buffer that receives the requested information."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ObjectInformationLength",
        "description": "Specifies the size, in bytes, of the ObjectInformation buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnLength",
        "description": "A pointer to a variable that receives the size, in bytes, of the requested key information. If ZwQueryObject returns STATUS_SUCCESS, the variable contains the amount of data returned. If ZwQueryObject returns STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL, you can use the value of the variable to determine the required buffer size."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 9,
    "description": "The ZwQueryQuotaInformationFile routine retrieves quota entries associated with the volume specified by the FileHandle parameter.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "The ZwQueryQuotaInformationFile routine returns STATUS_SUCCESS if at least one FILE_QUOTA_INFORMATION structure is returned in the Buffer parameter or an appropriate NTSTATUS value such as one of the following:  ",
    "remarks": "The amount of information returned by ZwQueryQuotaInformationFile is based on the size of the quota information associated with the volume, the size of the buffer, and whether a specific set of entries has been requested. A call to ZwQueryQuotaInformationFile will result in an IRP_MJ_QUERY_QUOTA request being sent to the device object that is associated with the file object whose handle is stored in the FileHandle parameter. If the underlying file system does not support quota information (FAT and CDFS file systems, for example), ZwQueryQuotaInformationFile will fail returning STATUS_INVALID_DEVICE_REQUEST. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryQuotaInformationFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle for the file object that represents the file or volume for which the quota information is requested."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "The address of the caller's I/O status block."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "A buffer to receive the quota information for the volume. The quota information is formatted as one or more FILE_QUOTA_INFORMATION structures. The NextEntryOffset field in the FILE_QUOTA_INFORMATION structure contains the offset, in bytes, of the next quota entry in the list. If there are no more entries after the current one, this member is zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The length in bytes of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ReturnSingleEntry",
        "description": "A Boolean value that indicates if only a single entry should be returned rather than filling the buffer with as many entries as possible."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SidList",
        "description": "An optional list of SIDs whose quota information is to be returned. Each entry in the list is a FILE_GET_QUOTA_INFORMATION structure. The NextEntryOffset field in the FILE_GET_QUOTA_INFORMATION structure contains the offset, in bytes, of the next quota entry in the list. If there are no more entries after the current one, this member is zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SidListLength",
        "description": "The length in bytes of the SID list, if one was specified."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSID",
        "name": "StartSid",
        "description": "An optional pointer to the SID of the entry at which to begin scanning the quota information. This parameter should be set if the returned information is to start with an entry other than the first SID. This parameter is ignored if a SidList parameter is specified."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "RestartScan",
        "description": "A Boolean value that indicates whether the scan of the quota information is to be restarted from the beginning. Set this parameter to TRUE if the scan of the quota information is to start at the first entry in the volume's quota information list. Set to FALSE if resuming the scan from a previous call to ZwQueryQuotaInformationFile. The caller must set this parameter to TRUE when calling ZwQueryQuotaInformationFile for the first time."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQuerySecurityObject routine retrieves a copy of an object's security descriptor.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwQuerySecurityObject returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "A security descriptor can be in absolute or self-relative form. In self-relative form, all members of the structure are located contiguously in memory. In absolute form, the structure only contains pointers to the members. The NTFS file system imposes a 64K limit on the size of the security descriptor that is written to disk for a file. (The FAT file system does not support security descriptors for files.) Thus a 64K SecurityDescriptor buffer is guaranteed to be large enough to hold the returned SECURITY_DESCRIPTOR structure. For more information about security and access control, see the documentation on these topics in the Windows SDK. Minifilters should call FltQuerySecurityObject instead of ZwQuerySecurityObject. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQuerySecurityObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "Handle for the object whose security descriptor is to be queried. This handle must have the access specified in the Meaning column of the table shown in the description of the SecurityInformation parameter."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_INFORMATION",
        "name": "SecurityInformation",
        "description": "Pointer to a SECURITY_INFORMATION value specifying the information to be queried.  ValueMeaning  DACL_SECURITY_INFORMATION  Indicates the discretionary access control list (DACL) of the object is being queried. Requires READ_CONTROL access.    GROUP_SECURITY_INFORMATION  Indicates the primary group identifier of the object is being queried. Requires READ_CONTROL access.    OWNER_SECURITY_INFORMATION  Indicates the owner identifier of the object is being queried. Requires READ_CONTROL access.    SACL_SECURITY_INFORMATION  Indicates the system ACL (SACL) of the object is being queried. Requires ACCESS_SYSTEM_SECURITY access."
      },
      {
        "in_out": "_Out_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Caller-allocated buffer that ZwQuerySecurityObject fills with a copy of the specified security descriptor. The SECURITY_DESCRIPTOR structure is returned in self-relative format."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Size, in bytes, of the buffer pointed to by SecurityDescriptor."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "LengthNeeded",
        "description": "Pointer to a caller-allocated variable that receives the number of bytes required to store the copied security descriptor."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwQuerySymbolicLinkObject routine returns a Unicode string that contains the target of a symbolic link.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwQuerySymbolicLinkObject returns either STATUS_SUCCESS to indicate the routine completed without error or STATUS_BUFFER_TOO_SMALL if the Unicode string provided at LinkTarget is too small to hold the returned string. ",
    "remarks": "Before calling this routine, driver writers must ensure that the Unicode string at LinkTarget has been properly initialized and a buffer for the string has been allocated. The MaximumLength and Buffer members of the Unicode string must be set before calling ZwQuerySymbolicLinkObject or the call will fail. If ZwQuerySymbolicLinkObject returns STATUS_BUFFER_TOO_SMALL drivers should examine the value returned at ReturnedLength. The number returned in this variable indicates the maximum length that the Unicode string for the target of the symbolic link. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQuerySymbolicLinkObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "LinkHandle",
        "description": "Handle to the symbolic-link object that you want to query. This handle is created by a successful call to ZwOpenSymbolicLinkObject."
      },
      {
        "in_out": "_Inout_",
        "type": "PUNICODE_STRING",
        "name": "LinkTarget",
        "description": "Pointer to an initialized Unicode string that receives the target of the symbolic link."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "ReturnedLength",
        "description": "contains the maximum number of bytes to copy into the Unicode string at LinkTarget. On output, the unsigned long integer contains the length of the Unicode string naming the target of the symbolic link."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ZwQueryVirtualMemory routine determines the state,     protection, and type of a region of pages within the virtual address     space of the subject process.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h",
    "return_value": "Returns STATUS_SUCCESS if the call is successful. If the call fails, possible error codes include the following:  ",
    "remarks": "ZwQueryVirtualMemory determines the state of the first page within the region and then     scans subsequent entries in the process address map from the     base address upward until either the entire range of pages has been     scanned or until a page with a non-matching set of attributes is     encountered. The region attributes, the length of the region of pages     with matching attributes, and an appropriate status value are     returned. If the entire region of pages does not have a matching set of     attributes, then the ReturnLength parameter value can be used to     compute the address and length of the region of pages that was not     scanned. NtQueryVirtualMemory and ZwQueryVirtualMemory are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryVirtualMemory",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle for the process in whose context the pages to be queried reside. Use the ZwCurrentProcess macro to specify the current process."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "BaseAddress",
        "description": "The base address of the region of pages to be                   queried. This value is rounded down to the next host-page-                   address boundary."
      },
      {
        "in_out": "_In_",
        "type": "MEMORY_INFORMATION_CLASS",
        "name": "MemoryInformationClass",
        "description": "The memory information class about which                              to retrieve information. Currently, the only supported MEMORY_INFORMATION_CLASS value is MemoryBasicInformation."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "MemoryInformation",
        "description": "A pointer to a buffer that receives the specified                         information.  The format and content of the buffer                         depend on the specified information class specified in the MemoryInformationClass parameter. When the value MemoryBasicInformation is passed to MemoryInformationClass, the MemoryInformationClass parameter value is a MEMORY_BASIC_INFORMATION."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "MemoryInformationLength",
        "description": "Specifies the length in bytes of                               the memory information buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PSIZE_T",
        "name": "ReturnLength",
        "description": "An optional pointer which, if specified, receives the                    number of bytes placed in the memory information buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwQueryVolumeInformationFile routine retrieves information about the volume associated with a given file, directory, storage device, or volume.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwQueryVolumeInformationFile returns STATUS_SUCCESS or an appropriate error status. ",
    "remarks": "ZwQueryVolumeInformationFile retrieves information about the volume associated with a given file, directory, storage device, or volume. If the FileHandle represents a direct device open, only FileFsDeviceInformation can be specified as the value of FsInformationClass. ZwQueryVolumeInformationFile returns zero in any member of a FILE_XXX_INFORMATION structure that is not supported by the file system. For information about other file information query routines, see File Objects. Minifilters should use FltQueryVolumeInformationFile instead of ZwQueryVolumeInformationFile. Callers of ZwQueryVolumeInformationFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwQueryVolumeInformationFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle to a file object returned by ZwCreateFile or ZwOpenFile for an open file, directory, storage device, or volume for which volume information is being requested."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the query operation. For successful calls that return data, the number of bytes written to the FsInformation buffer is returned in the structure's Information member."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "FsInformation",
        "description": "A pointer to a caller-allocated buffer that receives the desired information about the volume. The structure of the information returned in the buffer is defined by the FsInformationClass parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Size in bytes of the buffer pointed to by FsInformation. The caller should set this parameter according to the given FsInformationClass."
      },
      {
        "in_out": "_In_",
        "type": "FS_INFORMATION_CLASS",
        "name": "FsInformationClass",
        "description": "Type of information to be returned about the volume. Set this member to one of the following FS_INFORMATION_CLASS enumeration values.  ValueMeaning  FileFsAttributeInformation  Return a FILE_FS_ATTRIBUTE_INFORMATION structure containing attribute information about the file system responsible for the volume.   FileFsControlInformation  Return a FILE_FS_CONTROL_INFORMATION structure containing file system control information about the volume.   FileFsDeviceInformation  Return a FILE_FS_DEVICE_INFORMATION structure containing device information for the volume.   FileFsDriverPathInformation  Return a FILE_FS_DRIVER_PATH_INFORMATION structure containing information about whether a specified driver is in the I/O path for the volume. The caller must store the name of the driver into the FILE_FS_DRIVER_PATH_INFORMATION structure before calling ZwQueryVolumeInformationFile.   FileFsFullSizeInformation  Return a FILE_FS_FULL_SIZE_INFORMATION structure containing information about the total amount of space available on the volume.   FileFsObjectIdInformation  Return a FILE_FS_OBJECTID_INFORMATION structure containing file system-specific object ID information for the volume. Note that this is not the same as the (GUID-based) unique volume name assigned by the operating system.   FileFsSizeInformation  Return a FILE_FS_SIZE_INFORMATION structure containing information about the amount of space on the volume that is available to the user associated with the calling thread.   FileFsVolumeInformation  Return a FILE_FS_VOLUME_INFORMATION containing information about the volume such as the volume label, serial number, and creation time.   FileFsSectorSizeInformation  Return a FILE_FS_SECTOR_SIZE_INFORMATION structure that contains information about the physical and logical sector sizes of a volume."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwReadOnlyEnlistment routine sets a specified enlistment to be read-only.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwReadOnlyEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "Your component cannot call ZwReadOnlyEnlistment for a superior enlistment. For more information about ZwReadOnlyEnlistment, see Creating a Read-Only Enlistment. NtReadOnlyEnlistment and ZwReadOnlyEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwReadOnlyEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwRecoverEnlistment routine initiates a recovery operation for the transaction that is associated with a specified enlistment.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwRecoverEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "After a resource manager calls ZwRecoverEnlistment, KTM delivers either a TRANSACTION_NOTIFY_COMMIT, TRANSACTION_NOTIFY_ROLLBACK, or TRANSACTION_NOTIFY_INDOUBT notification for the enlistment. Therefore, unless the resource manager is using a ResourceManagerNotification callback routine, it must immediately call ZwGetNotificationResourceManager if ZwRecoverEnlistment returns STATUS_SUCCESS or STATUS_PENDING. For more information about ZwRecoverEnlistment, see Handling Recovery Operations. NtRecoverEnlistment and ZwRecoverEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRecoverEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_RECOVER access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "EnlistmentKey",
        "description": "A pointer to the enlistment key value that the resource manager previously specified as the EnlistmentKey parameter to ZwCreateEnlistment. This parameter is optional and can be NULL if the resource manager did not provide an enlistment key when it called ZwCreateEnlistment."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwRecoverResourceManager routine tries to recover the transaction that is associated with each enlistment of a specified resource manager object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwRecoverResourceManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "When a resource manager calls ZwRecoverResourceManager, KTM sends a TRANSACTION_NOTIFY_RECOVER notification to the resource manager for each of the resource manager's enlistments. (If the enlistment is a superior enlistment, KTM sends TRANSACTION_NOTIFY_RECOVER_QUERY instead of TRANSACTION_NOTIFY_RECOVER.) The final notification that KTM sends to the resource manager is TRANSACTION_NOTIFY_LAST_RECOVER. For more information about ZwRecoverResourceManager, see Handling Recovery Operations. NtRecoverResourceManager and ZwRecoverResourceManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRecoverResourceManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ResourceManagerHandle",
        "description": "A handle to a resource manager object that was obtained by a previous call to ZwCreateResourceManager or ZwOpenResourceManager. The handle must have RESOURCEMANAGER_RECOVER access to the object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwRecoverTransactionManager routine reconstructs the state of the transaction manager object (including all transactions, enlistments, and resource managers) from the recovery information that is in the log stream.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwRecoverTransactionManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "The ZwRecoverTransactionManager routine tries to reconstruct the state of the transaction manager object, including all transactions, enlistments, and resource managers, from the recovery information that is in the object's log stream, beginning at the last restart area that KTM created and ending at the stream's end. To recover up to a specific virtual time, use the ZwRollforwardTransactionManager routine instead of ZwRecoverTransactionManager. Your TPS component must call ZwRecoverTransactionManager after it has called ZwCreateTransactionManager or ZwOpenTransactionManager. For more information about recovery operations, see Handling Recovery Operations. NtRecoverTransactionManager and ZwRecoverTransactionManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRecoverTransactionManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionManagerHandle",
        "description": "A handle to a transaction manager object that was obtained by a previous call to ZwCreateTransactionManager or ZwOpenTransactionManager. The handle must have TRANSACTIONMANAGER_RECOVER access to the object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwRollbackComplete routine notifies KTM that the calling resource manager has finished rolling back a transaction's data.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwRollbackComplete returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager must call ZwRollbackComplete after it has finished servicing a TRANSACTION_NOTIFY_ROLLBACK notification. For more information about ZwRollbackComplete, see Handling Rollback Operations. NtRollbackComplete and ZwRollbackComplete are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRollbackComplete",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwRollbackEnlistment routine rolls back the transaction that is associated with a specified enlistment.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwRollbackEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager can call ZwRollbackEnlistment to roll back a transaction at any time before it calls ZwPrepareComplete. For more information about ZwRollbackEnlistment, see Handling Rollback Operations. NtRollbackEnlistment and ZwRollbackEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRollbackEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwRollbackTransaction routine initiates a rollback operation for a specified transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h or Ntifs.h)",
    "return_value": "ZwRollbackTransaction returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "For more information about ZwRollbackTransaction, see Handling Rollback Operations. NtRollbackEnlistment and ZwRollbackEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRollbackTransaction",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionHandle",
        "description": "A handle to a transaction object that was obtained by a previous call to ZwCreateTransaction or ZwOpenTransaction. The handle must have TRANSACTION_ROLLBACK access to the object."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Wait",
        "description": "A Boolean value that the caller sets to TRUE for synchronous operation or FALSE for asynchronous operation. If this parameter is set to TRUE, the call does not return until the rollback operation is complete."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwRollforwardTransactionManager routine initiates recovery operations for all of the in-progress transactions that are assigned to a specified transaction manager.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwRollforwardTransactionManager returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "The ZwRollforwardTransactionManager routine recovers all logged activity that KTM finds in the transaction manager's log file, up to and including the virtual clock value that the TmVirtualClock parameter supplies. Your component can traverse the log file incrementally by calling ZwRollforwardTransactionManager repetitively and setting the VirtualClock parameter to a higher value before each call. If the TmVirtualClock parameter is NULL, calling ZwRollforwardTransactionManager is equivalent to calling ZwRecoverTransactionManager. For more information about recovery operations, see Handling Recovery Operations. NtRollforwardTransactionManager and ZwRollforwardTransactionManager are two versions of the same Windows Native System Services routine. The NtRollforwardTransactionManager routine in the Windows kernel is not directly accessible to kernel-mode drivers. However, kernel-mode drivers can access this routine indirectly by calling the ZwRollforwardTransactionManager routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwRollforwardTransactionManager",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionManagerHandle",
        "description": "A handle to a transaction manager object that was obtained by a previous call to ZwCreateTransactionManager or ZwOpenTransactionManager. The handle must have TRANSACTIONMANAGER_RECOVER access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL. For more information about this parameter, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwSetEvent routine sets an event object to a Signaled state and attempts to satisfy as many waits as possible.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwSetEvent returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "ZwSetEvent sets an event object to a Signaled state and attempts to satisfy as many waits as possible. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EventHandle",
        "description": "A handle to an event object."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PLONG",
        "name": "PreviousState",
        "description": "An optional pointer to a variable where the previous state of the event object is stored on output."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwSetInformationEnlistment routine sets information for a specified enlistment object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwSetInformationEnlistment returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager can use the ZwSetInformationEnlistment routine to set recovery information for an enlistment. KTM writes the recovery information to the log stream, and the resource manager can call ZwQueryInformationEnlistment to read this information from the log stream at any time. Each subsequent call to ZwSetInformationEnlistment deletes the recovery information that the previous call specified before it stores the new recovery information. For more information about how to use ZwSetInformationEnlistment, see Using Log Streams with KTM. NtSetInformationEnlistment and ZwSetInformationEnlistment are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetInformationEnlistment",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SET_INFORMATION access to the object."
      },
      {
        "in_out": "_In_",
        "type": "ENLISTMENT_INFORMATION_CLASS",
        "name": "EnlistmentInformationClass",
        "description": "A ENLISTMENT_INFORMATION_CLASS-typed enumeration value that specifies the type of information to be set. This value must be EnlistmentRecoveryInformation. The enumeration's EnlistmentBasicInformation and EnlistmentFullInformation values are not used with ZwSetInformationEnlistment."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "EnlistmentInformation",
        "description": "A pointer to a caller-allocated buffer that contains caller-defined recovery information for the enlistment."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "EnlistmentInformationLength",
        "description": "The length, in bytes, of the buffer that the EnlistmentInformation parameter points to."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The ZwSetInformationResourceManager routine is not used.",
    "library": "",
    "min_server": "",
    "header": "",
    "return_value": "This function does not return a value. ",
    "remarks": "NtSetInformationResourceManager and ZwSetInformationResourceManager are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines.   Send comments about this topic to Microsoft ",
    "return_type": "void",
    "category": "Drivers",
    "name": "ZwSetInformationResourceManager",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwSetInformationToken routine modifies information in a specified token. The calling process must have appropriate access rights to set the information.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwSetInformationToken returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "For more information about security and access control, see the documentation on these topics in the Windows SDK. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetInformationToken",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TokenHandle",
        "description": "Handle for an access token in which information is to be modified."
      },
      {
        "in_out": "_In_",
        "type": "TOKEN_INFORMATION_CLASS",
        "name": "TokenInformationClass",
        "description": "A value from the TOKEN_INFORMATION_CLASS enumerated type identifying the type of information to be modified. The possible values for this parameter are listed in the TokenInformationClass Value column of the table shown in the description of the TokenInformation parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "TokenInformation",
        "description": "Pointer to a caller-supplied buffer containing the information to be modified in the token. The structure of the information in this buffer depends upon the value of TokenInformationClass, as shown in the following table. All structures must be aligned on a 32-bit boundary.   TokenInformationClass valueEffect on TokenInformation buffer  TokenDefaultDacl  The buffer contains a TOKEN_DEFAULT_DACL structure specifying the default DACL for newly created objects. TOKEN_ADJUST_DEFAULT access is required to set this information. The buffer contents are not validated for structural correctness or consistency.    TokenGroups  Not a valid information class. This information is read-only.    TokenOwner  The buffer contains a TOKEN_OWNER structure specifying the default owner SID for newly created objects. TOKEN_ADJUST_DEFAULT access is required to set this information. The owner values that may be specified are restricted to the user and group IDs with an attribute indicating they can be assigned as the owner of objects.    TokenPrimaryGroup  The buffer contains a TOKEN_PRIMARY_GROUP structure specifying the default primary group SID for newly created objects. TOKEN_ADJUST_DEFAULT access is required to set this information. Must be one of the group IDs already in the token.    TokenPrivileges  Not a valid information class. This information is read-only.    TokenSource  Not a valid information class. This information is read-only.    TokenStatistics  Not a valid information class. This information is read-only.    TokenUser  Not a valid information class. This information is read-only."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TokenInformationLength",
        "description": "Size, in bytes, of the structure passed in the TokenInformation buffer. Must be greater than or equal to the minimum value given in the following table.   TokenInformationClass valueMinimum TokenInformationLength  TokenDefaultDacl  sizeof(TOKEN_DEFAULT_DACL)    TokenOwner  sizeof(TOKEN_OWNER)    TokenPrimaryGroup  sizeof(TOKEN_PRIMARY_GROUP)"
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwSetInformationTransaction routine sets information for a specified transaction.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwSetInformationTransaction returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "For more information about ZwSetInformationTransaction, see Creating a Transactional Client. NtSetInformationTransaction and ZwSetInformationTransaction are two versions of the same Windows Native System Services routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetInformationTransaction",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "TransactionHandle",
        "description": "A handle to a transaction object that was obtained by a previous call to ZwCreateTransaction or ZwOpenTransaction. The handle must have TRANSACTION_SET_INFORMATION access to the object."
      },
      {
        "in_out": "_In_",
        "type": "TRANSACTION_INFORMATION_CLASS",
        "name": "TransactionInformationClass",
        "description": "A TRANSACTION_INFORMATION_CLASS-typed value that specifies the type of information to set. The value must be TransactionPropertiesInformation."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "TransactionInformation",
        "description": "A pointer to a caller-allocated buffer that contains the information to set. The buffer's structure type must be TRANSACTION_PROPERTIES_INFORMATION."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TransactionInformationLength",
        "description": "The length, in bytes, of the buffer that the TransactionInformation parameter points to."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ZwSetQuotaInformationFile routine changes quota entries for the volume associated with the FileHandle parameter. All of the quota entries in the specified buffer are applied to the volume.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "The ZwSetQuotaInformationFile routine returns STATUS_SUCCESS or an appropriate NTSTATUS value such as one of the following:  ",
    "remarks": "The ZwSetQuotaInformationFile routine applies all of the quota entries in the specified Buffer parameter to the volume. The IoCheckQuotaBufferValidity function can check whether the specified quota buffer passed as the Buffer parameter is valid. A call to ZwSetQuotaInformationFile will result in an IRP_MJ_SET_QUOTA request being sent to the device object that is associated with the file object whose handle is stored in the FileHandle parameter. If the underlying file system does not support quota information (FAT and CDFS file systems, for example), ZwSetQuotaInformationFile will fail returning STATUS_INVALID_DEVICE_REQUEST. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetQuotaInformationFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle for the file object that represents the file or volume for which the quota information is to be modified."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "The address of the caller's I/O status block."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "A buffer containing the new quota entries that should be applied to the volume. The quota information must be formatted as one or more FILE_QUOTA_INFORMATION structures. The NextEntryOffset field in the FILE_QUOTA_INFORMATION structure contains the offset, in bytes, of the next quota entry in the list. If there are no more entries after the current one, this member is zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "The length in bytes of the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwSetSecurityObject routine sets an object's security state.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwSetSecurityObject returns STATUS_SUCCESS or an appropriate error status. Possible error status codes include the following:  ",
    "remarks": "A security descriptor can be in absolute or self-relative form. In self-relative form, all members of the structure are located contiguously in memory. In absolute form, the structure only contains pointers to the members. For more information, see \"Absolute and Self-Relative Security Descriptors\" in the Security section of the Windows SDK documentation. For more information about security and access control, see the documentation on these topics in the Windows SDK. Minifilters should use FltSetSecurityObject instead of ZwSetSecurityObject. Callers of ZwSetSecurityObject must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetSecurityObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "Handle for the object whose security state is to be set. This handle must have the access specified in the Meaning column of the table shown in the description of the SecurityInformation parameter."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_INFORMATION",
        "name": "SecurityInformation",
        "description": "SECURITY_INFORMATION value specifying the information to be set. Can be a combination of one or more of the following.   ValueMeaning  DACL_SECURITY_INFORMATION  Indicates the discretionary access control list (DACL) of the object is to be set. Requires WRITE_DAC access.   GROUP_SECURITY_INFORMATION  Indicates the primary group identifier of the object is to be set. Requires WRITE_OWNER access.   OWNER_SECURITY_INFORMATION  Indicates the owner identifier of the object is to be set. Requires WRITE_OWNER access.   SACL_SECURITY_INFORMATION  Indicates the system ACL (SACL) of the object is to be set. Requires ACCESS_SYSTEM_SECURITY access."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to the security descriptor to be set for the object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwSetVolumeInformationFile routine modifies information about the volume associated with a given file, directory, storage device, or volume.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h)",
    "return_value": "ZwSetVolumeInformationFile returns STATUS_SUCCESS or an appropriate NTSTATUS value such as one of the following:  ",
    "remarks": "To query volume information, call ZwQueryVolumeInformationFile. To change information about a file, call ZwSetVolumeInformationFile. Minifilters should use FltSetInformationFile instead of ZwSetVolumeInformationFile. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSetVolumeInformationFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "Handle to a file object for an open file, directory, storage device, or volume whose volume information is to be modified."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the operation."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "FsInformation",
        "description": "Pointer to a caller-allocated buffer containing the volume information to be modified. The structure of the information in this buffer depends on the value of FsInformationClass, as shown in the following table."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Size in bytes of the buffer pointed to by FsInformation. The caller should set this parameter according to the given FsInformationClass."
      },
      {
        "in_out": "_In_",
        "type": "FS_INFORMATION_CLASS",
        "name": "FsInformationClass",
        "description": "Type of volume information to be set. One of the following:   ValueMeaning  FileFsControlInformation  Set FILE_FS_CONTROL_INFORMATION for the volume.    FileFsLabelInformation  Set FILE_FS_LABEL_INFORMATION for the volume.    FileFsObjectIdInformation  Set FILE_FS_OBJECTID_INFORMATION for the volume."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwSinglePhaseReject routine informs KTM that the calling resource manager will not support single-phase commit operations for a specified enlistment.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwSinglePhaseReject returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine might return one of the following values:  The routine might return other NTSTATUS values. ",
    "remarks": "A resource manager can call ZwSinglePhaseReject when it receives a TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT notification. For more information about ZwSinglePhaseReject, see Handling Commit Operations. NtSinglePhaseReject and ZwSinglePhaseReject are two versions of the same Windows Native System Services routine. The NtSinglePhaseReject routine in the Windows kernel is not directly accessible to kernel-mode drivers. However, kernel-mode drivers can access this routine indirectly by calling the ZwSinglePhaseReject routine. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwSinglePhaseReject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "EnlistmentHandle",
        "description": "A handle to an enlistment object that was obtained by a previous call to ZwCreateEnlistment or ZwOpenEnlistment. The handle must have ENLISTMENT_SUBORDINATE_RIGHTS access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "TmVirtualClock",
        "description": "A pointer to a virtual clock value. This parameter is optional and can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ZwTerminateProcess routine terminates a process and all of its threads.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "ZwTerminateProcess returns STATUS_SUCCESS if the operation succeeds. Additional return values include:  If the caller specifies the current process in the ProcessHandle parameter, ZwTerminateProcess does not return. ",
    "remarks": "To obtain a process handle that a driver can specify for the ProcessHandle parameter, the driver can call ZwOpenProcess. The handle must be a kernel handle. Drivers must not specify the current process if resources have not been freed from the kernel stack, because the operating system will not unwind the kernel stack for the calling thread. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwTerminateProcess",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "ProcessHandle",
        "description": "A handle to the process object that represents the process to be terminated."
      },
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "ExitStatus",
        "description": "An NTSTATUS value that the operating system uses as the final status for the process and each of its threads."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ZwUnloadDriver routine unloads a driver from the system. Use this routine with extreme caution. (See the following Remarks section.)",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ZwUnloadDriver returns STATUS_SUCCESS or an error NTSTATUS value such as STATUS_INVALID_DEVICE_REQUEST. ",
    "remarks": "ZwUnloadDriver dynamically unloads a device or file system driver from the currently running system. Note that a file system filter driver cannot safely be unloaded from a running system. Thus a filter should only use ZwUnloadDriver for debugging purposes. It should not call this routine in a retail version of the filter. If DriverName is the name of a PnP device driver, ZwUnloadDriver returns STATUS_INVALID_DEVICE_REQUEST and does not unload the driver. A minifilter should use FltUnloadFilter instead of ZwUnloadDriver to unload a supporting minifilter. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwUnloadDriver",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "DriverServiceName",
        "description": "Pointer to a counted Unicode string that specifies a path to the driver's registry key, \\Registry\\Machine\\System\\CurrentControlSet\\Services\\DriverName, where DriverName is the name of the driver."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The ZwUnlockFile routine unlocks a byte-range lock in a file.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "The ZwUnlockFile routine returns STATUS_SUCCESS on success or an appropriate NTSTATUS value. Possible NTSTATUS values include:  ",
    "remarks": "The ZwUnlockFile routine takes a range of bytes as specified by the ByteOffset and Length arguments. This range must be identical to a range of bytes in the file that was previously locked with a single call to the ZwUnlockFile routine. It is not possible to unlock two previously locked adjacent ranges with a single call to ZwUnlockFile. It is also not possible to unlock part of a range that was previously locked with a single call to the ZwUnlockFile routine. Callers of ZwUnlockFile must be running at IRQL = PASSIVE_LEVEL and with special kernel APCs enabled. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwUnlockFile",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "FileHandle",
        "description": "A handle for the file object that represents the file whose byte range is to be unlocked."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to an IO_STATUS_BLOCK structure that contains the final status."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "ByteOffset",
        "description": "A pointer to a variable that specifies the starting byte offset for the byte range to be unlocked."
      },
      {
        "in_out": "_In_",
        "type": "PLARGE_INTEGER",
        "name": "Length",
        "description": "A pointer to a variable that specifies the length, in bytes, of the byte range to unlock."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Key",
        "description": "The caller-assigned value used to describe groups of related locks. This value should be set to zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ZwWaitForSingleObject routine waits until the specified object attains a state of Signaled. An optional time-out can also be specified.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntifs.h (include Ntifs.h or FltKernel.h)",
    "return_value": "ZwWaitForSingleObject can return one of the following possible status codes:  Note that the NT_SUCCESS macro recognizes the STATUS_ALERTED, STATUS_SUCCESS, STATUS_TIMEOUT, and STATUS_USER_APC status values as \"success\" values. ",
    "remarks": "ZwWaitForSingleObject waits until the specified object attains a state of Signaled. An optional timeout can also be specified. ZwWaitForSingleObject examines the current state of the specified object to determine whether the wait can be satisfied immediately. If so, actions are performed. Otherwise, the current thread is put in a waiting state and a new thread is selected for execution on the current processor. If a Timeout parameter is not specified, then the wait will not be satisfied until the object attains a state of Signaled. If a Timeout parameter is specified, and the object has not attained a state of Signaled when the time-out expires, then the wait is automatically satisfied. If an explicit Timeout value of zero is specified, then no wait will occur if the wait cannot be satisfied immediately. A Timeout value of zero allows the testing of a set of wait conditions and for the conditional performance of any side effects if the wait can be immediately satisfied, as in the acquisition of a mutex. The wait can also be specified as alertable. The Alertable parameter specifies whether the thread can be alerted and its wait state consequently aborted. If the value of this parameter is FALSE then the thread cannot be alerted. The only exception to this rule is that of a terminating thread. Under certain circumstances a terminating thread can be alerted while it is in the process of winding down. A thread is automatically made alertable, for instance, when terminated by a user with a CTRL+C. If the value of Alertableis TRUE and one of the following conditions is present, the thread will be alerted: In the first of these two cases, the thread's wait is satisfied with a completion status of STATUS_ALERTED. In the second case, it is satisfied with a completion status of STATUS_USER_APC. The thread must be alertable for a user-mode APC to be delivered. This is not the case for kernel-mode APCs. A kernel-mode APC can be delivered and executed even though the thread is not alerted. Once the APC's execution completes, the thread's wait resumes. A thread is never alerted, nor is its wait aborted, by the delivery of a kernel-mode APC. The delivery of kernel-mode APCs to a waiting thread does not depend on whether the thread can be alerted. If the kernel-mode APC is a special kernel-mode APC, then the APC is delivered provided that the IRQL is less than APC_LEVEL. If the kernel-mode APC is a normal kernel-mode APC, then the APC is delivered provided that the following three conditions hold: (1) the IRQL is less than APC_LEVEL, (2) no kernel APC is in progress, and (3) the thread is not in a critical section. If the handle passed to ZwWaitForSingleObject refers to a mutex, the APC delivery is the same as for all other dispatcher objects during the wait. However, once ZwWaitForSingleObject returns with STATUS_SUCCESS and the thread actually holds the mutex, only special kernel-mode APCs are delivered. Delivery of all other APCs, both kernel-mode and user-mode, is disabled. This restriction on the delivery of APCs persists until the mutex is released. It is especially important to check the return value of ZwWaitForSingleObject when the Alertable parameter is TRUE, because ZwWaitForSingleObject might return early with a status of STATUS_USER_APC or STATUS_ALERTED. All long term waits can be aborted by a user if the Alertable parameter is set to FALSE. For additional information, see Do Waiting Threads Receive Alerts and APCs? Callers of ZwWaitForSingleObject must be running at IRQL less than or equal to DISPATCH_LEVEL. Usually, the caller must be running at IRQL PASSIVE_LEVEL and in a nonarbitrary thread context. A call while running at IRQL DISPATCH_LEVEL is valid if and only if the caller specifies a Timeout parameter of zero. That is, a driver must not wait for a nonzero interval at IRQL equal to DISPATCH_LEVEL. Time-out intervals are measured relative to the system clock, and the accuracy of the time-out measurement is limited by the granularity of the system clock. For more information, see Timer Accuracy. For calls from kernel-mode drivers, the NtXxx and ZwXxx versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the NtXxx and ZwXxx versions of a routine, see Using Nt and Zw Versions of the Native System Services Routines. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ZwWaitForSingleObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "A handle to the object."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Alertable",
        "description": "A boolean value that specifies whether the wait is alertable."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "Timeout",
        "description": "An optional pointer to a time-out value that specifies the absolute or relative time at which the wait is to be completed. A negative value specifies an interval relative to the current time. The value should be expressed in units of 100 nanoseconds. Absolute expiration times track any changes in the system time. Relative expiration times are not affected by system time changes."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "ASSERTMSG tests an expression. If the expression is false, it breaks into the kernel debugger and sends it the specified message.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Wdm.h or Ntddk.h)",
    "return_value": "None ",
    "remarks": "ASSERTMSG is identical to ASSERT, except that it sends an additional message to the debugger. This macro will only be included in your binary if your code is compiled in a Debug configuration. Once your driver is built, ASSERTMSG will work properly regardless of whether your driver is run on the checked build or on the free build of Windows. If Expression evaluates to TRUE, this routine has no effect. If Expression evaluates to FALSE, a message is displayed in the Debugger Command window. The message contains the source-code string of Expression, as well as the path of the source-code file and the line number of the instruction that called the macro. In this event, ASSERTMSG can be ignored and the process or thread in which ASSERTMSG occurred can be terminated. Alternatively, the debugger can be used to analyze the situation or to edit memory. If ASSERTMSG is ignored, execution continues as if the g (Go) command was entered. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ASSERTMSG",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "Message",
        "type": "",
        "name": "Message",
        "description": "Specifies the null-delimited string to be displayed by the debugger."
      },
      {
        "in_out": "Expression",
        "type": "",
        "name": "Expression",
        "description": "Specifies any logical expression."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The DbgBreakPoint routine breaks into the kernel debugger.",
    "library": "NtDll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Ntddk.h (include Wdm.h or Ntddk.h)",
    "return_value": "None ",
    "remarks": "The DbgBreakPoint routine is the kernel-mode equivalent of DebugBreak. This routine raises an exception that is handled by the kernel debugger if one is installed; otherwise, it is handled by the debug system. If a debugger is not connected to the system, the exception can be handled in the standard way. In kernel mode, a break exception that is not handled will cause a bug check. You can, however, connect a kernel-mode debugger to a target computer that has stopped responding and has kernel debugging enabled. For more information, see Windows Debugging. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "DbgBreakPoint",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The DbgBreakPointWithStatus routine breaks into the kernel debugger and sends the value of Status to the debugger.",
    "library": "Ntdll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "DbgBreakPointWithStatus is identical to DbgBreakPoint, except for the Status message. On x86 computers, the Status parameter is stored in the eax register. On machines that have register calling conventions, Status is stored in the first argument register. This routine raises an exception that is handled by the kernel debugger if one is installed; otherwise it is handled by the debug system. If a debugger is not connected to the system, the exception can be handled in the standard way. In kernel mode, a break exception that is not handled will cause a bug check. You can, however, connect a kernel-mode debugger to a target computer that has stopped responding and has kernel debugging enabled. For more information, see Windows Debugging. ",
    "return_type": "NTSYSAPI VOID",
    "category": "Drivers",
    "name": "DbgBreakPointWithStatus",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Status",
        "description": "Specifies a ULONG value that is sent to the debugger (for example, a status code or an address)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The DbgPrint routine sends a message to the kernel debugger.",
    "library": "NtDll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "If successful, DbgPrint returns the NTSTATUS code STATUS_SUCCESS; otherwise it returns the appropriate error code. ",
    "remarks": "DbgPrint and DbgPrintEx can be called at IRQL<=DIRQL. However, Unicode format codes (%wc and %ws) can be used only at IRQL=PASSIVE_LEVEL. Also, because the debugger uses interprocess interrupts (IPIs) to communicate with other processors, calling DbgPrint at IRQL>DIRQL can cause deadlocks. Only kernel-mode drivers can call the DbgPrint routine. In Microsoft Windows Server 2003 and earlier versions of Windows, the DbgPrint routine sends a message to the kernel debugger. In Windows Vista and later versions of Windows, DbgPrint sends a message only if certain conditions apply. Specifically, it behaves like the DbgPrintEx routine with the DEFAULT component and a message importance level of DPFLTR_INFO_LEVEL. In other words, the following two function calls are identical: For more information about message filtering, components, and message importance level, see Reading and Filtering Debugging Messages. Unless it is absolutely necessary, you should not obtain a string from user input or another process and pass it to DbgPrint. If you do use a string that you did not create, you must verify that this is a valid format string, and that the format codes match the argument list in type and quantity. The best coding practice is for all Format strings to be static and defined at compile time. There is no upper limit to the size of the Format string or the number of arguments. However, any single call to DbgPrint will only transmit 512 bytes of information. There is also a limit to the size of the DbgPrint buffer. See DbgPrint Buffer and the Debugger for details. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "DbgPrint",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCHAR",
        "name": "Format",
        "description": "Specifies a pointer to the format string to print. The Format string supports most of the printf-style format specification fields. However, the Unicode format codes (%C, %S, %lc, %ls, %wc, %ws, and %wZ) can only be used with IRQL = PASSIVE_LEVEL. The DbgPrint routine does not support any of the floating point types (%f, %e, %E, %g, %G, %a, or %A)."
      },
      {
        "in_out": "arguments",
        "type": "",
        "name": "arguments",
        "description": "Specifies arguments for the format string, as in printf."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The DbgPrintEx routine sends a string to the kernel debugger if the  conditions you specify are met.",
    "library": "NtDll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "If successful, DbgPrintEx returns the NTSTATUS code STATUS_SUCCESS; otherwise, it returns the appropriate error code. ",
    "remarks": "Only kernel-mode drivers can call the DbgPrintEx routine. DbgPrint and DbgPrintEx can be called at IRQL<=DIRQL. However, Unicode format codes (%wc and %ws) can be used only at IRQL = PASSIVE_LEVEL. Also, because the debugger uses interprocess interrupts (IPIs) to communicate with other processors, calling DbgPrint at IRQL>DIRQL can cause deadlocks. DbgPrintEx either passes the specified string to the kernel debugger or does nothing at all, depending on the values of ComponentId, Level, and the corresponding component filter masks. For details, see Reading and Filtering Debugging Messages. Unless it is absolutely necessary, you should not obtain a string from user input or another process and pass it to DbgPrintEx. If you do use a string that you did not create, you must verify that this is a valid format string, and that the format codes match the argument list in type and quantity. The best coding practice is for all Format strings to be static and defined at compile time. There is no upper limit to the size of the Format string or the number of arguments. However, any single call to DbgPrintEx will only transmit 512 bytes of information. There is also a limit to the size of the DbgPrint buffer. See The DbgPrint Buffer and the Debugger for details. ",
    "return_type": "ULONG __cdecl",
    "category": "Drivers",
    "name": "DbgPrintEx",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ComponentId",
        "description": "Specifies the component calling this routine. This must be one of the component name filter IDs defined in the Dpfilter.h header file. To avoid mixing your driver's output with the output of Windows components, you should use only the following values for ComponentId:   DPFLTR_IHVVIDEO_ID    DPFLTR_IHVAUDIO_ID    DPFLTR_IHVNETWORK_ID    DPFLTR_IHVSTREAMING_ID    DPFLTR_IHVBUS_ID    DPFLTR_IHVDRIVER_ID"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Level",
        "description": "Specifies the severity of the message being sent. This can be any 32-bit integer. Values between 0 and 31 (inclusive) are treated differently than values between 32 and 0xFFFFFFFF. For details, see Reading and Filtering Debugging Messages."
      },
      {
        "in_out": "_In_",
        "type": "PCSTR",
        "name": "Format",
        "description": "Specifies a pointer to the format string to print. The Format string supports most of the printf-style format specification fields. However, the Unicode format codes (%C, %S, %lc, %ls, %wc, %ws, and %wZ) can only be used with IRQL = PASSIVE_LEVEL. The DbgPrintEx routine does not support any of the floating point types (%f, %e, %E, %g, %G, %a, or %A)."
      },
      {
        "in_out": "",
        "type": "...",
        "name": "arguments",
        "description": "Specifies arguments for the format string, as in printf."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The DbgPrompt routine displays a caller-specified user prompt string on the kernel debugger's display device and obtains a user response string.",
    "library": "NtDll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "DbgPrompt returns the number of characters that the Response buffer received, including the terminating newline character. DbgPrompt returns zero if it receives no characters. ",
    "remarks": "The DbgPrompt routine displays the specified prompt string on the kernel debugger's display device and then reads a line of user input text. After DbgPrompt returns, the Response buffer contains the user's response, including the terminating newline character. The user response string is not NULL-terminated. The following code example asks if the user wants to continue and accepts the letter \"y\" for yes and the letter \"n\" for no. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "DbgPrompt",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCCH",
        "name": "Prompt",
        "description": "A pointer to a NULL-terminated constant character string that the debugger will display as a user prompt. The maximum size of this string is 512 characters."
      },
      {
        "in_out": "_Out_",
        "type": "PCHAR",
        "name": "Response",
        "description": "A pointer to a character array buffer that receives the user's response, including a terminating newline character. The maximum size of this buffer is 512 characters."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaximumResponseLength",
        "description": "The size, in characters, of the buffer that receives the user's response. This size is the maximum number of characters that the routine will return."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KdBreakPoint macro breaks into the kernel debugger.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Wdm.h or Ntddk.h)",
    "return_value": "None ",
    "remarks": "KdBreakPoint is the kernel-mode equivalent of the DebugBreak  routine. KdBreakPoint is identical to the DbgBreakPoint routine in code that is compiled for a debug configuration. It has no effect if compiled for a release configuration. This routine raises an exception that is handled by the kernel debugger if one is installed; otherwise it is handled by the debug system. If a debugger is not connected to the system, the exception can be handled in the standard way. In kernel mode, a break exception that is not handled will cause a bug check. You can, however, connect a kernel-mode debugger to a target computer that has stopped responding and has kernel debugging enabled. For more information, see Windows Debugging. ",
    "return_type": "VOID NTAPI",
    "category": "Drivers",
    "name": "KdBreakPoint",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoCompletion routine completes the processing of I/O operations.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the IoCompletion routine determines that additional processing is required for the IRP, it must return STATUS_MORE_PROCESSING_REQUIRED. For more information, see the following Remarks section. Otherwise, it should return STATUS_SUCCESS. (The I/O manager only checks for the presence or absence of STATUS_MORE_PROCESSING_REQUIRED.) ",
    "remarks": "A driver's IoCompletion routine executes in an arbitrary thread or DPC context, and at an IRQL that is less than or equal to DISPATCH_LEVEL. Because code written to execute at DISPATCH_LEVEL will also execute at lower levels, IoCompletion routines should be designed for execution at DISPATCH_LEVEL. However, because these routines are not guaranteed to run at DISPATCH_LEVEL, they must not call system routines that actually require execution at DISPATCH_LEVEL. (For more information about IRQLs, see Managing Hardware Priorities.) To register an IoCompletion routine for a specific IRP, a driver must call IoSetCompletionRoutine or IoSetCompletionRoutineEx, which stores the IoCompletion routine's address in the next-lower driver's I/O stack location. (Thus, a lowest-level driver cannot register an IoCompletion routine.) A driver typically calls IoSetCompletionRoutine or IoSetCompletionRoutineEx from one of its dispatch routines, each time an IRP is received. Most drivers, including all PnP drivers, can use IoSetCompletionRoutine to register their IoCompletion routine. Non-PnP drivers that may be unloaded before their IoCompletion routine executes should use IoSetCompletionRoutineEx instead. When any driver completes an IRP, it calls IoCompleteRequest, which in turn calls the IoCompletion routine of each higher-level driver, from the next-highest to the highest, until all higher IoCompletion routines have been called or until one routine returns STATUS_MORE_PROCESSING_REQUIRED. When you create the IRP, allocate a stack location for the current driver as well as any lower drivers. If you do not allocate sufficient stack locations, the DeviceObject pointer might be set to NULL when the completion routine is called. You can avoid allocating extra stack location for the current driver if you use the Context field to pass information to IoCompletion rather then relying on the DeviceObject parameter. If an IoCompletion routine returns STATUS_MORE_PROCESSING_REQUIRED, the lower driver's call to IoCompleteRequest immediately returns. In this case, a higher-level driver will have to call IoCompleteRequest to complete the IRP. For more information about implementing IoCompletion routines, see Completing IRPs. To define an IoCompletion callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define an IoCompletion callback routine that is named MyIoCompletion, use the IO_COMPLETION_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The IO_COMPLETION_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the IO_COMPLETION_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "IO_COMPLETION_ROUTINE IoCompletion; NTSTATUS",
    "category": "Drivers",
    "name": "IoCompletion",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Caller-supplied pointer to an IRP structure that describes the I/O operation."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Caller-supplied pointer to driver-specific context information, previously supplied when calling IoSetCompletionRoutine or IoSetCompletionRoutineEx. Context information must be stored in nonpaged memory, since an IoCompletion routine can be called at DISPATCH_LEVEL. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The IoBuildSynchronousFsdRequest routine allocates and sets up an IRP for a synchronously processed I/O request.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the operation succeeds, IoBuildSynchronousFsdRequest returns a pointer to an initialized IRP structure, with the next-lower driver's I/O stack location set up from the supplied parameters. Otherwise, the routine returns NULL. ",
    "remarks": "A file system driver (FSD) or other higher-level driver can call IoBuildSynchronousFsdRequest to set up IRPs that it synchronously sends to lower-level drivers. IoBuildSynchronousFsdRequest allocates and sets up an IRP that requests lower-level drivers to perform a synchronous read, write, flush, or shutdown operation. The IRP contains enough information to start the operation. Lower-level drivers might impose restrictions on parameters supplied to this routine. For example, disk drivers might require that values supplied for Length and StartingOffset be integer multiples of the device's sector size. After calling IoBuildSynchronousFsdRequest to create a request, the driver must call IoCallDriver to send the request to the next-lower driver. If IoCallDriver returns STATUS_PENDING, the driver must wait for the completion of the IRP by calling KeWaitForSingleObject on the given Event. Most drivers do not need to set an IoCompletion routine for the IRP. IRPs that are created by IoBuildSynchronousFsdRequest must be completed by a driver's call to IoCompleteRequest. A driver that calls IoBuildSynchronousFsdRequest must not call IoFreeIrp, because the I/O manager frees these synchronous IRPs after IoCompleteRequest has been called. IoBuildSynchronousFsdRequest queues the IRPs that it creates to an IRP queue that is specific to the current thread. If the thread exits, the I/O manager cancels the IRP. ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoBuildSynchronousFsdRequest",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MajorFunction",
        "description": "The major function code for the IRP. This code can be IRP_MJ_PNP, IRP_MJ_READ, IRP_MJ_WRITE, IRP_MJ_FLUSH_BUFFERS, or IRP_MJ_SHUTDOWN."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the DEVICE_OBJECT structure for the next-lower driver's device object, which represents the target device."
      },
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "A pointer to a data buffer. If MajorFunction is IRP_MJ_WRITE, the buffer contains data to be written. If MajorFunction is IRP_MJ_READ, the buffer receives data. If MajorFunction is IRP_MJ_FLUSH_BUFFERS or IRP_MJ_SHUTDOWN, this parameter must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "Length",
        "description": "The length, in bytes, of the buffer pointed to by Buffer. For devices such as disks, this value must be an integer multiple of the sector size. Starting with Windows 8, the sector size can be 4,096 or 512 bytes. In earlier versions of Windows, the sector size is always 512 bytes. This parameter is required for read and write requests, but must be zero for flush and shutdown requests."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLARGE_INTEGER",
        "name": "StartingOffset",
        "description": "A pointer to the offset on the disk, for read and write requests. The units and meaning of this value are driver-specific. This parameter is required for read and write requests, but must be zero for flush and shutdown requests."
      },
      {
        "in_out": "_In_",
        "type": "PKEVENT",
        "name": "Event",
        "description": "A pointer to a caller-allocated and initialized event object. The I/O manager sets the event to the Signaled state when a lower-level driver completes the requested operation. After calling IoCallDriver, the driver can wait for the event object."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "A pointer to a location that receives the I/O status block that is set when the IRP is completed by a lower-level driver."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 9,
    "description": "The IoBuildDeviceIoControlRequest routine allocates and sets up an IRP for a synchronously processed device control request.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the operation succeeds, IoBuildDeviceIoControlRequest returns a pointer to an IRP, with the next-lower driver's I/O stack location set up from the supplied parameters. Otherwise, the routine returns NULL. ",
    "remarks": "A driver can call IoBuildDeviceIoControlRequest to set up IRPs for device control requests that it synchronously sends to lower-level drivers. After calling IoBuildDeviceIoControlRequest to create a request, the driver must call IoCallDriver to send the request to the next-lower driver. If IoCallDriver returns STATUS_PENDING, the driver must wait for the completion of the IRP by calling KeWaitForSingleObject on the given Event. Most drivers do not need to set an IoCompletion routine for the IRP. IRPs that are created by IoBuildDeviceIoControlRequest must be completed by a driver's call to IoCompleteRequest. A driver that calls IoBuildDeviceIoControlRequest must not call IoFreeIrp, because the I/O manager frees these synchronous IRPs after IoCompleteRequest has been called. IoBuildDeviceIoControlRequest queues the IRPs that it creates to an IRP queue that is specific to the current thread. If the thread exits, the I/O manager cancels the IRP. If the caller supplies an InputBuffer or OutputBuffer parameter, this parameter must point to a buffer that resides in system memory. The caller is responsible for validating any parameter values that it copies into the input buffer from a user-mode buffer. The input buffer might contain parameter values that are interpreted differently depending on whether the originator of the request is a user-mode application or a kernel-mode driver. In the IRP that IoBuildDeviceIoControlRequest returns, the RequestorMode field is always set to KernelMode. This value indicates that the request, and any information contained in the request, is from a trusted, kernel-mode component. If the caller cannot validate parameter values that it copies from a user-mode buffer to the input buffer, or if these values must not be interpreted as coming from a kernel-mode component, the caller should set the RequestorMode field in the IRP to UserMode. This setting informs the driver that handles the I/O control request that the buffer contains untrusted, user-mode data. The actual method by which the contents of the InputBuffer and OutputBuffer parameters are stored in the IRP depends on the TransferType value for the IOCTL. For more information about this value, see Buffer Descriptions for I/O Control Codes. ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoBuildDeviceIoControlRequest",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "IoControlCode",
        "description": "Supplies the I/O control code (IOCTL) to be used in the request. For information about device type-specific I/O control codes, see device type-specific sections in the Windows Driver Kit (WDK)."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Supplies a pointer to the DEVICE_OBJECT structure for the next-lower driver's device object, which represents the target device."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "InputBuffer",
        "description": "Supplies a pointer to an input buffer to be passed to the lower driver, or NULL if the request does not pass input data to lower drivers."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InputBufferLength",
        "description": "Supplies the length, in bytes, of the input buffer. If InputBuffer is NULL, InputBufferLength must be zero."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "OutputBuffer",
        "description": "Supplies a pointer to an output buffer in which the lower driver is to return data, or NULL if the request does not require lower drivers to return data."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "OutputBufferLength",
        "description": "Supplies the length, in bytes, of the output buffer. If OutputBuffer is NULL, OutputBufferLength must be zero."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InternalDeviceIoControl",
        "description": "If TRUE, the routine sets the IRP's major function code to IRP_MJ_INTERNAL_DEVICE_CONTROL. Otherwise, the routine sets the IRP's major function code to IRP_MJ_DEVICE_CONTROL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PKEVENT",
        "name": "Event",
        "description": "Supplies a pointer to a caller-allocated and initialized event object. The I/O manager sets the event to the Signaled state when a lower-level driver completes the requested operation. After calling IoCallDriver, the driver can wait for the event object. The Event parameter is optional and can be set to NULL. However, if Event is NULL, the caller must supply an IoCompletion routine for the IRP to notify the caller when the operation completes."
      },
      {
        "in_out": "_Out_",
        "type": "PIO_STATUS_BLOCK",
        "name": "IoStatusBlock",
        "description": "Specifies an I/O status block to be set when the request is completed by lower drivers."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The PoRequestPowerIrp routine allocates a power IRP and sends it to the top driver in the device stack for the specified device.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PoRequestPowerIrp returns one of the following:  ",
    "remarks": "A device power policy owner calls this routine to send a wait/wake, query, or set-power IRP. A driver calls PoRequestPowerIrp\u00e2\u0080\u0094not IoAllocateIrp\u00e2\u0080\u0094to allocate and send a power IRP that has minor IRP code IRP_MN_SET_POWER, IRP_MN_QUERY_POWER, or IRP_MN_WAIT_WAKE. (A driver must call IoAllocateIrp to send a power IRP with minor IRP code IRP_MN_POWER_SEQUENCE.) If PoRequestPowerIrp returns a status value of STATUS_PENDING, the routine successfully allocated a device power IRP and sent it to the top of the device stack for the device. After the bus driver and all other drivers have completed the IRP, and the I/O manager has called all IoCompletion routines set by drivers as they passed the IRP down the device stack, the I/O manager calls the PowerCompletion routine and passes to this routine the specified Context value. If PoRequestPowerIrp returns a status other than STATUS_PENDING, the routine did not send a device power IRP and the PowerCompletion routine is not called. The PowerCompletion routine performs any additional tasks the sender of the IRP requires after all other drivers have completed the IRP. It need not free the IRP; the power manager does that. In Windows 2000 and later versions of Windows, the PowerCompletion routine can be called at IRQL = PASSIVE_LEVEL or IRQL = DISPATCH_LEVEL. In Windows 98/Me, the PowerCompletion routine is always called at IRQL = PASSIVE_LEVEL, and drivers must complete IRPs at IRQL = PASSIVE_LEVEL. A device power policy owner calls PoRequestPowerIrp to send a device query- or set-power IRP when it receives a system query- or set-power IRP. The driver should set an IoCompletion routine in the system IRP and pass the system IRP to the next lower driver. The IoCompletion routine calls PoRequestPowerIrp to send the device IRP, passing the system IRP in the Context parameter. The Context parameter is subsequently passed to the PowerCompletion routine for the device IRP. In the PowerCompletion routine, the driver can complete the system IRP. For more information, see Sending IRP_MN_QUERY_POWER or IRP_MN_SET_POWER for Device Power States and Wait/Wake Callback Routines. Drivers can use the returned Irp to cancel an IRP_MN_WAIT_WAKE IRP. Drivers that are requesting other types of power IRPs must pass NULL for this parameter. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PoRequestPowerIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the target DEVICE_OBJECT for the IRP. In Windows 2000 and later versions of Windows, this parameter can point to a physical device object (PDO) or a functional device object (FDO). In Windows 98/Me, this parameter must point to the PDO of the underlying device."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR",
        "name": "MinorFunction",
        "description": "Specifies one of the following minor power IRP codes: IRP_MN_QUERY_POWER, IRP_MN_SET_POWER, or IRP_MN_WAIT_WAKE."
      },
      {
        "in_out": "_In_",
        "type": "POWER_STATE",
        "name": "PowerState",
        "description": "Specifies a POWER_STATE value to pass in the IRP. For IRP_MN_SET_POWER and IRP_MN_QUERY_POWER, specify the requested new device power state. Possible values are DEVICE_POWER_STATE values. For IRP_MN_WAIT_WAKE, specify the lowest (least-powered) system power state from which the device should be allowed to wake the system. Possible values are SYSTEM_POWER_STATE values."
      },
      {
        "in_out": "_In_opt_",
        "type": "PREQUEST_POWER_COMPLETE",
        "name": "CompletionFunction",
        "description": "A pointer to the caller's PowerCompletion callback routine. The I/O manager calls this routine when the IRP has completed. This parameter is optional and can be set to NULL if no PowerCompletion callback routine is needed."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "A pointer to a caller-supplied context to be passed through to the PowerCompletion callback. When the caller requests a device set-power IRP in response to a system set-power IRP, Context should contain the system set-power IRP that triggered the request."
      },
      {
        "in_out": "_Out_",
        "type": "PIRP*",
        "name": "Irp",
        "description": "A pointer to a caller-supplied variable in which PoRequestPowerIrp returns a pointer to the IRP that it allocates. Specify a value for Irp only if the MinorFunction parameter is set to IRP_MN_WAIT_WAKE. Otherwise, this parameter should always be NULL because the IRP might be completed before PoRequestPowerIrp returns, causing this parameter to point to memory that has already been discarded."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoSizeOfIrp routine determines the size in bytes for an IRP, given the number of stack locations in the IRP.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoSizeOfIrp returns the size, in bytes, of the IRP. ",
    "remarks": "The input StackSize value is either that of the next-lower driver's device object or one more than that value. ",
    "return_type": "USHORT",
    "category": "Drivers",
    "name": "IoSizeOfIrp",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "StackSize",
        "description": "Specifies the number of stack locations for the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoAllocateIrp routine allocates an IRP, given the number of I/O stack locations for each driver layered under the caller, and, optionally, for the caller.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoAllocateIrp returns a pointer to an IRP, which was allocated from nonpaged system space, or NULL if an IRP could not be allocated. ",
    "remarks": "The IoAllocateIrp routine does not associate the IRP with a thread. The allocating driver must free the IRP instead of completing it back to the I/O manager. An intermediate or highest-level driver can call IoAllocateIrp to create IRPs for requests it sends to lower-level drivers. Such a driver must initialize the IRP and must set its IoCompletion routine in the IRP it creates so the caller can dispose of the IRP when lower-level drivers have completed processing of the request. IoAllocateIrp automatically initializes the IRP's members. Do not use IoInitializeIrp to initialize the IRP before its first use. (You can use IoInitializeIrp to reuse an IRP that you have already used under certain special circumstances. See Reusing IRPs for details.) An intermediate or highest-level driver also can call IoBuildDeviceIoControlRequest, IoBuildAsynchronousFsdRequest or IoBuildSynchronousFsdRequest to set up requests it sends to lower-level drivers. Only a highest-level driver can call IoMakeAssociatedIrp. ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoAllocateIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "StackSize",
        "description": "Specifies the number of I/O stack locations to be allocated for the IRP. This value must be at least equal to the StackSize of the next-lower driver's device object, but can be one greater than this value. The calling driver need not allocate a stack location in the IRP for itself."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "ChargeQuota",
        "description": "Setting this to TRUE causes the memory allocated for the IRP to be charged against the quota for the current process. Should be set to FALSE by intermediate drivers. This can be set to TRUE only by highest-level drivers that are called in the context of the thread that originates the I/O request for which the driver is allocating another IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoInitializeIrp routine initializes a given IRP that was allocated by the caller.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers use IoInitializeIrp to initialize IRPs the driver allocated as raw memory. Do not use IoInitializeIrp to initialize an IRP allocated by IoAllocateIrp. IoAllocateIrp automatically initializes the members of the IRP. Drivers can use IoInitializeIrp to reinitialize an IRP for reuse only under certain circumstances. See Reusing IRPs for details. If the driver associates an MDL with the IRP it allocated, the driver is responsible for releasing the MDL when the IRP is completed. An intermediate or highest-level driver also can call IoBuildDeviceIoControlRequest, IoBuildAsynchronousFsdRequest, or IoBuildSynchronousFsdRequest to set up requests it sends to lower-level drivers. Only a highest-level driver can call IoMakeAssociatedIrp. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoInitializeIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP to be initialized."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "PacketSize",
        "description": "Specifies the size in bytes of the IRP."
      },
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "StackSize",
        "description": "Specifies the number of stack locations in the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoSetNextIrpStackLocation routine sets the IRP stack location in a driver-allocated IRP to that of the caller.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "In general, this routine is seldom used by drivers. It is primarily used by drivers that require their own stack location in an IRP that they have allocated, on their own, to send to another driver. IoSetNextIrpStackLocation is generally not needed because either: Care should be taken if this routine is called, especially when allocating the IRP with IoAllocateIrp or IoMakeAssociatedIrp. The writer of the allocating driver must remember that a caller-specific stack location is not included in the number of stack locations required by the lower-level drivers to which it sends IRPs with IoCallDriver. A driver must explicitly specify a stack location for itself in its call to IoAllocateIrp or IoMakeAssociatedIrp if it calls IoSetNextIrpStackLocation with the IRP returned by either routine. A driver cannot call IoSetNextIrpStackLocation with any IRP it allocates by calling IoBuildAsynchronousFsdRequest, IoBuildDeviceIoControlRequest, or IoBuildSynchronousFsdRequest. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoSetNextIrpStackLocation",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP whose stack location is to be set."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "This routine is reserved for use by file systems and file system filter drivers. The IoMakeAssociatedIrp routine allocates and initializes an IRP to be associated with a master IRP sent to a highest-level driver, allowing the caller to split the original request and send associated IRPs on to lower-level drivers.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoMakeAssociatedIrp returns a pointer to the associated IRP or returns a NULL pointer if an IRP cannot be allocated. ",
    "remarks": "Only a highest-level driver can call this routine. The I/O manager completes the master IRP automatically when lower drivers have completed all associated IRPs as long as the caller has not set its IoCompletion routine in an associated IRP and returned STATUS_MORE_PROCESSING_REQUIRED from its IoCompletion routine. In these circumstances, the caller must explicitly complete the master IRP when that driver has determined that all associated IRPs were completed. Only the master IRP is associated with a thread; associated IRPs are not. For this reason, the I/O manager cannot call Cancel routines for associated IRPs when a thread exits. When the master IRP's thread exits, the I/O manager calls the master IRP's Cancel routine. The Cancel routine is responsible for tracking down all associated IRPs and calling IoCancelIrp to cancel them. ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoMakeAssociatedIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the master IRP that was input to a highest-level driver's Dispatch routine."
      },
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "StackSize",
        "description": "Specifies the number of stack locations to be allocated for the associated IRP. The value must be at least equal to the StackSize of the next-lower driver's device object, but the associated IRP can have an additional stack location for the caller."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 7,
    "description": "The IoSetCompletionRoutineEx routine registers an IoCompletion routine, which is called when the next-lower-level driver has completed the requested operation for the given IRP.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine returns STATUS_SUCCESS on success, or STATUS_INSUFFICIENT_RESOURCES if insufficient memory is available for the operation. ",
    "remarks": "The IoCompletion routine must belong to the driver that owns the device object pointed to by DeviceObject. This requirement prevents the IoCompletion routine from being unloaded before it returns. The behavior of IoSetCompletionRoutineEx is the same as the IoSetCompletionRoutine routine, except that: ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoSetCompletionRoutineEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the driver's device object."
      },
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP that the driver is processing."
      },
      {
        "in_out": "_In_",
        "type": "PIO_COMPLETION_ROUTINE",
        "name": "CompletionRoutine",
        "description": "Specifies the entry point for the driver-supplied IoCompletion routine, which is called when the next-lower driver completes the packet."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to a driver-determined context to pass to the IoCompletion routine. Context information must be stored in nonpaged memory, because the IoCompletion routine is called at IRQL <= DISPATCH_LEVEL."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InvokeOnSuccess",
        "description": "Specifies whether the completion routine is called if the IRP is completed with a success status value in the IRP's IO_STATUS_BLOCK structure, based on results of the NT_SUCCESS macro (see Using NTSTATUS values)."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InvokeOnError",
        "description": "Specifies whether the completion routine is called if the IRP is completed with a nonsuccess status value in the IRP's IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InvokeOnCancel",
        "description": "Specifies whether the completion routine is called if a driver or the kernel has called IoCancelIrp to cancel the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoCallDriver routine sends an IRP to the driver associated with a specified device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoCallDriver returns the NTSTATUS value that a lower driver set in the I/O status block for the given request, or STATUS_PENDING if the request was queued for additional processing. ",
    "remarks": "Before calling IoCallDriver, the calling driver must set up the I/O stack location in the IRP for the target driver. For more information, see Passing IRPs Down the Driver Stack. IoCallDriver assigns the DeviceObject input parameter to the DeviceObject member of the IO_STACK_LOCATION structure for the driver being called. An IRP passed in a call to IoCallDriver becomes inaccessible to the higher-level driver, unless the higher-level driver has called IoSetCompletionRoutine to set up an IoCompletion routine for the IRP. If it has, the IRP input to the IoCompletion routine has its I/O status block set by the lower drivers, and all lower-level drivers' I/O stack locations are filled with zeros. Drivers for Windows Server 2003, Windows XP, and Windows 2000 must use PoCallDriver rather than IoCallDriver to pass power IRPs (IRP_MJ_POWER). For more information, see Calling IoCallDriver vs. Calling PoCallDriver. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "IoCallDriver",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to a device object, representing the target device for the requested I/O operation."
      },
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoFreeIrp routine releases a caller-allocated IRP from the caller's IoCompletion routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine is the reciprocal to IoAllocateIrp or IoBuildAsynchronousFsdRequest. The released IRP must have been allocated by the caller. This routine also releases an IRP allocated with IoMakeAssociatedIrp in which the caller set up its IoCompletion routine that returns STATUS_MORE_PROCESSING_REQUIRED for the associated IRP. IoFreeIrp does not free any MDLs that might be attached to the IRP. The driver that frees the IRP must explicitly free these MDLs. In addition, if the physical pages that are described by an MDL are locked, the driver must unlock the pages before it frees the MDL. However, the driver does not need to explicitly unmap these pages. Instead, IoFreeMdl automatically unmaps the pages when it frees the MDL. For a code example that shows how to free an MDL chain, see Using MDLs. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoFreeIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP that is to be released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoReuseIrp routine reinitializes an IRP so that it can be reused.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "Drivers for Windows 2000 and later versions of Windows use IoReuseIrp to reuse an IRP. A driver should use IoReuseIrp only on IRPs it previously allocated either as raw memory or with IoAllocateIrp. In particular, drivers should not use this routine for IRPs created with IoMakeAssociatedIrp, IoBuildSynchronousFsdRequest, IoBuildAsynchronousFsdRequest, or IoBuildDeviceIoControlRequest. See Reusing IRPs for more details on how to reuse IRPs. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoReuseIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP to be reinitialized for reuse."
      },
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "Status",
        "description": "Specifies the NTSTATUS value to be set in the IRP after it is reinitialized."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The PoCallDriver routine passes a power IRP to the next-lower driver in the device stack. (Windows Server 2003, Windows XP, and Windows 2000 only.)",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "PoCallDriver returns STATUS_SUCCESS to indicate success. It returns STATUS_PENDING if it has queued the IRP. ",
    "remarks": "Beginning with Windows Vista, drivers should call IoCallDriver, not PoCallDriver to pass a power IRP to the next-lower driver. However, on Windows Server 2003, Windows XP, and Windows 2000, drivers must call PoCallDriver, not IoCallDriver  to pass a power IRP to the next-lower driver. On Windows Server 2003, Windows XP, an Windows 2000, drivers must also call PoStartNextPowerIrp before calling PoCallDriver. A driver that requires a new IRP should call PoRequestPowerIrp. A driver must not allocate its own power IRP. When passing a power IRP down to the next-lower driver, the caller should use IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to set the IRP stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext if processing the IRP requires setting an IoCompletion routine, or IoSkipCurrentStackLocation if no IoCompletion routine is required. When a device is powering up, its drivers must set IoCompletion routines to perform start-up tasks (initializing the device, restoring context, and so on) after the bus driver has set the device in the working state. Set IoCompletion routines before calling PoCallDriver. When a device is powering down, its drivers must perform necessary power-down tasks before passing the IRP to the next lower driver. After the IRP has reached the bus driver, the device will be powered off and its drivers will no longer have access to it. On Windows Server 2003, Windows XP, and Windows 2000, an IoCompletion routine that is associated with a power-down IRP is only required to call PoStartNextPowerIrp. Only one inrush IRP can be active in the system at a time. When passing a power-up IRP for a device that requires inrush current (in other words, the DO_POWER_INRUSH flag is set in the device object), PoCallDriver checks whether another inrush IRP is already active. If so, PoCallDriver queues the current IRP for handling after the previous IRP completes, and then returns STATUS_PENDING. For more information about inrush IRPs, see Setting Device Object Flags for Power Management. If an IRP_MN_SET_POWER or IRP_MN_QUERY_POWER request is already active for DeviceObject, PoCallDriver queues this IRP and returns STATUS_PENDING. On Windows 2000 and later systems, pageable drivers (the DO_POWER_PAGABLE flag is set in the device object) must call PoCallDriver at IRQL = PASSIVE_LEVEL. Drivers that cannot be paged (DO_POWER_PAGABLE is not set in the device object) or that require inrush current (DO_POWER_INRUSH is set in the device object) can call PoCallDriver at IRQL = PASSIVE_LEVEL or DISPATCH_LEVEL. On Windows 98/Me, all drivers call PoCallDriver at IRQL = PASSIVE_LEVEL. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "PoCallDriver",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "A pointer to the driver-created DEVICE_OBJECT to which the IRP is to be routed."
      },
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to an IRP."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoForwardIrpSynchronously routine sends an IRP to a specified driver and waits for that driver to complete the IRP.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoForwardIrpSynchronously returns TRUE if the IRP is sent successfully. Otherwise, it returns FALSE. ",
    "remarks": "Use the IoForwardIrpSynchronously routine to synchronously forward the current IRP to the next driver in the stack. (To asynchronously forward the IRP, use the IoCopyCurrentIrpStackLocationToNext, IoCallDriver, and IoSetCompletionRoutine routines.) The IoForwardIrpSynchronously routine copies the current stack location to the next stack location. That stack location is then used as the current stack location by the driver specified in DeviceObject. If no next stack location is available, the routine returns FALSE. If the routine returns TRUE, then the IRP has been sent to the specified driver, and that driver has completed its processing of this IRP. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IoForwardIrpSynchronously",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Specifies the device object of the driver to which the IRP is sent."
      },
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Specifies the IRP to send."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoMarkIrpPending routine marks the specified IRP, indicating that a driver's dispatch routine subsequently returned STATUS_PENDING because further processing is required by other driver routines.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Unless the driver's dispatch routine completes the IRP (by calling IoCompleteRequest) or passes the IRP on to lower drivers, it must call IoMarkIrpPending with the IRP. Otherwise, the I/O manager attempts to complete the IRP as soon as the dispatch routine returns control. After calling IoMarkIrpPending, the dispatch routine must return STATUS_PENDING, even if some routine completes the IRP (by calling IoCompleteRequest) before the dispatch routine that called IoMarkIrpPending returns. If a driver queues incoming IRPs, it should call IoMarkIrpPending before it queues each IRP. Otherwise, an IRP could be dequeued, completed by another driver routine, and freed by the system before the call to IoMarkIrpPending occurs, thereby causing a crash. If a driver sets an IoCompletion routine for an IRP and then passes the IRP down to a lower driver, the IoCompletion routine should check the IRP->PendingReturned flag. If the flag is set, the IoCompletion routine must call IoMarkIrpPending with the IRP. (IoCompletion routines do not return STATUS_PENDING, however. For more information, see Implementing an IoCompletion Routine.) A driver that passes down the IRP and then waits on an event should not mark the IRP pending. Instead, its IoCompletion routine should signal the event and return STATUS_MORE_PROCESSING_REQUIRED. If your driver calls IoSkipCurrentIrpStackLocation, be careful not to modify the IO_STACK_LOCATION structure in a way that could unintentionally affect the lower driver or the system's behavior with respect to that driver. In particular, your driver should not modify the IO_STACK_LOCATION structure's Parameters union, and should not call IoMarkIrpPending. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoMarkIrpPending",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP to be marked as pending."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoStartPacket routine calls the driver's StartIo routine with the given IRP or inserts the IRP into the device queue associated with the given device object if the device is already busy.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If the driver is already busy processing a request for the target device object, then the packet is queued in the device queue. Otherwise, this routine calls the driver's StartIo routine with the specified IRP. If a non-NULL CancelFunction pointer is supplied, it is set in the IRP so the driver's Cancel routine is called if the IRP is canceled before its completion. Drivers that do not have a StartIo routine cannot call IoStartPacket. Callers of IoStartPacket must be running at IRQL <= DISPATCH_LEVEL. Usually, this routine is called from a device driver's Dispatch routine at IRQL = PASSIVE_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoStartPacket",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the target device object for the IRP."
      },
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP to be processed."
      },
      {
        "in_out": "_In_opt_",
        "type": "PULONG",
        "name": "Key",
        "description": "Pointer to a value that determines where to insert the packet into the device queue. If this is zero, the packet is inserted at the tail of the device queue."
      },
      {
        "in_out": "_In_opt_",
        "type": "PDRIVER_CANCEL",
        "name": "CancelFunction",
        "description": "Specifies the entry point for a driver-supplied Cancel routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The StartIo routine starts the I/O operation described by an IRP.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver's StartIo routine executes in an arbitrary thread context at IRQL = DISPATCH_LEVEL. The StartIo routine is optional. A driver's StartIo routine, if supplied, should be named XxxStartIo, where Xxx is a driver-specific prefix. The driver's DriverEntry routine must store the StartIo routine's address in DriverObject->DriverStartIo. (If no routine is supplied, this pointer must be NULL.) A driver can use IoSetStartIoAttributes to set attributes on when its StartIo routine is called. For detailed information about implementing a driver's StartIo routine, see Writing a StartIo Routine. To define a StartIo callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a StartIo callback routine that is named MyStartIo, use the DRIVER_STARTIO type as shown in this code example: Then, implement your callback routine as follows: The DRIVER_STARTIO function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the DRIVER_STARTIO function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "DRIVER_STARTIO StartIo; VOID",
    "category": "Drivers",
    "name": "StartIo",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "struct _DEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_Inout_",
        "type": "struct _IRP*",
        "name": "Irp",
        "description": "Caller-supplied pointer to an IRP structure that describes the requested I/O operation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoSetStartIoAttributes routine sets attributes for the driver's StartIo routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoSetStartIoAttributes",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object for the driver's device."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "DeferredStartIo",
        "description": "If TRUE, the I/O manager will defer any call to the driver's StartIo routine while the driver is already inside the routine. In particular, if the StartIo routine calls IoStartNextPacket, the StartIo routine will not be called again until the current invocation completes. The default is FALSE."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "NonCancelable",
        "description": "If TRUE, the IRP cannot be canceled once it has been dequeued by a call to IoStartNextPacket. The default is FALSE. Drivers that set this member to FALSE must synchronize their IRP handling with the cancel spin lock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The Cancel routine cancels an I/O operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "When a driver or other system component calls IoCancelIrp, the I/O manager calls the IRP's Cancel routine, if one has been registered for the IRP. To register a Cancel routine for an IRP, a driver can use either of the following two methods: Only one Cancel routine can be registered for an IRP at one time. The I/O manager calls IoAcquireCancelSpinLock before calling a driver's Cancel routine, so the Cancel routine must call IoReleaseCancelSpinLock at some point. The routine should not hold the spin lock longer than necessary. The Cancel routine executes in an arbitrary thread context at IRQL = DISPATCH_LEVEL until it calls IoReleaseCancelSpinLock, which changes the IRQL to a caller-supplied value. The driver should specify Irp->CancelIrql for this value. The Cancel routine must set the I/O status block's Status member to STATUS_CANCELLED, and set its Information member to zero. The routine must then complete the specified IRP by calling IoCompleteRequest. For detailed information about implementing a driver's Cancel routine, see Canceling IRPs. To define a Cancel callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a Cancel callback routine that is named MyCancel, use the DRIVER_CANCEL type as shown in this code example: Then, implement your callback routine as follows: The DRIVER_CANCEL function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the DRIVER_CANCEL function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "DRIVER_CANCEL Cancel; VOID",
    "category": "Drivers",
    "name": "Cancel",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "struct _DEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_Inout_",
        "type": "struct _IRP*",
        "name": "Irp",
        "description": "Caller-supplied pointer to an IRP structure that describes the I/O operation to be canceled."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoReleaseCancelSpinLock routine releases the cancel spin lock after the driver has changed the cancelable state of an IRP.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine is a reciprocal to IoAcquireCancelSpinLock. This routine also releases the cancel spin lock from the driver's Cancel routine. The holder of the cancel spin lock runs at IRQL = DISPATCH_LEVEL after calling IoAcquireCancelSpinLock. IoReleaseCancelSpinLock restores the original IRQL of the caller. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoReleaseCancelSpinLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "Irql",
        "description": "The IRQL to be restored. The caller obtained this IRQL in the previous call to the IoAcquireCancelSpinLock routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoCancelIrp routine sets the cancel bit in a given IRP and calls the cancel routine for the IRP if there is one.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoCancelIrp returns TRUE if the IRP had a cancel routine and this routine was called. Otherwise, it returns FALSE. In either case, the IRP's cancel bit is set to TRUE. For more information, see Remarks. ",
    "remarks": "If the IRP has a cancel routine, IoCancelIrp sets the cancel bit and calls the cancel routine. If Irp->CancelRoutine is NULL, and therefore the IRP is not cancelable, IoCancelIrp sets the IRP's cancel bit and returns FALSE. The IRP should be canceled at a later time when it becomes cancelable. If a driver that does not own the IRP calls IoCancelIrp, the results are unpredictable. The IRP might be completed with a successful status even though its cancel bit was set. An intermediate driver should not arbitrarily call IoCancelIrp unless that driver created the IRP passed in the call. Otherwise, the intermediate driver might cancel an IRP that some higher-level driver is tracking for purposes of its own. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "IoCancelIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "A pointer to the IRP to be canceled."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoSetPartitionInformation routine is obsolete and is provided only to support existing drivers. New drivers must use IoSetPartitionInformationEx.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "If IoSetPartitionInformation returns STATUS_SUCCESS, the disk driver updates its notion of the partition type for this partition in its device extension. ",
    "remarks": "IoSetPartitionInformation must only be used by disk drivers. Other drivers should use the IOCTL_DISK_SET_PARTITION_INFO disk I/O request instead. This routine is called when a disk device driver is asked to set the partition type in a partition table entry by an IRP_MJ_DEVICE_CONTROL request. This request is generally issued by the format utility, which performs I/O control functions on the partition. The driver passes a pointer to the device object representing the physical disk and the number of the partition associated with the device object that the format utility has open. Since the HAL routines that underlie IoSetPartitionInformation were developed before support of dynamic partitioning was implemented, they do not distinguish between the partition ordinal (that is the order of a partition on a disk) and the partition number (the partition number assigned to a partition in order to identify it to the system). Drivers must call IoSetPartitionInformation using the ordinal number of the partition and not the actual partition number. This routine is synchronous and must be called by the disk driver's Dispatch routine or by a driver thread. Thus, all user and file system threads must be prepared to enter a wait state when issuing the device control request to set the partition type for the device. This routine operates under the assumption that the partition number passed in by the disk driver actually exists. This routine must be called at IRQL = PASSIVE_LEVEL because it uses a kernel event object to synchronize I/O completion on the device. The event cannot be set to the Signaled state without queuing and executing the I/O system's special kernel APC routine for I/O completion. ",
    "return_type": "NTSTATUS FASTCALL",
    "category": "Drivers",
    "name": "IoSetPartitionInformation",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object representing the device on which the partition type is to be set."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SectorSize",
        "description": "Specifies the size, in bytes, of sectors on the disk."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PartitionNumber",
        "description": "Specifies the partition number on the device whose partition type is to be set."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PartitionType",
        "description": "Specifies the type for the partition. For a list of some of the key partition types see PARTITION_INFORMATION."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The IoWritePartitionTable routine is obsolete and is provided only to support existing drivers. New drivers must use IoWritePartitionTableEx.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoWritePartitionTablo returns a status code of STATUS_SUCCESS if all writes were completed without error. In case of failure, the error codes returned by IoWritePartitionTable might include, but are not limited to, the following list:  ",
    "remarks": "IoWritePartitionTable must only be used by disk drivers. Other drivers should use the IOCTL_DISK_SET_DRIVE_LAYOUT disk I/O request instead. IoWritePartitionTable is called when a disk device driver is requested to set the partition type in a partition table entry or to repartition the disk by an IRP_MJ_DEVICE_CONTROL request. The device control request is generally issued by the format utility, which performs I/O control functions on the partitions and disks in the machine. To reset a partition type, the driver passes a pointer to the device object representing the physical disk and the number of the partition associated with the device object that the format utility has open. When a disk is to be repartitioned dynamically, the disk driver must tear down its set of device objects representing the current disk partitions and create a new set of device objects representing the new partitions on the disk. Applications that create and delete partitions and require full descriptions of the system should call IoReadPartitionTable with ReturnRecognizedPartitions set to FALSE. The drive layout structure can be modified by the system format utility to reflect a new configuration of the disk. IoWritePartitionTable is synchronous. It must be called by the disk driver's Dispatch routine or by a driver thread. Thus, all user and file system threads must be prepared to enter a wait state when issuing the device control request to reset partition types for the device. ",
    "return_type": "NTSTATUS FASTCALL",
    "category": "Drivers",
    "name": "IoWritePartitionTable",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object representing the disk whose partition tables are to be written."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SectorSize",
        "description": "Specifies the size in bytes of sectors on the device."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SectorsPerTrack",
        "description": "Specifies the track size on the device."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NumberOfHeads",
        "description": "Specifies the number of tracks per cylinder."
      },
      {
        "in_out": "_In_",
        "type": "struct _DRIVE_LAYOUT_INFORMATION*",
        "name": "PartitionBuffer",
        "description": "Pointer to the drive layout buffer that contains the partition list entries. For more detailed information see DRIVE_LAYOUT_INFORMATION."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoStartNextPacket routine dequeues the next IRP, if any, from the given device object's associated device queue and calls the driver's StartIo routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If there are no IRPs currently in the device queue for the target DeviceObject, this routine simply returns control to the caller. If the driver passed a pointer to a cancel routine when it called IoStartPacket, it should pass TRUE in the Cancelable parameter. If Cancelable is TRUE, the I/O manager will use the cancel spin lock to protect the device queue and the current IRP. Drivers that do not have a StartIo routine cannot call IoStartNextPacket. Drivers that call IoStartNextPacket from their StartIo routine should be aware of recursion issues. If a driver can call IoStartNextPacket on a large number of requests in succession from its StartIo routine (for example, when a device error occurs and the driver is clearing out it device queue), you should set the DeferredStartIo attribute for the device by using IoSetStartIoAttributes routine. This attribute ensures that the next packet will not be issued until the previous StartIo call returns. Callers of IoStartNextPacket must be running at IRQL = DISPATCH_LEVEL. Usually, this routine is called from a device driver's DpcForIsr or CustomDpc routine, both of which are run at IRQL = DISPATCH_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoStartNextPacket",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object for which the IRP is to be dequeued."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Cancelable",
        "description": "Specifies whether IRPs in the device queue can be canceled."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoStartNextPacketByKey routine dequeues the next I/O request packet from the specified device object's associated device queue according to a specified sort-key value and calls the driver's StartIo routine with that IRP.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "If there are no IRPs currently in the device queue for the target device object, this routine simply returns control to the caller. If the driver passed a pointer to a cancel routine when it called IoStartPacket, it should pass TRUE in the Cancelable parameter. If Cancelable  is TRUE, the I/O manager will use the cancel spin lock to protect the device queue and the current IRP. Drivers that do not have a StartIo routine cannot call IoStartNextPacketByKey. Callers of IoStartNextPacketByKey must be running at IRQL <= DISPATCH_LEVEL. Usually, this routine is called from a device driver's DpcForIsr or CustomDpc routine, both of which are run at IRQL = DISPATCH_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoStartNextPacketByKey",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object for which the IRP is to be dequeued."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Cancelable",
        "description": "Specifies whether IRPs in the device queue can be canceled."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Key",
        "description": "Specifies the sort key that determines which entry to remove from the queue."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoCompleteRequest routine indicates that the caller has completed all processing for a given I/O request and is returning the given IRP to the I/O manager.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "When a driver has finished all processing for a given IRP, it calls IoCompleteRequest. The I/O manager checks the IRP to determine whether any higher-level drivers have set up an IoCompletion routine for the IRP. If so, each IoCompletion routine is called, in turn, until every layered driver in the chain has completed the IRP. When all drivers have completed a given IRP, the I/O manager returns status to the original requester of the operation. Note that a higher-level driver that sets up a driver-created IRP must supply an IoCompletion routine to release the IRP it created. Never call IoCompleteRequest while holding a spin lock. Attempting to complete an IRP while holding a spin lock can cause deadlocks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoCompleteRequest",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP to be completed."
      },
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "PriorityBoost",
        "description": "Specifies a system-defined constant by which to increment the run-time priority of the original thread that requested the operation. This value is IO_NO_INCREMENT if the original thread requested an operation the driver could complete quickly (so the requesting thread is not compensated for its assumed wait for I/O to be completed) or if the IRP is completed with an error. Otherwise, the set of PriorityBoost constants are device-type-specific. See Ntddk.h or Wdm.h for these constants."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The SynchCritSection routine is used to access hardware resources or driver data that are shared with a driver's InterruptService routine.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the routine's operation succeeds, the routine should return TRUE; otherwise, it should return FALSE. (Success and failure of this routine are driver-defined.) The specified return value becomes the return value for KeSynchronizeExecution. ",
    "remarks": "Drivers must use SynchCritSection routines to access hardware resources or driver data that can also be accessed by an InterruptService routine (ISR). The system calls a driver's SynchCritSection routine when the driver calls KeSynchronizeExecution. When a driver calls KeSynchronizeExecution, it specifies the address of a SynchCritSection routine, context information for the routine, and an interrupt object pointer. The KeSynchronizeExecution routine acquires the interrupt object's spin lock, then calls the SynchCritSection routine. A driver's SynchCritSection routine executes at the same IRQL as the ISR with which it is associated. Specifically, it executes at some system-assigned DIRQL, as specified by the SynchronizeIrql parameter to IoConnectInterrupt. (Other devices, with higher DIRQL values, can interrupt a SynchCritSection routine.) To define a SynchCritSection callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a SynchCritSection callback routine that is named MySynchCritSection, use the KSYNCHRONIZE_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The KSYNCHRONIZE_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the KSYNCHRONIZE_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "KSYNCHRONIZE_ROUTINE SynchCritSection; BOOLEAN",
    "category": "Drivers",
    "name": "SynchCritSection",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SynchronizeContext",
        "description": "Caller-supplied context information, specified by the driver's call to KeSynchronizeExecution."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoRequestDpc routine queues a driver-supplied DpcForIsr routine to complete interrupt-driven I/O processing at a lower IRQL.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Callers of IoRequestDpc must be running at DIRQL. Drivers call  IoRequestDpc from an InterruptService routine. Because of this, IoRequestDpc runs at the DIRQL value that was specified by SynchronizeIrql when the driver called IoConnectInterrupt. However, it is also possible to queue a DPC at any IRQL >= DISPATCH_LEVEL by using the KeXxxDpc routines. For more information, see Which Type of DPC Should You Use? ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoRequestDpc",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object for which the request that caused the interrupt is being processed."
      },
      {
        "in_out": "_In_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the current IRP for the specified device."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to a driver-determined context to be passed to the DPC routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The DpcForIsr routine finishes the servicing of an I/O operation, after an InterruptService routine returns.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "To register a DpcForIsr routine for a specific device object, a driver must call IoInitializeDpcRequest, which causes the system to allocate and initialize one DPC object. (If you need multiple DPC routines, use CustomDpc routines.) To queue a DpcForIsr routine for execution, a driver's InterruptService routine must call IoRequestDPC. A DpcForIsr routine is typically responsible for at least the following tasks: A DpcForIsr routine might also retry a failed operation or set up the next transfer for a large I/O request that has been broken into smaller pieces. For more information about DpcForIsr routines, see DPC Objects and DPCs. To define a DpcForIsr callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a DpcForIsr callback routine that is named MyDpcForIsr, use the IO_DPC_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The IO_DPC_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the IO_DPC_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "IO_DPC_ROUTINE DpcForIsr; VOID",
    "category": "Drivers",
    "name": "DpcForIsr",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKDPC",
        "name": "Dpc",
        "description": "Caller-supplied pointer to a KDPC structure, which represents the DPC object that is associated with this DpcForIsr routine."
      },
      {
        "in_out": "_In_",
        "type": "struct _DEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_Inout_",
        "type": "struct _IRP*",
        "name": "Irp",
        "description": "Caller-supplied pointer to an IRP structure that describes the I/O operation."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Caller-supplied pointer to driver-defined context information, specified in a previous call to IoRequestDpc."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeInsertQueueDpc routine queues a DPC for execution.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the specified DPC object is not currently in a DPC queue, KeInsertQueueDpc queues the DPC and returns TRUE. ",
    "remarks": "If the specified DPC object has already been queued, no operation is performed except to return FALSE. Otherwise, the DPC object is inserted in a DPC queue. For more information about DPC queues, see Organization of DPC Queues. Note that a particular DPC object and the function that it represents can each be queued for execution only once at any particular time. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeInsertQueueDpc",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKDPC",
        "name": "Dpc",
        "description": "Pointer to the KDPC structure for the DPC object. This structure must have been initialized by either KeInitializeDpc or KeInitializeThreadedDpc."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SystemArgument1",
        "description": "Specifies driver-determined context data. This value is passed as the SystemArgument1 parameter to the DPC object's CustomDpc or CustomThreadedDpc routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SystemArgument2",
        "description": "Specifies driver-determined context data. This value is passed as the SystemArgument2 parameter to the DPC object's CustomDpc or CustomThreadedDpc routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeRemoveQueueDpc routine removes the specified DPC object from the system DPC queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeRemoveQueueDpc returns TRUE if the DPC object is in the DPC queue. If the specified DPC object is not currently in the DPC queue, no operation is performed and FALSE is returned. ",
    "remarks": "If the specified DPC object is currently queued, it is removed from the queue, canceling a call to the associated DPC routine. Starting with Windows Vista with Service Pack 1 (SP1) and Windows Server 2008, a return value of TRUE always means that KeRemoveQueueDpc successfully removed the DPC object from the DPC queue before the DPC routine started to run. In earlier versions of Windows, the DPC routine might occasionally run even if KeRemoveQueueDpc returns TRUE. In these earlier versions of Windows, drivers that cannot tolerate ambiguity in the TRUE return value should treat return values of TRUE and FALSE identically. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeRemoveQueueDpc",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKDPC",
        "name": "Dpc",
        "description": "A pointer to an initialized DPC object that was queued by a previous call to the KeInsertQueueDpc routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeSetImportanceDpc routine specifies how soon the DPC routine is run.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The KeSetImportanceDpc routine influences how soon a DPC is run after it is queued by determining: By default, DPCs are assigned to the DPC queue for the current processor, so specifying MediumImportance or MediumHighImportance for Importance has the same effect. However, drivers can use KeSetTargetProcessorDpc to change the processor that the DPC will be assigned to. For Windows Vista and later versions of the Windows operating system, you can use KeSetImportanceDpc for threaded DPCs. If the caller sets Importance to HighImportance, the DPC is placed at the beginning of the queue; otherwise, it is placed at the end. The routine does not affect when the threaded DPC queue is processed. Threaded DPCs are always processed by a dedicated thread at IRQL = PASSIVE_LEVEL. For more information about threaded DPCs, see Threaded DPCs. Note that a driver must call KeSetImportanceDpc before it calls KeInsertQueueDpc and IoRequestDpc to have any effect. For more information about how the system processes the DPC queue, see Organization of DPC Queues. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeSetImportanceDpc",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKDPC",
        "name": "Dpc",
        "description": "Pointer to the caller's DPC object, which KeInitializeDpc already initialized."
      },
      {
        "in_out": "_In_",
        "type": "KDPC_IMPORTANCE",
        "name": "Importance",
        "description": "Specifies one of the following system-defined values to determine the behavior of KeInsertQueueDpc and IoRequestDpc when either routine is used to queue the DPC.   LowImportance  Place the DPC at the end of the DPC queue, and do not begin processing of the queue.   MediumImportance  Place the DPC at the end of the DPC queue. If the DPC is assigned to the current processor's DPC queue, begin processing the queue immediately. MediumImportance is the default value for Importance.   MediumHighImportance  Place the DPC at the end of the DPC queue, and begin processing the queue immediately. MediumHighImportance is available only on Windows Vista and later versions of Windows.  HighImportance  Place the DPC at the beginning of the DPC queue, and begin processing the queue immediately."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeSetTargetProcessorDpc routine specifies the processor that a DPC routine will be run on.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "On multiprocessor systems, each processor has its own DPC queue. The KeSetTargetProcessorDpc routine specifies which processor's queue the system should use when the driver calls KeInsertQueueDpc or IoRequestDpc to queue a DPC to be run later. Starting with Windows Vista, you can also use KeSetTargetProcessorDpc to specify the target processor for threaded DPCs. A call to KeSetTargetProcessorDpcEx that occurs after a DPC object has been queued has no effect on the selection of a processor for the DPC routine to run on. To control the selection of the target processor, a KeSetTargetProcessorDpc call must occur before the call to KeInsertQueueDpc or IoRequestDpc that queues the DPC object. For more information about DPC queues, see Organization of DPC Queues. Windows 7 and later versions of Windows support processor groups. Drivers that are designed to handle information about processor groups should use the KeSetTargetProcessorDpcEx routine, which specifies a processor group, instead of KeSetTargetProcessorDpc, which does not. However, the implementation of KeSetTargetProcessorDpc in Windows 7 and later versions of Windows provides compatibility for drivers that were written for earlier versions of Windows, which do not support processor groups. In this implementation, if Number is less than the number of active logical processors in group 0, KeSetTargetProcessorDpc sets the target for the DPC to the processor in group 0 that is specified by Number. Otherwise, the DPC target does not change. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeSetTargetProcessorDpc",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PRKDPC",
        "name": "Dpc",
        "description": "Pointer to the caller's DPC object, which KeInitializeDpc already initialized."
      },
      {
        "in_out": "_In_",
        "type": "CCHAR",
        "name": "Number",
        "description": "Specifies the zero-based number of the target processor on which the DPC should be queued and executed."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoTimer routine is a DPC that, if registered, is called once per second.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "A driver's IoTimer routine executes in a DPC context, at IRQL = DISPATCH_LEVEL. A driver can associate an IoTimer routine with each device object it creates. (You can use a single IoTimer routine with multiple device objects, or a separate routine with each device object.) To register an IoTimer routine, a driver must call IoInitializeTimer, supplying the IoTimer routine's address and a device object pointer. To queue an IoTimer routine for execution, a driver routine must call IoStartTimer. The system calls the IoTimer routine once per second until the driver calls IoStopTimer. For more information about IoTimer routines, see IoTimer Routines. To define an IoTimer callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define an IoTimer callback routine that is named MyIoTimer, use the IO_TIMER_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The IO_TIMER_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the IO_TIMER_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "IO_TIMER_ROUTINE IoTimer; VOID",
    "category": "Drivers",
    "name": "IoTimer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct DEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Caller-supplied pointer to driver-defined context information, specified in a previous call to IoInitializeTimer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoStartTimer routine enables the timer associated with a given device object so the driver-supplied IoTimer routine is called once per second.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The driver must already have set up the IoTimer routine for the DeviceObject by calling IoInitializeTimer. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoStartTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to a device object whose timer routine is to be called."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoStopTimer routine disables the timer for a specified device object so the driver-supplied IoTimer routine is not called.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The driver-supplied IoTimer routine can be reenabled with a call to IoStartTimer. Do not call IoStopTimer from within the IoTimer routine. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoStopTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object with which the IoTimer routine is associated."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeInitializeDpc routine initializes a DPC object, and registers a CustomDpc routine for that object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The caller can queue an initialized DPC with KeInsertQueueDpc. The caller also can set up a timer object associated with the initialized DPC object and queue the DPC with KeSetTimer. Storage for the DPC object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeDpc",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PRKDPC",
        "name": "Dpc",
        "description": "Pointer to a KDPC structure that represents the DPC object to initialize. The caller must allocate storage for the structure from resident memory."
      },
      {
        "in_out": "_In_",
        "type": "PKDEFERRED_ROUTINE",
        "name": "DeferredRoutine",
        "description": "Pointer to the CustomDpc routine to associate with the DPC."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "DeferredContext",
        "description": "Specifies the value to pass as the DeferredContext parameter to CustomDpc."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The CustomTimerDpc routine executes after a timer object's time interval expires.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "To create a DPC object and register a CustomTimerDpc routine for that object, a driver must call KeInitializeDpc. To queue a CustomTimerDpc routine for execution, a driver routine must call KeSetTimer or KeSetTimerEx, supplying a DPC object pointer returned by KeInitializeDpc. The system calls the CustomTimerDpc routine when the timer interval expires. For more information about CustomTimerDpc routines, see Timer Objects and DPCs. To define a CustomTimerDpc callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a CustomTimerDpc callback routine that is named MyCustomTimerDpc, use the KDEFERRED_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The KDEFERRED_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the KDEFERRED_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "KDEFERRED_ROUTINE CustomTimerDpc; VOID",
    "category": "Drivers",
    "name": "CustomTimerDpc",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct _KDPC*",
        "name": "Dpc",
        "description": "Caller-supplied pointer to a KDPC structure, which represents the DPC object associated with this CustomTimerDpc routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "DeferredContext",
        "description": "Caller-supplied pointer to driver-defined context information, specified in a previous call to KeInitializeDpc."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SystemArgument1",
        "description": "Not used."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SystemArgument2",
        "description": "Not used."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeInitializeTimer routine initializes a timer object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The timer object is initialized to a not-signaled state. Storage for a timer object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. KeInitializeTimer can only initialize a notification timer. Use KeInitializeTimerEx to initialize a notification timer or a synchronization timer. Use KeSetTimer or KeSetTimerEx to define when the timer will expire. For more information about timer objects, see Timer Objects and DPCs. Callers of KeInitializeTimer should be running at IRQL = DISPATCH_LEVEL or lower. It is best to initialize timers at IRQL = PASSIVE_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeTimer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKTIMER",
        "name": "Timer",
        "description": "Pointer to a timer object, for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeInitializeTimerEx routine initializes an extended kernel timer object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The timer object is initialized to a not-signaled state. Storage for a timer object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. When a notification timer expires, all waiting threads are released and the timer remains in the signaled state until it is explicitly reset. When a synchronization timer expires, it is set to a signaled state until a single waiting thread is released and then the timer is reset to a not-signaled state. Callers of KeInitializeTimerEx should be running at IRQL = DISPATCH_LEVEL or lower. It is best to initialize timers at IRQL = PASSIVE_LEVEL. For more information about timer objects, see Timer Objects and DPCs. Use KeSetTimer or KeSetTimerEx to define when the timer will expire. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeTimerEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PKTIMER",
        "name": "Timer",
        "description": "Pointer to a timer object, for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "TIMER_TYPE",
        "name": "Type",
        "description": "Specifies the type of the timer object, either NotificationTimer or SynchronizationTimer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeQuerySystemTime routine obtains the current system time.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "System time is a count of 100-nanosecond intervals since January 1, 1601. System time is typically updated approximately every ten milliseconds. This value is computed for the GMT time zone. To adjust this value for the local time zone use ExSystemTimeToLocalTime. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeQuerySystemTime",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "CurrentTime",
        "description": "Pointer to the current time on return from KeQuerySystemTime."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeQueryRuntimeThread routine reports the accumulated kernel-mode and user-mode run time of a thread, in clock ticks.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeQueryRuntimeThread returns the accumulated kernel-mode run time of the current thread, in clock ticks. ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "KeQueryRuntimeThread",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKTHREAD",
        "name": "Thread",
        "description": "Pointer to a dispatcher object of type KTHREAD."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "UserTime",
        "description": "Pointer to the memory location where KeQueryRuntimeThread returns the accumulated user-mode run time of the current thread, in clock ticks."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeQueryTickCount routine maintains a count of the interval timer interrupts that have occurred since the system was booted.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The TickCount value increases by one at each interval timer interrupt while the system is running. The preferred method of determining elapsed time is by using TickCount for relative timing and time stamps. To determine the absolute elapsed time multiply the returned TickCount by the KeQueryTimeIncrement return value using compiler support for 64-bit integer operations. You should not make any assumptions about the length of a tick, because it might vary depending on hardware and other considerations. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeQueryTickCount",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "TickCount",
        "description": "Pointer to the tick count value on return from KeQueryTickCount."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeAcquireSpinLock routine acquires a spin lock so the caller can synchronize access to shared data in a multiprocessor-safe way by raising IRQL.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "KeAcquireSpinLock first resets the IRQL to DISPATCH_LEVEL and then acquires the lock. The previous IRQL is written to OldIrql after the lock is acquired. The OldIrql value must be specified when the spin lock is released with KeReleaseSpinLock. Most drivers use a local variable to store the old IRQL value. A driver can also use a shared memory location, such as a global variable, but the driver must not use the same location for two different locks. Otherwise, a race condition can occur. Spin locks can cause serious problems if not used judiciously. In particular, no deadlock protection is performed and dispatching is disabled while the spin lock is held. Therefore: Attempting to acquire a spin lock recursively is guaranteed to cause a deadlock. For more information about spin locks, see Spin Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeAcquireSpinLock",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Pointer to an initialized spin lock for which the caller provides the storage."
      },
      {
        "in_out": "_Out_",
        "type": "PKIRQL",
        "name": "OldIrql",
        "description": "Pointer to a variable that is set to the current IRQL when this call occurs."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeAcquireSpinLockRaiseToDpc routine is a faster version of the KeAcquireSpinLock routine.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeAcquireSpinLockRaiseToDpc returns the current IRQL at the time the routine is called. This value is passed to KeReleaseSpinLock when the spin lock is released. ",
    "remarks": "The effect of this routine is identical to that of KeAcquireSpinLock. In particular, the acquired spin lock is released by KeReleaseSpinLock. For more information, see the reference page for KeAcquireSpinLock. Drivers can try to acquire the spin lock without blocking by using KeTryToAcquireSpinLockAtDpcLevel. For more information about spin locks, see Spin Locks. ",
    "return_type": "KIRQL",
    "category": "Drivers",
    "name": "KeAcquireSpinLockRaiseToDpc",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Specifies the spin lock to acquire. The spin lock must already have been initialized by KeInitializeSpinLock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeReleaseSpinLock routine releases a spin lock and restores the original IRQL at which the caller was running.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This call is a reciprocal to KeAcquireSpinLock. The input NewIrql value must be the OldIrql returned by KeAcquireSpinLock. For more information about spin locks, see Spin Locks. Callers of this routine are running at IRQL = DISPATCH_LEVEL. On return from KeReleaseSpinLock, IRQL is restored to the NewIrql value. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeReleaseSpinLock",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Pointer to a spin lock for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "NewIrql",
        "description": "Specifies the IRQL value saved from the preceding call to KeAcquireSpinLock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeAcquireSpinLockAtDpcLevel routine acquires a spin lock when the caller is already running at IRQL >= DISPATCH_LEVEL.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers call KeAcquireSpinLockAtDpcLevel instead of KeAcquireSpinLock for better driver performance if and only if they are already running at an IRQL of DISPATCH_LEVEL or above. If a driver is running at IRQL <= APC_LEVEL, it should call KeAcquireSpinLock to have IRQL raised by that routine. KeAcquireSpinLockAtDpcLevel assumes the caller is already running at IRQL >= DISPATCH_LEVEL, so no raise is necessary. The caller should release the spin lock with KeReleaseSpinLockFromDpcLevel as quickly as possible. For more information about spin locks, see Spin Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeAcquireSpinLockAtDpcLevel",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Pointer to an initialized spin lock for which the caller must provide the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeTryToAcquireSpinLockAtDpcLevel routine attempts to acquire a spin lock at DISPATCH_LEVEL.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeTryToAcquireSpinLockAtDpcLevel returns TRUE if the spin lock has been acquired, and FALSE if the spin lock is already being held and cannot be acquired. ",
    "remarks": "If the specified spin lock is not busy, the KeTryToAcquireSpinLockAtDpcLevel routine acquires the spin lock (see KeAcquireSpinLock for details) and returns TRUE. If the spin lock has already been acquired, the routine immediately returns FALSE. If the spin lock is acquired, the caller can release it by using the KeReleaseSpinLock routine. If you want the driver to block when it is unable to acquire the spin lock, use KeAcquireSpinLockAtDpcLevel instead. For more information about spin locks, see Spin Locks. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "KeTryToAcquireSpinLockAtDpcLevel",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Specifies the spin lock to acquire. The spin lock must have already been initialized by KeInitializeSpinLock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReleaseSpinLockFromDpcLevel routine releases an executive spin lock without changing the IRQL.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers call KeReleaseSpinLockFromDpcLevel to release a spin lock acquired by calling KeAcquireSpinLockAtDpcLevel. It is an error to call KeReleaseSpinLockFromDpcLevel if the specified spin lock was acquired by calling KeAcquireSpinLock because the caller's original IRQL is not restored, which can cause deadlocks or fatal page faults. For more information about spin locks, see Spin Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeReleaseSpinLockFromDpcLevel",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Pointer to an executive spin lock for which the caller provides the storage."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeAcquireInStackQueuedSpinLock routine acquires a queued spin lock.",
    "library": "Ntoskrnl.lib;  Ntdll.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "KeAcquireInStackQueuedSpinLock acquires a spin lock as a queued spin lock. For more information, see Queued Spin Locks. The caller releases the spin lock by calling the KeReleaseInStackQueuedSpinLock routine. Like ordinary spin locks, queued spin locks must only be used in very special circumstances. For a description of when to use spin locks, see KeAcquireSpinLock. This routine raises the IRQL level to DISPATCH_LEVEL when acquiring the spin lock. If the caller is guaranteed to already be running at DISPATCH_LEVEL, it is more efficient to call KeAcquireInStackQueuedSpinLockAtDpcLevel. The call to KeReleaseInStackQueuedSpinLock that releases the spin lock must occur at IRQL = DISPATCH_LEVEL. This call restores the original IRQL that the operating system saved at the beginning of the KeAcquireInStackQueuedSpinLock call. Drivers must not combine calls to KeAcquireSpinLock and KeAcquireInStackQueuedSpinLock on the same spin lock. A spin lock must always be acquired or released as either a queued spin lock, or as an ordinary spin lock. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeAcquireInStackQueuedSpinLock",
    "is_callback": 0,
    "dll": "Ntoskrnl.exe;  Ntdll.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Specifies the spin lock to acquire. This parameter must have been initialized with KeInitializeSpinLock."
      },
      {
        "in_out": "_Out_",
        "type": "PKLOCK_QUEUE_HANDLE",
        "name": "LockHandle",
        "description": "A pointer to a caller-supplied KLOCK_QUEUE_HANDLE variable that the routine can use to return the spin lock queue handle. The caller passes this value to KeReleaseInStackQueuedSpinLock when releasing the lock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReleaseInStackQueuedSpinLock routine releases a queued spin lock acquired by KeAcquireInStackQueuedSpinLock.",
    "library": "Hal.lib;  Ntoskrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "This routine restores the original IRQL that the operating system saved at the beginning of the KeAcquireInStackQueuedSpinLock call. For more information about queued spin locks, see Queued Spin Locks. Use Hal.lib on 32-bit versions of Windows and Ntoskrnl.lib on 64-bit versions of Windows. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeReleaseInStackQueuedSpinLock",
    "is_callback": 0,
    "dll": "Hal.dll;  Ntoskrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKLOCK_QUEUE_HANDLE",
        "name": "LockHandle",
        "description": "Specifies the queued spin lock handle initialized by the call to KeAcquireInStackQueuedSpinLock that acquired the lock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeAcquireInStackQueuedSpinLockAtDpcLevel routine acquires a queued spin lock when the caller is already running at IRQL >= DISPATCH_LEVEL.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "For a driver running at IRQL >= DISPATCH_LEVEL, KeAcquireInStackQueuedSpinLockAtDpcLevel acquires a spin lock as a queued spin lock. For more information, see Queued Spin Locks. To release the spin lock, call the KeReleaseInStackQueuedSpinLockFromDpcLevel routine. Drivers that are already running at an IRQL >= DISPATCH_LEVEL can call this routine to acquire the queued spin lock more quickly. Otherwise, use the KeAcquireInStackQueuedSpinLock routine to acquire the spin lock. For a driver that is running at IRQL > DISPATCH_LEVEL, this routine acquires the lock without modifying the current IRQL. For a driver that is running at IRQL = DISPATCH_LEVEL, this routine improves performance by acquiring the lock without first setting the IRQL to DISPATCH_LEVEL, which, in this case, would be a redundant operation. Like ordinary spin locks, queued spin locks must only be used in very special circumstances. For a description of when to use spin locks, see KeAcquireSpinLock. Drivers must not combine calls to KeAcquireSpinLock and KeAcquireInStackQueuedSpinLock on the same spin lock. A spin lock must always be acquired or released either as a queued spin lock, or as an ordinary spin lock. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeAcquireInStackQueuedSpinLockAtDpcLevel",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "SpinLock",
        "description": "Specifies the spin lock to acquire. This parameter must have been initialized by a call to the KeInitializeSpinLock routine."
      },
      {
        "in_out": "_Out_",
        "type": "PKLOCK_QUEUE_HANDLE",
        "name": "LockHandle",
        "description": "Pointer to a caller-supplied KLOCK_QUEUE_HANDLE structure that the routine can use to return the spin lock queue handle. To release the lock, the caller passes this value to the KeReleaseInStackQueuedSpinLockFromDpcLevel routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeReleaseInStackQueuedSpinLockFromDpcLevel routine releases a queued spin lock acquired by KeAcquireInStackQueuedSpinLockAtDpcLevel.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "For more information about queued spin locks, see Queued Spin Locks. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeReleaseInStackQueuedSpinLockFromDpcLevel",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PKLOCK_QUEUE_HANDLE",
        "name": "LockHandle",
        "description": "Specifies the queued spin lock handle initialized by the call to KeAcquireInStackQueuedSpinLockAtDpcLevel that acquired the lock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeAcquireInterruptSpinLock routine acquires the spin lock associated with an interrupt object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeAcquireInterruptSpinLock returns the current IRQL at the time the routine is called. This value is passed to KeReleaseInterruptSpinLock when the spin lock is released. ",
    "remarks": "Drivers use the interrupt spin lock to synchronize access to memory shared with the interrupt's ISR. The driver can release the spin lock by calling KeReleaseInterruptSpinLock. Any code that executes while the interrupt spin lock is held does so at IRQL = DIRQL for the specified Interrupt, so it must execute very quickly. For more information, see Using Critical Sections. The preferred way to synchronize a driver routine to an ISR is to use the KeSynchronizeExecution routine. Starting with Windows 8, a driver can use IoConnectInterruptEx to register an interrupt service routine that runs at IRQL = PASSIVE_LEVEL and that does not use a spin lock for interrupt synchronization. If Interrupt points to an interrupt object that connects to a passive-level ISR, KeAcquireInterruptSpinLock causes a bug check. For more information, see Using Passive-Level Interrupt Service Routines. Callers must be running at IRQL <= DIRQL for Interrupt. (This is the value the driver passed as the SynchronizeIrql parameter of IoConnectInterrupt when Interrupt is created.) ",
    "return_type": "KIRQL",
    "category": "Drivers",
    "name": "KeAcquireInterruptSpinLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKINTERRUPT",
        "name": "Interrupt",
        "description": "Specifies a pointer to an interrupt object. This value must be supplied by IoConnectInterrupt or IoConnectInterruptEx."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeReleaseInterruptSpinLock routine releases an interrupt spin lock acquired by KeAcquireInterruptSpinLock.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The KeReleaseInterruptSpinLock releases the interrupt spin lock, and lowers the IRQL value back to the OldIrql value. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeReleaseInterruptSpinLock",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PKINTERRUPT",
        "name": "Interrupt",
        "description": "Specifies the value of the Interrupt parameter passed to KeAcquireInterruptSpinLock."
      },
      {
        "in_out": "_In_",
        "type": "KIRQL",
        "name": "OldIrql",
        "description": "Specifies the IRQL value returned by KeAcquireInterruptSpinLock."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExInterlockedAddUlong routine adds an unsigned long value to a given unsigned integer as an atomic operation.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedAddUlong returns the original (unsummed) value of the Addend. ",
    "remarks": "Consider using InterlockedExchangeAdd instead of this routine. InterlockedExchangeAdd can be more efficient because it does not use a spin lock and it is inlined by the compiler. Support routines that do interlocked operations are assumed to be incapable of causing a page fault. That is, neither their code nor any of the data they touch can cause a page fault without bringing down the system. They use spin locks to achieve atomicity on symmetric multiprocessor machines. The caller must provide resident storage for the Lock, which must be initialized with KeInitializeSpinLock before the initial call to an ExInterlockedXxx. The Lock passed to ExInterlockedAddULong is used to assure that the add operation on Addend is atomic with respect to any other operations on the same value which synchronize with this same spin lock. ExInterlockedAddUlong masks interrupts. Consequently, it can be used for synchronization between an ISR and other driver code, provided that the same Lock is never reused in a call to a routine that runs at IRQL = DISPATCH_LEVEL. Note that calls to InterlockedXxx are guaranteed to be atomic with respect to other InterlockedXxx calls without caller-supplied spin locks. Callers of ExInterlockedAddUlong run at any IRQL. The storage for the Addend parameter must be resident at all IRQLs. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "ExInterlockedAddUlong",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "Addend",
        "description": "A pointer to an unsigned long integer whose value is to be adjusted by the Increment value."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Increment",
        "description": "Specifies an unsigned long integer to be added."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a spin lock to be used to synchronize access to the Addend."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ExInterlockedAddLargeInteger routine adds a large integer value to the specified variable as an atomic operation.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedAddLargeInteger returns the initial value of the Addend parameter. ",
    "remarks": "Support routines that do interlocked operations are assumed to be incapable of causing a page fault. That is, neither their code nor any of the data they touch can cause a page fault without bringing down the system. They use spin locks to achieve atomicity on symmetric multiprocessor machines. The caller must provide resident storage for the Lock, which must be initialized with KeInitializeSpinLock before the initial call to an ExInterlockedXxx. The Lock passed to ExInterlockedAddLargeInteger is used to assure that the add operation on Addend is atomic with respect to any other operations on the same value which synchronize with this same spin lock. ExInterlockedAddLargeInteger masks interrupts. Consequently, it can be used for synchronization between an ISR and other device driver code, provided that the same Lock is never reused in a call to a routine that runs at IRQL = DISPATCH_LEVEL. Note that calls to InterlockedXxx are guaranteed to be atomic with respect to other InterlockedXxx calls without caller-supplied spin locks. Callers of ExInterlockedAddLargeInteger run at any IRQL. The storage for the Addend parameter must be resident at all IRQLs. ",
    "return_type": "LARGE_INTEGER",
    "category": "Drivers",
    "name": "ExInterlockedAddLargeInteger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLARGE_INTEGER",
        "name": "Addend",
        "description": "A pointer to the variable to be adjusted by the Increment value."
      },
      {
        "in_out": "_In_",
        "type": "LARGE_INTEGER",
        "name": "Increment",
        "description": "Specifies a value to be added to Addend."
      },
      {
        "in_out": "_Inout_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a spin lock to be used to synchronize access to Addend."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ExInterlockedCompareExchange64 routine compares one integer variable to another and, if they are equal, sets the first variable to a caller-supplied value.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ExInterlockedCompareExchange64 returns the initial value of the variable at Destination when the call occurred. ",
    "remarks": "ExInterlockedCompareExchange64 tests and, possibly, replaces the value of a given variable. For most underlying microprocessors, this routine is implemented inline by the compiler to execute as an atomic operation. If a spin lock is used, this routine can only be safely used on nonpaged parameters. If the Destination and Comparand are unequal, ExInterlockedCompareExchange64 simply returns the value of Destination. ExInterlockedCompareExchange64 is atomic only with respect to other (Ex)InterlockedXxx calls. Callers of ExInterlockedCompareExchange64 can be running at any IRQL. The storage for the Destination, Comparand, and Exchange parameter and the list entries must be resident at all IRQLs. ",
    "return_type": "LONGLONG",
    "category": "Drivers",
    "name": "ExInterlockedCompareExchange64",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PLONGLONG",
        "name": "Destination",
        "description": "A pointer to an integer that will be compared and possibly replaced."
      },
      {
        "in_out": "_In_",
        "type": "PLONGLONG",
        "name": "Exchange",
        "description": "A pointer to an integer that will replace the one at Destination if the comparison results in equality."
      },
      {
        "in_out": "_In_",
        "type": "PLONGLONG",
        "name": "Comparand",
        "description": "A pointer to an integer with which the value at Destination will be compared."
      },
      {
        "in_out": "_In_",
        "type": "PKSPIN_LOCK",
        "name": "Lock",
        "description": "A pointer to a caller-allocated spin-lock that is used if the host system does not support an 8-byte atomic compare-and-exchange operation."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The AdapterControl routine starts a DMA data-transfer operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine must return one of the values defined by the IO_ALLOCATION_ACTION enumeration. Drivers of bus-master devices return either DeallocateObject or DeallocateObjectKeepRegisters; drivers that use system DMA return KeepObject. ",
    "remarks": "To register an AdapterControl routine for a specific device object, a driver must call IoGetDmaAdapter to obtain an adapter object, then call AllocateAdapterChannel to request use of the adapter and to supply the AdapterControl routine's address. When the adapter is free, the system calls the AdapterControl routine. If AdapterControl has been registered by a StartIo routine, then the Irp parameter is guaranteed to point to the IRP currently being processed by the StartIo routine. Otherwise, drivers must set the CurrentIrp member of the device object structure before calling AllocateAdapterChannel. For detailed information about implementing an AdapterControl routine, see Writing AdapterControl Routines. To define an AdapterControl callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define an AdapterControl callback routine that is named MyAdapterControl, use the DRIVER_CONTROL type as shown in this code example: Then, implement your callback routine as follows: The DRIVER_CONTROL function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the DRIVER_CONTROL function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "DRIVER_CONTROL AdapterControl; IO_ALLOCATION_ACTION",
    "category": "Drivers",
    "name": "AdapterControl",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct _DEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_Inout_",
        "type": "struct _IRP*",
        "name": "Irp",
        "description": "Caller-supplied pointer to an IRP structure. Irp is equal to the value of the CurrentIrp member of DeviceObject when the AdapterControl routine was registered."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "MapRegisterBase",
        "description": "Caller-supplied opaque value that represents  the map registers that the system has assigned for this transfer operation. The driver passes this value to FlushAdapterBuffers, FreeMapRegisters, and MapTransfer."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Caller-supplied pointer to driver-defined context information, specified in a previous call to AllocateAdapterChannel."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The BuildMdlFromScatterGatherList routine builds an MDL from a scatter/gather list allocated by the system.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "BuildMdlFromScatterGatherList returns one of the following status codes:  ",
    "remarks": "BuildMdlFromScatterGatherList            is not a system routine that can be called directly by name. This routine can be called only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter with the Version member of the DeviceDescription parameter set to DEVICE_DESCRIPTION_VERSION2. If IoGetDmaAdapter returns NULL, the routine is not available on your platform. When a driver creates a scatter/gather list to write to a device, the system can make a copy of the data to be written, and use that copy to perform the DMA operation. Use this routine to access the memory locations in the scatter/gather list, regardless of whether those locations are a copy. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "BuildMdlFromScatterGatherList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PADAPTER_OBJECT",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PSCATTER_GATHER_LIST",
        "name": "ScatterGather",
        "description": "Pointer to the SCATTER_GATHER_LIST structure passed to the driver's AdapterListControl routine."
      },
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "OriginalMdl",
        "description": "Pointer to the original MDL that the driver used to build the scatter/gather list."
      },
      {
        "in_out": "_Out_",
        "type": "PMDL*",
        "name": "TargetMdl",
        "description": "Pointer to a variable the routine uses to return the MDL created to hold the buffer described by the scatter/gather list. The value returned can be the same as OriginalMdl."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 10,
    "description": "The BuildScatterGatherList routine prepares the system for a DMA operation, using a driver-supplied buffer to build the scatter/gather list.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "BuildScatterGatherList returns one of the following values:  ",
    "remarks": "BuildScatterGatherList            is not a system routine that can be called directly by name. This routine can be called only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter with the Version member of the DeviceDescription parameter set to DEVICE_DESCRIPTION_VERSION2. If IoGetDmaAdapter returns NULL, the routine is not available on your platform. BuildScatterGatherList performs the same operation as GetScatterGatherList, except that it uses the buffer supplied in the ScatterGatherBuffer parameter to hold the scatter/gather list that it creates. In contrast, GetScatterGatherList dynamically allocates a buffer to hold the scatter/gather list. If insufficient memory is available to allocate the buffer, GetScatterGatherList can fail with a STATUS_INSUFFICIENT_RESOURCES error. Drivers that must avoid this scenario can preallocate a buffer to hold the scatter/gather list, and use BuildScatterGatherList instead. A driver can use the CalculateScatterGatherList routine to determine the size of buffer to allocate to hold the scatter/gather list. The driver should retain the pointer to the scatter/gather list in ScatterGatherBuffer for use when the driver calls PutScatterGatherList. The driver must call PutScatterGatherList (which flushes the list) before it can access the data in the list. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "BuildScatterGatherList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object that represents the target device for the DMA operation."
      },
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "Pointer to the MDL that describes the buffer specified by the MdlAddress member of the current IRP."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CurrentVa",
        "description": "Pointer to the current virtual address in the MDL for the buffer to be mapped for a DMA transfer operation."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length, in bytes, of the buffer to be mapped."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_LIST_CONTROL",
        "name": "ExecutionRoutine",
        "description": "Pointer to a driver-supplied AdapterListControl routine, which is called at IRQL = DISPATCH_LEVEL when the system DMA controller or bus-master adapter is available."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to the driver-determined context passed to ExecutionRoutine when it is called."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "WriteToDevice",
        "description": "Indicates the direction of the DMA transfer: TRUE for a transfer from the buffer to the device, and FALSE otherwise."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ScatterGatherBuffer",
        "description": "Pointer to the caller-supplied buffer that the routine fills with a SCATTER_GATHER_LIST structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ScatterGatherBufferLength",
        "description": "Specifies the size, in bytes, of the buffer passed in the ScatterGatherBuffer parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The CalculateScatterGatherList routine calculates the size, in bytes, of scatter/gather list necessary to hold a given buffer.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "CalculateScatterGatherList returns one of the following status codes.  ",
    "remarks": "CalculateScatterGatherList       is not a system routine that can be called directly by name. This routine can be called only by pointer from the address returned in a       DMA_OPERATIONS       structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter with the Version member of the DeviceDescription parameter set to DEVICE_DESCRIPTION_VERSION2. If IoGetDmaAdapter returns NULL, the routine is not available on your platform. If the caller passes NULL for the Mdl parameter, the routine calculates the maximum possible size needed to hold a scatter/gather list for the specified buffer. If the caller specifies the MDL that contains the buffer in the Mdl parameter, the routine computes the actual size needed to hold the scatter/gather list. A driver uses CalculateScatterGatherList to allocate a scatter/gather list buffer to pass to BuildScatterGatherList. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "CalculateScatterGatherList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_opt_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "Either NULL or a pointer to the MDL that contains the buffer."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CurrentVa",
        "description": "Pointer to the virtual address of the beginning of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length of the buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ScatterGatherListSize",
        "description": "Pointer to the variable the routine uses to return the size of the scatter/gather list, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "NumberOfMapRegisters",
        "description": "Either NULL or pointer to the variable the routine uses to return the number of map registers needed for DMA operations on the buffer."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The FlushAdapterBuffers routine flushes any data remaining in the system DMA controller's internal cache or in a bus-master adapter's internal cache at the end of a DMA transfer operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "FlushAdapterBuffers returns TRUE if any data remaining in the DMA controller's or bus-master adapter's internal cache has been successfully flushed into system memory or out to the device. ",
    "remarks": "FlushAdapterBuffers            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. To ensure that a DMA transfer is complete, every driver that performs DMA operations must call FlushAdapterBuffers before completing the IRP that requested the DMA transfer and before freeing the map registers. A driver can get the initial CurrentVa for the start of a packet-based DMA transfer by calling MmGetMdlVirtualAddress. However, the value returned is an index into the Mdl, rather than a valid virtual address. If the driver must split a large transfer request into more than one DMA operation, it must update CurrentVa and Length for each DMA operation. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "FlushAdapterBuffers",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "Pointer to the MDL that describes the buffer previously passed in the driver's call to MapTransfer."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "MapRegisterBase",
        "description": "Specifies the map registers allocated for the DMA operation.  The system passes this value  to the driver's AdapterControl routine."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CurrentVa",
        "description": "Pointer to the current virtual address in the buffer, described by the Mdl, where the I/O operation occurred. This value must be the same as the initial CurrentVa value passed to MapTransfer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length, in bytes, of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "WriteToDevice",
        "description": "Specifies the direction of the DMA transfer operation: TRUE for a transfer from a buffer in system memory to the driver's device."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The FreeAdapterChannel routine releases the system DMA controller when a driver has completed all DMA operations necessary to satisfy the current IRP.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "FreeAdapterChannel            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. After a driver has transferred all the data and called FlushAdapterBuffers, it calls FreeAdapterChannel to release the system DMA controller that was previously allocated with a call to AllocateAdapterChannel. FreeAdapterChannel frees any map registers that were allocated by an earlier call to AllocateAdapterChannel. A driver calls this routine only if its AdapterControl routine returns KeepObject. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "FreeAdapterChannel",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER  structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The FreeMapRegisters routine releases a set of map registers that were saved from a call to AllocateAdapterChannel.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "FreeMapRegisters            is not a system routine that can be called directly by name. This routine is only callable by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. When the driver of a bus-master device has completed the current packet-based DMA transfer request, it calls FreeMapRegisters to release the map registers previously allocated by a call to AllocateAdapterChannel and retained because its AdapterControl routine returned DeallocateObjectKeepRegisters. The driver must call FreeMapRegisters after calling FlushAdapterBuffers. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "FreeMapRegisters",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "MapRegisterBase",
        "description": "Specifies the map registers allocated for the DMA operation.  The system passes this value  to the driver's AdapterControl routine."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NumberOfMapRegisters",
        "description": "Specifies the number of map registers to be released. This value must match the number specified in an earlier call to AllocateAdapterChannel."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The GetDmaAlignment routine returns the alignment requirements of the DMA system.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "GetDmaAlignment returns the alignment requirements, in bytes, of the DMA system.  The starting address and length of DMA buffers must be a multiple of this value. ",
    "remarks": "GetDmaAlignment            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. A driver can call this routine to determine alignment requirements for DMA buffers it allocates. The returned value should be used to set the AlignmentRequirement field in the device object. A driver may need to increase this value because of additional hardware device restrictions.  For more information, see Initializing a Device Object. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "GetDmaAlignment",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "A pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 8,
    "description": "The GetScatterGatherList routine prepares the system for a DMA scatter/gather operation on behalf of the target device object, through either the system DMA controller or a bus-master adapter.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine can return one of the following NTSTATUS values.  ",
    "remarks": "The GetScatterGatherList routine dynamically allocates a buffer to hold the scatter/gather list. For possible NTSTATUS values if the buffer allocation fails, see the return value. GetScatterGatherList            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. As soon as the appropriate DMA channel and any necessary map registers are available, GetScatterGatherList creates a scatter/gather list, initializes the map registers, and then calls the driver-supplied AdapterListControl routine to carry out the I/O operation. GetScatterGatherList combines the actions of the AllocateAdapterChannel and MapTransfer routines for drivers that perform scatter/gather DMA. GetScatterGatherList determines how many map registers are required for the transfer, allocates the map registers, maps the buffers for DMA, and fills in the scatter/gather list. It then calls the supplied AdapterListControl routine, passing a pointer to the scatter/gather list in ScatterGather. The driver should retain this pointer for use when calling PutScatterGatherList. Note that GetScatterGatherList does not have the queuing restrictions that apply to AllocateAdapterChannel. In its AdapterListControl routine, the driver should perform the I/O. On return from the driver-supplied routine, GetScatterGatherList keeps the map registers but frees the DMA adapter structure. The driver must call PutScatterGatherList (which flushes the buffers) before it can access the data in the buffer. This routine can handle chained MDLs, provided that the total number of map registers required by all chained MDLs does not exceed the number of map registers that are available. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "GetScatterGatherList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object that represents the target device for the DMA operation."
      },
      {
        "in_out": "_In_",
        "type": "PMDL",
        "name": "Mdl",
        "description": "Pointer to the MDL that describes the buffer at MdlAddress in the current IRP."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CurrentVa",
        "description": "Pointer to the current virtual address in the MDL for the buffer to be mapped for a DMA transfer operation."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Specifies the length, in bytes, to be mapped."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_LIST_CONTROL",
        "name": "ExecutionRoutine",
        "description": "Pointer to a driver-supplied AdapterListControl routine, which is called at DISPATCH_LEVEL when the system DMA controller or bus-master adapter is available."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to the driver-determined context passed to the driver's AdapterListControl routine when it is called."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "WriteToDevice",
        "description": "Indicates the direction of the DMA transfer: TRUE for a transfer from the buffer to the device, and FALSE otherwise."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The PutDmaAdapter routine frees a DMA_ADAPTER structure previously allocated by IoGetDmaAdapter.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "PutDmaAdapter            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. PutDmaAdapter frees a DMA adapter object previously allocated by IoGetDmaAdapter. Drivers should call PutDmaAdapter after completing DMA operations and freeing any map registers and common buffer allocated with this adapter object. After PutDmaAdapter returns, the driver can no longer use the DMA adapter object. A driver must call PutDmaAdapter when it receives a PnP IRP_MN_STOP_DEVICE request. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "PutDmaAdapter",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure to be released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The PutScatterGatherList routine frees the previously allocated map registers and scatter/gather list used in scatter/gather DMA.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "PutScatterGatherList            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. Drivers should call PutScatterGatherList after completing scatter/gather I/O. This routine flushes the adapter buffers, frees the map registers, and unmaps and frees the associated MDLs. Additionally, the routine frees the scatter/gather list if it was previously allocated by GetScatterGatherList. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "PutScatterGatherList",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the DMA_ADAPTER structure returned by IoGetDmaAdapter that represents the bus-master adapter or DMA controller."
      },
      {
        "in_out": "_In_",
        "type": "PSCATTER_GATHER_LIST",
        "name": "ScatterGather",
        "description": "Pointer to a SCATTER_GATHER_LIST structure previously returned by GetScatterGatherList."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "WriteToDevice",
        "description": "Indicates the direction of the DMA transfer: specify TRUE for a transfer from the buffer to the device, and FALSE otherwise."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ReadDmaCounter routine returns the number of bytes remaining to be transferred during the current subordinate DMA operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ReadDmaCounter returns the number of bytes remaining to be transferred in the current DMA operation. ",
    "remarks": "ReadDmaCounter            is not a system routine that can be called directly by name. This routine is callable only by pointer from the address returned in a            DMA_OPERATIONS            structure. Drivers obtain the address of this routine by calling IoGetDmaAdapter. ReadDmaCounter can be called only by drivers of subordinate DMA devices. Usually, the caller is the driver of a subordinate device that uses a system DMA controller's autoinitialize mode. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "ReadDmaCounter",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDMA_ADAPTER",
        "name": "DmaAdapter",
        "description": "Pointer to the adapter object previously returned by IoGetDmaAdapter representing the system DMA controller channel currently in use."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The InterruptService routine (ISR) quickly services a device interrupt and schedules post-interrupt processing of received data, if necessary.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "If the routine determines that the interrupt did not come from one of the driver's devices, it must return FALSE. Otherwise, the routine must service the interrupt and return TRUE. ",
    "remarks": "To register an ISR for a specific interrupt vector and processor affinity, a driver must call IoConnectInterrupt or IoConnectInterruptEx. A driver's InterruptService routine (ISR) executes in an interrupt context, at some system-assigned DIRQL, as specified by the SynchronizeIrql parameter to IoConnectInterrupt. (Other devices, with higher DIRQL values, can interrupt the ISR.) Before the system calls an ISR, it acquires the interrupt's spin lock (the SpinLock parameter to IoConnectInterrupt), so the ISR cannot simultaneously execute on another processor. After the ISR returns, the system releases the spin lock. An ISR must first determine if the interrupt came from one of the driver's devices, by examining context information supplied by Context. If the interrupt is not from one of the driver's devices, the routine must immediately return FALSE so the I/O manager can call other drivers that have registered ISRs for the same processor and interrupt vector. For more information about implementing ISRs, see Interrupt Service Routines. To define an InterruptService callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define an InterruptService callback routine that is named MyInterruptService, use the KSERVICE_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The KSERVICE_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the KSERVICE_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "KSERVICE_ROUTINE InterruptService; BOOLEAN",
    "category": "Drivers",
    "name": "InterruptService",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct _KINTERRUPT*",
        "name": "Interrupt",
        "description": "Caller-supplied pointer to the KINTERRUPT structure for the interrupt."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ServiceContext",
        "description": "Caller-supplied pointer to context information, specified in a previous call to IoConnectInterrupt or IoConnectInterruptEx."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "An InterruptMessageService routine services a message-signaled interrupt.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The InterruptMessageService routine returns TRUE if the interrupt is one handled by the InterruptMessageService routine. Otherwise, it returns FALSE. ",
    "remarks": "Drivers use IoConnectInterruptEx to register an InterruptMessageService routine to handle their message-signaled interrupts. A driver can subsequently unregister the routine by calling IoDisconnectInterruptEx. Message-signaled interrupts are supported starting with Windows Vista. The system can call an InterruptMessageService routine even when the routine's interrupt has not occurred. For example, if a message-signaled interrupt is shared, InterruptMessageService can be called for interrupts belonging to other devices. The routine must check whether the value for the ServiceContext parameter matches the value passed to IoConnectInterruptEx. If the value does match, InterruptMessageService handles the interrupt and returns TRUE. Otherwise, InterruptMessageService does not handle the interrupt and returns FALSE. Note that if the system receives multiple identical interrupts over a short time interval, it can combine these into a single call to InterruptMessageService. The routine must be written to handle multiple identical interrupts within a single call. Message-signaled interrupts are similar in behavior to edge-triggered interrupts. The device sends an interrupt request but does not receive any hardware acknowledgment that the request was received. An InterruptMessageService executes at an IRQL greater than or equal to the maximum device IRQL (DIRQL) for every interrupt the routine handles. To define an InterruptMessageService callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define an InterruptMessageService callback routine that is named MyInterruptMessageService, use the KMESSAGE_SERVICE_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The KMESSAGE_SERVICE_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the KMESSAGE_SERVICE_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "KMESSAGE_SERVICE_ROUTINE InterruptMessageService; BOOLEAN",
    "category": "Drivers",
    "name": "InterruptMessageService",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct _KINTERRUPT*",
        "name": "Interrupt",
        "description": "A pointer to the KINTERRUPT structure for the interrupt. The driver received this pointer in the call to the IoConnectInterruptEx routine that registered the driver's InterruptMessageService routine."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ServiceContext",
        "description": "The ServiceContext value that the driver passed to IoConnectInterruptEx when the InterruptMessageService routine was registered."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageId",
        "description": "The message ID for the interrupt. This value is the index for the interrupt's entry in the MessageInfo member array in the IO_INTERRUPT_MESSAGE_INFO structure that describes the driver's message-signaled interrupts."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "For more information, see the WdmlibIoDisconnectInterruptEx function.",
    "library": "NtosKrnl.lib;  Iointex.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "For more information, see the WdmlibIoDisconnectInterruptEx function. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoDisconnectInterruptEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIO_DISCONNECT_INTERRUPT_PARAMETERS",
        "name": "Parameters",
        "description": "For more information, see the WdmlibIoDisconnectInterruptEx function."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoInitializeDpcRequest routine registers a driver-supplied DpcForIsr routine.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "IoInitializeDpcRequest associates a driver-supplied DpcForIsr routine with a given device object. The driver's InterruptService routine (ISR) can call IoRequestDpc to queue the DpcForIsr routine. The DpcForIsr routine completes interrupt-driven I/O operations at a lower IRQL than that of the ISR. PnP drivers call IoInitializeDpcRequest from the AddDevice routine. For more information, see DPC Objects and DPCs. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoInitializeDpcRequest",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Supplies a pointer to the DEVICE_OBJECT structure representing the physical device that generates interrupts."
      },
      {
        "in_out": "_In_",
        "type": "PIO_DPC_ROUTINE",
        "name": "DpcRoutine",
        "description": "Supplies a pointer to the driver-supplied DpcForIsr routine."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoCreateController routine allocates memory for and initializes a controller object with a controller extension of a driver-determined size.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "IoCreateController returns a pointer to the controller object or a NULL pointer if memory could not be allocated for the requested device extension. ",
    "remarks": "A controller object usually represents a physical device controller with attached devices on which a single driver carries out I/O requests. The controller extension is allocated from nonpaged pool and is guaranteed to be accessible by any driver routine and in an arbitrary thread context. The controller object is used to synchronize I/O operations to target devices for which I/O requests can come in concurrently to a single, monolithic driver. A driver also might use a controller object to synchronize operations through device channels. If IoCreateController returns NULL, the driver should fail device start-up. ",
    "return_type": "PCONTROLLER_OBJECT",
    "category": "Drivers",
    "name": "IoCreateController",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Size",
        "description": "Specifies the number of bytes to be allocated for the controller extension."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoDeleteController routine removes a given controller object from the system, for example, when the driver that created it is being unloaded.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "IoDeleteController deallocates the memory for the controller object, including the controller extension. This routine must be called when a driver that created a controller object is being unloaded or when the driver encounters a fatal error during device start-up, such as being unable to properly initialize a physical device. A driver must release certain resources for which the driver supplied storage in its controller extension before it calls IoDeleteController. For example, if the driver stores the pointer to its interrupt object(s) in the controller extension, it must call IoDisconnectInterrupt before IoDeleteController. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoDeleteController",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCONTROLLER_OBJECT",
        "name": "ControllerObject",
        "description": "Pointer to the controller object to be released."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The CustomDpc routine finishes the servicing of an I/O operation, after an InterruptService routine returns.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "To create a DPC object and register a CustomDpc routine for that object, a driver must call KeInitializeDpc. (If you need only one DPC routine, you can use a DpcForIsr routine and the system-allocated DPC object.) To queue a CustomDpc routine for execution, a driver's InterruptService routine must call KeInsertQueueDpc. One or more CustomDpc routines can be used instead of, or in conjunction with, a DpcForIsr routine. A driver that maintains several internal IRP queues typically supplies a CustomDpc routine for each queue. Each CustomDpc routine is typically responsible for at least the following tasks: A CustomDpc routine might also retry a failed operation or set up the next transfer for a large I/O request that has been broken into smaller pieces. For more information about CustomDpc routines, see DPC Objects and DPCs. To define a CustomDpc callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a CustomDpc callback routine that is named MyCustomDpc, use the KDEFERRED_ROUTINE type as shown in this code example: Then, implement your callback routine as follows: The KDEFERRED_ROUTINE function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the KDEFERRED_ROUTINE function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "KDEFERRED_ROUTINE CustomDpc; VOID",
    "category": "Drivers",
    "name": "CustomDpc",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct _KDPC*",
        "name": "Dpc",
        "description": "Caller-supplied pointer to a KDPC structure, which represents the DPC object that is associated with this CustomDpc routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "DeferredContext",
        "description": "Caller-supplied pointer to driver-defined context information that was specified in a previous call to KeInitializeDpc."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SystemArgument1",
        "description": "Caller-supplied pointer to driver-supplied information that was specified in a previous call to KeInsertQueueDpc."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "SystemArgument2",
        "description": "Caller-supplied pointer to driver-supplied information that was specified in a previous call to KeInsertQueueDpc."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeInitializeEvent routine initializes an event object as a synchronization (single waiter) or notification type event and sets it to a signaled or not-signaled state.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Storage for an event object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. If you allocate the event on the stack, you must specify a KernelMode wait when calling KeWaitForSingleObject, KeWaitForMutexObject, or KeWaitForMultipleObjects. During a KernelMode wait, the stack containing the event will not be paged out. Drivers typically use a NotificationEvent to wait for an I/O operation to complete. When a notification event is set to the signaled state, all threads that were waiting for the event to be set to the signaled state become eligible for execution. The event remains in the signaled state until a thread calls KeResetEvent or KeClearEvent to set the event in the not-signaled state. A SynchronizationEvent is also called an autoreset or autoclearing event. When such an event is set, a single waiting thread becomes eligible for execution. The kernel automatically resets the event to the not-signaled state each time a wait is satisfied. A driver might use a synchronization event to protect a shared resource that is used in synchronizing the operations of several threads. Synchronization events are rarely used in a typical driver. For more information about event objects, see Event Objects. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PRKEVENT",
        "name": "Event",
        "description": "Pointer to an event object, for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "EVENT_TYPE",
        "name": "Type",
        "description": "Specifies the event type, either NotificationEvent or SynchronizationEvent."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "State",
        "description": "Specifies the initial state of the event. TRUE indicates a signaled state."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ExInitializeFastMutex routine initializes a fast mutex variable, used to synchronize mutually exclusive access by a set of threads to a shared resource.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "ExInitializeFastMutex must be called before any calls to other ExXxxFastMutex routines occur. Although the caller supplies the storage for the given fast mutex, the FAST_MUTEX structure is opaque: that is, its members are reserved for system use. For better performance, use the ExXxxFastMutex routines instead of the KeXxxMutex routines. However, a fast mutex cannot be acquired recursively, as a kernel mutex can. For more information about fast mutexes, see Fast Mutexes and Guarded Mutexes. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ExInitializeFastMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PFAST_MUTEX",
        "name": "FastMutex",
        "description": "A pointer to a caller-allocated FAST_MUTEX structure, which represents the fast mutex, in the nonpaged memory pool. The allocation must be 4-byte aligned on 32-bit platforms, and 8-byte aligned on 64-bit platforms."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KeInitializeMutex routine initializes a mutex object, setting it to a signaled state.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "For better performance, use fast mutexes or guarded mutexes. For more information, see Alternatives to Mutex Objects. The mutex object is initialized with an initial state of signaled. Storage for a mutex object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. For more information about mutex objects, see Mutex Objects. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeMutex",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PRKMUTEX",
        "name": "Mutex",
        "description": "Pointer to a mutex object, for which the caller provides the storage. The storage must be 4-byte aligned on 32-bit platforms, and 8-byte aligned on 64-bit platforms."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Level",
        "description": "Reserved. Drivers set this to zero."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The KeInitializeSemaphore routine initializes a semaphore object with a specified count and specifies an upper limit that the count can attain.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "The semaphore object is initialized with the specified initial count and limit. Storage for a semaphore object must be resident: in the device extension of a driver-created device object, in the controller extension of a driver-created controller object, or in nonpaged pool allocated by the caller. For more information about semaphore objects, see Semaphore Objects. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeInitializeSemaphore",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PRKSEMAPHORE",
        "name": "Semaphore",
        "description": "Pointer to a dispatcher object of type semaphore, for which the caller provides the storage."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Count",
        "description": "Specifies the initial count value to be assigned to the semaphore. This value must be positive. A nonzero value sets the initial state of the semaphore to signaled."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "Limit",
        "description": "Specifies the maximum count value that the semaphore can attain. This value must be positive. It determines how many waiting threads become eligible for execution when the semaphore is set to the signaled state and can therefore access the resource that the semaphore protects."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoCreateNotificationEvent routine creates or opens a named notification event used to notify one or more threads of execution that an event has occurred.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoCreateNotificationEvent returns a pointer to the created or opened event object or NULL if the event object could not be created or opened. ",
    "remarks": "IoCreateNotificationEvent creates and opens the event object if it does not already exist. IoCreateNotificationEvent sets the state of a new notification event to Signaled. If the event object already exists, IoCreateNotificationEvent just opens the event object. When a notification event is set to the Signaled state it remains in that state until it is explicitly cleared. Notification events, like synchronization events, are used to coordinate execution. Unlike a synchronization event, a notification event is not auto-resetting. Once a notification event is in the Signaled state, it remains in that state until it is explicitly reset (with a call to KeClearEvent or KeResetEvent). To synchronize on a notification event: Sharing event objects between user mode and kernel mode requires care. There are two main methods for sharing event objects: For more information about events, see Event Objects. ",
    "return_type": "PKEVENT",
    "category": "Drivers",
    "name": "IoCreateNotificationEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "EventName",
        "description": "Pointer to a buffer containing a null-terminated Unicode string that names the event."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "EventHandle",
        "description": "Pointer to a location in which to return a handle for the event object. In Windows Server 2003 and later versions of Windows, the returned handle is a kernel handle."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoCreateSynchronizationEvent routine creates or opens a named synchronization event for use in serialization of access to hardware between two otherwise unrelated drivers.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Ntddk.h)",
    "return_value": "IoCreateSynchronizationEvent returns a pointer to the created or opened event object or NULL if the event object could not be created or opened. ",
    "remarks": "The event object is created if it does not already exist. IoCreateSynchronizationEvent sets the state of a new synchronization event to Signaled. If the event object already exists, it is simply opened. The pair of drivers that use a synchronization event call KeWaitForSingleObject with the PKEVENT pointer returned by this routine. When a synchronization event is set to the Signaled state, a single thread of execution that was waiting for the event is released, and the event is automatically reset to the Not-Signaled state. To release the event, a driver calls ZwClose with the event handle. Sharing event objects between user mode and kernel mode requires care. There are two main methods for sharing event objects: For more information about events, see Event Objects. ",
    "return_type": "PKEVENT",
    "category": "Drivers",
    "name": "IoCreateSynchronizationEvent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "EventName",
        "description": "Pointer to a buffer containing a null-terminated Unicode string that names the event."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "EventHandle",
        "description": "Pointer to a location in which to return a handle for the event object. In Windows Server 2003 and later versions of Windows, the returned handle is a kernel handle."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The ObReferenceObjectByHandle routine provides access validation on the object handle, and, if access can be granted, returns the corresponding pointer to the object's body.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ObReferenceObjectByHandle returns STATUS_SUCCESS if the call is successful. Possible return values include the following error codes:  ",
    "remarks": "A pointer to the object body is retrieved from the object table entry and returned to the caller by means of the Object parameter. If AccessMode is UserMode, the requested access is compared to the granted access for the object. If AccessMode is KernelMode, the handle should originate in the kernel address space. Starting with Windows 7, if AccessMode is KernelMode and handle is received from user address space, Driver Verifier issues bugcheck C4, subcode F6. If the call succeeds, a pointer to the object body is returned to the caller and the pointer reference count is incremented. Incrementing this count prevents the object from being deleted while the pointer is being referenced. The caller must decrement the reference count with ObDereferenceObject as soon as it is done with the object. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ObReferenceObjectByHandle",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Handle",
        "description": "Specifies an open handle for an object."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies the requested types of access to the object. The interpretation of this field is dependent on the object type. Do not use any generic access rights. For more information, see ACCESS_MASK."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_TYPE",
        "name": "ObjectType",
        "description": "Pointer to the object type. ObjectType can be *ExEventObjectType, *ExSemaphoreObjectType, *IoFileObjectType, *PsProcessType, *PsThreadType, *SeTokenObjectType, *TmEnlistmentObjectType, *TmResourceManagerObjectType, *TmTransactionManagerObjectType, or *TmTransactionObjectType. Note  The SeTokenObjectType object type is supported starting with Windows XP.   If ObjectType is not NULL, the operating system verifies that the supplied object type matches the object type of the object that Handle specifies."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "AccessMode",
        "description": "Specifies the access mode to use for the access check. It must be either UserMode or KernelMode. Drivers should always specify UserMode for handles they receive from user address space."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "Object",
        "description": "Pointer to a variable that receives a pointer to the object's body. The following table contains the pointer types.  ObjectType parameterObject pointer type  *ExEventObjectType  PKEVENT   *ExSemaphoreObjectType  PKSEMAPHORE   *IoFileObjectType  PFILE_OBJECT   *PsProcessType  PEPROCESS or PKPROCESS   *PsThreadType  PETHREAD or PKTHREAD   *SeTokenObjectType  PACCESS_TOKEN   *TmEnlistmentObjectType  PKENLISTMENT   *TmResourceManagerObjectType  PKRESOURCEMANAGER   *TmTransactionManagerObjectType  PKTM   *TmTransactionObjectType  PKTRANSACTION     The structures that the pointer types reference are opaque, and drivers cannot access the structure members. Because the structures are opaque, PEPROCESS is equivalent to PKPROCESS, and PETHREAD is equivalent to PKTHREAD. Note  The SeTokenObjectType object type is supported starting with Windows XP."
      },
      {
        "in_out": "_Out_opt_",
        "type": "POBJECT_HANDLE_INFORMATION",
        "name": "HandleInformation",
        "description": "Drivers set this to NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ObReferenceObjectByPointer routine increments the pointer reference count for a given object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ObReferenceObjectByPointer returns an NTSTATUS value. Possible return values include: ",
    "remarks": "Calling this routine prevents the object from being deleted, possibly by another component's call to ObDereferenceObject or ZwClose. The caller must decrement the reference count with ObDereferenceObject as soon as it is done with the object. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ObReferenceObjectByPointer",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Object",
        "description": "Pointer to the object's body."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "Specifies a mask representing the requested access to the object."
      },
      {
        "in_out": "_In_opt_",
        "type": "POBJECT_TYPE",
        "name": "ObjectType",
        "description": "Pointer to the object type. ObjectType can be *ExEventObjectType, *ExSemaphoreObjectType, *IoFileObjectType, *PsProcessType, *PsThreadType, *SeTokenObjectType, *TmEnlistmentObjectType, *TmResourceManagerObjectType, *TmTransactionManagerObjectType, or *TmTransactionObjectType.  Note    The SeTokenObjectType object type is supported in Windows XP and later versions of Windows.   This parameter can also be NULL if AccessMode is KernelMode."
      },
      {
        "in_out": "_In_",
        "type": "KPROCESSOR_MODE",
        "name": "AccessMode",
        "description": "Indicates the access mode to use for the access check. It must be either UserMode or KernelMode. Lower-level drivers should specify KernelMode."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ObReferenceObject routine increments the reference count to the given object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ObReferenceObject returns a value that is reserved for system use. Drivers must treat this value as VOID. ",
    "remarks": "ObReferenceObject simply increments the pointer reference count for an object, without making any access checks on the given object, as ObReferenceObjectByHandle and ObReferenceObjectByPointer do. ObReferenceObject prevents deletion of the object at least until the driver subsequently calls its reciprocal, ObDereferenceObject, or closes the given object. The caller must decrement the reference count with ObDereferenceObject as soon as it is done with the object. When the reference count for an object reaches zero, a kernel-mode component can remove the object from the system. However, a driver can remove only those objects that it created, and a driver should never attempt to remove any object that it did not create. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ObReferenceObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Object",
        "description": "Pointer to the object. The caller obtained this parameter either when it created the object or from a preceding call to ObReferenceObjectByHandle after it opened the object."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The ObDereferenceObject routine decrements the given object's reference count and performs retention checks.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, Ntifs.h, or Fltkernel.h)",
    "return_value": "ObDereferenceObject returns a value that is reserved for system use. Drivers must treat this value as VOID. ",
    "remarks": "ObDereferenceObject decreases the reference count of an object by one. If the object was created as temporary (the OBJ_PERMANENT flag was not specified on creation), and the reference count reaches zero, the object can be deleted by the system. A driver can delete a temporary object it created by decreasing its reference count to zero. A driver must never attempt to delete an object it did not create. An object is permanent if it was created with the OBJ_PERMANENT object attribute flag specified. (For more information about object attributes, see InitializeObjectAttributes.) A permanent object is created with a reference count of one, so it is not deleted when the driver dereferences it. A driver can only delete a permanent object it created by using the ZwMakeTemporaryObject routine to make it temporary. Use the following steps to delete a permanent object that you created: ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ObDereferenceObject",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Object",
        "description": "Pointer to the object's body."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "This function is obsolete in Windows XP and later versions of the Windows operating system. Use RtlGetVersion instead.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "PsGetVersion returns whether the system is a checked or free build, as follows:  ",
    "remarks": "PsGetVersion returns the requested information, depending on which optional parameter(s) the caller supplies. To retrieve the current service-pack number, it is easier and more efficient to make an application-level call within the Win32 environment than to call PsGetVersion during system driver initialization, which then must parse the string it returns at CSDVersion. When the registry is initialized, a driver cannot obtain this string from PsGetVersion, but must read the CmCSDVersionString value from the registry. ",
    "return_type": "BOOLEAN",
    "category": "Drivers",
    "name": "PsGetVersion",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "MajorVersion",
        "description": "Points to a caller-supplied variable that this routine sets to the major version of the operating system. This optional parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "MinorVersion",
        "description": "Points to a caller-supplied variable that this routine sets to the minor version of the operating system. This optional parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "BuildNumber",
        "description": "Points to a caller-supplied variable that this routine sets to the current build number of the operating system. This optional parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PUNICODE_STRING",
        "name": "CSDVersion",
        "description": "Points to a caller-allocated buffer in which this routine returns the current service-pack version as a Unicode string only during system driver initialization. This optional parameter can be NULL."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The ObGetObjectSecurity routine gets the security descriptor for a given object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "ObGetObjectSecurity either returns STATUS_SUCCESS or an error status, such as STATUS_INSUFFICIENT_RESOURCES if it could not allocate enough memory to return the requested information. ",
    "remarks": "A successful call to ObGetObjectSecurity either returns a self-relative security descriptor in the buffer at *SecurityDescriptor or it returns NULL at *SecurityDescriptor if the given object has no security descriptor. For example, any unnamed object, such as an event object, has no security descriptor. If ObGetObjectSecurity returns STATUS_SUCCESS, the caller must save the value returned at MemoryAllocated. Such a caller must pass MemoryAllocated in a reciprocal call to ObReleaseObjectSecurity eventually, thereby restoring the reference count on the security descriptor to its original value and releasing the buffer, if any, that was allocated by ObGetObjectSecurity. ObGetObjectSecurity should only be called at IRQL Level = PASSIVE_LEVEL with APCs enabled, otherwise deadlocks or crashes may occur. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "ObGetObjectSecurity",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Object",
        "description": "Pointer to the object."
      },
      {
        "in_out": "_Out_",
        "type": "PSECURITY_DESCRIPTOR*",
        "name": "SecurityDescriptor",
        "description": "Pointer to a caller-supplied variable that this routine sets to the address of a buffer containing the SECURITY_DESCRIPTOR for the given object. If the given object has no security descriptor, this variable is set to NULL on return from ObGetObjectSecurity."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "MemoryAllocated",
        "description": "Pointer to a caller-supplied variable that this routine sets to TRUE if it allocated a buffer to contain the security descriptor."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The ObReleaseObjectSecurity routine is the reciprocal to ObGetObjectSecurity.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "After a successful call to ObGetObjectSecurity, a driver must call ObReleaseObjectSecurity eventually. ObReleaseObjectSecurity releases any resources that were allocated by ObGetObjectSecurity. It also decrements the reference count on the given security descriptor. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "ObReleaseObjectSecurity",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "SecurityDescriptor",
        "description": "Pointer to the buffered SECURITY_DESCRIPTOR to be released. The caller obtained this parameter from ObGetObjectSecurity"
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "MemoryAllocated",
        "description": "Specifies the value also obtained from ObGetObjectSecurity."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The IoGetInitialStack routine returns the base address of the current thread's stack.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Ntddk.h)",
    "return_value": "IoGetInitialStack returns the initial base address of the current thread's stack. ",
    "remarks": "Highest-level drivers can call this routine, particularly file systems attempting to determine whether they've been passed a pointer to a location on the current thread's stack. ",
    "return_type": "PVOID",
    "category": "Drivers",
    "name": "IoGetInitialStack",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The IoGetRemainingStackSize routine returns the current amount of available kernel-mode stack space.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "IoGetRemainingStackSize returns the number of bytes of stack space in the current thread context. ",
    "remarks": "Highest-level drivers, such as file systems, can call this routine, particularly drivers that use recursive code paths. Such a driver would call IoGetRemainingStackSize before launching a recursion to determine whether it should continue processing on an alternate code path. For Windows Server 2003 Service Pack 1 (SP1) and later versions of Windows, callers of IoGetRemainingStackSize can be running at any IRQL. For earlier versions of Windows, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "ULONG_PTR",
    "category": "Drivers",
    "name": "IoGetRemainingStackSize",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoGetStackLimits routine returns the boundaries of the current thread's stack frame.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Highest-level drivers can call this routine, particularly file systems that have been passed a pointer to a location on the current thread's stack. In Windows Server 2003 Service Pack 1 (SP1) and later versions of Windows, callers of IoGetStackLimits can be running at any IRQL. For earlier operating systems, the caller must be running at IRQL <= APC_LEVEL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoGetStackLimits",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "LowLimit",
        "description": "Pointer to a caller-supplied variable in which this routine returns the lower offset of the current thread's stack frame."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG_PTR",
        "name": "HighLimit",
        "description": "Pointer to a caller-supplied variable in which this routine returns the higher offset of the current thread's stack frame."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "The IoCsqInsertIrp routine inserts an IRP in the driver's cancel-safe IRP queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "IoCsqInsertIrp uses the queue's dispatch routines to insert the IRP. The IoCsqInsertIrp routine: If the IRP to be inserted has already been canceled, IoCsqInsertIrp does not attempt to insert the IRP into the queue. Drivers can also use IoCsqInsertIrpEx to insert an IRP into the queue. For a queue that is specified by IoCsqInitializeEx, IoCsqInsertIrpEx provides additional capabilities. For more information, see Cancel-Safe IRP Queues. Note that the IoCsqXxx routines use the DriverContext[3] member of the IRP to hold IRP context information. Drivers that use these routines to queue IRPs must leave that member unused. Callers of IoCsqInsertIrp must be running at an IRQL <= DISPATCH_LEVEL. The driver's callback routines must work correctly at that IRQL. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoCsqInsertIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIO_CSQ",
        "name": "Csq",
        "description": "Pointer to the IO_CSQ structure for the driver's cancel-safe IRP queue. This structure must have been initialized by IoCsqInitialize or IoCsqInitializeEx."
      },
      {
        "in_out": "_Inout_",
        "type": "PIRP",
        "name": "Irp",
        "description": "Pointer to the IRP to be queued."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PIO_CSQ_IRP_CONTEXT",
        "name": "Context",
        "description": "Pointer to an IO_CSQ_IRP_CONTEXT structure. IoCsqInsertIrp initializes this structure with context information for the inserted IRP. The driver passes this value to IoCsqRemoveIrp to delete the IRP from the queue. Context can be NULL if the driver will not use IoCsqRemoveIrp to remove this IRP from the queue."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoCsqRemoveIrp routine removes a particular IRP from the queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine returns a pointer to the IRP that was removed from the queue, or NULL if that IRP has been canceled. ",
    "remarks": "IoCsqRemoveIrp uses the queue's dispatch routines to remove the IRP. The IoCsqRemoveIrp routine: Drivers can use the IoCsqRemoveNextIrp routine to remove an IRP that matches a specific criterion. For more information, see Cancel-Safe IRP Queues. Note that IoCsqXxx routines use the DriverContext[3] member of the IRP to hold IRP context information. Drivers that use these routines to queue IRPs must leave that member unused. Callers of IoCsqRemoveIrp must be running at an IRQL <= DISPATCH_LEVEL. The driver's callback routines must work correctly at that IRQL. ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoCsqRemoveIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIO_CSQ",
        "name": "Csq",
        "description": "Pointer to the IO_CSQ structure for the driver's cancel-safe IRP queue. This structure must have been initialized by IoCsqInitialize or IoCsqInitializeEx."
      },
      {
        "in_out": "_Inout_",
        "type": "PIO_CSQ_IRP_CONTEXT",
        "name": "Context",
        "description": "Pointer to the IO_CSQ_IRP_CONTEXT structure that identifies the IRP to remove. The IO_CSQ_IRP_CONTEXT structure is initialized by IoCsqInsertIrp or IoCsqInsertIrpEx when the IRP is first inserted in the queue."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The IoCsqRemoveNextIrp routine removes the next matching IRP in the queue.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "This routine returns a pointer to the next matching IRP in the queue, or NULL if no more IRPs are available. The routine only returns IRPs that have not yet been canceled. ",
    "remarks": "IoCsqRemoveNextIrp uses the queue's dispatch routines to remove the IRP. The IoCsqRemoveNextIrp routine: For more information, see Cancel-Safe IRP Queues. Note that IoCsqXxx routines use the DriverContext[3] member of the IRP to hold IRP context information. Drivers that use these routines to queue IRPs must leave that member unused. Callers of IoCsqRemoveNextIrp must be running at an IRQL <= DISPATCH_LEVEL. The driver's callback routines must work correctly at that IRQL. ",
    "return_type": "PIRP",
    "category": "Drivers",
    "name": "IoCsqRemoveNextIrp",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PIO_CSQ",
        "name": "Csq",
        "description": "Pointer to the driver's dispatch table for cancel-safe IRP queues. The dispatch table must be initialized by IoCsqInitialize."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "PeekContext",
        "description": "A pointer to a driver-defined context value. IoCsqRemoveNextIrp passes this parameter to the driver's CsqPeekNextIrp routine. For more information, see the following Remarks section."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeFlushQueuedDpcs routine returns after all queued DPCs on all processors have executed.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "Drivers can use this routine to wait until all currently-queued DPCs are run. Note that KeFlushQueuedDpcs can take a long time to return, so drivers should not use it along any critical code paths. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "KeFlushQueuedDpcs",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The IoAllocateController routine sets up the call to a driver-supplied ControllerControl routine as soon as the device controller, represented by the given controller object, is available to carry out an I/O operation for the target device, represented by the given device object.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "This routine reserves exclusive access to the hardware controller for the specified device. The ControllerControl routine returns a value indicating whether the controller remains allocated to the device, either DeallocateObject or KeepObject. If it returns KeepObject, the driver must subsequently call IoFreeController to release the controller object. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoAllocateController",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCONTROLLER_OBJECT",
        "name": "ControllerObject",
        "description": "Pointer to a driver-created controller object, usually representing a physical controller to be allocated for an I/O operation on an attached device."
      },
      {
        "in_out": "_In_",
        "type": "PDEVICE_OBJECT",
        "name": "DeviceObject",
        "description": "Pointer to the device object, representing the target device of the current IRP."
      },
      {
        "in_out": "_In_",
        "type": "PDRIVER_CONTROL",
        "name": "ExecutionRoutine",
        "description": "Pointer to the driver-supplied ControllerControl routine."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "Context",
        "description": "Pointer to a driver-determined context, passed to the driver's ControllerControl routine when it is called."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The ControllerControl routine starts a data transfer operation.",
    "library": "",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The routine must return one of the enumerated values defined by IO_ALLOCATION_ACTION. ",
    "remarks": "A driver's ControllerControl routine executes in an arbitrary thread context at IRQL = DISPATCH_LEVEL. To register a ControllerControl routine for a specific device object, a driver must call IoCreateController to obtain a controller object, then call IoAllocateController to request use of the controller and to supply the ControllerControl routine's address. When the controller is free, the system calls the ControllerControl routine. For detailed information about implementing a ControllerControl routine, see Writing ControllerControl Routines. Also see Controller Objects. To define a ControllerControl callback routine, you must first provide a function declaration that identifies the type of callback routine you're defining. Windows provides a set of callback function types for drivers. Declaring a function using the callback function types helps Code Analysis for Drivers, Static Driver Verifier (SDV), and other verification tools find errors, and it's a requirement for writing drivers for the Windows operating system. For example, to define a ControllerControl callback routine that is named MyControllerControl, use the DRIVER_CONTROL type as shown in this code example: Then, implement your callback routine as follows: The DRIVER_CONTROL function type is defined in the Wdm.h header file. To more accurately identify errors when you run the code analysis tools, be sure to add the _Use_decl_annotations_ annotation to your function definition. The _Use_decl_annotations_ annotation ensures that the annotations that are applied to the DRIVER_CONTROL function type in the header file are used. For more information about the requirements for function declarations, see Declaring Functions by Using Function Role Types for WDM Drivers. For information about _Use_decl_annotations_, see Annotating Function Behavior. ",
    "return_type": "DRIVER_CONTROL ControllerControl; IO_ALLOCATION_ACTION",
    "category": "Drivers",
    "name": "ControllerControl",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct _DEVICE_OBJECT*",
        "name": "DeviceObject",
        "description": "Caller-supplied pointer to a DEVICE_OBJECT structure. This is the device object for the target device, previously created by the driver's AddDevice routine."
      },
      {
        "in_out": "_Inout_",
        "type": "struct _IRP*",
        "name": "Irp",
        "description": "Caller-supplied pointer to an IRP structure that describes the I/O operation, if the driver has a StartIo routine. Otherwise, not used."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "MapRegisterBase",
        "description": "Not used."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Context",
        "description": "Caller-supplied pointer to driver-defined context information, specified in a previous call to IoAllocateController."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The IoFreeController routine releases a previously allocated controller object when the driver has completed an I/O request.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "The connection between the current target device object and the controller object is released only if no requests are currently queued to the same device. Otherwise, the driver's ControllerControl routine is called with the next IRP bound through the device controller to the target device. ",
    "return_type": "VOID",
    "category": "Drivers",
    "name": "IoFreeController",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCONTROLLER_OBJECT",
        "name": "ControllerObject",
        "description": "Pointer to the driver's controller object, which was allocated for the current I/O operation on a particular device by calling IoAllocateController."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeStallExecutionProcessor routine stalls the caller on the current processor for a specified time interval.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "None ",
    "remarks": "KeStallExecutionProcessor is a processor-dependent routine that busy-waits for at least the specified number of microseconds, but not significantly longer. This routine is for use by device drivers and other software that must wait for an interval of less than a clock tick but more than for a few instructions. If you use this routine you must minimize the stall interval, typically to less than 50 microseconds. If a driver must wait for a longer interval, you should use a different synchronization technique. ",
    "return_type": " VOID",
    "category": "Drivers",
    "name": "KeStallExecutionProcessor",
    "is_callback": 0,
    "dll": "Hal.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MicroSeconds",
        "description": "Specifies the number of microseconds to stall."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeQueryTimeIncrement routine returns the number of 100-nanosecond units that are added to the system time each time the interval clock interrupts.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeQueryTimeIncrement returns a ULONG value indicating the number of 100-nanosecond units that are added to the system time each time the interval clock interrupts. ",
    "remarks": "At startup time, the operating system determines the time increment to use for the system time. This time increment remains constant until the computer restarts. During this time, calls to KeQueryTimeIncrement always return the same time increment value. The time increment does not change while the computer is running, and it does not change as the result of a suspend-resume cycle. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "KeQueryTimeIncrement",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeQueryInterruptTime routine returns the current value of the system interrupt time count, with accuracy to within system clock tick.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeQueryInterruptTime returns the current interrupt-time count in 100-nanosecond units. The update to this return value generally occurs at least once per system clock tick. ",
    "remarks": "This routine returns the system interrupt time, which is the amount of time since the operating system was last started. The interrupt-time count begins at zero when the operating system starts and is incremented at each clock interrupt by the length of a clock tick. For various reasons, such as hardware differences, the length of a system clock tick can vary between computers. Call the KeQueryTimeIncrement routine to determine the size of a system clock tick. KeQueryInterruptTime can be used for performance tuning. This routine returns a finer grained measurement than the KeQueryTickCount routine. A call to KeQueryInterruptTime has considerably less overhead than a call to the KeQueryPerformanceCounter routine, as well. Consequently, interrupt time can be used to measure very fine-grained durations while the system is running because operations that set or reset the system time have no effect on the system interrupt time count. However, power-management state changes do affect the system interrupt time count. Maintenance of the interrupt time count is suspended during system sleep states. When a subsequent wake state transition occurs, the system adds a \"bias\" value to the interrupt time count to compensate for the estimated duration of such a sleep state. The interrupt time count that is returned by KeQueryInterruptTime includes this bias value. To obtain an unbiased interrupt time count, use the KeQueryUnbiasedInterruptTime routine instead of KeQueryInterruptTime. ",
    "return_type": "ULONGLONG",
    "category": "Drivers",
    "name": "KeQueryInterruptTime",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeQueryInterruptTimePrecise routine returns the current value of the system interrupt time count, with accuracy to within a microsecond.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "The current interrupt-time count in 100-nanosecond units. ",
    "remarks": "KeQueryInterruptTimePrecise returns the system's current interrupt time, which is the amount of time since the operating system was last started. KeQueryInterruptTimePrecise is similar to the KeQueryInterruptTime routine, but is more precise. The interrupt time reported by KeQueryInterruptTime is based on the latest tick of the system clock timer. The clock timer is the hardware timer that periodically generates interrupts for the system clock. The uniform period between clock timer interrupts is referred to as a system clock tick, and is typically in the range of 500 microseconds to 15.625 milliseconds, depending on the hardware platform. The interrupt time value retrieved by KeQueryInterruptTime is accurate within a system clock tick. To provide an interrupt time value that is more precise than that of KeQueryInterruptTime, KeQueryInterruptTimePrecise uses the system performance counter to measure the time elapsed since the last clock timer interrupt, and adds this time to the interrupt time associated with the latest clock time. The interrupt time reported by KeQueryInterruptTimePrecise is accurate to within a microsecond. On some hardware platforms, a KeQueryInterruptTimePrecise call might be slower than a KeQueryInterruptTime call. The reason is that KeQueryInterruptTimePrecise reads the performance counter, which can introduce an additional delay. For more information, see KeQueryPerformanceCounter. Call the KeQueryTimeIncrement routine to determine the size of a system clock tick. Precise interrupt time can be used to measure very fine-grained durations while the system is running because operations that set or reset the system time have no effect on the system interrupt time count. However, power-management state changes do affect the system interrupt time count. Maintenance of the interrupt time count is suspended during system sleep states. When a subsequent wake state transition occurs, the system adds a \"bias\" value to the interrupt time count to compensate for the estimated duration of such a sleep state. The interrupt time count that is returned by KeQueryInterruptTimePrecise includes this bias value. To obtain an unbiased interrupt time count, use the KeQueryUnbiasedInterruptTime. A precise version of the unbiased interrupt time count is not currently available. ",
    "return_type": "ULONG64",
    "category": "Drivers",
    "name": "KeQueryInterruptTimePrecise",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "QpcTimeStamp",
        "description": "A pointer to a ULONG64 variable into which the routine writes the performance counter value used to interpolate the return value."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KeQueryPerformanceCounter routine retrieves the current value and frequency of the performance counter.",
    "library": "Hal.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)",
    "return_value": "KeQueryPerformanceCounter returns the performance counter value in units of ticks. ",
    "remarks": "KeQueryPerformanceCounter returns a 64-bit integer that represents the current value of a high-resolution monotonically nondecreasing counter. To obtain the frequency of the performance counter, specify a non-NULL pointer value for the PerformanceFrequency parameter. The frequency of the performance counter is fixed at system boot and is consistent across all processors. Therefore, a driver can cache the frequency of the performance counter during initialization. For more info about this function and its usage, see Acquiring high-resolution time stamps. ",
    "return_type": "LARGE_INTEGER",
    "category": "Drivers",
    "name": "KeQueryPerformanceCounter",
    "is_callback": 0,
    "dll": "Hal.dll",
    "arguments": [
      {
        "in_out": "_Out_opt_",
        "type": "PLARGE_INTEGER",
        "name": "PerformanceFrequency",
        "description": "A pointer to a variable to which KeQueryPerformanceCounter writes the performance counter frequency, in ticks per second. This parameter is optional and can be NULL if the caller does not need the counter frequency value."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KeGetCurrentProcessorNumber routine returns the system-assigned number of the current processor on which the caller is running.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "KeGetCurrentProcessorNumber returns a ULONG value that represents the processor on which the caller is currently running. ",
    "remarks": "KeGetCurrentProcessorNumber can be called to debug spin lock usage on SMP machines during driver development. A driver also might call KeGetCurrentProcessorNumber if it maintained some per-processor data and attempted to reduce cache-line contention. The number of processors in an SMP machine is a zero-based value. Windows 7 and later versions of Windows support processor groups. Drivers that are designed to handle information about processor groups should use the KeGetCurrentProcessorNumberEx routine, which specifies a processor group, instead of KeGetCurrentProcessorNumber, which does not. However, the implementation of KeGetCurrentProcessorNumber in Windows 7 and later versions of Windows provides compatibility for drivers that were written for earlier versions of Windows. In this implementation, KeGetCurrentProcessorNumber returns the group-relative processor number if the caller is running on a processor in group 0, which is compatible with the behavior of this routine in earlier versions of Windows that do not support processor groups. If the caller is running on a processor in any group other than group 0, this routine returns a number that is less than the number of processors in group 0. This behavior ensures that the return value is less than the return value of the KeQueryActiveProcessorCount routine. If the call to KeGetCurrentProcessorNumber occurs at IRQL <= APC_LEVEL, a processor switch can occur between instructions. Consequently, callers of KeGetCurrentProcessorNumber usually run at IRQL >= DISPATCH_LEVEL. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "KeGetCurrentProcessorNumber",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The KdBreakPointWithStatus macro breaks into the kernel debugger and sends the value of Status to the debugger.",
    "library": "",
    "min_server": "",
    "header": "Ntddk.h (include Ntddk.h)",
    "return_value": "None ",
    "remarks": "KdBreakPointWithStatus is identical to the DbgBreakPointWithStatus routine in code that is compiled for a debug configuration. This routine has no effect if compiled in a release configuration. On x86 computers, the Status parameter is stored in the eax register. On computers that have register calling conventions, Status is stored in the first argument register. This routine raises an exception that is handled by the kernel debugger if one is installed; otherwise it is handled by the debug system. If a debugger is not connected to the system, the exception can be handled in the standard way. In kernel mode, a break exception that is not handled will cause a bug check. You can, however, connect a kernel-mode debugger to a target computer that has stopped responding and has kernel debugging enabled. For more information, see Windows Debugging. ",
    "return_type": "NTSYSAPI VOID NTAPI",
    "category": "Drivers",
    "name": "KdBreakPointWithStatus",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Status",
        "description": "Specifies a ULONG value to be sent to the debugger (for example, a status code or an address)."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 6,
    "description": "The KdChangeOption routine accesses and changes state in the kernel that is related to kernel debugging.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "KdChangeOption returns STATUS_SUCCESS if it successfully carried out the requested operation. Otherwise, the return value can be one of the following error status codes: STATUS_ACCESS_DENIED STATUS_INVALID_INFO_CLASS STATUS_INVALID_PARAMETER STATUS_DEBUGGER_INACTIVE ",
    "remarks": "If the operating system was booted with no debug controls, KdChangeOption returns STATUS_DEBUGGER_INACTIVE. Currently, the only valid value for the Option parameter is KD_OPTION_SET_BLOCK_ENABLE. If Option is set to any other value, KdChangeOption returns STATUS_INVALID_INFO_CLASS. When Option is KD_OPTION_SET_BLOCK_ENABLE, the caller must set the InBufferBytes parameter to sizeof(BOOLEAN), the OutBufferBytes parameter to zero, and the OutBuffer parameter to NULL; otherwise, KdChangeOption returns STATUS_INVALID_PARAMETER. If the high bit (0x80) in the KdBlockEnable system variable is set to one, the debugger can never be re-enabled, and KdChangeOption returns STATUS_ACCESS_DENIED. Otherwise, KdChangeOption sets the KdBlockEnable system variable to the BOOLEAN value that InBuffer points to. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KdChangeOption",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "KD_OPTION",
        "name": "Option",
        "description": "A value from the KD_OPTION enumeration that indicates the kernel state to access and change. The value of this parameter determines the format and required length of the InBuffer and OutBuffer. Currently, the only valid value is KD_OPTION_SET_BLOCK_ENABLE."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "InBufferBytes",
        "description": "The size, in bytes, of the buffer at InBuffer. This value is optional."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "InBuffer",
        "description": "A pointer to a caller-allocated input buffer that contains information about the kernel state to change. If Option specifies a kernel state that does not require input data, this pointer can be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "ULONG",
        "name": "OutBufferBytes",
        "description": "The size, in bytes, of the buffer at OutBuffer. This value is optional."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "OutBuffer",
        "description": "A pointer to a caller-allocated output buffer in which information that pertains to the kernel state is returned. If Option specifies a kernel state that does not produce output data, this pointer can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "OutBufferNeeded",
        "description": "A pointer to a variable that receives the size, in bytes, of the required output buffer at OutBuffer. This value is optional."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KdDisableDebugger routine disables the kernel debugger.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "KdDisableDebugger returns STATUS_SUCCESS if the kernel debugger was successfully disabled. Otherwise, the return value can be one of the following error status codes: STATUS_ACCESS_DENIED STATUS_DEBUGGER_INACTIVE ",
    "remarks": "If the operating system was booted with no debug controls, KdDisableDebugger returns STATUS_DEBUGGER_INACTIVE. If the kernel debugger is blocked (that is, the KdBlockEnable system variable is set to a value other than FALSE), KdDisableDebugger returns STATUS_ACCESS_DENIED. After a caller calls KdDisableDebugger to disable the kernel debugger, the caller can call the KdEnableDebugger routine to re-enable the kernel debugger. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KdDisableDebugger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KdEnableDebugger routine re-enables the kernel debugger after a call to the KdDisableDebugger routine disables the kernel debugger.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "KdEnableDebugger returns STATUS_SUCCESS if the kernel debugger was successfully re-enabled. Otherwise, the return value can be one of the following error status codes:S TATUS_ACCESS_DENIED STATUS_DEBUGGER_INACTIVE ",
    "remarks": "If the operating system was booted with no debug controls, KdEnableDebugger returns STATUS_DEBUGGER_INACTIVE. If the kernel debugger is blocked (that is, the KdBlockEnable system variable is set to a value other than FALSE), KdEnableDebugger returns STATUS_ACCESS_DENIED. ",
    "return_type": "NTSTATUS",
    "category": "Drivers",
    "name": "KdEnableDebugger",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "The KdPrint macro sends a message to the kernel debugger.",
    "library": "NtosKrnl.lib (See DbgPrint.)",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "If successful, KdPrint returns the NTSTATUS code STATUS_SUCCESS; otherwise it returns the appropriate error code. ",
    "remarks": "KdPrint is identical to the DbgPrint routine in code that is compiled for a debug configuration.  This routine has no effect if compiled for a release configuration. Only kernel-mode drivers can call the KdPrint routine. In Microsoft Windows Server 2003 and earlier versions of Windows, the DbgPrint routine sends a message to the kernel debugger. In Windows Vista and later versions of Windows, KdPrint sends a message only if certain conditions apply. Specifically, it behaves like KdPrintEx with the DEFAULT component and a message importance level of DPFLTR_INFO_LEVEL. In other words, the following two function calls are identical: For more information about message filtering, components, and message importance level, see Reading and Filtering Debugging Messages. Unless it is absolutely necessary, you should not obtain a string from user input or another process and pass it to KdPrint. If you do use a string that you did not create, you must verify that this is a valid format string, and that the format codes match the argument list in type and quantity. The best coding practice is for all Format strings to be static and defined at compile time. There is no upper limit to the size of the Format string or the number of arguments. However, any single call to KdPrint will only transmit 512 bytes of information. There is also a limit to the size of the DbgPrint buffer. See The DbgPrint Buffer and the Debugger for details. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "KdPrint",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCHAR",
        "name": "Format",
        "description": "Specifies a pointer to the format string to print. The Format string supports most of the printf-style format specification fields. However, the Unicode format codes (%C, %S, %lc, %ls, %wc, %ws, and %wZ) can only be used with IRQL = PASSIVE_LEVEL. The KdPrint routine does not support any of the floating point types (%f, %e, %E, %g, %G, %a, or %A)."
      },
      {
        "in_out": "",
        "type": "",
        "name": "arguments",
        "description": "Specifies arguments for the format string, as in printf."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The KdPrintEx macro sends a string to the kernel debugger if the conditions you specify are met.",
    "library": "NtosKrnl.lib (See DbgPrintEx.)",
    "min_server": "",
    "header": "Wdm.h (include Wdm.h)",
    "return_value": "If successful, KdPrintEx returns the NTSTATUS code STATUS_SUCCESS; otherwise, it returns the appropriate error code. ",
    "remarks": "KdPrintEx is identical to the DbgPrintEx routine in code that is compiled for a debug configuration. This routine has no effect in code that is compiled for a release build. Only kernel-mode drivers can call the KdPrintEx routine. KdPrintEx either passes the specified string to the kernel debugger or does nothing at all, depending on the values of ComponentId, Level, and the corresponding component filter masks. For details, see Reading and Filtering Debugging Messages. Unless it is absolutely necessary, you should not obtain a string from user input or another process and pass it to KdPrintEx. If you do use a string that you did not create, you must verify that this is a valid format string, and that the format codes match the argument list in type and quantity. The best coding practice is for all Format strings to be static and defined at compile time. There is no upper limit to the size of the Format string or the number of arguments. However, any single call to KdPrintEx will only transmit 512 bytes of information. There is also a limit to the size of the DbgPrint buffer. See The DbgPrint Buffer and the Debugger for details. This routine is defined in ntddk.h and ndis.h; component filter IDs are defined in dpfilter.h, ndis.h, and wdm.h. Include ntddk.h or ndis.h. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "KdPrintEx",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ComponentId",
        "description": "Specifies the component calling this routine. This must be one of the component name filter IDs defined in the dpfilter.h header file. To avoid mixing your driver's output with the output of Windows components, you should use only the following values for ComponentId:   DPFLTR_IHVVIDEO_ID    DPFLTR_IHVAUDIO_ID    DPFLTR_IHVNETWORK_ID    DPFLTR_IHVSTREAMING_ID    DPFLTR_IHVBUS_ID    DPFLTR_IHVDRIVER_ID"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Level",
        "description": "Specifies the severity of this message. This can be any 32-bit integer. Values between 0 and 31 (inclusive) are treated differently than values between 32 and 0xFFFFFFFF. For details, see Reading and Filtering Debugging Messages."
      },
      {
        "in_out": "_In_",
        "type": "PCSTR",
        "name": "Format",
        "description": "Specifies a pointer to the format string to print. The Format string supports most of the printf-style format specification fields. However, the Unicode format codes (%C, %S, %lc, %ls, %wc, %ws, and %wZ) can only be used with IRQL = PASSIVE_LEVEL. The KdPrintEx routine does not support any of the floating point types (%f, %e, %E, %g, %G, %a, or %A)."
      },
      {
        "in_out": "",
        "type": "...",
        "name": "arguments",
        "description": "Specifies arguments for the format string, as in printf."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "The KdRefreshDebuggerNotPresent macro refreshes the value of the KD_DEBUGGER_NOT_PRESENT global kernel variable.",
    "library": "NtosKrnl.lib",
    "min_server": "",
    "header": "Ntddk.h (include Wdm.h or Ntddk.h)",
    "return_value": "KdRefreshDebuggerNotPresent returns the value of KD_DEBUGGER_NOT_PRESENT. ",
    "remarks": "When KdRefreshDebuggerNotPresent is called, it forces the value of KD_DEBUGGER_NOT_PRESENT to be updated to reflect whether a kernel debugger is currently attached. This updated value is also used as the return value of this routine. If a kernel debugger was recently attached or removed, the value of KD_DEBUGGER_NOT_PRESENT may not reflect the new state. If you suspect this has happened, you should call KdRefreshDebuggerNotPresent to refresh the value of this variable. After this call, you may use either the value of KD_DEBUGGER_NOT_PRESENT or the return value of KdRefreshDebuggerNotPresent to determine if the kernel debugger is present. KD_DEBUGGER_NOT_PRESENT can be modified by Windows or any other kernel-mode binary. Therefore, it is possible that the most recent return value of KdRefreshDebuggerNotPresent may not match the current value of KD_DEBUGGER_NOT_PRESENT. The following sample shows how to use KdRefreshDebuggerNotPresent: ",
    "return_type": "NTKERNELAPI BOOLEAN",
    "category": "Drivers",
    "name": "KdRefreshDebuggerNotPresent",
    "is_callback": 0,
    "dll": "NtosKrnl.exe",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 4,
    "description": "The vDbgPrintEx routine sends a string to the kernel debugger if certain conditions are met.",
    "library": "NtDll.lib (user mode);  NtosKrnl.lib (kernel mode)",
    "min_server": "",
    "header": "Wdm.h (include Dpfilter.h, Wdm.h, Ntddk.h, or Ndis.h)",
    "return_value": "vDbgPrintEx returns STATUS_SUCCESS if the operation succeeds. Otherwise, this routine returns the appropriate error code. ",
    "remarks": "Only kernel-mode drivers can call the vDbgPrintEx routine. vDbgPrintEx can be called at IRQL <= DIRQL. However, you can use Unicode format codes (%wc and %ws) only at IRQL = PASSIVE_LEVEL. Also, because the debugger uses interprocess interrupts (IPIs) to communicate with other processors, calling vDbgPrintEx at IRQL > DIRQL can cause deadlocks. vDbgPrintEx either passes the string that it creates to the kernel debugger or does nothing at all, depending on the values of ComponentId, Level, and the corresponding component filter masks. For more information about what vDbgPrintEx does, see Reading and Filtering Debugging Messages. Unless it is absolutely necessary, you should not obtain a string from user input or another process and pass it to vDbgPrintEx. If you do use a string that you did not create, you must verify that this string is a valid format string and that the format codes match the argument list in type and quantity. The best coding practice is for all Format strings to be static and defined at compile time. There is no upper limit to the size of the Format string or the number of arguments in the arglist list. However, any single call to vDbgPrintEx will transmit only 512 bytes of information. There is also a limit to the size of the buffer that the debugger uses. For more information about this limit, see The DbgPrint Buffer and the Debugger. This routine is defined in Wdm.h. Component filter IDs are defined in Dpfilter.h. ",
    "return_type": "ULONG",
    "category": "Drivers",
    "name": "vDbgPrintEx",
    "is_callback": 0,
    "dll": "NtDll.dll (user mode);  NtosKrnl.exe (kernel mode)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ComponentId",
        "description": "The component that is calling this routine. This parameter must be one of the component name filter IDs that are defined in Dpfilter.h. To avoid mixing your driver's output with the output of Windows components, you should use only the following values for ComponentId:   DPFLTR_IHVVIDEO_ID    DPFLTR_IHVAUDIO_ID    DPFLTR_IHVNETWORK_ID    DPFLTR_IHVSTREAMING_ID    DPFLTR_IHVBUS_ID    DPFLTR_IHVDRIVER_ID"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Level",
        "description": "The severity of the message that is being sent. This parameter can be any 32-bit integer. Values between 0 and 31 (inclusive) are treated differently than values between 32 and 0xFFFFFFFF. For more information about how the values are treated, see Reading and Filtering Debugging Messages."
      },
      {
        "in_out": "_In_",
        "type": "PCCH",
        "name": "Format",
        "description": "A pointer to the format string to print. The Format string supports most of the printf-style formatting codes. However, you can use the Unicode format codes (%C, %S, %lc, %ls, %wc, %ws, and %wZ) only with IRQL = PASSIVE_LEVEL. The vDbgPrintEx routine does not support any of the floating point types (%f, %e, %E, %g, %G, %a, or %A)."
      },
      {
        "in_out": "_In_",
        "type": "va_list",
        "name": "arglist",
        "description": "An argument list for the format string. The vDbgPrintEx routine uses this list in the same way that vprintf does."
      }
    ],
    "min_client": ""
  }
]