[
  {
    "n_arguments": 1,
    "description": "Adds a directory to the process DLL search path.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "LibLoaderAPI.h (include Windows.h);  None on Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008",
    "return_value": "If the function succeeds, the return value is an opaque pointer that can be passed to        RemoveDllDirectory to remove the DLL from the        process DLL search path. If the function fails, the return value is zero. To get extended error        information, call GetLastError. ",
    "remarks": "The AddDllDirectory function can be used to add      any absolute path to the set of directories that are searched for a DLL. If      SetDefaultDllDirectories is first called with      LOAD_LIBRARY_SEARCH_USER_DIRS, directories specified with      AddDllDirectory are added to the process DLL search      path. Otherwise, directories specified with the      AddDllDirectory function are used only for      LoadLibraryEx function calls that specify      LOAD_LIBRARY_SEARCH_USER_DIRS. If AddDllDirectory is used to add more than one      directory to the process DLL search path, the order in which those directories are searched is unspecified. To remove a directory added with AddDllDirectory,      use the RemoveDllDirectory function. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  To use this function in an application, call        GetProcAddress to retrieve the function's address        from Kernel32.dll.        KB2533623 must be        installed on the target platform. ",
    "return_type": " DLL_DIRECTORY_COOKIE",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "AddDllDirectory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "NewDirectory",
        "description": "An absolute path to the directory to add to the search path. For example, to add the directory        Dir2 to the process DLL search path, specify \\Dir2. For more information about paths,        see Naming Files, Paths, and Namespaces."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Disables the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications for the specified dynamic-link library (DLL). This can reduce the size of the working set for some applications.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. The  DisableThreadLibraryCalls function fails if the DLL specified by hModule has active static thread local storage, or if hModule is an invalid module handle. To get extended error information, call  GetLastError. ",
    "remarks": "The  DisableThreadLibraryCalls function lets a DLL disable the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notification calls. This can be a useful optimization for multithreaded applications that have many DLLs, frequently create and delete threads, and whose DLLs do not need these thread-level notifications of attachment/detachment. A remote procedure call (RPC) server application is an example of such an application. In these sorts of applications, DLL initialization routines often remain in memory to service DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications. By disabling the notifications, the DLL initialization code is not paged in because a thread is created or deleted, thus reducing the size of the application's working code set. To implement the optimization, modify a DLL's DLL_PROCESS_ATTACH code to call  DisableThreadLibraryCalls. Do not call this function from a DLL that is linked to the static C run-time library (CRT). The static CRT requires DLL_THREAD_ATTACH and DLL_THREAD_DETATCH notifications to function properly. ",
    "return_type": "BOOL",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "DisableThreadLibraryCalls",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMODULE",
        "name": "hModule",
        "description": "A handle to the DLL module for which the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications are to be disabled. The  LoadLibrary, LoadLibraryEx,  or  GetModuleHandle function returns this handle. Note that you cannot call GetModuleHandle with NULL because this returns the base address of the executable image, not the DLL image."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the reference count reaches zero, the module is unloaded from the address space of the calling process and the handle is no longer valid.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  the GetLastError function. ",
    "remarks": "The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to  LoadLibrary. The reference count is also incremented by a call to LoadLibraryEx unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time  the FreeLibrary or FreeLibraryAndExitThread function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's  DllMain function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call  FreeLibrary from  DllMain. For more information, see the Remarks section in  DllMain. Calling  FreeLibrary does not affect other processes that are using the same module. Use caution when calling FreeLibrary with a handle returned by GetModuleHandle. The GetModuleHandle function does not increment a module's reference count, so passing this handle to FreeLibrary can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call FreeLibraryAndExitThread instead of calling FreeLibrary and ExitThread separately. Otherwise, a race condition can occur. For details, see the Remarks section of FreeLibraryAndExitThread. For an example, see  Using Run-Time Dynamic Linking. ",
    "return_type": "BOOL",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "FreeLibrary",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMODULE",
        "name": "hModule",
        "description": "A handle to the loaded library module. The  LoadLibrary, LoadLibraryEx,   GetModuleHandle, or GetModuleHandleEx function returns this handle."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Decrements the reference count of a loaded dynamic-link library (DLL) by one, then calls  ExitThread to terminate the calling thread. The function does not return.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "This function does not return a value. Invalid module handles are ignored. ",
    "remarks": "The  FreeLibraryAndExitThread function allows threads that are executing within a DLL to safely free the DLL in which they are executing and terminate themselves. If they were to call  FreeLibrary and  ExitThread separately, a race condition would exist. The library could be unloaded before  ExitThread is called. ",
    "return_type": "VOID",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "FreeLibraryAndExitThread",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMODULE",
        "name": "hModule",
        "description": "A handle to the DLL module whose reference count the function decrements. The  LoadLibrary or  GetModuleHandleEx function returns this handle. Do not call this function with a handle returned by the GetModuleHandle function, since this function does not maintain a reference count for the module."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwExitCode",
        "description": "The exit code for the calling thread."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Ends the calling thread.",
    "library": "Kernel32.lib;  WindowsPhoneCore.lib on Windows Phone 8.1",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "WinBase.h on Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2 (include Windows.h);  Processthreadsapi.h on Windows 8, Windows Server 2012 and Windows Phone 8.1",
    "return_value": "This function does not return a value. ",
    "remarks": "ExitThread is the preferred method of exiting a thread in C code. However, in C++ code, the thread is exited before any destructors can be called or any other automatic cleanup can be performed. Therefore, in C++ code, you should return from your thread function. When this function is called (either explicitly or by returning from a thread procedure), the current thread's stack is deallocated, all pending I/O initiated by the thread is canceled, and the thread terminates. The entry-point function of all attached dynamic-link libraries (DLLs) is invoked with a value indicating that the thread is detaching from the DLL. If the thread is the last thread in the process when this function is called, the thread's process is also terminated. The state of the thread object becomes signaled, releasing any other threads that had been waiting for the thread to terminate. The thread's termination status changes from STILL_ACTIVE to the value of the dwExitCode parameter. Terminating a thread does not necessarily remove the thread object from the operating system. A thread object is deleted when the last handle to the thread is closed. The  ExitProcess,  ExitThread,  CreateThread,  CreateRemoteThread functions, and a process that is starting (as the result of a  CreateProcess call) are serialized between each other within a process. Only one of these events can happen in an address space at a time. This means the following restrictions hold: A thread in an executable that is linked to the static C run-time library (CRT) should use _beginthread and _endthread for thread management rather than  CreateThread and  ExitThread. Failure to do so results in small memory leaks when  the thread calls ExitThread. Another work around is to link the executable to the CRT in a DLL instead of the static CRT. Note that this memory leak only occurs from a DLL if the DLL is linked to the static CRT and a thread calls the DisableThreadLibraryCalls function. Otherwise, it is safe to call CreateThread and  ExitThread from a thread in a DLL that links to the static CRT. Use the  GetExitCodeThread function to retrieve a thread's exit code. Windows Phone 8.1: This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. For an example, see  Using Event Objects. ",
    "return_type": "VOID",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "ExitThread",
    "is_callback": 0,
    "dll": "Kernel32.dll;  KernelBase.dll on Windows Phone 8.1",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwExitCode",
        "description": "The exit code for the thread."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the application-specific portion of the search path used to locate DLLs for the     application.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinBase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length of the string copied to         lpBuffer, in characters, not including the terminating null character. If the return         value is greater than nBufferLength, it specifies the size of the buffer required for         the path. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0502      or later. For more information, see      Using the Windows Headers. ",
    "return_type": "DWORD",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "GetDllDirectory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nBufferLength",
        "description": "The size of the output buffer, in characters."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpBuffer",
        "description": "A pointer to a buffer that receives the application-specific portion of the search path."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to nSize characters including the terminating null character, the function returns nSize, and the function sets the last error to ERROR_INSUFFICIENT_BUFFER. Windows XP:  If the buffer is too small to hold the module name, the function returns nSize. The last error code remains ERROR_SUCCESS. If nSize is zero, the return value is zero and the last error code is ERROR_SUCCESS. If the function fails, the return value is 0 (zero). To get extended error information, call  GetLastError. ",
    "remarks": "If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process. The global variable _pgmptr is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file. For an example, see  Installing a Service. ",
    "return_type": "DWORD",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "GetModuleFileName",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "HMODULE",
        "name": "hModule",
        "description": "A handle to the loaded module whose path is being requested. If this parameter is NULL,  GetModuleFileName retrieves the path of the executable file of the current process. The GetModuleFileName function does not retrieve the path for modules  that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpFilename",
        "description": "A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the nSize parameter specifies, the function succeeds and the path is returned as a null-terminated string.  If the length of the path exceeds the size that  the nSize parameter specifies, the function succeeds and the string is truncated to nSize  characters including the terminating null character. Windows XP:  The string is truncated to nSize characters and is not null-terminated. The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix \"\\\\?\\\". For more information, see  Naming a File."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the lpFilename buffer, in TCHARs."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves a module handle for the specified module. The module must have been loaded by the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The returned handle is not global or inheritable. It cannot be duplicated or used by another process. If lpModuleName does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use side-by-side assemblies, or use GetModuleHandleEx to specify a memory location rather than a DLL name. The  GetModuleHandle function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the FreeLibrary function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by GetModuleHandle to the  FreeLibrary function. Doing so can cause a DLL module to be unmapped prematurely. This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended. For an example, see  Using Brushes. ",
    "return_type": "HMODULE",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "GetModuleHandle",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpModuleName",
        "description": "The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.     If this parameter is NULL,  GetModuleHandle returns a handle to the file used to create the calling process (.exe file). The GetModuleHandle function does not retrieve handles for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, see  GetLastError. ",
    "remarks": "The handle returned is not global or inheritable. It cannot be duplicated or used by another process. If lpModuleName does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use side-by-side assemblies, or specify a memory location rather than a DLL name in the lpModuleName parameter. If dwFlags contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the GetModuleHandleEx function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the FreeLibrary function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by GetModuleHandleEx with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the  FreeLibrary function. Doing so can cause a DLL module to be unmapped prematurely. If dwFlags contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended. To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "GetModuleHandleEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the FreeLibrary function to decrement the reference count when the module handle is no longer needed.  GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)   The lpModuleName parameter is an address in the module.  GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)   The module stays loaded until the process is terminated, no matter how many times  FreeLibrary is called.     This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.  GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)   The reference count for the module is not incremented. This option is equivalent to the behavior of  GetModuleHandle. Do not pass the retrieved module handle to the FreeLibrary function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.     This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpModuleName",
        "description": "The name of the loaded module (either a .dll or .exe file), or an address in the module (if dwFlags is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).     For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process. If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file)."
      },
      {
        "in_out": "_Out_",
        "type": "HMODULE*",
        "name": "phModule",
        "description": "A handle to the specified module. If the function fails, this parameter is NULL. The GetModuleHandleEx function does not retrieve handles for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call  GetLastError. ",
    "remarks": "The spelling and case of a function name pointed to by lpProcName must be identical to that in the EXPORTS statement of the source DLL's module-definition (.def) file. The exported names of functions may differ from the names you use when calling these functions in your code. This difference is hidden by macros used in the SDK header files. For more information, see  Conventions for Function Prototypes. The lpProcName parameter can identify the DLL function by specifying an ordinal value associated with the function in the EXPORTS statement.  GetProcAddress verifies that the specified ordinal is in the range 1 through the highest ordinal value exported in the .def file. The function then uses the ordinal as an index to read the function's address from a function table. If the .def file does not number the functions consecutively from 1 to N (where N is the number of exported functions), an error can occur where  GetProcAddress returns an invalid, non-NULL address, even though there is no function with the specified ordinal. If the function might not exist in the DLL module\u00e2\u0080\u0094for example, if the function  is available only on Windows Vista but the application  might be running on Windows XP\u00e2\u0080\u0094specify the function by name rather than by ordinal value and design your application to handle the case when the function is not available, as shown in the following code fragment. For the complete example that contains this code fragment, see Getting the System Version. For an example, see  Using Run-Time Dynamic Linking. ",
    "return_type": "FARPROC",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "GetProcAddress",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMODULE",
        "name": "hModule",
        "description": "A handle to the DLL module that contains the function or variable. The  LoadLibrary, LoadLibraryEx, LoadPackagedLibrary, or  GetModuleHandle function returns this handle.  The GetProcAddress function does not retrieve addresses from modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx."
      },
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "lpProcName",
        "description": "The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Loads the specified  module into the address space of the calling process. The specified      module may cause other modules to be loaded.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call         GetLastError. ",
    "remarks": "To enable or disable error messages displayed by the loader during DLL loads, use the      SetErrorMode function. LoadLibrary can be used to load a library module into      the address space of the process and return a handle that can be used in      GetProcAddress to get the address of a DLL function.      LoadLibrary can also be used to load other executable      modules. For example, the function can specify an .exe file to get a handle that can be used in      FindResource or      LoadResource. However, do not use      LoadLibrary to run an .exe file. Instead, use      the CreateProcess function. If the specified module is a DLL that is not already loaded for the calling process, the system calls the      DLL's DllMain function with the      DLL_PROCESS_ATTACH value. If      DllMain returns TRUE,      LoadLibrary returns a handle to the module. If      DllMain returns FALSE,      the system unloads the DLL from the process address space and      LoadLibrary returns NULL. It is      not safe to call LoadLibrary from      DllMain. For more information, see the Remarks section in      DllMain. Module handles are not global or inheritable. A call to      LoadLibrary by one process does not produce a handle that      another process can use \u00e2\u0080\u0094 for example, in calling      GetProcAddress. The other process must make its own      call to LoadLibrary for the module before calling      GetProcAddress. If lpFileName does not include a path and there is more than one loaded module with      the same base name and extension, the function returns a handle to the module that was loaded first. If no file name extension is specified in the lpFileName parameter, the default      library extension .dll is appended. However, the file name string can include a trailing point character (.) to      indicate that the module name has no extension. When no path is specified, the function searches for loaded      modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.      Otherwise, the function searches for the file. The first directory searched is the directory containing the image file used to create the calling process      (for more information, see the      CreateProcess function). Doing this allows      private dynamic-link library (DLL) files associated with a process to be found without adding the process's      installed directory to the PATH environment variable. If a relative path is      specified, the entire relative path is appended to every token in the DLL search path list. To load a module from      a relative path without searching any other path, use      GetFullPathName to get a nonrelative path and call      LoadLibrary with the nonrelative path. For more      information on the DLL search order, see      Dynamic-Link Library Search Order. The search path can be altered using the      SetDllDirectory function. This solution is recommended      instead of using SetCurrentDirectory or      hard-coding the full path to the DLL. If a path is specified and there is a redirection file for the application, the function searches for the      module in the application's directory. If the module exists in the application's directory,      LoadLibrary ignores the specified path and loads the      module from the application's directory. If the module does not exist in the application's directory,      LoadLibrary loads the module from the specified      directory. For more information, see      Dynamic Link Library Redirection. If you call LoadLibrary with the name of an assembly      without a path specification and the assembly is listed in the system compatible manifest, the call is      automatically redirected to the side-by-side assembly. The system maintains a per-process reference      count on all loaded modules. Calling LoadLibrary      increments the reference count. Calling the FreeLibrary or      FreeLibraryAndExitThread function decrements      the reference count. The system unloads a module when its reference count reaches zero or when the process      terminates (regardless of the reference count). Windows Server 2003 and Windows XP:  The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:        _declspec(thread). If you use this syntax in a DLL, you will not be able to load the        DLL explicitly using LoadLibrary on versions of Windows        prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local        storage functions instead of _declspec(thread). For an example, see        Using Thread Local Storage        in a Dynamic Link Library. Do not use the SearchPath function to retrieve a path to        a DLL for a subsequent LoadLibrary call. The        SearchPath function uses a different search order than        LoadLibrary and it does not use safe process search mode        unless this is explicitly enabled by calling        SetSearchPathMode with        BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE. Therefore,        SearchPath is likely to first search the user's current        working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current        working directory, the path retrieved by SearchPath will        point to the malicious DLL, which LoadLibrary will then        load. Do not make assumptions about the operating system version based on a        LoadLibrary call that searches for a DLL. If the        application is running in an environment where the DLL is legitimately not present but a malicious version of        the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended        techniques described in        Getting the System Version. For an example, see       Using Run-Time Dynamic Linking. ",
    "return_type": "HMODULE",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "LoadLibrary",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the module. This can be either a library module (a .dll file) or an executable         module (an .exe file). The name specified is the file name of the module and is not related to the         name stored in the library module itself, as specified by the LIBRARY keyword in         the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search         strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use         backslashes (\\), not forward slashes (/). For more information about paths, see         Naming a File or Directory. If the string specifies a module name without a path and the file name extension is omitted, the function         appends the default library extension .dll to the module name. To prevent the function from appending         .dll to the module name, include a trailing point character (.) in the module name string."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Loads the specified module into the address space of the calling process. The specified      module may cause other modules to be loaded.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "LibLoaderAPI.h on Windows 8 (include Windows.h);  WinBase.h on Windows 7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP and Windows Server 2003 (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the loaded module. If the function fails, the return value is NULL. To get extended error information,         call GetLastError. ",
    "remarks": "The LoadLibraryEx function is very similar to the       LoadLibrary function. The differences consist of a set of       optional behaviors that LoadLibraryEx provides: You select these optional behaviors by setting the dwFlags parameter; if       dwFlags is zero,       LoadLibraryEx behaves identically to       LoadLibrary. The calling process can use the handle returned by      LoadLibraryEx to identify the module in calls to the      GetProcAddress,      FindResource, and      LoadResource functions. To enable or disable error messages displayed by the loader during DLL loads, use the      SetErrorMode function. It is not safe to call LoadLibraryEx from      DllMain. For more information, see the Remarks section in      DllMain. Visual C++:  The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:        _declspec(thread). If you use this syntax in a DLL, you will not be able to load the        DLL explicitly using LoadLibraryEx on versions of        Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread        local storage functions instead of _declspec(thread). For an example, see        Using Thread Local Storage in a Dynamic Link Library. The LOAD_LIBRARY_AS_DATAFILE,        LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE, and        LOAD_LIBRARY_AS_IMAGE_RESOURCE values affect the per-process reference count and the        loading of the specified module. If any of these values is specified for the dwFlags        parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,        this means that the module is already mapped into the virtual address space of the calling process. In this        case, LoadLibraryEx returns a handle to the DLL and        increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the        module as a data or image file and not as an executable DLL. In this case,        LoadLibraryEx returns a handle to the loaded data or        image file but does not increment the reference count for the module and does not make the module visible to functions such as CreateToolhelp32Snapshot or EnumProcessModules. If LoadLibraryEx is called twice for the same file        with LOAD_LIBRARY_AS_DATAFILE,        LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE, or        LOAD_LIBRARY_AS_IMAGE_RESOURCE, two separate mappings are created for the file. When the LOAD_LIBRARY_AS_IMAGE_RESOURCE value is used, the module is loaded as an        image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have        to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying        LOAD_LIBRARY_AS_IMAGE_RESOURCE prevents other processes from modifying the module        while it is loaded. Unless an application depends on specific image mapping characteristics, the        LOAD_LIBRARY_AS_IMAGE_RESOURCE value should be used with either        LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE or        LOAD_LIBRARY_AS_DATAFILE. This allows the loader to choose whether to load the module        as an image resource or a data file, selecting whichever option enables the system to share pages more        effectively. Resource  functions such as        FindResource can use either mapping.  To determine how a module was loaded, use one of the  following macros to test the handle returned by        LoadLibraryEx. The following table describes these macros.  Use the FreeLibrary function to free a loaded module,        whether or not loading the module caused its reference count to be incremented. If the module was loaded as a        data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL        reference count is decremented. Therefore, it is safe to call        FreeLibrary with any handle returned by        LoadLibraryEx. The search path is the set of directories that are searched for a DLL. The        LoadLibraryEx function can search for a DLL using a        standard search path or an altered search path, or it can use a process-specific search path established with        the SetDefaultDllDirectories and        AddDllDirectory functions. For a list of directories        and the order in which they are searched, see        Dynamic-Link Library Search Order. The LoadLibraryEx function uses the standard search        path in the following cases: If lpFileName specifies a relative path, the entire relative path is appended to        every token in the DLL search path. To load a module from a relative path without searching any other path, use        GetFullPathName to get a nonrelative path and call        LoadLibraryEx with the nonrelative path. If the module        is being loaded as a datafile and the relative path starts with  \".\\\" or        \"..\\\", the relative path is treated as an absolute path. If lpFileName specifies an absolute path and dwFlags is        set to LOAD_WITH_ALTERED_SEARCH_PATH,        LoadLibraryEx uses the altered search path.        The behavior is undefined when LOAD_WITH_ALTERED_SEARCH_PATHflag is set, and lpFileName specifiies a relative path. The SetDllDirectory function can be used to modify        the search path. This solution is better than using        SetCurrentDirectory or hard-coding the full path        to the DLL. However, be aware that using        SetDllDirectory effectively disables safe DLL search        mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to        use AddDllDirectory to modify a default process        search path. For more information, see        Dynamic-Link Library Search Order. An application can specify the directories to search for a single        LoadLibraryEx call by using the        LOAD_LIBRARY_SEARCH_* flags. If more than one        LOAD_LIBRARY_SEARCH flag is specified, the directories are searched in the following        order: Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  The LOAD_LIBRARY_SEARCH_* flags are available on systems that have         KB2533623         installed. To determine whether the flags are available, use         GetProcAddress to get the address of the         AddDllDirectory,         RemoveDllDirectory, or         SetDefaultDllDirectories function. If         GetProcAddress succeeds, the         LOAD_LIBRARY_SEARCH_* flags can be used with         LoadLibraryEx. If the application has used the        SetDefaultDllDirectories function to        establish a DLL search path for the process and none of the LOAD_LIBRARY_SEARCH_*        flags are used, the LoadLibraryEx function uses the        process DLL search path instead of the standard search path. If a path is specified and there is a redirection file associated with the application, the        LoadLibraryEx function searches for the module in the        application directory. If the module exists in the application directory,        LoadLibraryEx ignores the path specification and        loads the module from the application directory. If the module does not exist in the application directory, the        function loads the module from the specified directory. For more information, see        Dynamic Link Library Redirection. If you call LoadLibraryEx with the name of an        assembly without a path specification and the assembly is listed in the system compatible manifest, the call is        automatically redirected to the side-by-side assembly. LOAD_LIBRARY_AS_DATAFILE does not prevent other processes from modifying the module        while it is loaded. Because this can make your application less secure, you should use        LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE instead of        LOAD_LIBRARY_AS_DATAFILE when loading a module as a data file, unless you        specifically need to use LOAD_LIBRARY_AS_DATAFILE. Specifying        LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE prevents other processes from modifying the module        while it is loaded. Do not specify  LOAD_LIBRARY_AS_DATAFILE and        LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE in the same call. Do not use the SearchPath function to retrieve a path to        a DLL for a subsequent LoadLibraryEx call. The        SearchPath function uses a different search order than        LoadLibraryEx and it does not use safe process search        mode unless this is explicitly enabled by calling        SetSearchPathMode with        BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE. Therefore,        SearchPath is likely to first search the user's current        working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the        current working directory, the path retrieved by        SearchPath will point to the malicious DLL, which        LoadLibraryEx will then load. Do not make assumptions about the operating system version based on a        LoadLibraryEx call that searches for a DLL. If the        application is running in an environment where the DLL is legitimately not present but a malicious version of        the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended        techniques described in        Getting the System Version. For a general discussion of DLL security issues, see        Dynamic-Link Library Security. For an example, see       Looking Up Text for Error Code Numbers. ",
    "return_type": "HMODULE",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "LoadLibraryEx",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "A string that specifies the file name of the module to load. This name is not related to the name stored in a         library module itself, as specified by the LIBRARY keyword in the module-definition         (.def) file. The module can be a library module (a .dll file) or an executable module (an .exe file). If the         specified module is an executable module, static imports are not loaded; instead, the module is loaded as if         DONT_RESOLVE_DLL_REFERENCES was specified. See the dwFlags         parameter for more information. If the string specifies a module name without a path and the file name extension is omitted, the function         appends the default library extension .dll to the module name. To prevent the function from appending         .dll to the module name, include a trailing point character (.) in the module name string. If the string specifies a fully qualified path, the function searches only that path for the module. When         specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths,         see Naming Files, Paths, and Namespaces. If the string specifies a module name without a path and more than one loaded module has the same base name         and extension, the function returns a handle to the module that was loaded first. If the string specifies a module name without a path and a module of the same name is not already loaded, or         if the string specifies a module name with a relative path, the function searches for the specified module. The         function also searches for modules if loading the specified module causes the system to load other associated         modules (that is, if the module has dependencies). The directories that are searched and the order in which         they are searched depend on the specified path and the dwFlags parameter. For more         information, see Remarks. If the function cannot find the  module or one of its dependencies, the function fails."
      },
      {
        "in_out": "_Reserved_",
        "type": "HANDLE",
        "name": "hFile",
        "description": "This parameter is reserved for future use. It must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The action to be taken when loading the module. If no flags are specified, the behavior of this function is        identical to that of the LoadLibrary function. This        parameter can be one of the following values.  ValueMeaning  DONT_RESOLVE_DLL_REFERENCES 0x00000001   If this value is used, and the executable module is a DLL, the system does not call           DllMain for process and thread initialization and           termination. Also, the system does not load additional executable modules that are referenced by the           specified module. Note  Do not use this value; it is provided only for backward compatibility. If you are planning to access           only data or resources in the DLL, use LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE or           LOAD_LIBRARY_AS_IMAGE_RESOURCE or both. Otherwise, load the library as a DLL or           executable module using the LoadLibrary           function.     LOAD_IGNORE_CODE_AUTHZ_LEVEL 0x00000010   If this value is used, the system does not check           AppLocker rules or apply           Software Restriction Policies           for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is           recommended for use in setup programs that must run extracted DLLs during installation. Windows Server 2008 R2 and Windows 7:  On systems with KB2532445 installed, the caller must be running as \"LocalSystem\" or            \"TrustedInstaller\"; otherwise the system ignores this flag. For more information, see            \"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2\"            in the Help and Support Knowledge Base at            http://support.microsoft.com/kb/2532445. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  AppLocker was introduced in Windows 7 and Windows Server 2008 R2.   LOAD_LIBRARY_AS_DATAFILE 0x00000002   If this value is used, the system maps the file into the calling process's virtual address space as if it           were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot           call functions like GetModuleFileName,            GetModuleHandle or           GetProcAddress with this DLL. Using this value           causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL           only to extract messages or resources from it. This value can be used with LOAD_LIBRARY_AS_IMAGE_RESOURCE. For more information,           see Remarks.   LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 0x00000040   Similar to LOAD_LIBRARY_AS_DATAFILE, except that the DLL file is opened with           exclusive write access for the calling process. Other processes cannot open the DLL file for write access           while it is in use. However, the DLL can still be opened by other processes. This value can be used with LOAD_LIBRARY_AS_IMAGE_RESOURCE. For more information,           see Remarks. Windows Server 2003 and Windows XP:  This value is not supported until Windows Vista.   LOAD_LIBRARY_AS_IMAGE_RESOURCE 0x00000020   If this value is used, the system maps the file into the process's virtual address space as an image file.           However, the loader does not load the static imports or perform the other usual initialization steps. Use           this flag when you want to load a DLL only to extract messages or resources from it. Unless the application depends on the file having the in-memory layout of an image, this value should be used with either           LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE or           LOAD_LIBRARY_AS_DATAFILE. For more information, see the Remarks section. Windows Server 2003 and Windows XP:  This value is not supported  until Windows Vista.   LOAD_LIBRARY_SEARCH_APPLICATION_DIR 0x00000200   If this value is used, the application's installation directory is searched for the DLL and its           dependencies. Directories in the standard search path are not searched. This value cannot be combined with           LOAD_WITH_ALTERED_SEARCH_PATH. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  This value requires            KB2533623 to be            installed. Windows Server 2003 and Windows XP:  This value is not supported.   LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0x00001000   This value is a combination of LOAD_LIBRARY_SEARCH_APPLICATION_DIR,           LOAD_LIBRARY_SEARCH_SYSTEM32, and           LOAD_LIBRARY_SEARCH_USER_DIRS. Directories in the standard search path are not           searched. This value cannot be combined with LOAD_WITH_ALTERED_SEARCH_PATH. This value represents the recommended maximum number of directories an application should include in its           DLL search path. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  This value requires            KB2533623 to be            installed. Windows Server 2003 and Windows XP:  This value is not supported.   LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0x00000100   If this value is used, the directory that contains the DLL is temporarily added to the beginning of the           list of directories that are searched for the DLL's dependencies.  Directories in the standard search path           are not searched. The lpFileName parameter must specify a fully qualified path. This value cannot           be combined with LOAD_WITH_ALTERED_SEARCH_PATH. For example, if Lib2.dll is a dependency of C:\\Dir1\\Lib1.dll, loading           Lib1.dll  with this value causes the system to search for Lib2.dll only in           C:\\Dir1. To search for Lib2.dll in C:\\Dir1 and all of the directories           in the DLL search path, combine this value with LOAD_LIBRARY_DEFAULT_DIRS. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  This value requires            KB2533623 to be            installed. Windows Server 2003 and Windows XP:  This value is not supported.   LOAD_LIBRARY_SEARCH_SYSTEM32 0x00000800   If this value is used, %windows%\\system32 is searched for the DLL and its dependencies.           Directories in the standard search path are not searched. This value cannot be combined with           LOAD_WITH_ALTERED_SEARCH_PATH. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  This value requires            KB2533623 to be            installed. Windows Server 2003 and Windows XP:  This value is not supported.   LOAD_LIBRARY_SEARCH_USER_DIRS 0x00000400   If this value is used, directories added using the           AddDllDirectory or the           SetDllDirectory function are searched for the DLL           and its dependencies. If more than one directory has been added, the order in which the directories are           searched is unspecified. Directories in the standard search path are not searched. This value cannot be           combined with LOAD_WITH_ALTERED_SEARCH_PATH. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  This value requires            KB2533623 to be            installed. Windows Server 2003 and Windows XP:  This value is not supported.   LOAD_WITH_ALTERED_SEARCH_PATH 0x00000008   If this value is used and lpFileName specifies an absolute path, the system uses           the alternate file search strategy discussed in the Remarks section to find associated executable modules           that the specified module causes to be loaded. If this value is used and lpFileName           specifies a relative path, the behavior is undefined. If this value is not used, or if lpFileName does not specify a path, the system           uses the standard search strategy discussed in the Remarks section to find associated executable modules that           the specified module causes to be loaded. This value cannot be combined with any LOAD_LIBRARY_SEARCH flag."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Loads the specified packaged module and its dependencies into the address space of the calling process.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the loaded module. If the function fails, the return value is NULL. To get extended error information, call GetLastError. ",
    "remarks": "The  LoadPackagedLibrary function is a simplified version of LoadLibraryEx. Windows Runtime apps  can use LoadPackagedLibrary to load packaged modules. Desktop applications cannot use LoadPackagedLibrary; if a desktop application calls this function it fails with APPMODEL_ERROR_NO_PACKAGE. LoadPackagedLibrary returns a handle to the specified module and increments its reference count. If the module is already loaded, the function returns a handle to the loaded module. The calling process can use the handle returned by LoadPackagedLibrary to identify the module in calls to the  GetProcAddress function. Use the FreeLibrary function to free a loaded module and decrement its reference              count. If the function must search for the specified module or its dependencies, it searches only the package dependency graph of the process.  This is the application's package plus any dependencies specified as <PackageDependency> in the <Dependencies> section of the application's package manifest. Dependencies are searched in the order they appear in the manifest. The package dependency graph is specified in the <Dependencies> section of the application's package manifest. Dependencies are searched in the order they appear in the manifest. The search proceeds as follows: It is not safe to call  LoadPackagedLibrary from  DllMain. For more information, see the Remarks section in  DllMain.  ",
    "return_type": "HMODULE",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "LoadPackagedLibrary",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpwLibFileName",
        "description": "The file name of the packaged module to load. The module can be a library module (a .dll file) or an executable module (an .exe file).   If this parameter specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.  If this parameter specifies a path, the function searches that path for the module. The path cannot be an absolute path or a relative path that contains \"..\" in the path.   When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces.  If the specified module is already loaded in the process, the function returns a handle to the loaded module. The module must have been originally loaded  from the package dependency graph of the process. If loading the specified module causes the system to load other associated modules, the function first searches loaded modules, then it searches the package dependency graph of the process.  For more information, see Remarks."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "This parameter is reserved. It must be 0."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "Removes a directory that was added to the process DLL search path by using       AddDllDirectory.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "LibLoaderAPI.h (include Windows.h);  None on Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value        is zero. To get extended error information, call        GetLastError. ",
    "remarks": "After RemoveDllDirectory returns, the cookie is      no longer valid and should not be used. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  To call this function in an application, use the        GetProcAddress function to retrieve its address from        Kernel32.dll.        KB2533623 must be        installed on the target platform. ",
    "return_type": " BOOL",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "RemoveDllDirectory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DLL_DIRECTORY_COOKIE",
        "name": "Cookie",
        "description": "The cookie returned by AddDllDirectory when the        directory was added to the search path."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Specifies a default set of directories to search when the calling process loads a DLL. This search      path is used when LoadLibraryEx is called with no      LOAD_LIBRARY_SEARCH flags.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "LibLoaderAPI.h (include Windows.h);  None on Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call         GetLastError. ",
    "remarks": "The DLL search path is the set of directories that are searched for a DLL when a full path is not specified in      a LoadLibrary or      LoadLibraryEx function call, or when a full path to the      DLL is specified but the system must search for dependent DLLs. For more information about the standard DLL search      path, see      Dynamic-Link Library Search Order. The standard DLL search path contains directories that can be vulnerable to a      DLL pre-loading attack. An application can      use the SetDefaultDllDirectories function to      specify  a default DLL search path for the process that eliminates the most vulnerable directories and limits the      other directories that are searched. The process DLL search path applies only to the calling process and persists      for the life of the process. If the DirectoryFlags parameter specifies more than one flag, the directories are      searched in the following order: If SetDefaultDllDirectories does not      specify LOAD_LIBRARY_SEARCH_USER_DIRS, directories specified with the      AddDllDirectory function are used only for      LoadLibraryEx function calls that specify      LOAD_LIBRARY_SEARCH_USER_DIRS. It is not possible to revert to the standard DLL search path or remove any directory specified with      SetDefaultDllDirectories from the search      path. However, the process DLL search path can be overridden by calling      LoadLibraryEx with one or more      LOAD_LIBRARY_SEARCH flags, and directories added with      AddDllDirectory can be removed by calling      RemoveDllDirectory. Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  To call this function in an application, use the        GetProcAddress function to retrieve its address from        Kernel32.dll.        KB2533623 must be        installed on the target platform. ",
    "return_type": " BOOL",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "SetDefaultDllDirectories",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "DirectoryFlags",
        "description": "The directories to search. This parameter can be any combination of the following values.  ValueMeaning  LOAD_LIBRARY_SEARCH_APPLICATION_DIR 0x00000200   If this value is used, the application's installation directory is searched.   LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0x00001000   This value is a combination of LOAD_LIBRARY_SEARCH_APPLICATION_DIR,            LOAD_LIBRARY_SEARCH_SYSTEM32, and           LOAD_LIBRARY_SEARCH_USER_DIRS. This value represents the recommended maximum number of directories an application should include in its           DLL search path.   LOAD_LIBRARY_SEARCH_SYSTEM32 0x00000800   If this value is used, %windows%\\system32 is searched.   LOAD_LIBRARY_SEARCH_USER_DIRS 0x00000400   If this value is used, any path explicitly added using the          AddDllDirectory or          SetDllDirectory function is searched. If more than          one directory has been added, the order in which those directories are searched is unspecified."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Adds a directory to the search path used to locate DLLs for the application.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The  SetDllDirectory function affects all subsequent calls to the  LoadLibrary and  LoadLibraryEx functions. It also effectively disables safe DLL search mode while the specified directory is in the search path. After calling  SetDllDirectory, the standard DLL search path is: Each time the SetDllDirectory function is called, it replaces the directory specified in the previous SetDllDirectory call. To specify more than one directory, use the AddDllDirectory function and call LoadLibraryEx with LOAD_LIBRARY_SEARCH_USER_DIRS. To revert to the standard search path used by  LoadLibrary and  LoadLibraryEx, call  SetDllDirectory with NULL. This also restores safe DLL search mode  based on the SafeDllSearchMode registry value. To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "BOOL",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "SetDllDirectory",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpPathName",
        "description": "The directory to be added to the search path. If this parameter is an empty string (\"\"), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Loads and executes an application or creates a new instance of an existing application.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is greater than 31. If the function fails, the return value is an error value, which may be one of the following values.  ",
    "remarks": "The LOADPARMS32 structure has the following form:  Applications should use the  CreateProcess function instead of  LoadModule. The  LoadModule function calls  CreateProcess by forming the parameters as follows.  ",
    "return_type": "DWORD",
    "category": "Dynamic-Link Libraries (DLLs)",
    "name": "LoadModule",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "lpModuleName",
        "description": "The file name of the application to be run. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). If the lpModuleName parameter does not contain a directory path, the system searches for the executable file in this order:      The directory from which the application loaded. The current directory. The system directory. Use the  GetSystemDirectory function to get the path of this directory.      The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System. The Windows directory. Use the  GetWindowsDirectory function to get the path of this directory. The directories that are listed in the PATH environment variable."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpParameterBlock",
        "description": "A pointer to an application-defined LOADPARMS32 structure that defines the new application's parameter block.    Set all unused members to NULL, except for lpCmdLine, which must point to a null-terminated string if it is not used. For more information, see Remarks."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]