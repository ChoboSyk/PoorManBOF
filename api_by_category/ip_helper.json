[
  {
    "n_arguments": 2,
    "description": "The  GetAdapterIndex function obtains the index of an adapter, given its name.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "Until an adapter is fully disabled, the GetAdapterIndex function reports the adapter as present. For example, the NotifyAddrChange function may indicate a recently disabled adapter's IP address is removed, but GetAdapterIndex continues to report an adapter  index until the process of disabling the adapter is complete. When one or more adapters are present on the system, GetAdapterIndex  returns ERROR_DEV_NOT_EXIST when the adapter being queried does not exist. When no adapters are present, the GetAdapterIndex function returns ERROR_NO_DATA. The adapter index  may change when an adapter is disabled and then enabled, or under other circumstances, and should not be considered persistent. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetAdapterIndex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "AdapterName",
        "description": "A pointer to a Unicode string that specifies the name of the adapter."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "IfIndex",
        "description": "A pointer to a ULONG variable that points to the index of the adapter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  GetAdaptersAddresses function retrieves the addresses associated with the adapters on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS (defined to the same value as NO_ERROR). If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The   GetAdaptersAddresses function can retrieve information for IPv4 and IPv6 addresses. Addresses are returned as a linked list of IP_ADAPTER_ADDRESSES structures in the buffer pointed to by the AdapterAddresses parameter. The application that calls the GetAdaptersAddresses function must allocate the amount of memory needed to return the IP_ADAPTER_ADDRESSES structures pointed to by the AdapterAddresses parameter. When these returned structures are no longer required, the application should free the memory allocated. This can be accomplished by calling the HeapAlloc function to allocate memory and later calling the HeapFree function to free the allocated memory, as shown in the example code. Other memory allocation and free functions can be used as long as the same family of functions are used for both the allocation and the free function. GetAdaptersAddresses is implemented only as a synchronous function call.  The GetAdaptersAddresses function requires a significant amount of network resources and time to complete since all of the low-level network interface tables must be traversed. One method that can be used to determine the memory needed to return the IP_ADAPTER_ADDRESSES structures pointed to by the AdapterAddresses parameter is to pass too small a buffer size as indicated in the SizePointer parameter in the first call to the GetAdaptersAddresses function,  so the function will fail with ERROR_BUFFER_OVERFLOW. When the return value is ERROR_BUFFER_OVERFLOW, the SizePointer parameter returned points to the required size of the buffer to hold the adapter information. Note that it is possible for the buffer size required for the IP_ADAPTER_ADDRESSES structures pointed to by the AdapterAddresses parameter to change between subsequent calls to the GetAdaptersAddresses function if an adapter address is added or removed.   However, this method of using the GetAdaptersAddresses function is strongly discouraged. This method requires calling the GetAdaptersAddresses function multiple times. The recommended method of calling the GetAdaptersAddresses function is to pre-allocate a 15KB working buffer pointed to by the AdapterAddresses parameter. On typical computers, this dramatically reduces the chances that the GetAdaptersAddresses function returns ERROR_BUFFER_OVERFLOW, which would require calling  GetAdaptersAddresses function multiple times. The example code illustrates this method of use. In versions prior to Windows 10, the order in which adapters appear in the list returned by this function can be controlled from the Network Connections folder: select the Advanced Settings menu item from the Advanced menu. Starting with Windows 10, the order in which adapters appear in the list is determined by the IPv4 or IPv6 route metric. If the GAA_FLAG_INCLUDE_ALL_INTERFACES is set, then all NDIS adapters will be retrieved even those addresses associated with adapters not bound to an address family specified in the Family parameter. When this flag is not set, then only the addresses that are bound to an adapter enabled for the address family specified in the Family parameter are returned. The size of the IP_ADAPTER_ADDRESSES structure was changed on Windows XP with Service Pack 1 (SP1) and later. Several additional members were added to this structure. The size of the IP_ADAPTER_ADDRESSES structure was also changed on Windows Vista and later. A number of additional members were added to this structure. The size of the       IP_ADAPTER_ADDRESSES structure also changed on       Windows Vista with Service Pack 1 (SP1)and later and onWindows Server 2008 and later. One additional member was added to this structure. The Length member of the IP_ADAPTER_ADDRESSES structure returned in the linked list of structures in the buffer pointed to by the AdapterAddresses parameter should be used to determine which version of the IP_ADAPTER_ADDRESSES structure is being used. The GetIpAddrTable function retrieves the interface\u00e2\u0080\u0093to\u00e2\u0080\u0093IPv4 address mapping table on a local computer and returns this information in an MIB_IPADDRTABLE structure. On the Platform Software Development Kit (SDK) released for Windows Server 2003 and earlier, the return value for the GetAdaptersAddresses function was defined as a DWORD, rather than a ULONG. The SOCKET_ADDRESS structure is used in the IP_ADAPTER_ADDRESSES structure pointed to by the AdapterAddresses parameter. On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files has changed and the SOCKET_ADDRESS structure is defined in the Ws2def.h header file which is automatically included by the Winsock2.h header file. On the Platform SDK released for Windows Server 2003 and Windows XP, the SOCKET_ADDRESS structure is declared in the Winsock2.h header file. In order to use the IP_ADAPTER_ADDRESSES structure, the Winsock2.h header file must be included before the Iphlpapi.h header file. This example retrieves the IP_ADAPTER_ADDRESSES structure for the adapters associated with the system and prints some members  for each adapter interface. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetAdaptersAddresses",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Family",
        "description": "The address family of the addresses to retrieve. This parameter must be one of the following values.  ValueMeaning  AF_UNSPEC 0   Return both IPv4 and IPv6 addresses associated with adapters with IPv4 or IPv6 enabled.   AF_INET 2   Return only IPv4 addresses associated with adapters with IPv4 enabled.   AF_INET6 23   Return only IPv6 addresses associated with adapters with IPv6 enabled."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "The type of addresses to retrieve. The possible values are defined in the Iptypes.h header file. Note that the Iptypes.h header file is automatically included in Iphlpapi.h, and should never be used directly. This parameter is a combination of the following values. If this parameter is zero, then unicast, anycast, and multicast IP addresses will be returned.  ValueMeaning  GAA_FLAG_SKIP_UNICAST 0x0001   Do not return unicast addresses.   GAA_FLAG_SKIP_ANYCAST 0x0002   Do not return IPv6 anycast addresses.   GAA_FLAG_SKIP_MULTICAST 0x0004   Do not return multicast addresses.   GAA_FLAG_SKIP_DNS_SERVER 0x0008   Do not return addresses of DNS servers.   GAA_FLAG_INCLUDE_PREFIX 0x0010   Return a list of IP address prefixes on this adapter. When this flag is set, IP address prefixes are returned for both IPv6 and IPv4 addresses.  This flag is supported on Windows XP with SP1 and later.   GAA_FLAG_SKIP_FRIENDLY_NAME 0x0020   Do not return the adapter friendly name.   GAA_FLAG_INCLUDE_WINS_INFO 0x0040   Return addresses of Windows Internet Name Service (WINS) servers.  This flag is supported on Windows Vista and later.   GAA_FLAG_INCLUDE_GATEWAYS 0x0080   Return the addresses of default gateways.  This flag is supported on Windows Vista and later.   GAA_FLAG_INCLUDE_ALL_INTERFACES 0x0100   Return addresses for all NDIS interfaces.  This flag is supported on Windows Vista and later.   GAA_FLAG_INCLUDE_ALL_COMPARTMENTS 0x0200   Return addresses in all routing compartments.  This flag is not currently supported and reserved for future use.   GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER 0x0400   Return the adapter addresses sorted in tunnel binding order. This flag is supported on Windows Vista and later."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Reserved",
        "description": "This parameter is not currently used, but is reserved for future system use. The calling application should pass NULL for this parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "PIP_ADAPTER_ADDRESSES",
        "name": "AdapterAddresses",
        "description": "A pointer to a buffer that contains a linked list of IP_ADAPTER_ADDRESSES structures on successful return."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "SizePointer",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by AdapterAddresses."
      }
    ],
    "min_client": "Windows XP [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetAdaptersInfo function retrieves adapter information for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS (defined to the same value as NO_ERROR). If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The   GetAdaptersInfo function can retrieve information only for IPv4 addresses. In versions prior to Windows 10, the order in which adapters appear in the list returned by this function can be controlled from the Network Connections folder: select the Advanced Settings menu item from the Advanced menu. Starting with Windows 10, the order is unspecified. The  GetAdaptersInfo and  GetInterfaceInfo functions do not return information about the IPv4 loopback interface. Information on the loopback interface is returned by the GetIpAddrTable function. On Windows XP and later:  The list of adapters returned by  GetAdaptersInfo includes unidirectional adapters. To generate a list of adapters that can both send and receive data, call  GetUniDirectionalAdapterInfo, and exclude the returned adapters from the list returned by  GetAdaptersInfo. This example retrieves the adapter information and prints various properties of each adapter. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetAdaptersInfo",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PIP_ADAPTER_INFO",
        "name": "pAdapterInfo",
        "description": "A pointer to a buffer that receives a linked list of  IP_ADAPTER_INFO structures."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "pOutBufLen",
        "description": "A pointer to a ULONG variable that specifies the size of the buffer pointed to by the pAdapterInfo parameter. If this size is insufficient to hold the adapter information,  GetAdaptersInfo fills in this variable with the required size, and returns an error code of ERROR_BUFFER_OVERFLOW."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetPerAdapterInfo function retrieves information about the adapter corresponding to the specified interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.   ",
    "remarks": "An  adapter index  may change when the adapter is disabled and then enabled, or under other circumstances, and should not be considered persistent. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetPerAdapterInfo",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "IfIndex",
        "description": "Index of an interface.  The GetPerAdapterInfo function retrieves information for the adapter corresponding to this interface."
      },
      {
        "in_out": "_Out_",
        "type": "PIP_PER_ADAPTER_INFO",
        "name": "pPerAdapterInfo",
        "description": "Pointer to an  IP_PER_ADAPTER_INFO structure that receives information about the adapter."
      },
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "pOutBufLen",
        "description": "Pointer to a ULONG variable that specifies the size of the  IP_PER_ADAPTER_INFO structure. If this size is insufficient to hold the information,  GetPerAdapterInfo fills in this variable with the required size, and returns an error code of ERROR_BUFFER_OVERFLOW."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetUniDirectionalAdapterInfo function retrieves information about the unidirectional adapters installed on the local computer. A unidirectional adapter is an adapter that can receive datagrams, but not transmit them.",
    "library": "Iphlpapi.lib",
    "min_server": "",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetUniDirectionalAdapterInfo",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS",
        "name": "pIPIfInfo",
        "description": "Pointer to an  IP_UNIDIRECTIONAL_ADAPTER_ADDRESS structure that receives information about the unidirectional adapters installed on the local computer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "dwOutBufLen",
        "description": "Pointer to a ULONG variable that receives the size of the structure pointed to by the pIPIfInfo parameter."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "The  CreateIpNetEntry function creates an Address Resolution Protocol (ARP) entry in the ARP table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To modify an existing ARP entry, use the  SetIpNetEntry function. To retrieve the ARP table, call the GetIpNetTable function. To delete an existing ARP entry, call the DeleteIpNetEntry. On Windows Vista and later, the CreateIpNetEntry function can only be called by a user logged on as a member of the Administrators group. If CreateIpNetEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The CreateIpNetEntry function can also fail because of user account control (UAC) on Windows Vista later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "CreateIpNetEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPNETROW",
        "name": "pArpEntry",
        "description": "A pointer to a  MIB_IPNETROW structure that specifies information for the new entry. The caller must specify values for all members of this structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CreateProxyArpEnry function creates a Proxy Address Resolution Protocol (PARP) entry on the local computer for the specified IPv4 address.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To retrieve the ARP table, call the GetIpNetTable function. To delete an existing PARP entry, call the DeleteProxyArpEntry \t\t\t. On Windows Vista and later, the CreateProxyArpEnry function can only be called by a user logged on as a member of the Administrators group. If CreateProxyArpEnry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "CreateProxyArpEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAddress",
        "description": "The IPv4 address for which this computer acts as a proxy."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMask",
        "description": "The subnet mask for the IPv4 address specified in dwAddress."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIfIndex",
        "description": "The index of the interface on which to proxy ARP for the IPv4 address identified by dwAddress. In other words, when an ARP request for dwAddress is received on this interface, the local computer responds with the physical address of this interface. If this interface is of a type that does not support ARP, such as PPP, then the call fails."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteIpNetEntry function deletes an ARP entry from the ARP table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To retrieve the ARP table, call the GetIpNetTable function. On Windows Vista and later, the DeleteIpNetEntry function can only be called by a user logged on as a member of the Administrators group. If DeleteIpNetEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The DeleteIpNetEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "DeleteIpNetEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPNETROW",
        "name": "pArpEntry",
        "description": "A pointer to a  MIB_IPNETROW structure. The information in this structure specifies the entry to delete. The caller must specify values for at least the dwIndex and dwAddr members of this structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  DeleteProxyArpEntry function deletes the PARP entry on the local computer specified by the dwAddress and dwIfIndex parameters.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To retrieve the ARP table, call the GetIpNetTable function. On Windows Vista and later, the DeleteProxyArpEntry function can only be called by a user logged on as a member of the Administrators group. If DeleteProxyArpEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "DeleteProxyArpEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAddress",
        "description": "The IPv4 address for which this computer is acting as a proxy."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwMask",
        "description": "The subnet mask for the IPv4 address specified in the dwAddress parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIfIndex",
        "description": "The index of the interface on which this computer is supporting proxy ARP for the IP address specified by the dwAddress parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  FlushIpNetTable function deletes all ARP entries for the specified interface from the ARP table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To retrieve the ARP table, call the GetIpNetTable function. On Windows Vista and later, the FlushIpNetTable function can only be called by a user logged on as a member of the Administrators group. If FlushIpNetTable is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "FlushIpNetTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIfIndex",
        "description": "The index of the interface for which to delete all ARP entries."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetIpNetTable function retrieves the IPv4 to physical address mapping table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR or ERROR_NO_DATA. If the function fails or does not return any data, the return value is one of the following error codes.  ",
    "remarks": "The   GetIpNetTable function enumerates the Address Resolution Protocol (ARP) entries for IPv4 on a local system from the IPv4 to physical address mapping table and returns this information in a MIB_IPNETTABLE structure. The IPv4 address entries are returned in a MIB_IPNETTABLE structure in the buffer pointed to by the pIpNetTable parameter. The MIB_IPNETTABLE structure contains a count of ARP entries and an array of MIB_IPNETROW structures for each IPv4 address entry. Note that the returned MIB_IPNETTABLE structure pointed to by the pIpNetTable parameter may contain padding for alignment between the dwNumEntries member and the first MIB_IPNETROW array entry in the table member of the MIB_IPNETTABLE structure. Padding for alignment may also be present between the MIB_IPNETROW array entries. Any access to a MIB_IPNETROW array entry should assume  padding may exist. on Windows Vista and later, the GetIpNetTable2 function can be used to retrieve the neighbor IP addresses for both IPv6 and IPv4. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIpNetTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IPNETTABLE",
        "name": "pIpNetTable",
        "description": "A pointer to a buffer that receives the IPv4 to physical address mapping table as a  MIB_IPNETTABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "pdwSize",
        "description": "On input, specifies the size in bytes of the buffer pointed to by the pIpNetTable parameter. On output, if the buffer is not large enough to hold the returned mapping table, the function sets this parameter equal to the required buffer size in bytes."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A Boolean value that specifies whether the returned mapping table should be sorted in ascending order by IP address. If this parameter is TRUE, the table is sorted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The  SendARP function sends an Address Resolution Protocol (ARP) request to obtain the physical address that corresponds to the specified destination IPv4 address.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SendARP function is used to request the physical hardware address (sometimes referred to as the MAC address) that corresponds to a specified destination IPv4 address. If the information requested is not in the ARP table on the local computer, then the SendARP function will cause an ARP request to be sent to obtain the physical address. If the function is successful, the physical address that corresponds to the specified destination IPv4 address is returned in the array pointed to by the pMacAddr parameter. The physical address of an IPv4 address is only available if the destination IPv4 address is on the local subnet (the IPv4 address can be reached directly without going through any routers). The SendARP function will fail if the destination IPv4 address is not on the local subnet. If the SendARP function is successful on Windows Vista and later, the ARP table on the local computer is updated with the results.  If the SendARP function is successful on Windows Server 2003 and earlier, the ARP table on the local computer is not affected. The SendARP function on Windows Vista and later returns different error return values  than the  SendARP function on    Windows Server 2003 and earlier. On Windows Vista and later, a NULL pointer passed as the pMacAddr or PhyAddrLen parameter to the SendARP function causes an access violation and the application is terminated. If an error occurs on Windows Vista and later and ERROR_BAD_NET_NAME,  ERROR_BUFFER_OVERFLOW, or ERROR_NOT_FOUND is returned, the ULONG value pointed to by the PhyAddrLen parameter is set to zero. If the ULONG value pointed to by the PhyAddrLen parameter is less than 6 on  Windows Vista and later, SendARP function returns  ERROR_BUFFER_OVERFLOW indicating the buffer to receive the physical address is too small. If the SrcIp parameter specifies an IPv4 address that is not an interface on the local computer, the SendARP function on    Windows Vista and later  returns ERROR_NOT_FOUND. On Windows Server 2003 and earlier, a NULL pointer passed as the pMacAddr or PhyAddrLen parameter to the SendARP function returns ERROR_INVALID_PARAMETER. If an error occurs on Windows Server 2003 and earlier and ERROR_GEN_FAILURE or   ERROR_INVALID_USER_BUFFER is returned, the ULONG value pointed to by the PhyAddrLen parameter is set to zero. If the ULONG value pointed to by the PhyAddrLen parameter is less than 6 on  Windows Server 2003 and earlier, the SendARP function does not return an error but only returns part of the hardware address in the array pointed to by the pMacAddr parameter. So if the value pointed to by the PhyAddrLen parameter is 4, then only the first 4 bytes of the hardware address are returned in the array pointed to by the pMacAddr parameter. If the SrcIp parameter specifies an IPv4 address that is not an interface on the local computer, the SendARP function on    Windows Server 2003 and  earlier ignores the SrcIp parameter and uses an IPv4 address on the local computer for the source IPv4 address. The GetIpNetTable function retrieves the ARP table on the local computer that maps IPv4 addresses to physical addresses.  The CreateIpNetEntry function creates an ARP entry in the ARP table on the local computer.  The DeleteIpNetEntry function deletes an ARP entry from the ARP table on the local computer.  The SetIpNetEntry function modifies an existing ARP entry in the ARP table on the local computer.  The FlushIpNetTable function deletes all ARP entries for the specified interface from the ARP table on the local computer. On Windows Vista and later, the ResolveIpNetEntry2 function can used to replace the SendARP function. An ARP request is sent if the Address member of the MIB_IPNET_ROW2 structure passed to the ResolveIpNetEntry2 function is an IPv4 address. On Windows Vista, a new group of functions can be used to access, modify, and delete the ARP table entries when the Address member of the MIB_IPNET_ROW2 structure passed to these functions is an IPv4 address.  The new functions include the following: GetIpNetTable2, CreateIpNetEntry2, DeleteIpNetEntry2,  FlushIpNetTable2, and SetIpNetEntry2. For information about the IPAddr data type, see  Windows Data Types. To convert an IP address between dotted decimal notation and IPAddr format, use the  inet_addr and  inet_ntoa functions. The following code demonstrates how to obtain the hardware or media access control (MAC) address associated with a specified IPv4 address. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SendARP",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "DestIP",
        "description": "The destination IPv4 address, in the form of an IPAddr structure. The ARP request attempts to obtain the physical address that corresponds to this IPv4 address."
      },
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "SrcIP",
        "description": "The source IPv4 address of the sender, in the form of an IPAddr structure. This parameter is optional and is used to select the interface to send the request on for the ARP entry. The caller may specify zero corresponding to the INADDR_ANY IPv4 address for this parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pMacAddr",
        "description": "A pointer to an array of ULONG variables. This array must have at least two ULONG elements to hold an  Ethernet or token ring physical address. The first six bytes of this array receive the physical address that corresponds to the IPv4 address specified by the DestIP parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "PhyAddrLen",
        "description": "On input, a pointer to a ULONG value that specifies the maximum buffer size, in bytes, the application has set aside to receive the physical address or MAC address. The buffer size should be at least 6 bytes for an Ethernet or token ring physical address  The buffer to receive the physical address is pointed to by the pMacAddr parameter.  On successful output, this parameter points to a value that specifies the number of bytes written to the buffer pointed to by the pMacAddr."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpNetEntry function modifies an existing ARP entry in the ARP table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "On Windows Vista and later , the SetIpNetEntry function can only be called by a user logged on as a member of the Administrators group. If SetIpNetEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIpNetEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetIpNetEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPNETROW",
        "name": "pArpEntry",
        "description": "A pointer to a  MIB_IPNETROW structure. The information in this structure specifies the entry to modify and the new information for the entry. The caller must specify values for all members of this structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceAliasToLuid function converts an interface alias name for a network interface to the locally unique identifier (LUID) for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceAliasToLuid returns NO_ERROR. Any nonzero return value indicates failure and a NULL is returned in the InterfaceLuid parameter.  ",
    "remarks": "The ConvertInterfaceAliasToLuid function is available on Windows Vista       and later. The ConvertInterfaceAliasToLuid function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceAliasToLuid",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const WCHAR*",
        "name": "InterfaceAlias",
        "description": "A pointer to a NULL-terminated Unicode string containing the alias name of the network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PNET_LUID",
        "name": "InterfaceLuid",
        "description": "A pointer to the NET_LUID for this interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceGuidToLuid function converts a globally unique identifier (GUID) for a network  interface to the locally unique identifier (LUID) for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceGuidToLuid returns NO_ERROR. Any nonzero return value indicates failure and a NULL is returned in the InterfaceLuid parameter.  ",
    "remarks": "The ConvertInterfaceGuidToLuid function is available on Windows Vista       and later. The ConvertInterfaceGuidToLuid function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceGuidToLuid",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const GUID*",
        "name": "InterfaceGuid",
        "description": "A pointer to a GUID for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PNET_LUID",
        "name": "InterfaceLuid",
        "description": "A pointer to the NET_LUID for this interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceIndexToLuid function converts a local index  for a network interface to the locally unique identifier (LUID) for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceIndexToLuid returns NO_ERROR. Any nonzero return value indicates failure and a NULL is returned in the InterfaceLuid parameter.  ",
    "remarks": "The ConvertInterfaceIndexToLuid function is available on Windows Vista       and later. The ConvertInterfaceIndexToLuid function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceIndexToLuid",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NET_IFINDEX",
        "name": "InterfaceIndex",
        "description": "The local index  value for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PNET_LUID",
        "name": "InterfaceLuid",
        "description": "A pointer to the NET_LUID for this interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  ConvertInterfaceLuidToAlias function converts a locally unique identifier (LUID) for a network interface to an interface alias.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceLuidToAlias returns NO_ERROR. Any nonzero return value indicates failure.  ",
    "remarks": "The ConvertInterfaceLuidToAlias function is available on Windows Vista       and later. The ConvertInterfaceLuidToAlias function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. The maximum length of the alias name for a network interface, NDIS_IF_MAX_STRING_SIZE, without the terminating NULL is declared in the Ntddndis.h header file. The NDIS_IF_MAX_STRING_SIZE is defined to be the IF_MAX_STRING_SIZE constant defined in the Ifdef.h header file. The Ntddndis.h and Ifdef.h header files are automatically included in the Netioapi.h header file which is automatically included by the Iphlpapi.h header file. The Ntddndis.h, Ifdef.h, and  Netioapi.h header files should never be used directly. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceLuidToAlias",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const NET_LUID*",
        "name": "InterfaceLuid",
        "description": "A pointer to a NET_LUID for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "InterfaceAlias",
        "description": "A pointer to a buffer to hold the NULL-terminated Unicode string containing the alias name of the network interface when the function returns successfully."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The length, in characters, of the buffer pointed to by the InterfaceAlias parameter. This value must be large enough to accommodate the alias name of the network interface and the terminating NULL character.  The maximum required length is         NDIS_IF_MAX_STRING_SIZE + 1."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceLuidToGuid function converts a locally unique identifier (LUID) for a network interface to a globally unique identifier (GUID) for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceLuidToGuid returns NO_ERROR. Any nonzero return value indicates failure and a NULL is returned in the InterfaceGuid parameter.  ",
    "remarks": "The ConvertInterfaceLuidToGuid function is available on Windows Vista       and later. The ConvertInterfaceLuidToGuid function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceLuidToGuid",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const NET_LUID*",
        "name": "InterfaceLuid",
        "description": "A pointer to a NET_LUID for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "GUID*",
        "name": "InterfaceGuid",
        "description": "A pointer to the GUID for this interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceLuidToIndex function converts a locally unique identifier (LUID) for a network interface to the local index  for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceLuidToIndex returns NO_ERROR. Any nonzero return value indicates failure and a NET_IFINDEX_UNSPECIFIED is returned in the InterfaceIndex parameter.  ",
    "remarks": "The ConvertInterfaceLuidToIndex function is available on Windows Vista       and later. The ConvertInterfaceLuidToIndex function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceLuidToIndex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const NET_LUID*",
        "name": "InterfaceLuid",
        "description": "A pointer to a NET_LUID for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PNET_IFINDEX",
        "name": "InterfaceIndex",
        "description": "The local index  value for the interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  ConvertInterfaceLuidToNameA function converts a locally unique identifier (LUID) for a network interface to the ANSI interface name.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceLuidToNameA returns NETIO_ERROR_SUCCESS. Any nonzero return value indicates failure.  ",
    "remarks": "The ConvertInterfaceLuidToNameA function is available on Windows Vista       and later. The ConvertInterfaceLuidToNameA function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. The ConvertInterfaceLuidToNameA converts a network interface LUID to an ANSI interface name. The ConvertInterfaceLuidToNameW converts a network interface LUID to a Unicode interface name. The maximum length of an interface name, NDIS_IF_MAX_STRING_SIZE, without the terminating NULL is declared in the Ntddndis.h header file. The NDIS_IF_MAX_STRING_SIZE is defined to be the IF_MAX_STRING_SIZE constant defined in the Ifdef.h header file. The Ntddndis.h and Ifdef.h header files are automatically included in the Netioapi.h header file which is automatically included by the Iphlpapi.h header file. The Ntddndis.h, Ifdef.h, and  Netioapi.h header files should never be used directly. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceLuidToNameA",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const NET_LUID*",
        "name": "InterfaceLuid",
        "description": "A pointer to a NET_LUID for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PSTR",
        "name": "InterfaceName",
        "description": "A pointer to a buffer to hold the NULL-terminated ANSI string containing the interface name when the function returns successfully."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The length, in bytes, of the buffer pointed to by the InterfaceName parameter. This value must be large enough to accommodate the interface name         and the terminating null character.  The maximum required length is         NDIS_IF_MAX_STRING_SIZE + 1."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  ConvertInterfaceLuidToNameW function converts a locally unique identifier (LUID) for a network interface to the Unicode interface name.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceLuidToNameW returns NETIO_ERROR_SUCCESS. Any nonzero return value indicates failure.  ",
    "remarks": "The ConvertInterfaceLuidToNameW function is available on Windows Vista       and later. The ConvertInterfaceLuidToNameW function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. The ConvertInterfaceLuidToNameW converts a network interface LUID to a Unicode interface name. The ConvertInterfaceLuidToNameA converts an ANSI interface name to a LUID. The maximum length of an interface name, NDIS_IF_MAX_STRING_SIZE, without the terminating NULL is declared in the Ntddndis.h header file. The NDIS_IF_MAX_STRING_SIZE is defined to be the IF_MAX_STRING_SIZE constant defined in the Ifdef.h header file. The Ntddndis.h and Ifdef.h header files are automatically included in the Netioapi.h header file which is automatically included by the Iphlpapi.h header file. The Ntddndis.h, Ifdef.h, and  Netioapi.h header files should never be used directly. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceLuidToNameW",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const NET_LUID*",
        "name": "InterfaceLuid",
        "description": "A pointer to a NET_LUID for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "InterfaceName",
        "description": "A pointer to a buffer to hold the NULL-terminated Unicode string containing the interface name when the function returns successfully."
      },
      {
        "in_out": "_In_",
        "type": "SIZE_T",
        "name": "Length",
        "description": "The number of characters in the array pointed to by the InterfaceName parameter. This value must be large enough to accommodate the interface name         and the terminating null character.  The maximum required length is         NDIS_IF_MAX_STRING_SIZE + 1."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceNameToLuidA function converts an ANSI network interface name to the locally unique identifier (LUID) for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceNameToLuidA returns NETIO_ERROR_SUCCESS. Any nonzero return value indicates failure.  ",
    "remarks": "The ConvertInterfaceNameToLuidA function is available on Windows Vista       and later. The ConvertInterfaceNameToLuidA function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. The ConvertInterfaceNameToLuidA converts an ANSI interface name to a LUID. The ConvertInterfaceNameToLuidW converts a Unicode interface name to a LUID. The maximum length of an interface name, NDIS_IF_MAX_STRING_SIZE, without the terminating NULL is declared in the Ntddndis.h header file. The NDIS_IF_MAX_STRING_SIZE is defined to be the IF_MAX_STRING_SIZE constant defined in the Ifdef.h header file. The Ntddndis.h and Ifdef.h header files are automatically included in the Netioapi.h header file which is automatically included by the Iphlpapi.h header file. The Ntddndis.h, Ifdef.h, and  Netioapi.h header files should never be used directly. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceNameToLuidA",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const CHAR*",
        "name": "InterfaceName",
        "description": "A pointer to a NULL-terminated ANSI string containing the network interface name."
      },
      {
        "in_out": "_Out_",
        "type": "PNET_LUID",
        "name": "InterfaceLuid",
        "description": "A pointer to the NET_LUID for this interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertInterfaceNameToLuidW function converts a  Unicode network interface name to the locally unique identifier (LUID) for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertInterfaceNameToLuidW returns NETIO_ERROR_SUCCESS. Any nonzero return value indicates failure.  ",
    "remarks": "The ConvertInterfaceNameToLuidW function is available on Windows Vista       and later. The ConvertInterfaceNameToLuidW function is protocol independent and works with network interfaces for both the IPv6 and IPv4 protocol. The ConvertInterfaceNameToLuidW converts a Unicode interface name to a LUID. The ConvertInterfaceNameToLuidA converts an ANSI interface name to a LUID. The maximum length of an interface name, NDIS_IF_MAX_STRING_SIZE, without the terminating NULL is declared in the Ntddndis.h header file. The NDIS_IF_MAX_STRING_SIZE is defined to be the IF_MAX_STRING_SIZE constant defined in the Ifdef.h header file. The Ntddndis.h and Ifdef.h header files are automatically included in the Netioapi.h header file which is automatically included by the Iphlpapi.h header file. The Ntddndis.h, Ifdef.h, and  Netioapi.h header files should never be used directly. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertInterfaceNameToLuidW",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const WCHAR*",
        "name": "InterfaceName",
        "description": "A pointer to a NULL-terminated Unicode string containing the network interface name."
      },
      {
        "in_out": "_Out_",
        "type": "PNET_LUID",
        "name": "InterfaceLuid",
        "description": "A pointer to the NET_LUID for this interface."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  if_indextoname function converts the local index for a network interface to the ANSI interface name.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  if_indextoname returns a pointer to NULL-terminated ANSI string containing the interface name. On failure, a NULL pointer is returned. ",
    "remarks": "The if_indextoname function is available on Windows Vista       and later. The if_indextoname function maps an interface index into its corresponding    name. This function is designed as part of basic socket extensions for IPv6 as described by the IETF in RFC 2553. For more information, see http://www.ietf.org/rfc/rfc2553.txt. The if_indextoname function is implemented for portability of applications with Unix environments, but the ConvertInterface functions are preferred. The if_indextoname function can be replaced by a call to the ConvertInterfaceIndexToLuid function to convert an interface index to a  NET_LUID followed by a call to the ConvertInterfaceLuidToNameA to convert the NET_LUID to the ANSI interface name. If the if_indextoname fails and returns a NULL pointer, it is not possible to determine an error code. The length, in bytes, of the buffer pointed to by the InterfaceName parameter must be equal or greater than IF_NAMESIZE, a value declared in the Netioapi.h header file equal to NDIS_IF_MAX_STRING_SIZE. The maximum length of an interface name, NDIS_IF_MAX_STRING_SIZE, without the terminating NULL is declared in the Ntddndis.h header file. The NDIS_IF_MAX_STRING_SIZE is defined to be the IF_MAX_STRING_SIZE constant defined in the Ifdef.h header file. The Ntddndis.h and Ifdef.h header files are automatically included in the Netioapi.h header file which is automatically included by the Iphlpapi.h header file. The Ntddndis.h, Ifdef.h, and  Netioapi.h header files should never be used directly. ",
    "return_type": "PCHAR",
    "category": "IP Helper",
    "name": "if_indextoname",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NET_IFINDEX",
        "name": "InterfaceIndex",
        "description": "The local index for a network interface."
      },
      {
        "in_out": "_Out_",
        "type": "PCHAR",
        "name": "InterfaceName",
        "description": "A pointer to a buffer to hold the NULL-terminated ANSI string containing the interface name when the function returns successfully. The length, in bytes, of the buffer pointed to by this parameter must be equal to or greater than          IF_NAMESIZE."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  if_nametoindex function converts the ANSI interface name for a network interface to the local index for the interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  if_nametoindex returns the local interface index. On failure, zero is returned. ",
    "remarks": "The if_nametoindex function is available on Windows Vista       and later. The if_nametoindex function maps an interface name into its corresponding    index. This function is designed as part of basic socket extensions for IPv6 as described by the IETF in RFC 2553. For more information, see http://www.ietf.org/rfc/rfc2553.txt. The if_nametoindex function is implemented for portability of applications with Unix environments, but the ConvertInterface functions are preferred. The if_nametoindex function can be replaced by a call to the ConvertInterfaceNameToLuidA function to convert the ANSI interface name to a  NET_LUID followed by a call to the ConvertInterfaceLuidToIndex to convert the NET_LUID to the local interface index. If the if_nametoindex function fails and returns zero, it is not possible to determine an error code. ",
    "return_type": "NET_IFINDEX",
    "category": "IP Helper",
    "name": "if_nametoindex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCSTR",
        "name": "InterfaceName",
        "description": "A pointer to a NULL-terminated ANSI string containing the interface name."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetFriendlyIfIndex function takes an interface index and returns a backward-compatible interface index, that is, an index that uses only the lower 24 bits.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "A backward-compatible interface index that uses only the lower 24 bits. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetFriendlyIfIndex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "IfIndex",
        "description": "The interface index from which the backward-compatible or \"friendly\" interface index is derived."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIfEntry function retrieves information for the specified interface on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIfEntry function retrieves information for an interface on a local computer. The dwIndex member in the MIB_IFROW structure pointed to by the pIfRow parameter must be initialized to a valid network interface index retrieved by a previous call to the GetIfTable, GetIfTable2, or GetIfTable2Ex function. The GetIfEntry function will fail if the  dwIndex  member of the MIB_IFROW pointed to by the pIfRow parameter does not match an existing interface index on the local computer. The following example retrieves the entries from the interface table and prints some of the information available for that  entry. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIfEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IFROW",
        "name": "pIfRow",
        "description": "A pointer to a  MIB_IFROW structure that, on successful return, receives information for an interface on the local computer. On input, set the dwIndex member of MIB_IFROW to the index of the interface for which to retrieve information. The value for the dwIndex must be retrieved by a previous call to the GetIfTable, GetIfTable2, or GetIfTable2Ex function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIfEntry2 function  retrieves information for the specified interface on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIfEntry2 function is defined on Windows Vista and later. On input, at least one of the following members in the MIB_IF_ROW2 structure passed in the Row parameter must be initialized:     InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the value of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output, the remaining fields of the MIB_IF_ROW2 structure pointed to by the Row parameter are filled in. Note that the Netioapi.h header file is automatically included in Iphlpapi.h header file, and should never be used directly. The following example retrieves a interface entry specified on the command line and prints some values from the retrieved MIB_IF_ROW2 structure. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIfEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PMIB_IF_ROW2",
        "name": "Row",
        "description": "A pointer to a  MIB_IF_ROW2 structure that, on successful return, receives information for an interface on the local computer. On input, the InterfaceLuid or the InterfaceIndex member of the MIB_IF_ROW2 must be set to the interface for which to retrieve information."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetIfEntry2Ex function  retrieves the specified level of information for the specified interface on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2016 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The   GetIfEntry2Ex function retrieves information for a specified interface on a local system and returns this information in a pointer to a   MIB_IF_ROW2 structure. GetIfEntry2Ex is an enhanced version of the GetIfEntry2 function that allows selecting the level of interface information to retrieve. On input, at least one of the following members in the MIB_IF_ROW2 structure passed in the Row parameter must be initialized:     InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the value of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output, the remaining fields of the MIB_IF_ROW2 structure pointed to by the Row parameter are filled in. Note that the Netioapi.h header file is automatically included in Iphlpapi.h header file, and should never be used directly. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIfEntry2Ex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "MIB_IF_ENTRY_LEVEL",
        "name": "Level",
        "description": "The level of interface information to retrieve. This parameter can be one of the values from the MIB_IF_ENTRY_LEVEL enumeration type defined in the Netioapi.h header file.  ValueMeaning  MibIfEntryNormal 0   The values of statistics and state returned in members of the MIB_IF_ROW2 structure pointed to by the Row parameter are returned from the top of the filter stack.   MibIfEntryNormalWithoutStatistics  2   The values of state (without statistics) returned in members of the MIB_IF_ROW2 structure  pointed to by the Row parameter are returned from the top of the filter stack."
      },
      {
        "in_out": "_Inout_",
        "type": "PMIB_IF_ROW2",
        "name": "Row",
        "description": "A pointer to a  MIB_IF_ROW2 structure that, on successful return, receives information for an interface on the local computer. On input, the InterfaceLuid or the InterfaceIndex member of the MIB_IF_ROW2 must be set to the interface for which to retrieve information."
      }
    ],
    "min_client": "Windows 10, next major update [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetIfStackTable function  retrieves a table of network interface stack row entries that specify the relationship of the network interfaces on an interface stack.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIfStackTable function is defined on Windows Vista and later. The   GetIfStackTable function enumerates the physical and logical network interfaces on an interface stack on a local system and returns this information in a MIB_IFSTACK_TABLE structure. Interface stack entries are returned in a MIB_IFSTACK_TABLE structure in the buffer pointed to by the Table parameter. The MIB_IFSTACK_TABLE structure contains an interface stack entry count and an array of MIB_IFSTACK_ROW structures for each interface stack entry. The relationship between the interfaces in the interface stack is that the interface with index in the HigherLayerInterfaceIndex member of the MIB_IFSTACK_ROW structure is immediately above the interface with index in the LowerLayerInterfaceIndex member of the MIB_IFSTACK_ROW structure. Memory is allocated by the GetIfStackTable function for the MIB_IFSTACK_TABLE structure and the MIB_IFSTACK_ROW entries in this structure. When these returned structures are no longer required, free the memory by calling the FreeMibTable. Note that the returned MIB_IFSTACK_TABLE structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IFSTACK_ROW array entry in the Table member of the MIB_IFSTACK_TABLE structure. Padding for alignment may also be present between the MIB_IFSTACK_ROW array entries. Any access to a MIB_IFSTACK_ROW array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIfStackTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IFSTACK_TABLE*",
        "name": "Table",
        "description": "A pointer to a buffer that receives the table of interface stack row entries in a MIB_IFSTACK_TABLE structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetIfTable function retrieves the MIB-II interface table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The   GetIfTable function enumerates physical interfaces on a local system and returns this information in a MIB_IFTABLE \t\tstructure. The physical interfaces include the software loopback interface. The GetIfTable2 and GetIfTable2Ex functions available on Windows Vista and later are an enhanced version of the GetIfTable function that enumerate both the physical and logical interfaces on a local system. Logical interfaces include various WAN Miniport interfaces used for L2TP, PPTP, PPOE, and other tunnel encapsulations. Interfaces are returned in a MIB_IFTABLE structure in the buffer pointed to by the pIfTable parameter. The MIB_IFTABLE structure contains an interface count and an array of MIB_IFROW \t\tstructures for each interface. Note that the returned MIB_IFTABLE structure pointed to by the pIfTable parameter may contain padding for alignment between the dwNumEntries member and the first MIB_IFROW array entry in the table member of the MIB_IFTABLE structure. Padding for alignment may also be present between the MIB_IFROW array entries. Any access to a MIB_IFROW array entry should assume  padding may exist. The following example retrieves the interface table and prints the number of entries in the table and some data on each entry. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIfTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IFTABLE",
        "name": "pIfTable",
        "description": "A pointer to a buffer that receives the interface table as a  MIB_IFTABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "pdwSize",
        "description": "On input, specifies the size in bytes of the buffer pointed to by the pIfTable parameter. On output, if the buffer is not large enough to hold the returned interface table, the function sets this parameter equal to the required buffer size in bytes."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A Boolean value that specifies whether the returned interface table should be sorted in ascending order by interface index. If this parameter is TRUE, the table is sorted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetIfTable2 function  retrieves the MIB-II interface table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The   GetIfTable2 function enumerates the logical and physical interfaces on a local system and returns this information in a MIB_IF_TABLE2 structure. GetIfTable2 is an enhanced version of the GetIfTable function. A similar GetIfTable2Ex function can be used to specify the level of interfaces to return. Calling the GetIfTable2Ex function with the Level parameter set to MibIfTableNormal retrieves the same results as calling the GetIfTable2 function. Interfaces are returned in a MIB_IF_TABLE2 structure in the buffer pointed to by the Table parameter. The MIB_IF_TABLE2 structure contains an interface count and an array of MIB_IF_ROW2 structures for each interface. Memory is allocated by the GetIfTable2 function for the MIB_IF_TABLE2 structure and the MIB_IF_ROW2 entries in this structure. When these returned structures are no longer required, free the memory by calling the FreeMibTable. Note that the returned MIB_IF_TABLE2 structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IF_ROW2 array entry in the Table member of the MIB_IF_TABLE2 structure. Padding for alignment may also be present between the MIB_IF_ROW2 array entries. Any access to a MIB_IF_ROW2 array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIfTable2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IF_TABLE2*",
        "name": "Table",
        "description": "A pointer to a buffer that receives the table of interfaces in a MIB_IF_TABLE2 structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetIfTable2Ex function  retrieves the MIB-II interface table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The   GetIfTable2Ex function enumerates the logical and physical interfaces on a local system and returns this information in a MIB_IF_TABLE2 structure. GetIfTable2Ex is an enhanced version of the GetIfTable function that allows selecting the level of interface information to retrieve. A similar GetIfTable2 function can also be used to retrieve interfaces. but does not allow specifying the level of interfaces  to return. Calling the GetIfTable2Ex function with the Level parameter set to MibIfTableNormal retrieves the same results as calling the GetIfTable2 function. Interfaces are returned in a MIB_IF_TABLE2 structure in the buffer pointed to by the Table parameter. The MIB_IF_TABLE2 structure contains an interface count and an array of MIB_IF_ROW2 structures for each interface. Memory is allocated by the GetIfTable2 function for the MIB_IF_TABLE2 structure and the MIB_IF_ROW2 entries in this structure. When these returned structures are no longer required, free the memory by calling the FreeMibTable. All interfaces including NDIS intermediate driver interfaces and NDIS filter driver interfaces are returned for either of the possible values for the Level parameter. The setting for the Level parameter affects how statistics and state members of the MIB_IF_ROW2 structure in the MIB_IF_TABLE2 structure pointed to by the Table parameter for the interface are returned. For example, a network interface card (NIC)  will have a NDIS miniport driver.  An NDIS intermediate driver can be installed to  interface between upper-level protocol drivers and NDIS miniport drivers. An NDIS filter driver (LWF) can be attached on top of the NDIS intermediate driver. Assume that the NIC reports the MediaConnectState member of the  MIB_IF_ROW2 structure as MediaConnectStateConnected  but NDIS filter driver modifies the state and reports the state as MediaConnectStateDisconnected. When the interface information is queried with Level parameter set to MibIfTableNormal, the state at the top of the filter stack, that is MediaConnectStateDisconnected is reported. When the interface is queried with the Level parameter set to MibIfTableRaw, the state at the interface level directly, that is MediaConnectStateConnected is returned. Note that the returned MIB_IF_TABLE2 structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IF_ROW2 array entry in the Table member of the MIB_IF_TABLE2 structure. Padding for alignment may also be present between the MIB_IF_ROW2 array entries. Any access to a MIB_IF_ROW2 array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIfTable2Ex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "MIB_IF_TABLE_LEVEL",
        "name": "Level",
        "description": "The level of interface information to retrieve. This parameter can be one of the values from the MIB_IF_TABLE_LEVEL enumeration type defined in the Netioapi.h header file.  ValueMeaning  MibIfTableNormal   The values of statistics and state returned in members of the MIB_IF_ROW2 structure in the MIB_IF_TABLE2 structure pointed to by the Table parameter are returned from the top of the filter stack when this parameter is specified.   MibIfTableRaw   The values of statistics and state returned in members of the MIB_IF_ROW2 structure in the MIB_IF_TABLE2 structure pointed to by the Table parameter are returned directly for the interface being queried."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IF_TABLE2*",
        "name": "Table",
        "description": "A pointer to a buffer that receives the table of interfaces in a MIB_IF_TABLE2 structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetInterfaceInfo function obtains the list of the network interface adapters with IPv4 enabled on the local system.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The  GetInterfaceInfo function is specific to network adapters with IPv4 enabled. The function returns an IP_INTERFACE_INFO structure pointed to by the pIfTable parameter that contains the number of network adapters with IPv4 enabled on the local system and an array of IP_ADAPTER_INDEX_MAP structures with information on each network adapter with IPv4 enabled. The IP_INTERFACE_INFO structure returned by GetInterfaceInfo contains at least one IP_ADAPTER_INDEX_MAP structure even if the NumAdapters member of the IP_INTERFACE_INFO structure indicates that no network adapters with IPv4 are enabled. When the NumAdapters member of the IP_INTERFACE_INFO structure returned by GetInterfaceInfo is zero, the value of the members of the single  IP_ADAPTER_INDEX_MAP structure returned in the IP_INTERFACE_INFO structure is undefined. If the  GetInterfaceInfo function is called with too small a buffer to retrieve the IPv4 interface information  (the  dwOutBufLen parameter indicates that the buffer pointed to by the pIfTable parameter is too small), the function returns  ERROR_INSUFFICIENT_BUFFER. The required size is returned in the DWORD variable pointed to by the dwOutBufLen parameter. The  correct way to use the GetInterfaceInfo function is to call this function twice. In the first call, pass a NULL pointer in the pIfTable parameter and zero in the variable pointed to by the dwOutBufLen parameter. The call with fail with ERROR_INSUFFICIENT_BUFFER and the required size for this buffer is returned in the DWORD variable pointed to by the dwOutBufLen parameter. A buffer can then  be allocated of the required size using the value pointed by the dwOutBufLen. Then  the GetInterfaceInfo function can be called a second time with a pointer to this buffer passed in the pIfTable parameter and the length of the buffer set to the size of this buffer. The  GetAdaptersInfo and  GetInterfaceInfo functions do not return information about the loopback interface. Information on the loopback interface is returned by the GetIpAddrTable function. On Windows Vista and later, the Name member of the IP_ADAPTER_INDEX_MAP structure returned in the IP_INTERFACE_INFO structure may be a Unicode string of the GUID for the network interface (the string begins with the '{' character). The following example retrieves the list of network adapters with IPv4 enabled on the local system and prints various properties of the first network adapter. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetInterfaceInfo",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PIP_INTERFACE_INFO",
        "name": "pIfTable",
        "description": "A pointer to a buffer that specifies an  IP_INTERFACE_INFO structure that receives the list of adapters. This buffer must be allocated by the caller."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "dwOutBufLen",
        "description": "A pointer to a DWORD variable that specifies the size of the  buffer pointed to by pIfTable parameter to receive the IP_INTERFACE_INFO structure. If this size is insufficient to hold the IPv4 interface information,  GetInterfaceInfo fills in this variable with the required size, and returns an error code of ERROR_INSUFFICIENT_BUFFER."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetInvertedIfStackTable function  retrieves a table of inverted network interface stack row entries that specify the relationship of the network interfaces on an interface stack.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetInvertedIfStackTable function is defined on Windows Vista and later. The   GetInvertedIfStackTable function enumerates the physical and logical network interfaces on an interface stack on a local system and returns this information in an inverted form in the MIB_INVERTEDIFSTACK_TABLE structure. Interface stack entries are returned in a MIB_INVERTEDIFSTACK_TABLE structure in the buffer pointed to by the Table parameter. The MIB_INVERTEDIFSTACK_TABLE structure contains an interface stack entry count and an array of MIB_INVERTEDIFSTACK_ROW structures for each interface stack entry. The relationship between the interfaces in the interface stack is that the interface with index in the HigherLayerInterfaceIndex member of the MIB_INVERTEDIFSTACK_ROW structure is immediately above the interface with index in the LowerLayerInterfaceIndex member of the MIB_INVERTEDIFSTACK_ROW structure. Memory is allocated by the GetInvertedIfStackTable function for the MIB_INVERTEDIFSTACK_TABLE structure and the MIB_INVERTEDIFSTACK_ROW entries in this structure. When these returned structures are no longer required, free the memory by calling the FreeMibTable. Note that the returned MIB_INVERTEDIFSTACK_TABLE structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_INVERTEDIFSTACK_ROW array entry in the Table member of the MIB_INVERTEDIFSTACK_TABLE structure. Padding for alignment may also be present between the MIB_INVERTEDIFSTACK_ROW array entries. Any access to a MIB_INVERTEDIFSTACK_ROW array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetInvertedIfStackTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_INVERTEDIFSTACK_TABLE*",
        "name": "Table",
        "description": "A pointer to a buffer that receives the table of inverted interface stack row entries in a MIB_INVERTEDIFSTACK_TABLE structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIpInterfaceEntry function  retrieves IP information for the specified interface on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpInterfaceEntry function is defined on Windows Vista and later. On input, the Family member in the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter must be initialized to either AF_INET or AF_INET6. In addition on input, at least one of the following members in the MIB_IPINTERFACE_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output, the InterfaceLuid member of the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter is filled in if the InterfaceIndex was specified. The other members of MIB_IPINTERFACE_ROW structure pointed to by the Row parameter are also filled in. The InitializeIpInterfaceEntry function must be used to initialize the fields of a     MIB_IPINTERFACE_ROW structure entry with default values.  An application can then change the     fields in the MIB_IPINTERFACE_ROW entry it wishes to modify, and then call the SetIpInterfaceEntry function. Unprivileged simultaneous access to multiple networks of different security requirements creates a security hole and allows an unprivileged application to accidentally relay data between the two networks. A typical example is simultaneous access to a virtual private network (VPN) and the Internet. Windows Server 2003 and Windows XP use a weak host model, where RAS prevents such simultaneous access by increasing the route metric of all default routes over other interfaces. Thus all traffic is routed through the VPN interface, disrupting other network connectivity. On Windows Vista and later, a strong host model is used by default. If a source IP address is specified in the route lookup using GetBestRoute2 or GetBestRoute, the route lookup is restricted to the interface of the source IP address. The route metric modification by RAS has no effect as the list of potential routes does not even have the route for the VPN interface thereby allowing traffic to the Internet. The DisableDefaultRoutes member of the MIB_IPINTERFACE_ROW can be used to disable using the default route on an interface. This member can be used as a security measure by VPN clients to restrict split tunneling when split tunneling is not required by the VPN client. A VPN client can call the SetIpInterfaceEntry function to set the DisableDefaultRoutes member to TRUE when required. A VPN client can query the current state of the DisableDefaultRoutes member by calling  the GetIpInterfaceEntry function. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpInterfaceEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPINTERFACE_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_IPINTERFACE_ROW structure that, on successful return, receives information for an interface on the local computer. On input, the InterfaceLuid or InterfaceIndex member of the MIB_IPINTERFACE_ROW must be set to the interface for which to retrieve information."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetIpInterfaceTable function  retrieves the IP interface entries on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpInterfaceTable function is defined on Windows Vista and later. The   GetIpInterfaceTable function enumerates the IP interfaces on a local system and returns this information in an MIB_IPINTERFACE_TABLE structure. IP interface entries are returned in a MIB_IPINTERFACE_TABLE structure in the buffer pointed to by the Table parameter. The MIB_IPINTERFACE_TABLE structure contains an IP interface entry count and an array of MIB_IPINTERFACE_ROW structures for each IP interface entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET or AF_INET6. Note that the returned MIB_IPINTERFACE_TABLE structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IPINTERFACE_ROW array entry in the Table member of the MIB_IPINTERFACE_TABLE structure. Padding for alignment may also be present between the MIB_IPINTERFACE_ROW array entries. Any access to a MIB_IPINTERFACE_ROW array entry should assume  padding may exist. The following example retrieves the IP interface table, then prints the values of a few members of the IP interface entries in the table. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpInterfaceTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family of IP interfaces to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On Windows Vista and later as well as on the Windows SDK, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  the GetIpInterfaceTable function  returns the IP interface table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family.   AF_INET6 23   The Internet Protocol version 6 (IPv6) address family."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IPINTERFACE_TABLE*",
        "name": "Table",
        "description": "A pointer to a buffer that receives the table of IP interface entries in a MIB_IPINTERFACE_TABLE structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetNumberOfInterfaces functions retrieves the number of interfaces on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "The  GetNumberOfInterfaces function returns the number of interfaces on the local computer, including the loopback interface. This number is one more than the number of adapters returned by the  GetAdaptersInfo and  GetInterfaceInfo functions because these functions do not return information about the loopback interface. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetNumberOfInterfaces",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "pdwNumIf",
        "description": "Pointer to a DWORD variable that receives the number of interfaces on the local computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  InitializeIpInterfaceEntry function  initializes the members of     an MIB_IPINTERFACE_ROW entry with default values.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The InitializeIpInterfaceEntry function is defined on Windows Vista and later. On output, the Family member in the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter will be initialized to either AF_UNSPEC, the InterfaceLuid member in the MIB_IPINTERFACE_ROW structure will be initialized to an unspecified value, and other fields are initialized to zero. The InitializeIpInterfaceEntry function must be used to initialize the fields of a     MIB_IPINTERFACE_ROW structure entry with default values.  An application can then change the     fields in the MIB_IPINTERFACE_ROW entry it wishes to modify, and then call the SetIpInterfaceEntry function. ",
    "return_type": "VOID",
    "category": "IP Helper",
    "name": "InitializeIpInterfaceEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPINTERFACE_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_IPINTERFACE_ROW structure to initialize. On successful return, the fields in this parameter are initialized with default information for an interface on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIfEntry function sets the administrative status of an interface.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetIfEntry function is used to set the administrative status of an interface on a local computer. The dwIndex member in the MIB_IFROW structure pointed to by the pIfRow parameter must be initialized to the interface index. The SetIfEntry function will fail if the  dwIndex  member of the MIB_IFROW pointed to by the pIfRow parameter does not match an existing interface on the local computer. On Windows Vista and later, the SetIfEntry function can only be called by a user logged on as a member of the Administrators group. If SetIfEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIfEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetIfEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IFROW",
        "name": "pIfRow",
        "description": "A pointer to a  MIB_IFROW structure. The dwIndex member of this structure specifies the interface on which to set administrative status. The dwAdminStatus member specifies the new administrative status. The dwAdminStatus member can be one of the following values.     ValueMeaning  MIB_IF_ADMIN_STATUS_UP   The interface is administratively enabled.   MIB_IF_ADMIN_STATUS_DOWN   The interface is administratively disabled."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpInterfaceEntry function  sets the properties of an IP interface on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetIpInterfaceEntry function is defined on Windows Vista and later. The SetIpInterfaceEntry function can is used to modify an existing IP interface entry. On input, the Family member in the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter must be initialized to either AF_INET or AF_INET6. In addition on input, at least one of the following members in the MIB_IPINTERFACE_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output, the InterfaceLuid member of the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter is filled in if the InterfaceIndex was specified. The MaxReassemblySize, MinRouterAdvertisementInterval, MaxRouterAdvertisementInterval ,   Connected, SupportsWakeUpPatterns, SupportsNeighborDiscovery, SupportsRouterDiscovery, ReachableTime, TransmitOffload, and ReceiveOffload members of the MIB_IPINTERFACE_ROW structure pointed to by the Row are ignored when the  SetIpInterfaceEntry function is called. These members are set by the network stack and cannot be changed using the SetIpInterfaceEntry function. An application would typically call the GetIpInterfaceTable function to retrieve the IP interface entries on the local computer or call the GetIpInterfaceEntry function to retrieve just the IP interface entry to modify.     The  MIB_IPINTERFACE_ROW structure for the specific IP interface entry could then be modified and a pointer to this structure passed to the SetIpInterfaceEntry function in the Row parameter. However for IPv4, an application must not try to modify the SitePrefixLength member of the MIB_IPINTERFACE_ROW structure. For IPv4, the SitePrefixLength member must be set to 0. Another possible method to modify an existing IP interface entry is to use InitializeIpInterfaceEntry function to initialize the fields of a     MIB_IPINTERFACE_ROW structure entry with default values.  Then set the Family member and either the  InterfaceIndex or InterfaceLuid members in the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter to match the IP interface to change. An application can then change the     fields in the MIB_IPINTERFACE_ROW entry it wishes to modify, and then call the SetIpInterfaceEntry function. However for IPv4, an application must not try to modify the SitePrefixLength member of the MIB_IPINTERFACE_ROW structure. For IPv4, the SitePrefixLength member must be set to 0. Caution must be used with this approach because the only way to determine  all of the fields being changed would be to compare the fields in the MIB_IPINTERFACE_ROW of the specific IP interface entry with fields set by the InitializeIpInterfaceEntry function when a MIB_IPINTERFACE_ROW is initialized to default values. Unprivileged simultaneous access to multiple networks of different security requirements creates a security hole and allows an unprivileged application to accidentally relay data between the two networks. A typical example is simultaneous access to a virtual private network (VPN) and the Internet. Windows Server 2003 and Windows XP use a weak host model, where RAS prevents such simultaneous access by increasing the route metric of all default routes over other interfaces. Thus all traffic is routed through the VPN interface, disrupting other network connectivity. On Windows Vista and later, a strong host model is used by default. If a source IP address is specified in the route lookup using GetBestRoute2 or GetBestRoute, the route lookup is restricted to the interface of the source IP address. The route metric modification by RAS has no effect as the list of potential routes does not even have the route for the VPN interface thereby allowing traffic to the Internet. The DisableDefaultRoutes member of the MIB_IPINTERFACE_ROW can be used to disable using the default route on an interface. This member can be used as a security measure by VPN clients to restrict split tunneling when split tunneling is not required by the VPN client. A VPN client can call the SetIpInterfaceEntry function to set the DisableDefaultRoutes member to TRUE when required. A VPN client can query the current state of the DisableDefaultRoutes member by calling  the GetIpInterfaceEntry function. The The SetIpInterfaceEntry function can only be called by a user logged on as a member of the Administrators group. If SetIpInterfaceEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "SetIpInterfaceEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPINTERFACE_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_IPINTERFACE_ROW structure entry for an interface. On input, the Family member of the MIB_IPINTERFACE_ROW must be set to AF_INET6 or AF_INET  and the InterfaceLuid or the  InterfaceIndex member of the MIB_IPINTERFACE_ROW must be specified. On a successful return, the InterfaceLuid member of the MIB_IPINTERFACE_ROW is filled in if InterfaceIndex member of the MIB_IPINTERFACE_ROW entry was specified."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIcmpStatistics function retrieves the Internet Control Message Protocol (ICMP) for IPv4 statistics for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The  GetIcmpStatistics function returns the ICMP statistics for IPv4 on the local computer.     On Windows XP and later, the GetIpStatisticsEx can be used to obtain the ICMP statistics for either IPv4 or IPv6 on the local computer. The following example retrieves the ICMP for IPv4 statistics for the local computer and prints some information from the returned data. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIcmpStatistics",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_ICMP",
        "name": "pStats",
        "description": "A pointer to a  MIB_ICMP structure that receives the ICMP statistics for the local computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIpStatistics function retrieves the IP statistics for the current computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The  GetIpStatistics function returns the statistics for IPv4 on the current computer.     On Windows XP and later, the GetIpStatisticsEx can be used to obtain the IP statistics for either IPv4 or IPv6. The following example retrieves the IPv4 statistics for the local computer and prints values from the returned data. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIpStatistics",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IPSTATS",
        "name": "pStats",
        "description": "A pointer to a  MIB_IPSTATS structure that receives the IP statistics for the local computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The  Icmp6CreateFile function opens a handle on which IPv6 ICMP echo requests can be issued.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "The  Icmp6CreateFile function returns an open handle on success. On failure, the function returns INVALID_HANDLE_VALUE. Call the  GetLastError function for extended error information. ",
    "remarks": "The  Icmp6CreateFile function opens a handle on which IPv6 ICMP echo requests can be issued. The Icmp6SendEcho2 function is used to send the IPv6 ICMP echo requests. The Icmp6ParseReplies function is used to parse the IPv6 ICMP replies. The IcmpCloseHandle function is used to close the ICMP handle opened by the Icmp6CreateFile function. For IPv4, use the IcmpCreateFile function. For IPv4, use the IcmpCreateFile,  IcmpSendEcho, IcmpSendEcho2, IcmpSendEcho2Ex, and IcmpParseReplies functions. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. The following example opens a handle on which IPv6 ICMP echo requests can be issued. ",
    "return_type": "HANDLE",
    "category": "IP Helper",
    "name": "Icmp6CreateFile",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The Icmp6ParseReplies function parses the reply buffer provided and returns an IPv6 ICMPv6 echo response reply if found.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "The Icmp6ParseReplies function returns 1 on success. In this case, the Status member in the ICMPV6_ECHO_REPLY structure pointed to by the ReplyBuffer parameter will be either IP_SUCCESS if the target node responded or IP_TTL_EXPIRED_TRANSIT. If the return value is zero, extended error information is available through  GetLastError.  ",
    "remarks": "The Icmp6ParseReplies function is used by IPv6 to parse replies that result from an ICMPv6 echo request. The Icmp6ParseReplies function  parses a reply buffer previously passed to  the Icmp6SendEcho2 function. Use the Icmp6ParseReplies  function only with  the Icmp6SendEcho2 function. The Icmp6ParseReplies function cannot be used on a reply buffer previously passed to  IcmpSendEcho or IcmpSendEcho2 for IPv4. For IPv4, use the IcmpCreateFile,  IcmpSendEcho, IcmpSendEcho2, IcmpSendEcho2Ex, and IcmpParseReplies functions. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "Icmp6ParseReplies",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "ReplyBuffer",
        "description": "A pointer to the buffer passed to  the Icmp6SendEcho2 function. This parameter is points to an ICMPV6_ECHO_REPLY structure to hold the response."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ReplySize",
        "description": "The size, in bytes, of the buffer pointed to by the ReplyBuffer parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The Icmp6SendEcho2 function sends an IPv6 ICMPv6 echo request and returns either immediately (if Event or ApcRoutine is non-NULL) or returns after the specified time-out. The ReplyBuffer contains the IPv6 ICMPv6 echo response, if any.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "When called synchronously, the Icmp6SendEcho2 function returns the number of replies received and stored in ReplyBuffer. If the return value is zero, call  GetLastError for extended error information. When called asynchronously, the Icmp6SendEcho2 function returns ERROR_IO_PENDING  to indicate the operation is in progress. The results can be retrieved later when the event specified in the Event parameter signals or the callback function in the ApcRoutine parameter is called. If the return value is zero, call  GetLastError for extended error information. If the function fails, the extended error code returned by GetLastError can be one of the following values.  ",
    "remarks": "The Icmp6SendEcho2 function is called synchronously if the ApcRoutine or Event parameters are NULL. When called synchronously, the return value contains the number of replies received and stored in ReplyBuffer after waiting for the time specified in the Timeout parameter. If the return value is zero, call  GetLastError for extended error information. The Icmp6SendEcho2 function is called asynchronously when either the ApcRoutine or Event parameters are specified. When called asynchronously,  the ReplyBuffer and ReplySize parameters are  required to accept the response. ICMP response data is copied to the ReplyBuffer provided and the application is signaled (when the Event parameter is specified) or the callback function is called (when the ApcRoutine parameter is specified). The application must parse the data pointed to by ReplyBuffer parameter using the Icmp6ParseReplies function. If the Event parameter is specified, the Icmp6SendEcho2 function is called asynchronously. The event specified in the Event parameter is signaled whenever an ICMPv6 response arrives. Use the  CreateEvent function to create this event object. If the ApcRoutine parameter is specified, the Icmp6SendEcho2 function is called asynchronously. The ApcRoutine  parameter should point to a user-defined callback function. The callback function specified in the ApcRoutine parameter is called whenever an ICMPv6 response arrives. The invocation of the callback function specified in the ApcRoutine parameter is serialized. If both the Event and ApcRoutine parameters are specified, the event specified in the Event parameter is signaled whenever an ICMPv6 response arrives, but the callback function specified in the ApcRoutine parameter is ignored . On Windows Vista and later, any application that calls Icmp6SendEcho2 function asynchronously using the ApcRoutine parameter must define PIO_APC_ROUTINE_DEFINED to force the datatype for the ApcRoutine parameter to PIO_APC_ROUTINE rather than FARPROC. On Windows Vista and later, the callback function pointed to by the ApcRoutine must be defined as a function of type VOID with the following syntax: On Windows Vista and later, the parameters passed to the callback function include the following:    On Windows Server 2003 and Windows XP   , any application that calls the Icmp6SendEcho2 function asynchronously using the ApcRoutine parameter must not define PIO_APC_ROUTINE_DEFINED to force the datatype for the ApcRoutine parameter to FARPROC rather than PIO_APC_ROUTINE. On Windows Server 2003 and Windows XP, the callback function pointed to by the ApcRoutine must be defined as a function of type VOID with the following syntax: On Windows Server 2003 and Windows XP, the parameters passed to the callback function include the following:    The callback function specified in the ApcRoutine parameter must be implemented in the same process as the application calling the Icmp6SendEcho2 function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the Icmp6SendEcho2 function. For IPv4, use the IcmpCreateFile,  IcmpSendEcho, IcmpSendEcho2, IcmpSendEcho2Ex, and IcmpParseReplies functions. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "Icmp6SendEcho2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "IcmpHandle",
        "description": "The open handle returned by Icmp6CreateFile."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "An event to be signaled whenever an ICMPv6 response arrives. If this parameter is specified, it requires a handle to a valid event object. Use the  CreateEvent or CreateEventEx function to create this event object.  For more information on using events, see Event Objects."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "The routine that is called when the calling thread is in an alertable thread and  an ICMPv6 reply arrives. On Windows Vista and later, PIO_APC_ROUTINE_DEFINED must be defined to force the datatype for this parameter to PIO_APC_ROUTINE rather than FARPROC.  On Windows Server 2003 and Windows XP   ,     PIO_APC_ROUTINE_DEFINED must not be defined to force the datatype for this parameter to FARPROC."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "An optional parameter passed to the callback routine specified in the  ApcRoutine parameter whenever an ICMPv6 response arrives or an error occurs."
      },
      {
        "in_out": "_In_",
        "type": "struct sockaddr_in6*",
        "name": "SourceAddress",
        "description": "The IPv6 source address on which to issue the echo request, in the form of a sockaddr structure."
      },
      {
        "in_out": "_In_",
        "type": "struct sockaddr_in6*",
        "name": "DestinationAddress",
        "description": "The IPv6 destination address of the echo request, in the form of a sockaddr structure."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "RequestData",
        "description": "A pointer to a buffer that contains data to send in the request."
      },
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "RequestSize",
        "description": "The size, in bytes, of the request data buffer pointed to by the RequestData parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIP_OPTION_INFORMATION",
        "name": "RequestOptions",
        "description": "A pointer to the IPv6 header options for the request, in the form of an IP_OPTION_INFORMATION structure. On a 64-bit platform, this parameter is in the form for an IP_OPTION_INFORMATION32 structure. This parameter may be NULL if no IP header options need to be specified. Note  On Windows Server 2003 and Windows XP, the RequestOptions parameter is not optional and must not be NULL and only the Ttl and Flags members are used."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "ReplyBuffer",
        "description": "A pointer to a buffer to hold replies to the request. Upon return, the buffer contains an ICMPV6_ECHO_REPLY structure followed by the message body from the ICMPv6 echo response reply data. The buffer must be large enough to hold at least one  ICMPV6_ECHO_REPLY structure plus the number of bytes of data specified in the RequestSize parameter. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message) plus space for an IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ReplySize",
        "description": "The size, in bytes,  of the reply buffer pointed to by the ReplyBuffer parameter. This buffer should be large enough to hold at least one  ICMPV6_ECHO_REPLY structure plus RequestSize bytes of data. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message) plus space for an IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Timeout",
        "description": "The time, in milliseconds, to wait for replies. This parameter is only used if the Icmp6SendEcho2 function is called synchronously. So this parameter is not used if either the ApcRoutine or Event                            parameter are not NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  IcmpCloseHandle function closes a handle opened by a call to  the IcmpCreateFile or Icmp6CreateFile functions.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "If the handle is closed successfully the return value is TRUE, otherwise FALSE. Call the  GetLastError function for extended error information. ",
    "remarks": "The IcmpCloseHandle function is exported from the Icmp.dll on Windows 2000. The IcmpCloseHandle function is exported from the Iphlpapi.dll on Windows XP and later. Windows version checking is not recommended to use this function. Applications requiring portability  with this function across Windows 2000, Windows XP, Windows Server 2003 and later Windows versions should not statically link to either the Icmp.lib or the Iphlpapi.lib file. Instead, the application should check for the presence of IcmpCloseHandle in the Iphlpapi.dll with calls to LoadLibrary and GetProcAddress.  Failing that, the application should check for the presence of IcmpCloseHandle in the Icmp.dll with  calls to LoadLibrary and GetProcAddress. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. The following example opens and closes a handle on which ICMP echo requests can be issued. ",
    "return_type": "BOOL",
    "category": "IP Helper",
    "name": "IcmpCloseHandle",
    "is_callback": 0,
    "dll": "Iphlpapi.dll on Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP;  Icmp.dll on Windows 2000 Server and Windows 2000 Professional",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "IcmpHandle",
        "description": "The handle to close. This handle must have been returned by a call to IcmpCreateFile or Icmp6CreateFile."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The  IcmpCreateFile function opens a handle on which IPv4 ICMP echo requests can be issued.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "The  IcmpCreateFile function returns an open handle on success. On failure, the function returns INVALID_HANDLE_VALUE. Call the  GetLastError function for extended error information. ",
    "remarks": "The IcmpCreateFile function is exported from the Icmp.dll on Windows 2000. The IcmpCreateFile function is exported from the Iphlpapi.dll on Windows XP and later. Windows version checking is not recommended to use this function. Applications requiring portability  with this function across Windows 2000, Windows XP, Windows Server 2003 and later Windows versions should not statically link to either the Icmp.lib or the Iphlpapi.lib file. Instead, the application should check for the presence of IcmpCreateFile in the Iphlpapi.dll with calls to LoadLibrary and GetProcAddress.  Failing that, the application should check for the presence of IcmpCreateFile in the Icmp.dll with  calls to LoadLibrary and GetProcAddress. For IPv6, use the Icmp6CreateFile, Icmp6SendEcho2, and Icmp6ParseReplies functions. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. The following example opens a handle on which ICMP echo requests can be issued. ",
    "return_type": "HANDLE",
    "category": "IP Helper",
    "name": "IcmpCreateFile",
    "is_callback": 0,
    "dll": "Iphlpapi.dll on Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP;  Icmp.dll on Windows 2000 Server and Windows 2000 Professional",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  IcmpParseReplies function parses the reply buffer provided and returns the number of ICMP echo request responses found.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "The  IcmpParseReplies function returns the number of ICMP responses found on success. The function returns zero on error. Call  GetLastError for additional error information. ",
    "remarks": "The IcmpParseReplies function should not be used on a reply buffer previously passed to  IcmpSendEcho. The  IcmpSendEcho function parses that buffer before returning to the user. Use this function only with  IcmpSendEcho2. The IcmpParseReplies function is exported from the Icmp.dll on Windows 2000. The IcmpParseReplies function is exported from the Iphlpapi.dll on Windows XP and later. Windows version checking is not recommended to use this function. Applications requiring portability  with this function across Windows 2000, Windows XP, Windows Server 2003 and later Windows versions should not statically link to either the Icmp.lib or the Iphlpapi.lib file. Instead, the application should check for the presence of IcmpParseReplies in the Iphlpapi.dll with calls to LoadLibrary and GetProcAddress.  Failing that, the application should check for the presence of IcmpParseReplies in the Icmp.dll with  calls to LoadLibrary and GetProcAddress. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "IcmpParseReplies",
    "is_callback": 0,
    "dll": "Iphlpapi.dll on Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP;  Icmp.dll on Windows 2000 Server and Windows 2000 Professional",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "ReplyBuffer",
        "description": "The buffer passed to  IcmpSendEcho2. This is rewritten to hold an array of  ICMP_ECHO_REPLY structures, its type is PICMP_ECHO_REPLY.  On a 64-bit plaform, this buffer is rewritten to hold an array of ICMP_ECHO_REPLY32 structures, its type is PICMP_ECHO_REPLY32."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ReplySize",
        "description": "The size, in bytes, of the buffer pointed to by the ReplyBuffer parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The  IcmpSendEcho function sends an IPv4 ICMP echo request and returns any echo response replies. The call returns when the time-out has expired or the reply buffer is filled.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "The  \t\t\t\t\t\tIcmpSendEcho function returns the number of  ICMP_ECHO_REPLY or ICMP_ECHO_REPLY32 structures stored in the ReplyBuffer. The status of each reply is contained in the structure. If the return value is zero, call  GetLastError for additional error information. If the function fails, the extended error code returned by GetLastError can be one of the following values.  ",
    "remarks": "The IcmpSendEcho function send an ICMP echo request to the specified address and returns the number of replies received and stored in ReplyBuffer.  The IcmpSendEcho function is a synchronous function and returns after waiting for the time specified in the Timeout parameter for a response. If the return value is zero, call  GetLastError for extended error information. The IcmpSendEcho2 and IcmpSendEcho2Ex functions are enhanced version of IcmpSendEcho that support asynchronous operation. The IcmpSendEcho2Ex function also allows the source IP address to be specified. This feature is useful on computers with multiple network interfaces. For IPv6, use the Icmp6CreateFile, Icmp6SendEcho2, and Icmp6ParseReplies functions. The IcmpSendEcho function is exported from the Icmp.dll on Windows 2000. The IcmpSendEcho function is exported from the Iphlpapi.dll on Windows XP and later. Windows version checking is not recommended to use this function. Applications requiring portability  with this function across Windows 2000, Windows XP, Windows Server 2003 and later Windows versions should not statically link to either the Icmp.lib or the Iphlpapi.lib file. Instead, the application should check for the presence of IcmpSendEcho in the Iphlpapi.dll with calls to LoadLibrary and GetProcAddress.  Failing that, the application should check for the presence of IcmpSendEcho in the Icmp.dll with  calls to LoadLibrary and GetProcAddress. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. The following example sends an ICMP echo request to the IP address specified on the command line and prints the information received from the first response. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "IcmpSendEcho",
    "is_callback": 0,
    "dll": "Iphlpapi.dll on Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP;  Icmp.dll on Windows 2000 Server and Windows 2000 Professional",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "IcmpHandle",
        "description": "The open handle returned by the IcmpCreateFile function."
      },
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "DestinationAddress",
        "description": "The IPv4 destination address of the echo request, in the form of an IPAddr structure."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "RequestData",
        "description": "A pointer to a buffer that contains data to send in the request."
      },
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "RequestSize",
        "description": "The size, in bytes, of the request data buffer pointed to by the RequestData parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIP_OPTION_INFORMATION",
        "name": "RequestOptions",
        "description": "A pointer to the IP header options for the request, in the form of an IP_OPTION_INFORMATION structure. On a 64-bit platform, this parameter is in the form for an IP_OPTION_INFORMATION32 structure. This parameter may be NULL if no IP header options need to be specified."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "ReplyBuffer",
        "description": "A buffer to hold any replies to the echo request. Upon return, the buffer contains an array of  ICMP_ECHO_REPLY structures followed by the options and data for the replies. The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY structure plus RequestSize bytes of data. On a 64-bit platform, upon return the buffer contains an array of ICMP_ECHO_REPLY32 structures followed by the options and data for the replies."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ReplySize",
        "description": "The allocated size, in bytes,  of the reply buffer. The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY structure plus RequestSize bytes of data. On a 64-bit platform, The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY32 structure plus RequestSize bytes of data. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message)."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Timeout",
        "description": "The time, in milliseconds, to wait for replies."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The  IcmpSendEcho2 function sends an IPv4 ICMP echo request and returns either immediately (if Event or ApcRoutine is non-NULL) or returns after the specified time-out. The ReplyBuffer contains the ICMP echo responses, if any.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "When called synchronously, the IcmpSendEcho2 function returns the number of replies received and stored in ReplyBuffer. If the return value is zero, call  GetLastError for extended error information. When called asynchronously, the IcmpSendEcho2 function returns ERROR_IO_PENDING to indicate the operation is in progress. The results can be retrieved later when the event specified in the Event parameter signals or the callback function in the ApcRoutine parameter is called. If the return value is zero, call  GetLastError for extended error information. If the function fails, the extended error code returned by GetLastError can be one of the following values.  ",
    "remarks": "The IcmpSendEcho2 function is called synchronously if the ApcRoutine or Event parameters are NULL. When called synchronously, the return value contains the number of replies received and stored in ReplyBuffer after waiting for the time specified in the Timeout parameter. If the return value is zero, call  GetLastError for extended error information. The IcmpSendEcho2 function is called asynchronously when either the ApcRoutine or Event parameters are specified. When called asynchronously,  the ReplyBuffer and ReplySize parameters are  required to accept the response. ICMP response data is copied to the ReplyBuffer provided and the application is signaled (when the Event parameter is specified) or the callback function is called (when the ApcRoutine parameter is specified). The application must parse the data pointed to by ReplyBuffer parameter using the IcmpParseReplies function. If the Event parameter is specified, the IcmpSendEcho2 function is called asynchronously. The event specified in the Event parameter is signaled whenever an ICMP response arrives. Use the  CreateEvent function to create this event object. If the ApcRoutine parameter is specified, the IcmpSendEcho2 function is called asynchronously. The ApcRoutine  parameter should point to a user-defined callback function. The callback function specified in the ApcRoutine parameter is called whenever an ICMP response arrives. The invocation of the callback function specified in the ApcRoutine parameter is serialized. If both the Event and ApcRoutine parameters are specified, the event specified in the Event parameter is signaled whenever an ICMP response arrives, but the callback function specified in the ApcRoutine parameter is ignored . On Windows Vista and later, any application that calls IcmpSendEcho2 function asynchronously using the ApcRoutine parameter must define PIO_APC_ROUTINE_DEFINED to force the datatype for the ApcRoutine parameter to PIO_APC_ROUTINE rather than FARPROC. On Windows Vista and later, the callback function pointed to by the ApcRoutine must be defined as a function of type VOID with the following syntax: On Windows Vista and later, the parameters passed to the callback function include the following:    On Windows Server 2003, Windows XP   , and  Windows 2000, any application that calls the IcmpSendEcho2 function asynchronously using the ApcRoutine parameter must not define PIO_APC_ROUTINE_DEFINED to force the datatype for the ApcRoutine parameter to FARPROC rather than PIO_APC_ROUTINE. On Windows Server 2003 and Windows XP, the callback function pointed to by the ApcRoutine must be defined as a function of type VOID with the following syntax: On Windows Server 2003, Windows XP, and Windows 2000, the parameters passed to the callback function include the following:    The callback function specified in the ApcRoutine parameter must be implemented in the same process as the application calling the IcmpSendEcho2 function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the IcmpSendEcho2 function. The IcmpSendEcho2 function is exported from the Icmp.dll on Windows 2000. The IcmpSendEcho2 function is exported from the Iphlpapi.dll on Windows XP and later. Windows version checking is not recommended to use this function. Applications requiring portability  with this function across Windows 2000, Windows XP, Windows Server 2003 and later Windows versions should not statically link to either the Icmp.lib or the Iphlpapi.lib file. Instead, the application should check for the presence of IcmpSendEcho2 in the Iphlpapi.dll with calls to LoadLibrary and GetProcAddress.  Failing that, the application should check for the presence of IcmpSendEcho2 in the Icmp.dll with  calls to LoadLibrary and GetProcAddress. For IPv6, use the Icmp6CreateFile, Icmp6SendEcho2, and Icmp6ParseReplies functions. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. The following example calls the IcmpSendEcho2 function synchronously. The example sends an ICMP echo request to the IP address specified on the command line and prints the information received from the first response. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "IcmpSendEcho2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll on Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP;  Icmp.dll on Windows 2000 Server and Windows 2000 Professional",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "IcmpHandle",
        "description": "The open handle returned by the ICMPCreateFile function."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "An event to be signaled whenever an ICMP response arrives. If this parameter is specified, it requires a handle to a valid event object. Use the  CreateEvent or CreateEventEx function to create this event object.  For more information on using events, see Event Objects."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "The routine that is called when the calling thread is in an alertable thread and  an ICMPv4 reply arrives. On Windows Vista and later, PIO_APC_ROUTINE_DEFINED must be defined to force the datatype for this parameter to PIO_APC_ROUTINE rather than FARPROC.  On Windows Server 2003, Windows XP   , and Windows 2000,     PIO_APC_ROUTINE_DEFINED must not be defined to force the datatype for this parameter to FARPROC."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "An optional parameter passed to the callback routine specified in the  ApcRoutine parameter whenever an ICMP response arrives or an error occurs."
      },
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "DestinationAddress",
        "description": "The IPv4 destination of the echo request, in the form of an IPAddr structure."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "RequestData",
        "description": "A pointer to a buffer that contains data to send in the request."
      },
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "RequestSize",
        "description": "The size, in bytes, of the request data buffer pointed to by the RequestData parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIP_OPTION_INFORMATION",
        "name": "RequestOptions",
        "description": "A pointer to the IP header options for the request, in the form of an IP_OPTION_INFORMATION structure. On a 64-bit platform, this parameter is in the form for an IP_OPTION_INFORMATION32 structure. This parameter may be NULL if no IP header options need to be specified."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "ReplyBuffer",
        "description": "A pointer to a buffer to hold any replies to the request. Upon return, the buffer contains an array of  ICMP_ECHO_REPLY structures followed by options and data. The buffer must be large enough to hold at least one  ICMP_ECHO_REPLY structure plus RequestSize bytes of data. On a 64-bit platform, upon return the buffer contains an array of ICMP_ECHO_REPLY32 structures followed by the options and data for the replies. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message) plus space for an IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ReplySize",
        "description": "The allocated size, in bytes,  of the reply buffer. The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY structure plus RequestSize bytes of data. On a 64-bit platform, The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY32 structure plus RequestSize bytes of data. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message) plus space for an IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Timeout",
        "description": "The time, in milliseconds, to wait for replies."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The  IcmpSendEcho2Ex function sends an IPv4 ICMP echo request and returns either immediately (if Event or ApcRoutine is non-NULL) or returns after the specified time-out. The ReplyBuffer contains the ICMP responses, if any.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Icmpapi.h",
    "return_value": "When called synchronously, the IcmpSendEcho2Ex function returns the number of replies received and stored in ReplyBuffer. If the return value is zero, call  GetLastError for extended error information. When called asynchronously, the IcmpSendEcho2Ex function returns ERROR_IO_PENDING  to indicate the operation is in progress. The results can be retrieved later when the event specified in the Event parameter signals or the callback function in the ApcRoutine parameter is called. If the return value is zero, call  GetLastError for extended error information. If the function fails, the extended error code returned by GetLastError can be one of the following values.  ",
    "remarks": "The IcmpSendEcho2Ex function is available on Windows Server 2008 and later. The IcmpSendEcho2Ex function is an enhanced version of the IcmpSendEcho2 function that allows the user to specify the IPv4 source address on which to issue the ICMP request. The IcmpSendEcho2Ex function is useful in cases where a computer has multiple network interfaces. The IcmpSendEcho2Ex function is called synchronously if the ApcRoutine or Event parameters are NULL. When called synchronously, the return value contains the number of replies received and stored in ReplyBuffer after waiting for the time specified in the Timeout parameter. If the return value is zero, call  GetLastError for extended error information. The IcmpSendEcho2Ex function is called asynchronously when either the ApcRoutine or Event parameters are specified. When called asynchronously,  the ReplyBuffer and ReplySize parameters are  required to accept the response. ICMP response data is copied to the ReplyBuffer provided and the application is signaled (when the Event parameter is specified) or the callback function is called (when the ApcRoutine parameter is specified). The application must parse the data pointed to by ReplyBuffer parameter using the IcmpParseReplies function. If the Event parameter is specified, the IcmpSendEcho2Ex function is called asynchronously. The event specified in the Event parameter is signaled whenever an ICMP response arrives. Use the  CreateEvent function to create this event object. If the ApcRoutine parameter is specified, the IcmpSendEcho2Ex function is called asynchronously. The ApcRoutine  parameter should point to a user-defined callback function. The callback function specified in the ApcRoutine parameter is called whenever an ICMP response arrives. The invocation of the callback function specified in the ApcRoutine parameter is serialized. If both the Event and ApcRoutine parameters are specified, the event specified in the Event parameter is signaled whenever an ICMP response arrives, but the callback function specified in the ApcRoutine parameter is ignored . Any application that calls the IcmpSendEcho2Ex function asynchronously using the ApcRoutine parameter must define PIO_APC_ROUTINE_DEFINED to force the datatype for the ApcRoutine parameter to PIO_APC_ROUTINE rather than FARPROC. The callback function pointed to by the ApcRoutine must be defined as a function of type VOID with the following syntax: The parameters passed to the callback function include the following:    The callback function specified in the ApcRoutine parameter must be implemented in the same process as the application calling the IcmpSendEcho2Ex function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the IcmpSendEcho2Ex function. For IPv6, use the Icmp6CreateFile, Icmp6SendEcho2, and Icmp6ParseReplies functions. Note that the include directive for Iphlpapi.h header file must be placed before the Icmpapi.h header file. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "IcmpSendEcho2Ex",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "IcmpHandle",
        "description": "An open handle returned by the ICMPCreateFile function."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "Event",
        "description": "An event to be signaled whenever an ICMP response arrives. If this parameter is specified, it requires a handle to a valid event object. Use the  CreateEvent or CreateEventEx function to create this event object.  For more information on using events, see Event Objects."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIO_APC_ROUTINE",
        "name": "ApcRoutine",
        "description": "The routine that is called when the calling thread is in an alertable thread and  an ICMP reply arrives. PIO_APC_ROUTINE_DEFINED must be defined to force the datatype for this parameter to PIO_APC_ROUTINE rather than FARPROC."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "ApcContext",
        "description": "An optional parameter passed to the callback routine specified in the  ApcRoutine parameter whenever an ICMP response arrives or an error occurs."
      },
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "SourceAddress",
        "description": "The IPv4 source address on which to issue the echo request. This address is in the form of an IPAddr structure."
      },
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "DestinationAddress",
        "description": "The IPv4 destination address for the echo request. This address is in the form of an IPAddr structure."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "RequestData",
        "description": "A pointer to a buffer that contains data to send in the request."
      },
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "RequestSize",
        "description": "The size, in bytes, of the request data buffer pointed to by the RequestData parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "PIP_OPTION_INFORMATION",
        "name": "RequestOptions",
        "description": "A pointer to the IP header options for the request, in the form of an IP_OPTION_INFORMATION structure. On a 64-bit platform, this parameter is in the form for an IP_OPTION_INFORMATION32 structure. This parameter may be NULL if no IP header options need to be specified."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "ReplyBuffer",
        "description": "A pointer to a buffer to hold any replies to the request. Upon return, the buffer contains an array of  ICMP_ECHO_REPLY structures followed by options and data. The buffer must be large enough to hold at least one  ICMP_ECHO_REPLY structure plus RequestSize bytes of data. On a 64-bit platform, upon return the buffer contains an array of ICMP_ECHO_REPLY32 structures followed by the options and data for the replies. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message) plus space for an IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ReplySize",
        "description": "The allocated size, in bytes,  of the reply buffer. The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY structure plus RequestSize bytes of data. On a 64-bit platform, The buffer should be large enough to hold at least one  ICMP_ECHO_REPLY32 structure plus RequestSize bytes of data. This buffer should also be large enough to also hold 8 more bytes of data (the size of an ICMP error message) plus space for an IO_STATUS_BLOCK structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Timeout",
        "description": "The time, in milliseconds, to wait for replies."
      }
    ],
    "min_client": "Windows Vista with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpTTL function sets the default time-to-live (TTL) value for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The default TTL can also be set using the  SetIpStatistics function. On Windows Vista and later, the SetIpTTL function can only be called by a user logged on as a member of the Administrators group. If SetIpTTL is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIpStatistics function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetIpTTL",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nTTL",
        "description": "The new TTL value for the local computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  AddIPAddress function adds the specified IPv4 address to the specified adapter.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The AddIPAddress function is used to add a new IPv4 address entry on a local computer. The IPv4 address added by  the AddIPAddress function is not persistent. The IPv4 address exists only as long as the adapter object exists. Restarting the computer destroys the IPv4 address, as does manually resetting the network interface card (NIC). Also, certain PnP events may destroy the address. To create an IPv4 address that persists, the EnableStatic method of the Win32_NetworkAdapterConfiguration Class in the Windows Management Instrumentation (WMI) controls may be used. The netsh commands can also be used to create a persistent IPv4 address.   For more information, please see the documentation on Netsh.exe in the Windows Sockets documentation. On  Windows Server 2003, Windows XP, and Windows 2000, if the IPv4 address in the Address parameter already exists on the network, the AddIPAddress function returns NO_ERROR and  the IPv4 address added is 0.0.0.0. On  Windows Vista and later, if the IPv4 address passed in the Address parameter already exists on the network, the AddIPAddress function returns NO_ERROR and  the duplicate IPv4 address is added with the IP_DAD_STATE member in  the IP_ADAPTER_UNICAST_ADDRESS structure set to IpDadStateDuplicate. An IPv4 address that is added using the AddIPAddress function can later be deleted by calling the DeleteIPAddress function  passing the  NTEContext parameter returned by the AddIPAddress function. For information about the IPAddr and IPMask data types, see  Windows Data Types. To convert an IPv4 address between dotted decimal notation and IPAddr format, use the  inet_addr and  inet_ntoa functions. On Windows Vista and later, the CreateUnicastIpAddressEntry function can be used to add a new unicast IPv4 or IPv6 address entry on a local computer. The following example retrieves the IP address table to determine the interface index for the first adapter, then adds the IP address specified on command line to the first adapter. The IP address that was added is then deleted. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "AddIPAddress",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "Address",
        "description": "The IPv4 address to add to the adapter, in the form of an IPAddr structure."
      },
      {
        "in_out": "_In_",
        "type": "IPMask",
        "name": "IpMask",
        "description": "The subnet mask for the IPv4 address specified in the Address parameter.   The IPMask parameter uses the same format as an IPAddr structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "IfIndex",
        "description": "The index of the adapter on which to add the IPv4 address."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "NTEContext",
        "description": "A pointer to a ULONG variable. On successful return, this parameter points to the Net Table Entry (NTE) context for the IPv4 address that was added. The caller can later use this context in a call to  the DeleteIPAddress function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "NTEInstance",
        "description": "A pointer to a ULONG variable. On successful return, this parameter points to the NTE instance for the IPv4 address that was added."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  CreateAnycastIpAddressEntry function  adds a new anycast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreateAnycastIpAddressEntry function is defined on Windows Vista and later. The CreateAnycastIpAddressEntry function is used to add a new anycast IP address entry on a local computer. The Address member in the MIB_ANYCASTIPADDRESS_ROW structure pointed to by the Row parameter must be initialized to a valid unicast IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_ANYCASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the unicast IP address. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. The ScopeId member of the MIB_ANYCASTIPADDRESS_ROW structure pointed to by the Row is ignored when the  CreateAnycastIpAddressEntry function is called. The  ScopeId member is automatically determined by the interface on which the address is added. The CreateAnycastIpAddressEntry function will fail if the anycast IP address passed in the Address member of the MIB_ANYCASTIPADDRESS_ROW pointed to by the Row parameter is a duplicate of an existing anycast IP address on the interface. The CreateAnycastIpAddressEntry function can only be called by a user logged on as a member of the Administrators group. If CreateAnycastIpAddressEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "CreateAnycastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_ANYCASTIPADDRESS_ROW*",
        "name": "Row",
        "description": "A pointer to a  MIB_ANYCASTIPADDRESS_ROW structure entry for an anycast IP address entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  CreateUnicastIpAddressEntry function  adds a new unicast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreateUnicastIpAddressEntry function is defined on Windows Vista and later. The CreateUnicastIpAddressEntry function is used to add a new unicast IP address entry on a local computer. The unicast IP address added by  the CreateUnicastIpAddressEntry function is not persistent. The IP address exists only as long as the adapter object exists. Restarting the computer destroys the IP address, as does manually resetting the network interface card (NIC). Also, certain PnP events may destroy the address. To create an IPv4 address that persists, the EnableStatic method of the Win32_NetworkAdapterConfiguration Class in the Windows Management Instrumentation (WMI) controls may be used. The netsh command can also be used to create a persistent IPv4 or IPv6 address.   For more information, please see the documentation on Netsh.exe in the Windows Sockets documentation. The InitializeUnicastIpAddressEntry function should be used to initialize the members of a     MIB_UNICASTIPADDRESS_ROW structure entry with default values.  An application can then change the     members in the MIB_UNICASTIPADDRESS_ROW entry it wishes to modify, and then call the CreateUnicastIpAddressEntry function. The Address member in the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row parameter must be initialized to a valid unicast IPv4 or IPv6 address. The si_family member of the SOCKADDR_INET structure  in the  Address member must be initialized to either AF_INET or AF_INET6 and the related Ipv4 or Ipv6 member of the  SOCKADDR_INET structure must be set to a valid unicast IP address. In addition, at least one of the following members in the MIB_UNICASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the unicast IP address. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. If the OnLinkPrefixLength member of the MIB_UNICASTIPADDRESS_ROW pointed to by the Row parameter is set to 255, then CreateUnicastIpAddressEntry will add the new unicast IP address with the  OnLinkPrefixLength member set equal to the length of the IP address. So for a unicast IPv4 address, the  OnLinkPrefixLength is set to 32 and the OnLinkPrefixLength is set to 128 for a unicast IPv6 address. If this would result in the incorrect subnet mask for an IPv4 address or the incorrect link prefix for an IPv6 address, then the application should set this member to the correct value before calling CreateUnicastIpAddressEntry. If a unicast IP address is created with the OnLinkPrefixLength member set incorrectly, then the IP address may be changed by calling SetUnicastIpAddressEntry with the  OnLinkPrefixLength member set to the correct value. The DadState, ScopeId, and CreationTimeStamp members of the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row are ignored when the  CreateUnicastIpAddressEntry function is called. These members are set by the network stack. The  ScopeId member is automatically determined by the interface on which the address is added. Beginning in Windows 10, if DadState is set to IpDadStatePreferred in the MIB_UNICASTIPADDRESS_ROW structure when calling CreateUnicastIpAddressEntry, the stack will set the initial DAD state of the address to \u00e2\u0080\u009cpreferred\u00e2\u0080\u009d instead of \u00e2\u0080\u009ctentative\u00e2\u0080\u009d and will do optimistic DAD for the address. The CreateUnicastIpAddressEntry function will fail if the unicast IP address passed in the Address member of the MIB_UNICASTIPADDRESS_ROW pointed to by the Row parameter is a duplicate of an existing unicast IP address on the interface. Note that a loopback IP address can only be added to a loopback interface using the CreateUnicastIpAddressEntry function. The unicast IP address passed in the Address member of the MIB_UNICASTIPADDRESS_ROW pointed to by the Row parameter is not usable immediately. The IP address is usable after the duplicate address detection process has completed successfully. It can take several seconds for the duplicate address detection process to complete since IP packets need to  be sent and potential responses must be awaited. For IPv6, the duplicate address detection process typically takes about a second. For IPv4, the duplicate address detection process typically takes about three seconds. If an application that needs to know when an IP address is usable after a call to  the CreateUnicastIpAddressEntry function, there are two methods that can be used. One method uses polling and the GetUnicastIpAddressEntry function. The second method calls one of the notification functions, NotifyAddrChange, NotifyIpInterfaceChange, or NotifyUnicastIpAddressChange to set up an asynchronous notification for when an address changes. The following method describes how to use the GetUnicastIpAddressEntry and polling. After the call to the CreateUnicastIpAddressEntry function returns successfully, pause for one to three seconds (depending on whether an IPv6 or IPv4 address is being created) to allow time for the successful completion of the duplication address detection process. Then call the GetUnicastIpAddressEntry function to retrieve the updated MIB_UNICASTIPADDRESS_ROW structure and examine the value of the DadState member. If the value of the DadState member is set to IpDadStatePreferred, the IP address is now usable.  If the value of the DadState member is set to IpDadStateTentative, then duplicate address detection has not yet completed. In this case, call the GetUnicastIpAddressEntry function again every half a second while the DadState member is still set to IpDadStateTentative. If the value of the DadState member returns with some value other than IpDadStatePreferred or IpDadStateTentative, duplicate address detection has failed and the IP address is not usable. The following method describes how to use an appropriate notification function. After the call to the CreateUnicastIpAddressEntry function returns successfully, call the NotifyUnicastIpAddressChange function to register to be notified of changes to either IPv6 or IPv4 unicast IP addresses, depending on the type of IP address being created. When a notification is received for the IP address being created, call the GetUnicastIpAddressEntry function to retrieve the DadState member.  If the value of the DadState member is set to IpDadStatePreferred, the IP address is now usable.  If the value of the DadState member is set to IpDadStateTentative, then duplicate address detection has not yet completed and the application needs to wait for future notifications. If the value of the DadState member returns with some value other than IpDadStatePreferred or IpDadStateTentative, duplicate address detection has failed and the IP address is not usable. If during the duplicate address detection process the media is disconnected and then reconnected, the duplicate address detection process is restarted. So it is possible for the time to complete the process to increase beyond the typical 1 second value for IPv6 or 3 second value for IPv4. The CreateUnicastIpAddressEntry function can only be called by a user logged on as a member of the Administrators group. If CreateUnicastIpAddressEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following example demonstrates how to use the CreateUnicastIpAddressEntry function to add a new unicast IP address entry on the local computer. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "CreateUnicastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_UNICASTIPADDRESS_ROW*",
        "name": "Row",
        "description": "A pointer to a  MIB_UNICASTIPADDRESS_ROW structure entry for a unicast IP address entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteIPAddress function deletes an IP address previously added using  AddIPAddress.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "On Windows Vista and later, the DeleteIPAddress function can only be called by a user logged on as a member of the Administrators group. If DeleteIPAddress is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following example retrieves the IP address table, then adds the IP address 192.168.0.27 to the first adapter. The IP address that was added is then deleted. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "DeleteIPAddress",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NTEContext",
        "description": "The Net Table Entry (NTE) context for the IP address. This context was returned by the previous call to  AddIPAddress."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteAnycastIpAddressEntry function   deletes an existing anycast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The DeleteAnycastIpAddressEntry function is defined on Windows Vista and later. The DeleteAnycastIpAddressEntry function is used to delete an existing MIB_ANYCASTIPADDRESS_ROW structure entry on the local computer. On input, the Address member in the MIB_ANYCASTIPADDRESS_ROW structure pointed to by the Row parameter must be set to a valid unicast IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_ANYCASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. If the function is successful, the existing IP address represented by the Row parameter was deleted. The GetAnycastIpAddressTable function can be called to enumerate the anycast IP address entries on a local computer. The GetAnycastIpAddressEntry function can be called to retrieve a specific existing anycast IP address entry. The DeleteAnycastIpAddressEntry function can only be called by a user logged on as a member of the Administrators group. If DeleteAnycastIpAddressEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "DeleteAnycastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_ANYCASTIPADDRESS_ROW*",
        "name": "Row",
        "description": "A pointer to a  MIB_ANYCASTIPADDRESS_ROW  structure entry for an existing anycast IP address entry to delete from the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteUnicastIpAddressEntry function   deletes an existing unicast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The DeleteUnicastIpAddressEntry function is defined on Windows Vista and later. The DeleteUnicastIpAddressEntry function is used to delete an existing MIB_UNICASTIPADDRESS_ROW structure entry on the local computer. On input, the Address member in the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row parameter must be set to a valid unicast IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_UNICASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. If the function is successful, the existing IP address represented by the Row parameter was deleted. The GetUnicastIpAddressTable function can be called to enumerate the unicast IP address entries on a local computer. The GetUnicastIpAddressEntry function can be called to retrieve a specific existing unicast IP address entry. The DeleteUnicastIpAddressEntry function can only be called by a user logged on as a member of the Administrators group. If DeleteUnicastIpAddressEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "DeleteUnicastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_UNICASTIPADDRESS_ROW*",
        "name": "Row",
        "description": "A pointer to a  MIB_UNICASTIPADDRESS_ROW structure entry for an existing unicast IP address entry to delete from the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetAnycastIpAddressEntry function  retrieves information for an existing anycast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetAnycastIpAddressEntry function is defined on Windows Vista and later. The GetAnycastIpAddressEntry function is used to retrieve an existing MIB_ANYCASTIPADDRESS_ROW structure entry. On input, the Address member in the MIB_ANYCASTIPADDRESS_ROW structure pointed to by the Row parameter must be initialized to a valid anycast IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_ANYCASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value is set for the  InterfaceLuid member (the value of this member is set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetAnycastIpAddressEntry retrieves the other properties for the anycast IP address and fills out the MIB_ANYCASTIPADDRESS_ROW structure pointed to by the Row parameter. The GetAnycastIpAddressTable function can be called to enumerate the anycast IP address entries on a local computer. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetAnycastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_ANYCASTIPADDRESS_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_ANYCASTIPADDRESS_ROW structure entry for an anycast IP address entry. On successful return, this structure will be updated with the properties for an existing anycast IP address."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetAnycastIpAddressTable function  retrieves the anycast IP address table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetAnycastIpAddressTable function is defined on Windows Vista and later. The   GetAnycastIpAddressTable function enumerates the anycast IP addresses on a local system and returns this information in a MIB_ANYCASTIPADDRESS_TABLE structure. The anycast IP address entries are returned in a MIB_ANYCASTIPADDRESS_TABLE structure in the buffer pointed to by the Table parameter. The MIB_ANYCASTIPADDRESS_TABLE structure contains an anycast IP address entry count and an array of MIB_ANYCASTIPADDRESS_ROW structures for each anycast IP address entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. Note that the returned MIB_ANYCASTIPADDRESS_TABLE structure pointed to by the Table parameter may contain padding  for alignment between the NumEntries member and the first MIB_ANYCASTIPADDRESS_ROW array entry in the Table member of the MIB_ANYCASTIPADDRESS_TABLE structure. Padding for alignment may also be present between the MIB_ANYCASTIPADDRESS_ROW array entries. Any access to a MIB_ANYCASTIPADDRESS_ROW array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetAnycastIpAddressTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  returns the anycast IP address table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns the anycast IP address table containing only  IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns the anycast IP address table containing only IPv6 entries."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_ANYCASTIPADDRESS_TABLE*",
        "name": "Table",
        "description": "A pointer to a  MIB_ANYCASTIPADDRESS_TABLE structure that contains a table of anycast IP address entries on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetIpAddrTable function retrieves the interface\u00e2\u0080\u0093to\u00e2\u0080\u0093IPv4 address mapping table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpAddrTable function retrieves the interface\u00e2\u0080\u0093to\u00e2\u0080\u0093IPv4 address mapping table on a local computer and returns this information in an MIB_IPADDRTABLE structure. The IPv4 addresses returned by the GetIpAddrTable function are affected by the status of the network interfaces on a local computer. Manually resetting a network interface card (NIC) and certain PnP events may result in an IP address being removed or changed. On Windows Server 2003 and Windows XP, the IPv4 addresses returned by the GetIpAddrTable function are also affected if the media sensing capability of the TCP/IP stack on a local computer has been disabled by calling the DisableMediaSense function. When media sensing has been disabled, the GetIpAddrTable function may return IPv4 addresses associated with disconnected interfaces. These Ipv4 addresses for disconnected interfaces are not valid for use. On Windows Server 2008 and Windows Vista, the IPv4 addresses returned by the GetIpAddrTable function are not affected by the media sensing capability of the TCP/IP stack on a local computer. The GetIpAddrTable function returns only valid IPv4 addresses. The GetAdaptersAddresses function available on Windows XP can be used to retrieve both IPv6 and IPv4 addresses and interface information. The MIB_IPADDRTABLE structure returned by the GetIpAddrTable function may contain padding for alignment between the dwNumEntries member and the first MIB_IPADDRROW array entry in the table member. Padding for alignment may also be present between the MIB_IPADDRROW array entries in the table member. Any access to a MIB_IPADDRROW array entry should assume  padding may exist. On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files has changed and the MIB_IPADDRROW is defined in the Ipmib.h header file not in the Iprtrmib.h header file. Note that the Ipmib.h header file is automatically included in Iprtrmib.h which is automatically included in the Iphlpapi.h header file. The Ipmib.h and Iprtrmib.h header files should never be used directly. The following example retrieves the IP address table, then prints some members of the IP address entries in the table. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIpAddrTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IPADDRTABLE",
        "name": "pIpAddrTable",
        "description": "A pointer to a buffer that receives the interface\u2013to\u2013IPv4 address mapping table as a  MIB_IPADDRTABLE structure. ..."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "pdwSize",
        "description": "On input, specifies the size in bytes  of the buffer pointed to by the pIpAddrTable parameter.     On output, if the buffer is not large enough to hold the returned mapping table, the function sets this parameter equal to the required buffer size in bytes."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A Boolean value that specifies whether the returned mapping table should be sorted in ascending order by IPv4 address. If this parameter is TRUE, the table is sorted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetMulticastIpAddressEntry function  retrieves information for an existing multicast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetMulticastIpAddressEntry function is defined on Windows Vista and later. The GetMulticastIpAddressEntry function is used to retrieve an existing MIB_MULTICASTIPADDRESS_ROW structure entry. On input, the Address member in the MIB_MULTICASTIPADDRESS_ROW structure pointed to by the Row parameter must be initialized to a valid multicast IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_MULTICASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value is set for the  InterfaceLuid member (the value of this member is set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetMulticastIpAddressEntry retrieves the other properties for the multicast IP address and fills out the MIB_MULTICASTIPADDRESS_ROW structure pointed to by the Row parameter. The GetMulticastIpAddressTable function can be called to enumerate the multicast IP address entries on a local computer. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetMulticastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_MULTICASTIPADDRESS_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_MULTICASTIPADDRESS_ROW structure entry for a multicast IP address entry. On successful return, this structure will be updated with the properties for an existing multicast IP address."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetMulticastIpAddressTable function  retrieves the multicast IP address table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetMulticastIpAddressTable function is defined on Windows Vista and later. The   GetMulticastIpAddressTable function enumerates the multicast IP addresses on a local system and returns this information in a MIB_MULTICASTIPADDRESS_TABLE structure. The multicast IP address entries are returned in a MIB_MULTICASTIPADDRESS_TABLE structure in the buffer pointed to by the Table parameter. The MIB_MULTICASTIPADDRESS_TABLE structure contains a multicast IP address entry count and an array of MIB_MULTICASTIPADDRESS_ROW structures for each multicast IP address entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. Note that the returned MIB_MULTICASTIPADDRESS_TABLE structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_MULTICASTIPADDRESS_ROW array entry in the Table member of the MIB_MULTICASTIPADDRESS_TABLE structure. Padding for alignment may also be present between the MIB_MULTICASTIPADDRESS_ROW array entries. Any access to a MIB_MULTICASTIPADDRESS_ROW array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetMulticastIpAddressTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  returns the multicast IP address table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns the multicast IP address table containing only IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns the multicast IP address table containing only IPv6 entries."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_MULTICASTIPADDRESS_TABLE*",
        "name": "Table",
        "description": "A pointer to a  MIB_MULTICASTIPADDRESS_TABLE structure that contains a table of anycast IP address entries on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetUnicastIpAddressEntry function  retrieves information for an existing unicast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetUnicastIpAddressEntry function is defined on Windows Vista and later. The GetUnicastIpAddressEntry function is normally used to retrieve an existing MIB_UNICASTIPADDRESS_ROW structure entry to be modified.  An application can then change the     members in the MIB_UNICASTIPADDRESS_ROW entry it wishes to modify, and then call the SetUnicastIpAddressEntry function. On input, the Address member in the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row parameter must be initialized to a valid unicast IPv4 or IPv6 address. The si_family member of the SOCKADDR_INET structure  in the  Address member must be initialized to either AF_INET or AF_INET6 and the related Ipv4 or Ipv6 member of the  SOCKADDR_INET structure must be set to a valid unicast IP address. In addition, at least one of the following members in the MIB_UNICASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value is set for the  InterfaceLuid member (the value of this member is set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetUnicastIpAddressEntry retrieves the other properties for the unicast IP address and fills out the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row parameter. The GetUnicastIpAddressTable function can be called to enumerate the unicast IP address entries on a local computer. The following example retrieves a unicast IP address entry specified on the command line and prints some values from the retrieved MIB_UNICASTIPADDRESS_ROW structure. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetUnicastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_UNICASTIPADDRESS_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_UNICASTIPADDRESS_ROW structure entry for a unicast IP address entry. On successful return, this structure will be updated with the properties for an existing unicast IP address."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetUnicastIpAddressTable function  retrieves the unicast IP address table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetUnicastIpAddressTable function is defined on Windows Vista and later. The   GetUnicastIpAddressTable function enumerates the unicast IP addresses on a local system and returns this information in an MIB_UNICASTIPADDRESS_TABLE structure. The unicast IP address entries are returned in a MIB_UNICASTIPADDRESS_TABLE structure in the buffer pointed to by the Table parameter. The MIB_UNICASTIPADDRESS_TABLE structure contains a unicast IP address entry count and an array of MIB_UNICASTIPADDRESS_ROW structures for each unicast IP address entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. Note that the returned MIB_UNICASTIPADDRESS_TABLE structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_UNICASTIPADDRESS_ROW array entry in the Table member of the MIB_UNICASTIPADDRESS_TABLE structure. Padding for alignment may also be present between the MIB_UNICASTIPADDRESS_ROW array entries. Any access to a MIB_UNICASTIPADDRESS_ROW array entry should assume  padding may exist. The following example retrieves a unicast IP address table and prints some values from each of the retrieved MIB_UNICASTIPADDRESS_ROW structures. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetUnicastIpAddressTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function returns the unicast IP address table containing both IPv4 and IPv6 entries.   AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function returns the unicast IP address table containing only IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function returns the unicast IP address table containing only IPv6 entries."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_UNICASTIPADDRESS_TABLE*",
        "name": "Table",
        "description": "A pointer to a  MIB_UNICASTIPADDRESS_TABLE structure that contains a table of unicast IP address entries on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  InitializeUnicastIpAddressEntry function  initializes a MIB_UNICASTIPADDRESS_ROW structure with default values for a unicast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The InitializeUnicastIpAddressEntry function is defined on Windows Vista and later. The InitializeUnicastIpAddressEntry function must be used to initialize the members of a     MIB_UNICASTIPADDRESS_ROW structure entry with default values for a unicast IP address for later use with the CreateUnicastIpAddressEntry function. On input, InitializeUnicastIpAddressEntry must be passed a new MIB_UNICASTIPADDRESS_ROW structure to initialize. On output, the PrefixOrigin member of the MIB_UNICASTIPADDRESS_ROW structure pointed to by Row parameter the will be initialized to IpPrefixOriginUnchanged, the SuffixOrigin member will be initialized to IpSuffixOriginUnchanged, and the  OnLinkPrefixLength member will be initialized to an illegal value. In addition, the PreferredLifetime and ValidLifetime members are set to infinite, the SkipAsSource member is set to FALSE, and other fields are initialized to zero. After calling InitializeUnicastIpAddressEntry, an application can then change the     members in the MIB_UNICASTIPADDRESS_ROW entry it wishes to modify, and then call the CreateUnicastIpAddressEntry  to add the new unicast IP address to the local computer. ",
    "return_type": "VOID NETIOAPI",
    "category": "IP Helper",
    "name": "InitializeUnicastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_UNICASTIPADDRESS_ROW",
        "name": "Row",
        "description": "On entry, a pointer to a  MIB_UNICASTIPADDRESS_ROW structure entry for a unicast IP address entry. On return, the  MIB_UNICASTIPADDRESS_ROW structure pointed to by this parameter is initialized with default values for a unicast IP address."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  IpReleaseAddress function releases an IPv4 address previously obtained through the Dynamic Host Configuration Protocol (DHCP).",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error.  ",
    "remarks": "The  IpReleaseAddress function is specific to IPv4 and releases only an IPv4 address previously obtained through the Dynamic Host Configuration Protocol (DHCP). The Name member of the IP_ADAPTER_INDEX_MAP structure pointed to by the AdapterInfo parameter is the only member used to determine the DHCP address to release. An array of IP_ADAPTER_INDEX_MAP structures is returned in the IP_INTERFACE_INFO structure by the GetInterfaceInfo function.  The IP_INTERFACE_INFO structure returned by GetInterfaceInfo contains at least one IP_ADAPTER_INDEX_MAP structure even if the NumAdapters member of the IP_INTERFACE_INFO structure indicates that no network adapters with IPv4 are enabled. When the NumAdapters member of the IP_INTERFACE_INFO structure returned by GetInterfaceInfo is zero, the value of the members of the single  IP_ADAPTER_INDEX_MAP structure returned in the IP_INTERFACE_INFO structure is undefined. If the Name member of the IP_ADAPTER_INDEX_MAP structure pointed to by the AdapterInfo parameter is NULL, the  IpReleaseAddress function returns ERROR_INVALID_PARAMETER. There are no functions available for releasing or renewing an IPv6 address. This can only be done by executing the Ipconfig command: ipconfig /release6 ipconfig /renew6 The following example retrieves the list of network adapters with IPv4 enabled on the local system, then releases and renews the IPv4 address for the first adapter in the list. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "IpReleaseAddress",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIP_ADAPTER_INDEX_MAP",
        "name": "AdapterInfo",
        "description": "A pointer to an  IP_ADAPTER_INDEX_MAP structure that specifies the adapter associated with the IPv4 address to release."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  IpRenewAddress \t\t\t function renews a lease on an IPv4 address previously obtained through Dynamic Host Configuration Protocol (DHCP).",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error.  ",
    "remarks": "The  IpRenewAddress \t\t\t function is specific to IPv4 and renews only an IPv4 address previously obtained through the Dynamic Host Configuration Protocol (DHCP). The Name member of the IP_ADAPTER_INDEX_MAP structure pointed to by the AdapterInfo parameter is the only member used to determine the DHCP address to renew. An array of  IP_ADAPTER_INDEX_MAP structures are returned in the IP_INTERFACE_INFO structure by the GetInterfaceInfo function.  The IP_INTERFACE_INFO structure returned by GetInterfaceInfo contains at least one IP_ADAPTER_INDEX_MAP structure even if the NumAdapters member of the IP_INTERFACE_INFO structure indicates that no network adapters with IPv4 are enabled. When the NumAdapters member of the IP_INTERFACE_INFO structure returned by GetInterfaceInfo is zero, the value of the members of the single  IP_ADAPTER_INDEX_MAP structure returned in the IP_INTERFACE_INFO structure is undefined. If the Name member of the IP_ADAPTER_INDEX_MAP structure pointed to by the AdapterInfo parameter is NULL, the  IpRenewAddress function returns ERROR_INVALID_PARAMETER. There are no functions available for releasing or renewing an IPv6 address. This can only be done by executing the Ipconfig command: ipconfig /release6 ipconfig /renew6 The following example retrieves the list of network adapters with IPv4 enabled on the local system, then releases and renews the IPv4 address for the first adapter in the list. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "IpRenewAddress",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PIP_ADAPTER_INDEX_MAP",
        "name": "AdapterInfo",
        "description": "A pointer to an  IP_ADAPTER_INDEX_MAP structure that specifies the adapter associated with the IP address to renew."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  NotifyStableUnicastIpAddressTable function  retrieves the stable unicast IP address table on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds immediately, the return value is NO_ERROR and the stable unicast IP table is returned in the Table parameter. If the I/O request is pending, the function returns ERROR_IO_PENDING and the function pointed to by the CallerCallback parameter is called when the I/O request has completed with the stable unicast IP address table. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The NotifyStableUnicastIpAddressTable function is defined on Windows Vista and later. If the NotifyStableUnicastIpAddressTable function succeeds immediately, the return value is NO_ERROR and the stable unicast IP table is returned in the Table parameter.  The calling application should free the memory pointed to by the Table parameter using the FreeMibTable function when the MIB_UNICASTIPADDRESS_TABLE information is no longer needed. All unicast IP addresses except dial-on-demand addresses are considered stable only if they are in the preferred state.  For a normal unicast IP address entry, this would correspond to a DadState member of the MIB_UNICASTIPADDRESS_ROW for the IP address set to IpDadStatePreferred.  Every dial-on-demand address defines its own stability metric.  Currently the only dial-on-demand address considered by this function is the unicast IP address used by the Teredo client on the local computer. The Family parameter must be set to either AF_INET, AF_INET6, or AF_UNSPEC. When NotifyStableUnicastIpAddressTable is successful and returns NO_ERROR, the Table parameter returns the stable unicast IP address table on the local computer. When NotifyStableUnicastIpAddressTable returns ERROR_IO_PENDING indicating that the I/O request is pending, then the  stable unicast IP address table is returned to the function in the CallerCallback  parameter. The NotifyStableUnicastIpAddressTable function is used primarily by applications that use the Teredo client. If the unicast IP address used by Teredo is available on the local computer but not in the stable (qualified) state, NotifyStableUnicastIpAddressTable returns ERROR_IO_PENDING and the stable unicast IP address table is eventually returned by  calling the function in the CallerCallback  parameter.  If the Teredo address is not available or is in the stable state and the other unicast IP addresses are in a stable state, then the function  in the CallerCallback  parameter will never be invoked. The callback function specified in the CallerCallback parameter should be defined as a function of type VOID. The parameters passed to the callback function include the following:   The callback function specified in the CallerCallback parameter must be implemented in the same process as the application calling the NotifyStableUnicastIpAddressTable function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the NotifyStableUnicastIpAddressTable function to register for change notifications. The memory pointed to by the AddressTable parameter used in a callback indication is alocated by the operating system. An application that receives a notification should free the memory pointed to by the AddressTable parameter using the FreeMibTable function when the MIB_UNICASTIPADDRESS_TABLE information is no longer needed. Once the NotifyStableUnicastIpAddressTable function is called to register for change notifications, these notifications will continue to be sent until the application deregisters for change notifications or the application terminates. If the application terminates, the system will automatically deregister any registration for change notifications. It is still recommended that an application explicitly deregister any change notifications before it terminates. Any registration for change notifications does not persist if the system is shutdown or rebooted. To deregister for change notifications, call the  CancelMibChangeNotify2 function passing the NotificationHandle parameter returned by  NotifyStableUnicastIpAddressTable. An application cannot make a call to the CancelMibChangeNotify2 function from the context of the thread which is currently executing the notification callback function for the same NotificationHandle parameter. Otherwise, the thread executing that callback will result in deadlock. So the CancelMibChangeNotify2 function must not be called directly as part of the notification callback routine. In a more general situation, a thread that executes the CancelMibChangeNotify2 function cannot own a resource on which the thread that executes a notification callback operation would wait because it would result in a similar deadlock. The CancelMibChangeNotify2 function should be called from a different thread, on which the thread that receives the notification callback doesn't have dependencies on. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "NotifyStableUnicastIpAddressTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  the function  retrieves the stable unicast IP address table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  the function retrieves the stable unicast IP address table containing only IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  the function retrieves the stable unicast IP address table containing only IPv6 entries."
      },
      {
        "in_out": "_Inout_",
        "type": "PMIB_UNICASTIPADDRESS_TABLE*",
        "name": "Table",
        "description": "A pointer to a  MIB_UNICASTIPADDRESS_TABLE structure. When NotifyStableUnicastIpAddressTable is successful, this parameter returns the stable unicast IP address table on the local computer.   When NotifyStableUnicastIpAddressTable returns ERROR_IO_PENDING indicating that the I/O request is pending, then the  stable unicast IP address table is returned to the function in the CallerCallback  parameter."
      },
      {
        "in_out": "_In_",
        "type": "PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK",
        "name": "CallerCallback",
        "description": "A pointer to the function to call with the stable unicast IP address table. This function will be invoked         if NotifyStableUnicastIpAddressTable returns ERROR_IO_PENDING, indicating that the I/O request is pending."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CallerContext",
        "description": "A user context passed to the callback function specified in the CallerCallback parameter when the stable unicast IP address table si available."
      },
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "NotificationHandle",
        "description": "A pointer used to return a handle that can be used to         cancel the request to retrieve the stable unicast IP address table. This parameter is returned if  the return value from NotifyStableUnicastIpAddressTable is ERROR_IO_PENDING indicating that the I/O request is pending."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetUnicastIpAddressEntry function  sets the properties of  an existing unicast IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetUnicastIpAddressEntry function is defined on Windows Vista and later. The GetUnicastIpAddressEntry function is normally used to retrieve an existing MIB_UNICASTIPADDRESS_ROW structure entry to be modified.  An application can then change the     members in the MIB_UNICASTIPADDRESS_ROW entry it wishes to modify, and then call the SetUnicastIpAddressEntry function. An application may call the InitializeUnicastIpAddressEntry function to initialize the members of a     MIB_UNICASTIPADDRESS_ROW structure entry with default values before making changes. However, the application would normally save either the InterfaceLuid or InterfaceIndex member before calling InitializeUnicastIpAddressEntry and restore one of these members after the call. The Address member in the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row parameter must be initialized to a valid unicast IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_UNICASTIPADDRESS_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. If the OnLinkPrefixLength member of the MIB_UNICASTIPADDRESS_ROW pointed to by the Row parameter is set to 255, then SetUnicastIpAddressEntry will set the unicast IP address properties so that the OnLinkPrefixLength member is equal to the length of the IP address. So for a unicast IPv4 address, the  OnLinkPrefixLength is set to 32 and the OnLinkPrefixLength is set to 128 for a unicast IPv6 address. If this would result in the incorrect subnet mask for an IPv4 address or the incorrect link prefix for an IPv6 address, then the application should set this member to the correct value before calling SetUnicastIpAddressEntry. The DadState, ScopeId, and CreationTimeStamp members of the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row are ignored when the  SetUnicastIpAddressEntry  function is called. These members are set by the network stack and cannot be changed using the SetUnicastIpAddressEntry  function. The  ScopeId member is automatically determined by the interface on which the address was added. The SetUnicastIpAddressEntry function can only be called by a user logged on as a member of the Administrators group. If SetUnicastIpAddressEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetUnicastIpAddressEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "SetUnicastIpAddressEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_UNICASTIPADDRESS_ROW*",
        "name": "Row",
        "description": "A pointer to a  MIB_UNICASTIPADDRESS_ROW structure entry for an existing unicast IP address entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  RtlIpv4AddressToString function  converts an IPv4 address to a string in Internet standard dotted-decimal format.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "A pointer to the NULL character inserted at the end of the string representation of the IPv4 address. This can be used by the caller to easily append more information to the string. ",
    "remarks": "The RtlIpv4AddressToString function is used to convert an IPv4 address to the string representation of the IPv4 address in Internet dotted-decimal format. RtlIpv4AddressToString is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. When either UNICODE or _UNICODE is defined, RtlIpv4AddressToString is defined to RtlIpv4AddressToStringW, the Unicode version of this function. The string parameter S and the function return value are defined to the PWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv4AddressToString is defined to RtlIpv4AddressToStringA, the ANSI version of this function. The string parameter S and the function return value are defined to the PSTR data type. The IN_ADDR structure is defined in the Inaddr.h header file. An import library containing the RtlIpv4AddressToString function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv4AddressToString function  is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "PTSTR NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv4AddressToString",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const IN_ADDR*",
        "name": "Addr",
        "description": "The IPv4 address in network byte order."
      },
      {
        "in_out": "_Out_",
        "type": "PTSTR",
        "name": "S",
        "description": "A pointer to a buffer in which to store the NULL-terminated string representation of the IPv4 address. This buffer should be large enough to hold at least 16 characters."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  RtlIpv4AddressToStringEx function  converts an IPv4 address and port number to a string in Internet standard format.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The RtlIpv4AddressToStringEx function is used to convert an IPv4 address and port number to the string representation of the IPv4 address in Internet dotted-decimal format followed by a colon character and a string representation of the port. RtlIpv4AddressToStringEx is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. If the length of the buffer pointed to by the AddressString parameter is not large enough to receive the string representation of the IPv4 address and port, RtlIpv4AddressToStringEx returns ERROR_INVALID_PARAMETER and sets the AddressStringLength parameter to the buffer length required. When either UNICODE or _UNICODE is defined, RtlIpv4AddressToStringEx is defined to RtlIpv4AddressToStringExW, the Unicode version of this function. The AddressString parameter is defined to the PWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv4AddressToStringEx is defined to RtlIpv4AddressToStringExA, the ANSI version of this function. The AddressString parameter is defined to the PSTR data type. The IN_ADDR structure is defined in the Inaddr.h header file. An import library containing the RtlIpv4AddressToStringEx function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv4AddressToStringEx function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LONG NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv4AddressToStringEx",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const IN_ADDR*",
        "name": "Address",
        "description": "The IPv4 address in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Port",
        "description": "The port number in network byte order format. This parameter is optional."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "AddressString",
        "description": "A pointer to the buffer to receive the NULL-terminated string representation of the IPv4 address and port. This buffer should be large enough to hold at least INET_ADDRSTRLEN characters. The INET_ADDRSTRLEN value is defined in the Ws2ipdef.h header file."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "AddressStringLength",
        "description": "On input, the number of characters that fit in the buffer pointed to by the AddressString parameter, including the NULL terminator.         On output, this parameter contains the number of characters actually written         to the buffer pointed to by the AddressString parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  RtlIpv4StringToAddress function  converts a string representation of an IPv4 address to a binary IPv4 address.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The RtlIpv4StringToAddress function is used to convert a string representation of the IPv4 address to an IPv4 address returned in network order (bytes ordered from     left to right). RtlIpv4StringToAddress is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. If the Strict parameter is set to TRUE, then the string pointed to by the S parameter must be in strict dotted-decimal notation. This strict format requires that four parts are specified. Each part is interpreted as a decimal byte of data     and assigned, from left to right, to the four bytes of an IPv4     address. When the Strict parameter is set to FALSE, the string pointed to by S parameter may be in any of the several possible formats. When the buffer pointed to by S parameter contains a three-part address string, the last part is interpreted     as a 16-bit quantity and placed in the right most two bytes of the     network address.  This makes the three-part address format     convenient for specifying Class B network addresses as     \"128.net.host\". When the buffer pointed to by S parameter contains a two-part address string, the last part is interpreted     as a 24-bit quantity and placed in the right most three bytes of the     network address.  This makes the two part address format convenient     for specifying Class A network addresses as \"net.host\". When the buffer pointed to by S parameter contains only a one-part address string, the value is stored directly in the     network address without any byte rearrangement. On success, the Terminator parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains an IP address plus additional information to the RtlIpv4StringToAddress function and then parse the remaining information. When either UNICODE or _UNICODE is defined, RtlIpv4StringToAddress is defined to RtlIpv4StringToAddressW, the Unicode version of this function. The S parameter is defined to the PCWSTR data type and the Terminator parameter is defined to the LPCWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv4StringToAddress is defined to RtlIpv4StringToAddressA, the ANSI version of this function. The S and Terminator parameters are defined to the PCSTR data type. The IN_ADDR structure is defined in the Inaddr.h header file. An import library containing the RtlIpv4StringToAddress function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv4StringToAddress function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LONG NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv4StringToAddress",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "S",
        "description": "A pointer to a buffer containing the NULL-terminated string representation of the IPv4 address."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Strict",
        "description": "A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is TRUE, the string must be dotted-decimal with four parts.              If this parameter is FALSE, any of four possible forms are allowed, with decimal,              octal, or hexadecimal notation. See the Remarks section for details."
      },
      {
        "in_out": "_Out_",
        "type": "LPCTSTR*",
        "name": "Terminator",
        "description": "A parameter that receives a pointer to the character that terminated         the converted string. This can be used by the caller to extract more information from the string."
      },
      {
        "in_out": "_Out_",
        "type": "IN_ADDR*",
        "name": "Addr",
        "description": "A pointer where the binary representation of the IPv4 address is to be stored."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  RtlIpv4StringToAddressEx function  converts a string representation of an IPv4 address and port number to a binary IPv4 address and port.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The RtlIpv4StringToAddressEx function is used to convert a string representation of the IPv4 address and port number to a binary IPv4 address and a port number. The IPv4 address is returned in network order (bytes ordered from     left to right). The port number is returned in network order. RtlIpv4StringToAddressEx is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. If the Strict parameter is set to TRUE, then the string pointed to by the AddressString parameter must be in strict dotted-decimal notation. This strict format requires that four parts are specified. Each part is interpreted as a decimal byte of data     and assigned, from left to right, to the four bytes of an IPv4     address. When the Strict parameter is set to FALSE, the string pointed to by the AddressString parameter may be in any of the several possible formats. When the buffer pointed to by AddressString parameter contains a three-part address string, the last part is interpreted     as a 16-bit quantity and placed in the right most two bytes of the     network address.  This makes the three-part address format     convenient for specifying Class B network addresses as     \"128.net.host\". When the buffer pointed to by AddressString parameter contains a two-part address string, the last part is interpreted     as a 24-bit quantity and placed in the right most three bytes of the     network address.  This makes the two part address format convenient     for specifying Class A network addresses as \"net.host\". When the buffer pointed to by AddressString parameter contains only a one-part address string, the value is stored directly in the     network address without any byte rearrangement. The buffer pointed to by the AddressString parameter may contain the IPv4 address string followed by an optional  colon and the string representation of a  port number. If a port number string is included in the buffer pointed to by AddressString parameter, the binary representation of the port number is returned in the Port parameter. If the buffer pointed to by AddressString parameter does not contain a port number, a zero is returned in the Port parameter. When either UNICODE or _UNICODE is defined, RtlIpv4StringToAddressEx is defined to RtlIpv4StringToAddressExW, the Unicode version of this function. The AddressString parameter is defined to the PCWSTR data type. When both UNICODE and  _UNICODE are not defined, RtlIpv4StringToAddressEx is defined to RtlIpv4StringToAddressExA, the ANSI version of this function. The AddressString parameter is defined to the PCSTR data type. The IN_ADDR structure is defined in the Inaddr.h header file. An import library containing the RtlIpv4StringToAddressEx function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv4StringToAddressEx function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LONG NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv4StringToAddressEx",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "AddressString",
        "description": "A pointer to a buffer containing the NULL-terminated string representation of the IPv4 address followed by an optional colon and string representation of a port number."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Strict",
        "description": "A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is TRUE, the string must be dotted-decimal with four parts. If this parameter is FALSE, any of four forms are allowed for the string representation of the Ipv4 address, with decimal,              octal, or hexadecimal notation. See the Remarks section for details."
      },
      {
        "in_out": "_Out_",
        "type": "IN_ADDR*",
        "name": "Address",
        "description": "A pointer where the binary representation of the IPv4 address is to be stored. The IPv4 address is stored in network byte order."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "Port",
        "description": "A pointer where the binary representation of the port number is to be stored. The port number is returned in network byte order. If no port was specified in the string pointed to by the AddressString parameter, then the Port parameter is set to zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  RtlIpv6AddressToString function  converts an IPv6 address to a string in Internet standard format.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "A pointer to the NULL character inserted at the end of the string representation of the IPv6 address. This can be used by the caller to easily append more information to the string. ",
    "remarks": "The RtlIpv6AddressToString function is used to convert an IPv6 address to the string representation of the IPv6 address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers     separated by colons. A string of consecutive zero numbers is replaced     with a double-colon.     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of RFC 5942 published by the IETF. RtlIpv6AddressToString is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. When either UNICODE or _UNICODE is defined, RtlIpv6AddressToString is defined to RtlIpv6AddressToStringW, the Unicode version of this function. The string parameter S and the function return value are defined to the PWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv6AddressToString is defined to RtlIpv6AddressToStringA, the ANSI version of this function. The string parameter S and the function return value are defined to the PSTR data type. The IN6_ADDR structure is defined in the In6addr.h header file. An import library containing the RtlIpv6AddressToString function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv6AddressToString function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LPTSTR NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv6AddressToString",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const IN6_ADDR*",
        "name": "Addr",
        "description": "The IPv6 address in network byte order."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "S",
        "description": "A pointer to a buffer in which to store the NULL-terminated string representation of the IPv6 address. This buffer should be large enough to hold at least 46 characters."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  RtlIpv6AddressToStringEx function  converts an IPv6 address, scope ID, and port number to a string.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The RtlIpv6AddressToStringEx function is used to convert an IPv6 address, scope ID, and port number to the string representation of the IPv6 address in Internet format followed by a string representation of the scope ID followed by a string representation of the port. The scope ID and port number are optional parameters. The basic string representation of the IPv6 address returned consists of 8 hexadecimal numbers     separated by colons. A string of consecutive zero hexadecimal numbers is replaced     with a double colon.     There can only be one double colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of RFC 5942 published by the IETF. If a scope ID is provided, the string representation of the scope ID is separated from the string representation of the IPv6 address by a percent character ('%'). If a port number is provided, the string representation of the IPv6 address and the scope ID are surrounded by square braces (a leading '[' character followed by the IPv6 address followed by a '% character followed by the scope ID with a trailing ']' character). The port number is represented as a colon following the right square brace character followed by the string representation of the port number in decimal. RtlIpv6AddressToStringEx is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. If the length of the buffer pointed to by the AddressString parameter is not large enough to receive the string representation of the IP address, scope ID, and port, RtlIpv6AddressToStringEx returns ERROR_INVALID_PARAMETER and sets the AddressStringLength parameter to the buffer length required. When either UNICODE or _UNICODE is defined, RtlIpv6AddressToStringEx is defined to RtlIpv6AddressToStringExW, the Unicode version of this function. The AddressString parameter is defined to the PWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv6AddressToStringEx is defined to RtlIpv6AddressToStringExA, the ANSI version of this function. The AddressString parameter is defined to the PSTR data type. The IN6_ADDR structure is defined in the In6addr.h header file. An import library containing the RtlIpv6AddressToStringEx function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv6AddressToStringEx function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LONG NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv6AddressToStringEx",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const IN6_ADDR*",
        "name": "Address",
        "description": "The IPv6 address in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ScopeId",
        "description": "The scope ID of the IPv6 address in network byte order. This parameter is optional."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "Port",
        "description": "The port number in network byte order format. This parameter is optional."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "AddressString",
        "description": "A pointer to the buffer to receive the NULL-terminated string representation of the IP address, scope ID, and port. This buffer should be large enough to hold at least INET6_ADDRSTRLEN characters. The INET6_ADDRSTRLEN value is defined in the Ws2ipdef.h header file."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "AddressStringLength",
        "description": "On input, the number of characters that fit in the buffer pointed to by the AddressString parameter, including the NULL terminator.         On output, this parameter contains the number of characters actually written         to the buffer pointed to by the AddressString parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  RtlIpv6StringToAddress function  converts a string representation of an IPv6 address to a binary IPv6 address.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The RtlIpv6StringToAddress function is used to convert a string representation of the IPv6 address to an IPv6 address returned in network order (bytes ordered from     left to right). RtlIpv6StringToAddress is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. The string pointed to by the S parameter must be represented in the form for an IPv6 address string. The basic string representation of an IPv6 address consists of 8 hexadecimal numbers     separated by colons. A string of consecutive zero numbers may be replaced     with a double-colon.     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of RFC 5942 published by the IETF. On success, the Terminator parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains and IP address plus additional information to the RtlIpv6StringToAddress function and then parse the remaining information. When either UNICODE or _UNICODE is defined, RtlIpv6StringToAddress is defined to RtlIpv6StringToAddressW, the Unicode version of this function. The S and Terminator parameters are defined to the PCWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv6StringToAddress is defined to RtlIpv6StringToAddressA, the ANSI version of this function. The S and Terminator parameters are defined to the PCSTR data type. The IN6_ADDR structure is defined in the In6addr.h header file. An import library containing the RtlIpv6StringToAddress function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv6StringToAddress function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LONG NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv6StringToAddress",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "S",
        "description": "A pointer to a buffer containing the NULL-terminated string representation of the IPv6 address."
      },
      {
        "in_out": "_Out_",
        "type": "PCTSTR*",
        "name": "Terminator",
        "description": "A parameter that receives a pointer to the character that terminated         the converted string. This can be used by the caller to extract more information from the string."
      },
      {
        "in_out": "_Out_",
        "type": "IN6_ADDR*",
        "name": "Addr",
        "description": "A pointer where the binary representation of the IPv6 address is to be stored."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  RtlIpv6StringToAddressEx function  converts a string representation of an IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mstcpip.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The RtlIpv6StringToAddressEx function is used to convert a string representation of the IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port number.  The IPv6 address is returned in network order (bytes ordered from     left to right). The port number and scope ID are returned in network order. RtlIpv6StringToAddressEx is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. The string pointed to by the AddressString parameter must be represented in the form for an IPv6 address string followed by an optional percent character and scope ID string. The IPv6 address and scope ID string must be enclosed  in square brackets. The right square bracket after the IPv6 address and scope ID  string may be followed by an optional colon and a string representation of a port number. The basic string representation of an IPv6 address consists of 8 hexadecimal numbers     separated by colons. A string of consecutive zero numbers may be replaced     with a double-colon.     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of RFC 5942 published by the IETF. When either UNICODE or _UNICODE is defined, RtlIpv6StringToAddressEx is defined to RtlIpv6StringToAddressExW, the Unicode version of this function. The AddressString parameter is defined to the PCWSTR data type. When both UNICODE and _UNICODE are not defined, RtlIpv6StringToAddressEx is defined to RtlIpv6StringToAddressExA, the ANSI version of this function. The AddressString parameter is defined to the PCSTR data type. The IN6_ADDR structure is defined in the In6addr.h header file. An import library containing the RtlIpv6StringToAddressEx function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The RtlIpv6StringToAddressEx function is included in the Ntdll.lib import library included in the Windows Driver Kit (WDK). An application could also use the GetModuleHandle and GetProcAddress functions to retrieve the function pointer from the Ntdll.dll and call this function. ",
    "return_type": "LONG NTAPI",
    "category": "IP Helper",
    "name": "RtlIpv6StringToAddressEx",
    "is_callback": 0,
    "dll": "Ntdll.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "AddressString",
        "description": "A pointer to a buffer containing the NULL-terminated string representation of the IPv6 address, scope ID, and port number."
      },
      {
        "in_out": "_Out_",
        "type": "IN6_ADDR*",
        "name": "Address",
        "description": "A pointer where the binary representation of the IPv6 address is to be stored."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ScopeId",
        "description": "A pointer to where scope ID of the IPv6 address is stored. If AddressString parameter does not contain the string representation of a scope ID, then zero is returned in this parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "Port",
        "description": "A pointer where the port number is stored. The port number is in network byte order format. If AddressString parameter does not contain the string representation of a port number, then zero is returned in this parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  CreateIpNetEntry2 function  creates a new neighbor IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreateIpNetEntry2 function is defined on Windows Vista and later. The CreateIpNetEntry2 function is used to add a new neighbor IP address entry on a local computer. The Address member in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid unicast, anycast, or multicast IPv4 or IPv6 address and family. The  PhysicalAddress and PhysicalAddressLength members in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid physical address. In addition, at least one of the following members in the MIB_IPNET_ROW2 structure pointed to the Row parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the unicast IP address. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. The CreateIpNetEntry2 function will fail if the IP address passed in the Address member of the MIB_IPNET_ROW2 pointed to by the Row parameter is a duplicate of an existing neighbor IP address on the interface. The CreateIpNetEntry2 function can only be called by a user logged on as a member of the Administrators group. If CreateIpNetEntry2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "CreateIpNetEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_IPNET_ROW2*",
        "name": "Row",
        "description": "A pointer to a  MIB_IPNET_ROW2 structure entry for a neighbor IP address entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteIpNetEntry2 function  deletes a neighbor IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The DeleteIpNetEntry2 function is defined on Windows Vista and later. The DeleteIpNetEntry2 function is used to delete a MIB_IPNET_ROW2 structure entry. On input, the Address member in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid neighbor IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_IPNET_ROW2 structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, DeleteIpNetEntry2 deletes the neighbor IP address. The GetIpNetTable2 function can be called to enumerate the neighbor IP address entries on a local computer. The DeleteIpNetEntry2 function can only be called by a user logged on as a member of the Administrators group. If DeleteIpNetEntry2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "DeleteIpNetEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_IPNET_ROW2*",
        "name": "Row",
        "description": "A pointer to a  MIB_IPNET_ROW2 structure entry for a neighbor IP address entry. On successful return, this entry will be deleted."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  FlushIpNetTable2 function flushes the IP neighbor table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The FlushIpNetTable2 function is defined on Windows Vista and later. The   FlushIpNetTable2 function flushes or deletes the neighbor IP addresses on a local system.  The Family parameter can be used to limit neighbor IP addresses to delete to a particular IP address family. If neighbor IP addresses for both IPv4 and IPv6 should be deleted, set the  Family parameter to AF_UNSPEC. The InterfaceIndex parameter can be used to limit neighbor IP addresses to delete to a particular interface. If neighbor IP addresses for all interfaces should be deleted, set the  InterfaceIndex parameter to zero. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. The FlushIpNetTable2 function can only be called by a user logged on as a member of the Administrators group. If FlushIpNetTable2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "FlushIpNetTable2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to flush.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  flushes the neighbor IP address table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  flushes the neighbor IP address table containing only  IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  flushes the neighbor IP address table containing only IPv6 entries."
      },
      {
        "in_out": "_In_",
        "type": "NET_IFINDEX",
        "name": "InterfaceIndex",
        "description": "The interface index.  If the index is specified,         flush the neighbor IP address entries on a specific interface, otherwise flush the         neighbor IP address entries on all the interfaces. To ignore the interface, set this parameter to zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIpNetEntry2 function  retrieves information for a neighbor IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpNetEntry2 function is defined on Windows Vista and later. The GetIpNetEntry2 function is used to retrieve a MIB_IPNET_ROW2 structure entry. On input, the Address member in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid neighbor IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_IPNET_ROW2 structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetIpNetEntry2 retrieves the other properties for the neighbor IP address and fills out the MIB_IPNET_ROW2 structure pointed to by the Row parameter. The GetIpNetTable2 function can be called to enumerate the neighbor IP address entries on a local computer. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpNetEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPNET_ROW2",
        "name": "Row",
        "description": "A pointer to a  MIB_IPNET_ROW2 structure entry for a neighbor IP address entry. On successful return, this structure will be updated with the properties for neighbor IP address."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetIpNetTable2 function retrieves the IP neighbor table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR or ERROR_NOT_FOUND. If the function fails or returns no data, the return value is one of the following error codes.  ",
    "remarks": "The GetIpNetTable2 function is defined on Windows Vista and later. The   GetIpNetTable2 function enumerates the neighbor IP addresses on a local system and returns this information in a MIB_IPNET_TABLE2 structure. The neighbor IP address entries are returned in a MIB_IPNET_TABLE2 structure in the buffer pointed to by the Table parameter. The MIB_IPNET_TABLE2 structure contains a neighbor IP address entry count and an array of MIB_IPNET_ROW2 structures for each neighbor IP address entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. Note that the returned MIB_IPNET_TABLE2 structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IPNET_ROW2 array entry in the Table member of the MIB_IPNET_TABLE2 structure. Padding for alignment may also be present between the MIB_IPNET_ROW2 array entries. Any access to a MIB_IPNET_ROW2 array entry should assume  padding may exist. The following example retrieves the IP neighbor table, then prints the values for IP neighbor row entries in the table. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpNetTable2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve. Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  returns the neighbor IP address table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns the neighbor IP address table containing only  IPv4 entries.   AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns the neighbor IP address table containing only IPv6 entries."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IPNET_TABLE2*",
        "name": "Table",
        "description": "A pointer to a  MIB_IPNET_TABLE2 structure that contains a table of neighbor IP address entries on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ResolveIpNetEntry2 function  resolves the physical address for a neighbor IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The ResolveIpNetEntry2 function is defined on Windows Vista and later. The ResolveIpNetEntry2 function is used to resolve the physical address for a neighbor IP address entry on a local computer. This function flushes any existing neighbor entry that matches the IP address on the interface and then resolves the physical address (MAC) address     by sending ARP requests for an IPv4 address or neighbor solicitation requests for an IPv6 address.     If the SourceAddress parameter is specified, the ResolveIpNetEntry2 function will select the     interface with this source IP address to send the requests on. If the SourceAddress parameter is not specified (NULL was passed in this parameter), the ResolveIpNetEntry2 function will automatically select the     best interface to send the requests on. The Address member in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_IPNET_ROW2 structure pointed to the Row parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the unicast IP address. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. If the IP address passed in the Address member of the MIB_IPNET_ROW2 pointed to by the Row parameter is a duplicate of an existing neighbor IP address on the interface, the ResolveIpNetEntry2 function will flush the existing entry before resolving the IP address. On output when the call is successful, ResolveIpNetEntry2 retrieves the other properties for the neighbor IP address and fills out the MIB_IPNET_ROW2 structure pointed to by the Row parameter. The  PhysicalAddress and PhysicalAddressLength members in the MIB_IPNET_ROW2 structure pointed to by the Row parameter will be initialized to a valid physical address. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "ResolveIpNetEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPNET_ROW2",
        "name": "Row",
        "description": "A pointer to a  MIB_IPNET_ROW2 structure entry for a neighbor IP address entry. On successful return, this structure will be updated with the properties for neighbor IP address."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SOCKADDR_INET*",
        "name": "SourceAddress",
        "description": "A pointer to a  an optional source IP address used to select the interface to send the requests on for the neighbor IP address entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[ResolveNeighbor is no longer available for use as of Windows Vista. Instead, use ResolveIpNetEntry2.]",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The ResolveNeighbor function always fails and returns the following error code.  ",
    "remarks": "",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "ResolveNeighbor",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKADDR*",
        "name": "NetworkAddress",
        "description": "A pointer to a   SOCKADDR structure that contains the neighbor IP address entry and address family."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "PhysicalAddress",
        "description": "A pointer to a byte array buffer that will receive the physical address that corresponds to the IP address specified by the NetworkAddress parameter if the function is successful. The length of the byte array is passed in the PhysicalAddressLength parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "PhysicalAddressLength",
        "description": "On input, this parameter specifies the maximum length, in bytes, of the buffer passed in the PhysicalAddress parameter to receive the physical address. If the function is successful, this parameter will receive the length of the physical address returned in the buffer pointed to by the PhysicalAddress parameter. If ERROR_BUFFER_OVERFLOW is returned, this parameter contains the number of bytes         required to hold the physical address."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpNetEntry2 function  sets the physical address of an existing neighbor IP address entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetIpNetEntry2 function is defined on Windows Vista and later. The SetIpNetEntry2 function is used to set the physical address for an existing neighbor IP address entry on a local computer. The Address member in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid unicast, anycast, or multicast IPv4 or IPv6 address and family. The  PhysicalAddress and PhysicalAddressLength members in the MIB_IPNET_ROW2 structure pointed to by the Row parameter must be initialized to a valid physical address. In addition, at least one of the following members in the MIB_IPNET_ROW2 structure pointed to the Row parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the unicast IP address. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. The SetIpNetEntry2 function will fail if the IP address passed in the Address member of the MIB_IPNET_ROW2 pointed to by the Row parameter is not an existing neighbor IP address on the interface specified. The SetIpNetEntry2 function can only be called by a user logged on as a member of the Administrators group. If SetIpNetEntry2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIpNetEntry2 function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "SetIpNetEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPNET_ROW2",
        "name": "Row",
        "description": "A pointer to a  MIB_IPNET_ROW2 structure entry for a neighbor IP address entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  FlushIpPathTable function flushes the IP path table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The FlushIpPathTable function is defined on Windows Vista and later. The   FlushIpPathTable function flushes or deletes the IP path entries on a local system.  The Family parameter can be used to limit the IP path entries to delete to a particular IP address family. If IP path entries for both IPv4 and IPv6 should be deleted, set the  Family parameter to AF_UNSPEC. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. The FlushIpPathTable function can only be called by a user logged on as a member of the Administrators group. If FlushIpPathTable is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "FlushIpPathTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to flush.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  flushes the IP path table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  flushes the IP path table containing only  IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  flushes the IP path table containing only IPv6 entries."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIpPathEntry function  retrieves information for a IP path entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpPathEntry function is defined on Windows Vista and later. The GetIpPathEntry function is used to retrieve a MIB_IPPATH_ROW structure entry. On input, the Destination member in the MIB_IPPATH_ROW structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address and family. The address family specified in Source member in the MIB_IPPATH_ROW structure must also either match the destination IP address family specified in the Destination member or the address family in the Source member must be specified as AF_UNSPEC. In addition , at least one of the following members in the MIB_IPPATH_ROW structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value is set for the  InterfaceLuid member (the values of this member is set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetIpPathEntry retrieves the other properties for the IP path entry and fills out the MIB_IPPATH_ROW structure pointed to by the Row parameter. The GetIpPathTable function can be called to enumerate the IP path entries on a local computer. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpPathEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPPATH_ROW",
        "name": "Row",
        "description": "A pointer to a  MIB_IPPATH_ROW structure entry for a IP path entry. On successful return, this structure will be updated with the properties for IP path entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetIpPathTable function retrieves the IP path table on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpPathTable function is defined on Windows Vista and later. The   GetIpPathTable function enumerates the IP path entries on a local system and returns this information in a MIB_IPPATH_TABLE structure. The IP path entries are returned in a MIB_IPPATH_TABLE structure in the buffer pointed to by the Table parameter. The MIB_IPPATH_TABLE structure contains an IP path entry count and an array of MIB_IPPATH_ROW structures for each IP path entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. Note that the returned MIB_IPPATH_TABLE structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IPPATH_ROW array entry in the Table member of the MIB_IPPATH_TABLE structure. Padding for alignment may also be present between the MIB_IPPATH_ROW array entries. Any access to a MIB_IPPATH_ROW array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpPathTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  returns the IP path table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns the IP path table containing only  IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns the IP path table containing only IPv6 entries."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IPPATH_TABLE*",
        "name": "Table",
        "description": "A pointer to a  MIB_IPPATH_TABLE structure that contains a table of IP path entries on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  CreateIpForwardEntry function creates a route in the local computer's IPv4 routing table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The dwForwardProto member of  MIB_IPFORWARDROW structure pointed to by the route parameter must be set to MIB_IPPROTO_NETMGMT otherwise CreateIpForwardEntry will fail. Routing protocol identifiers are used to identify route information for the specified routing protocol. For example, MIB_IPPROTO_NETMGMT is used to identify route information for IP  routing set through network management such as the Dynamic Host Configuration Protocol (DHCP), the Simple Network Management Protocol (SNMP), or by calls to the CreateIpForwardEntry,  DeleteIpForwardEntry, or SetIpForwardEntry functions. On Windows Vista and Windows Server 2008, the route metric specified in the dwForwardMetric1 member of the  MIB_IPFORWARDROW structure pointed to by pRoute parameter represents a combination of the route metric added to the interface metric specified in the Metric member of the MIB_IPINTERFACE_ROW structure of the associated interface.  So the dwForwardMetric1 member of the  MIB_IPFORWARDROW structure should be equal to or greater than Metric member of the associated MIB_IPINTERFACE_ROW structure. If an application would like to set the route metric to 0, then the dwForwardMetric1 member of the MIB_IPFORWARDROW structure  should be set equal to the value of the interface metric specified in the Metric member of the associated MIB_IPINTERFACE_ROW structure. An application can retrieve the interface metric by calling the GetIpInterfaceEntry function. On Windows Vista and Windows Server 2008, the CreateIpForwardEntry only works on interfaces with a single sub-interface (where the interface LUID and subinterface LUID are the same). The dwForwardIfIndex member of the MIB_IPFORWARDROW structure specifies the interface. A number of members of the MIB_IPFORWARDROW structure  pointed to by the route parameter are not currently used by CreateIpForwardEntry. These members include dwForwardPolicy, dwForwardType, dwForwardAge, dwForwardNextHopAS, dwForwardMetric2, dwForwardMetric3, dwForwardMetric4, and dwForwardMetric5. A new route created by CreateIpForwardEntry will automatically have a default value for dwForwardAge of INFINITE. To modify an existing route in the IPv4 routing table, use the  SetIpForwardEntry function. To retrieve the IPv4 routing table, call the GetIpForwardTable function. On Windows Vista and later, the CreateIpForwardEntry function can only be called by a user logged on as a member of the Administrators group. If CreateIpForwardEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The CreateIpForwardEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following example demonstrates how to change the default gateway to NewGateway. Simply calling GetIpForwardTable, changing the gateway, and then calling SetIpForwardEntry will not change the route, but rather will just add a new one. If for some reason there are multiple default gateways present, this code will delete them. Note that the new gateway must be viable; otherwise, TCP/IP will ignore the change. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "CreateIpForwardEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPFORWARDROW",
        "name": "pRoute",
        "description": "A pointer to a  MIB_IPFORWARDROW structure that specifies the information for the new route. The caller must specify values for all members of this structure. The caller must specify MIB_IPPROTO_NETMGMT for the dwForwardProto member of  MIB_IPFORWARDROW."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  CreateIpForwardEntry2 function  creates a new IP route entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreateIpForwardEntry2 function is defined on Windows Vista and later. The CreateIpForwardEntry2 function is used to add a new neighbor IP address entry on a local computer. The InitializeIpForwardEntry function should be used to initialize the members of a     MIB_IPFORWARD_ROW2 structure entry with default values.  An application can then change the     members in the MIB_IPFORWARD_ROW2 entry it wishes to modify, and then call the CreateIpForwardEntry2 function. The DestinationPrefix member in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address prefix. The NextHop member in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_IPFORWARD_ROW2 structure pointed to the Row parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the IP route entry. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. The route metric offset specified in the Metric member of the  MIB_IPFORWARD_ROW2 structure pointed to by Row parameter represents only part of the complete route metric. The complete metric is a combination of this route metric  offset added to the interface metric specified in the Metric member of the MIB_IPINTERFACE_ROW structure of the associated interface.  An application can retrieve the interface metric by calling the GetIpInterfaceEntry function. The Age and Origin members of the MIB_IPFORWARD_ROW2 structure pointed to by the Row are ignored when the  CreateIpForwardEntry2 function is called. These members are set by the network stack and cannot be set using the CreateIpForwardEntry2 function. The CreateIpForwardEntry2 function will fail if the DestinationPrefix and NextHop members of the MIB_IPFORWARD_ROW2 pointed to by the Row parameter are a duplicate of an existing IP route entry on the interface specified in the InterfaceLuid or InterfaceIndex members. The CreateIpForwardEntry2 function can only be called by a user logged on as a member of the Administrators group. If CreateIpForwardEntry2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "CreateIpForwardEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_IPFORWARD_ROW2*",
        "name": "Row",
        "description": "A pointer to a  MIB_IPFORWARD_ROW2 structure entry for an IP route entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteIpForwardEntry function deletes an existing route in the local computer's IPv4 routing table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the routine is successful. If the function fails, the return value is one of the following error codes.  If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "The dwForwardProto member of  MIB_IPFORWARDROW structure pointer to by the route parameter must be set to MIB_IPPROTO_NETMGMT otherwise DeleteIpForwardEntry will fail. Routing protocol identifiers are used to identify route information for the specified routing protocol. For example, MIB_IPPROTO_NETMGMT is used to identify route information for IP  routing set through network management such as the Dynamic Host Configuration Protocol (DHCP), the Simple Network Management Protocol (SNMP), or by calls to the CreateIpForwardEntry,  DeleteIpForwardEntry  \t\t, or SetIpForwardEntry functions. On Windows Vista and Windows Server 2008, the DeleteIpForwardEntry only works on interfaces with a single sub-interface (where the interface LUID and subinterface LUID are the same). The dwForwardIfIndex member of the MIB_IPFORWARDROW structure specifies the interface. A number of members of the MIB_IPFORWARDROW structure  pointed to by the route parameter are not currently used by CreateIpForwardEntry. These members include dwForwardPolicy, dwForwardType, dwForwardAge, dwForwardNextHopAS, dwForwardMetric1, dwForwardMetric2, dwForwardMetric3, dwForwardMetric4, and dwForwardMetric5. To modify an existing route in the IPv4 routing table, use the  SetIpForwardEntry function. To retrieve the IPv4 routing table, call the GetIpForwardTable function. On Windows Vista and later, the DeleteIpForwardEntry function can only be called by a user logged on as a member of the Administrators group. If DeleteIpForwardEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The DeleteIpForwardEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following code example shows how to change the default gateway to NewGateway. By calling GetIpForwardTable, changing the gateway, and then calling SetIpForwardEntry will not change the route, but will add a new one. If multiple default gateways exist, this code will delete them. Be aware that the new gateway must be viable; otherwise, TCP/IP will ignore the change. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "DeleteIpForwardEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPFORWARDROW",
        "name": "pRoute",
        "description": "A pointer to an  MIB_IPFORWARDROW structure. This structure specifies information that identifies the route to delete. The caller must specify values for the dwForwardIfIndex, dwForwardDest, dwForwardMask, dwForwardNextHop,  and dwForwardProto members of the structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  DeleteIpForwardEntry2 function  deletes an IP route entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The DeleteIpForwardEntry2 function is defined on Windows Vista and later. The DeleteIpForwardEntry2 function is used to delete a MIB_IPFORWARD_ROW2 structure entry. On input, the DestinationPrefix member in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address prefix and family. On input, the NextHop member in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_IPFORWARD_ROW2 structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, DeleteIpForwardEntry2 deletes the IP route entry. The DeleteIpForwardEntry2 function will fail if the DestinationPrefix and NextHop members of the MIB_IPFORWARD_ROW2 pointed to by the Row parameter do not match an existing IP route entry on the interface specified in the InterfaceLuid or InterfaceIndex members. The GetIpForwardTable2 function can be called to enumerate the IP route entries on a local computer. The DeleteIpForwardEntry2 function can only be called by a user logged on as a member of the Administrators group. If DeleteIpForwardEntry2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "DeleteIpForwardEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_IPFORWARD_ROW2*",
        "name": "Row",
        "description": "A pointer to a  MIB_IPFORWARD_ROW2 structure entry for an IP route entry. On successful return, this entry will be deleted."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  EnableRouter function turns on IPv4 forwarding on the local computer.  EnableRouter also increments a reference count that tracks the number of requests to enable IPv4 forwarding.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the EnableRouter function succeeds, the return value is ERROR_IO_PENDING. If the function fails, use FormatMessage to obtain the message string for the returned error.  ",
    "remarks": "The EnableRouter function is specific to IPv4 forwarding. If the process that calls  EnableRouter terminates without calling  UnenableRouter, the system  decrements the reference count that tracks the number of requests to enable IPv4 forwarding as though the process had called  UnenableRouter. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "EnableRouter",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HANDLE*",
        "name": "pHandle",
        "description": "A pointer to a handle. This parameter is currently unused."
      },
      {
        "in_out": "",
        "type": "OVERLAPPED*",
        "name": "pOverlapped",
        "description": "A pointer to an  OVERLAPPED structure. Except for the hEvent member, all members of this structure should be set to zero. The hEvent member should contain a handle to a valid event object. Use the  CreateEvent function to create this event object."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetBestInterface function retrieves the index of the interface that has the best route to the specified IPv4 address.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetBestInterface function only works with IPv4 addresses. For use with IPv6 addresses, the GetBestInterfaceEx must be used. For information about the IPAddr data type, see  Windows Data Types. To convert an IP address between dotted decimal notation and IPAddr format, use the  inet_addr and  inet_ntoa functions. On Windows Vista and later, the pdwBestIfIndex parameter is treated internally by IP Helper as a pointer to a NET_IFINDEX datatype. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetBestInterface",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "dwDestAddr",
        "description": "The destination IPv4 address for which to retrieve the interface that has the best route, in the form of an IPAddr structure."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "pdwBestIfIndex",
        "description": "A pointer to a DWORD variable that receives the index of the interface that has the best route to the IPv4 address specified by dwDestAddr."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetBestInterfaceEx function retrieves the index of the interface that has the best route to the specified IPv4 or IPv6 address.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetBestInterfaceEx function differs from the GetBestInterface function in that it can be used with either IPv4 or IPv6 addresses. The Family member of the sockaddr structure pointed to by the pDestAddr parameter must be set to one of the following values: AF_INET or AF_INET6. On Windows Vista and later, the pdwBestIfIndex parameter is treated internally by IP Helper as a pointer to a NET_IFINDEX datatype. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetBestInterfaceEx",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct sockaddr*",
        "name": "pDestAddr",
        "description": "The destination IPv6 or IPv4 address for which to retrieve the interface with the best route, in the form of a sockaddr structure."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "pdwBestIfIndex",
        "description": "A pointer to the index of the interface with the best route to the IPv6 or IPv4 address specified by pDestAddr."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetBestRoute function retrieves the best route to the specified destination IP address.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetBestRoute",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDestAddr",
        "description": "Destination IP address for which to obtain the best route."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSourceAddr",
        "description": "Source IP address. This IP address corresponds to an interface on the local computer. If multiple best routes to the destination address exist, the function selects the route that uses this interface.     This parameter is optional. The caller may specify zero for this parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IPFORWARDROW",
        "name": "pBestRoute",
        "description": "Pointer to a  MIB_IPFORWARDROW structure containing the best route for the IP address specified by dwDestAddr."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The  GetBestRoute2 function  retrieves the IP route entry on the local computer for the best route to the specified destination IP address.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetBestRoute2 function is defined on Windows Vista and later. The GetBestRoute2 function is used to retrieve a MIB_IPFORWARD_ROW2 structure entry for the best route from a source IP address to a destination IP address. On input, the DestinationAddress parameter must be initialized to a valid IPv4 or IPv6 address and family. On input, the SourceAddress parameter may be initialized to the preferred IPv4 or IPv6 address and family. In addition, at least one of the following parameters must be initialized:     the InterfaceLuid or InterfaceIndex.      The parameters are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetBestRoute2 retrieves and MIB_IPFORWARD_ROW2 structure for the best route from the source IP address the destination IP address. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetBestRoute2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "NET_LUID*",
        "name": "InterfaceLuid",
        "description": "The locally unique identifier (LUID) to specify the network interface associated with an IP route entry."
      },
      {
        "in_out": "_In_",
        "type": "NET_IFINDEX",
        "name": "InterfaceIndex",
        "description": "The local index value to specify the network interface associated with an IP route entry. This index value may change when a network adapter is disabled and then enabled, or under other circumstances, and should not be considered persistent."
      },
      {
        "in_out": "_In_",
        "type": "const SOCKADDR_INET*",
        "name": "SourceAddress",
        "description": "The source IP address. This parameter may be omitted and passed as a NULL pointer."
      },
      {
        "in_out": "_In_",
        "type": "const SOCKADDR_INET*",
        "name": "DestinationAddress",
        "description": "The destination IP address."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AddressSortOptions",
        "description": "A set of options that affect how IP addresses are sorted. This parameter is not currently used."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IPFORWARD_ROW2",
        "name": "BestRoute",
        "description": "A pointer to the MIB_IPFORWARD_ROW2 for the best route from the source IP address to the destination IP address."
      },
      {
        "in_out": "_Out_",
        "type": "SOCKADDR_INET*",
        "name": "BestSourceAddress",
        "description": "A pointer to the best source IP address."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetIpForwardEntry2 function  retrieves information for an IP route entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpForwardEntry2 function is defined on Windows Vista and later. The GetIpForwardEntry2 function is used to retrieve a MIB_IPFORWARD_ROW2 structure entry. On input, the DestinationPrefix member in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address prefix and family. On input, the NextHop member in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter must be initialized to a valid IPv4 or IPv6 address and family. In addition, at least one of the following members in the MIB_IPFORWARD_ROW2 structure pointed to the Row parameter must be initialized:     the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. On output when the call is successful, GetIpForwardEntry2 retrieves the other properties for the IP route entry and fills out the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter. The route metric offset specified in the Metric member of the  MIB_IPFORWARD_ROW2 structure pointed to by Row parameter represents only part of the complete route metric. The complete metric is a combination of this route metric  added to the interface metric specified in the Metric member of the MIB_IPINTERFACE_ROW structure of the associated interface.  An application can retrieve the interface metric by calling the GetIpInterfaceEntry function. The GetIpForwardTable2 function can be called to enumerate the IP route entries on a local computer. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpForwardEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PMIB_IPFORWARD_ROW2",
        "name": "Row",
        "description": "A pointer to a  MIB_IPFORWARD_ROW2 structure entry for an IP route entry. On successful return, this structure will be updated with the properties for the IP route entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetIpForwardTable function retrieves the IPv4 routing table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR (zero). If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The  dwForwardProto member of the  MIB_IPFORWARDROW structure specifies the protocol or routing mechanism that generated the route. See  Protocol Identifiers for a list of possible protocols and routing mechanisms. The  dwForwardDest, dwForwardMask, and dwForwardNextHop members of the  MIB_IPFORWARDROW structure represent an IPv4 address in network byte order. An IPv4 address of 0.0.0.0 in the  dwForwardDest member of the  MIB_IPFORWARDROW structure is considered a                 default route. The MIB_IPFORWARDTABLE may contain multiple MIB_IPFORWARDROW entries with the dwForwardDest member set to 0.0.0.0 when there are multiple network adapters installed. When dwForwardAge is set to INFINITE, the route will not be removed based on a timeout   value. Any other value for dwForwardAge specifies the number of seconds since the route was added or modified in the network routing table. On Windows Server 2003 or   Windows 2000 Server when the Routing and Remote Access Service (RRAS) is running, the  MIB_IPFORWARDROW entries returned have the dwForwardType and dwForwardAge members set to zero. On Windows Vista and Windows Server 2008, the route metric specified in the dwForwardMetric1 member of the  MIB_IPFORWARDROW structure represents a combination of the route metric added to the interface metric specified in the Metric member of the MIB_IPINTERFACE_ROW structure of the associated interface.  So the dwForwardMetric1 member of the  MIB_IPFORWARDROW structure should be equal to or greater than Metric member of the associated MIB_IPINTERFACE_ROW structure. If an application would like to set the route metric to 0 on Windows Vista and Windows Server 2008, then the dwForwardMetric1 member of the MIB_IPFORWARDROW structure  should be set equal to the value of the interface metric specified in the Metric member of the associated MIB_IPINTERFACE_ROW structure. An application can retrieve the interface metric by calling the GetIpInterfaceEntry function. A number of members of the MIB_IPFORWARDROW structure  entries returned by GetIpForwardTable are not currently used by IPv4 routing. These members include dwForwardPolicy, dwForwardNextHopAS, dwForwardMetric2, dwForwardMetric3, dwForwardMetric4, and dwForwardMetric5. The following example retrieves the IP routing table then prints some fields for each route in the table. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetIpForwardTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IPFORWARDTABLE",
        "name": "pIpForwardTable",
        "description": "A pointer to a buffer that receives the IPv4 routing table as a  MIB_IPFORWARDTABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "pdwSize",
        "description": "On input, specifies the size in bytes  of the buffer pointed to by the pIpForwardTable parameter.     On output, if the buffer is not large enough to hold the returned routing table, the function sets this parameter equal to the required buffer size in bytes."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A Boolean value that specifies whether the returned table should be sorted. If this parameter is TRUE, the table is sorted in the order of:     Destination address Protocol that generated the route Multipath routing policy Next-hop address"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetIpForwardTable2 function retrieves the IP route entries on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetIpForwardTable2 function is defined on Windows Vista and later. The   GetIpForwardTable2 function enumerates the IP route entries on a local system and returns this information in a MIB_IPFORWARD_TABLE2 structure. The IP route entries are returned in a MIB_IPFORWARD_TABLE2 structure in the buffer pointed to by the Table parameter. The MIB_IPFORWARD_TABLE2 structure contains an IP route entry count and an array of MIB_IPFORWARD_ROW2 structures for each IP route entry. When these returned structures are no longer required, free the memory by calling the FreeMibTable. The Family parameter must be initialized to either AF_INET,  AF_INET6, or AF_UNSPEC. Note that the returned MIB_IPFORWARD_TABLE2 structure pointed to by the Table parameter may contain padding for alignment between the NumEntries member and the first MIB_IPFORWARD_ROW2 array entry in the Table member of the MIB_IPFORWARD_TABLE2 structure. Padding for alignment may also be present between the MIB_IPFORWARD_ROW2 array entries. Any access to a MIB_IPFORWARD_ROW2 array entry should assume  padding may exist. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetIpForwardTable2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family to retrieve.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function  returns the IP routing table containing both IPv4 and IPv6 entries.    AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns the IP routing table containing only  IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns the IP routing table containing only IPv6 entries."
      },
      {
        "in_out": "_Out_",
        "type": "PMIB_IPFORWARD_TABLE2*",
        "name": "Table",
        "description": "A pointer to a  MIB_IPFORWARD_TABLE2 structure that contains a table of IP route entries on the local computer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The  GetRTTAndHopCount function determines the round-trip time (RTT) and hop count to the specified destination.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. Call  GetLastError to obtain the error code for the failure. ",
    "remarks": "For information about the IPAddr data type, see  Windows Data Types. To convert an IP address between dotted decimal notation and IPAddr format, use the  inet_addr and  inet_ntoa functions. The following example retrieves and prints the round trip time and hop count to the destination IP address 127.0.0.1. ",
    "return_type": "BOOL",
    "category": "IP Helper",
    "name": "GetRTTAndHopCount",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "IPAddr",
        "name": "DestIpAddress",
        "description": "IP address of the destination for which to determine the RTT and hop count, in the form of an IPAddr structure."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "HopCount",
        "description": "Pointer to a ULONG variable. This variable receives the hop count to the destination specified by the DestIpAddress parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxHops",
        "description": "Maximum number of hops to search for the destination. If the number of hops to the destination exceeds this number, the function terminates the search and returns FALSE."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "RTT",
        "description": "Round-trip time, in milliseconds, to the destination specified by DestIpAddress."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  InitializeIpForwardEntry function  initializes a  MIB_IPFORWARD_ROW2 structure with default values for an IP route entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The InitializeIpForwardEntry function is defined on Windows Vista and later. The InitializeIpForwardEntry function must be used to initialize the members of a     MIB_IPFORWARD_ROW2 structure entry with default values for an IP route entry for later use with the CreateIpForwardEntry2 function. On input, InitializeIpForwardEntry must be passed a new MIB_IPFORWARD_ROW2 structure to initialize. On output, the ValidLifetime and PreferredLifetime members of the MIB_IPFORWARD_ROW2 structure pointed to by Row parameter will be initialized to infinite and the Loopback,  AutoconfigureAddress, Publish, and Immortal members  will be initialized to TRUE. In addition, the SitePrefixLength,   Metric, and  Protocol members are set to an illegal value and other fields are initialized to zero. After calling InitializeIpForwardEntry, an application can then change the     members in the MIB_IPFORWARD_ROW2 entry it wishes to modify, and then call the CreateIpForwardEntry2  to add the new IP route entry to the local computer. ",
    "return_type": "VOID",
    "category": "IP Helper",
    "name": "InitializeIpForwardEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_IPFORWARD_ROW2",
        "name": "Row",
        "description": "On entry, a pointer to a  MIB_IPFORWARD_ROW2 structure entry for an IP route entry. On return, the  MIB_IPFORWARD_ROW2 structure pointed to by this parameter is initialized with default values for an IP route entry."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpForwardEntry function modifies an existing route in the local computer's IPv4 routing table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The dwForwardProto member of  MIB_IPFORWARDROW structure pointed to by the route parameter must be set to MIB_IPPROTO_NETMGMT otherwise SetIpForwardEntry will fail. Routing protocol identifiers are used to identify route information for the specified routing protocol. For example, MIB_IPPROTO_NETMGMT is used to identify route information for IP  routing set through network management such as the Dynamic Host Configuration Protocol (DHCP), the Simple Network Management Protocol (SNMP), or by calls to the CreateIpForwardEntry,  DeleteIpForwardEntry, or SetIpForwardEntry functions. On Windows Vista and Windows Server 2008, the route metric specified in the dwForwardMetric1 member of the  MIB_IPFORWARDROW structure pointed to by pRoute parameter represents a combination of the route metric added to the interface metric specified in the Metric member of the MIB_IPINTERFACE_ROW structure of the associated interface.  So the dwForwardMetric1 member of the  MIB_IPFORWARDROW structure should be equal to or greater than Metric member of the associated MIB_IPINTERFACE_ROW structure. If an application would like to set the route metric to 0, then the dwForwardMetric1 member of the MIB_IPFORWARDROW structure  should be set equal to the value of the interface metric specified in the Metric member of the associated MIB_IPINTERFACE_ROW structure. An application can retrieve the interface metric by calling the GetIpInterfaceEntry function. On Windows Vista and Windows Server 2008, the SetIpForwardEntry function only works on interfaces with a single sub-interface (where the interface LUID and subinterface LUID are the same). The dwForwardIfIndex member of the MIB_IPFORWARDROW structure specifies the interface. The dwForwardAge member the MIB_IPFORWARDROW structure  pointed to by the route parameter is not currently used by SetIpForwardEntry. The dwForwardAge member is used only if the Routing and Remote Access Service (RRAS)is running, and then only for routes of type MIB_IPPROTO_NETMGMT as defined on the Protocol Identifiers reference page. When dwForwardAge is set to INFINITE, the route will not be removed based on a timeout   value. Any other value for dwForwardAge specifies the number of seconds until the TCP/IP stack will remove the route from the network routing table.  A route modified by SetIpForwardEntry will automatically have a default value for dwForwardAge of INFINITE. A number of members of the MIB_IPFORWARDROW structure  pointed to by the route parameter are not currently used by SetIpForwardEntry. These members include dwForwardPolicy, dwForwardType, dwForwardAge, dwForwardNextHopAS, dwForwardMetric1, dwForwardMetric2, dwForwardMetric3, dwForwardMetric4, and dwForwardMetric5. To create a new route in the IP routing table, use the  CreateIpForwardEntry function. To retrieve the IP routing table, call the GetIpForwardTable function. On Windows Vista and later, the SetIpForwardEntry function can only be called by a user logged on as a member of the Administrators group. If SetIpForwardEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following example demonstrates how to change the default gateway to NewGateway. Simply calling GetIpForwardTable, changing the gateway and then calling SetIpForwardEntry will not change the route, but rather will just add a new one. If for some reason there are multiple default gateways present, this code will delete them. Note that the new gateway must be viable; otherwise, TCP/IP will ignore the change.   Windows Vista and later:  When the DeleteIpForwardEntry function and then SetIpForwardEntry function are called for the same route table entry on Windows Vista and later, ERROR_NOT_FOUND is returned. The proper way to replicate this example on Windows Vista and later is to use the CreateIpForwardEntry function to create the new route table entry and then delete the old route table entry by calling the DeleteIpForwardEntry function. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetIpForwardEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPFORWARDROW",
        "name": "pRoute",
        "description": "A pointer to a  MIB_IPFORWARDROW structure that specifies the new information for the existing route. The caller must specify MIB_IPPROTO_NETMGMT for the dwForwardProto member of this structure. The caller must also specify values for the dwForwardIfIndex, dwForwardDest, dwForwardMask, dwForwardNextHop, and dwForwardPolicy members of the structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpForwardEntry2 function  sets the properties of an IP route entry on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetIpForwardEntry2 function is defined on Windows Vista and later. The SetIpForwardEntry2 function is used to set the properties for an existing IP route entry on a local computer. The DestinationPrefix member in the MIB_IPFORWARD_ROW2 structure pointed to by the Route parameter must be initialized to a valid IP address prefix and family. The NextHop member in the MIB_IPFORWARD_ROW2 structure pointed to by the Route parameter must be initialized to a valid IP address and family. In addition, at least one of the following members in the MIB_IPFORWARD_ROW2 structure pointed to the Route parameter must be initialized to the interface: the InterfaceLuid or InterfaceIndex.      The fields are used in the order listed above. So if the InterfaceLuid is specified, then this member is used to determine the interface on which to add the unicast IP address. If no value was set for the  InterfaceLuid member (the values of this member was set to zero), then the InterfaceIndex member is next used to determine the interface. The route metric offset specified in the Metric member of the  MIB_IPFORWARD_ROW2 structure pointed to by Route parameter represents only part of the complete route metric. The complete metric is a combination of this route metric  offset added to the interface metric specified in the Metric member of the MIB_IPINTERFACE_ROW structure of the associated interface.  An application can retrieve the interface metric by calling the GetIpInterfaceEntry function. The Age and Origin members of the MIB_IPFORWARD_ROW2 structure pointed to by the Row are ignored when the  SetIpForwardEntry2 function is called. These members are set by the network stack and cannot be changed using the SetIpForwardEntry2 function. The SetIpForwardEntry2 function will fail if the  DestinationPrefix and NextHop members of the MIB_IPFORWARD_ROW2 pointed to by the Route parameter do not match an IP route entry on the interface specified. The SetIpForwardEntry2 function can only be called by a user logged on as a member of the Administrators group. If SetIpForwardEntry2 is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIpForwardEntry2 function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "SetIpForwardEntry2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const MIB_IPFORWARD_ROW2*",
        "name": "Route",
        "description": "A pointer to a  MIB_IPFORWARD_ROW2 structure entry for an IP route entry. The DestinationPrefix member of the MIB_IPFORWARD_ROW2 must be set to a valid IP destination prefix, the NextHop member of the MIB_IPFORWARD_ROW2 must be set to a valid IP address family and IP address,   and the InterfaceLuid or the  InterfaceIndex member of the MIB_IPFORWARD_ROW2 must be specified."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetIpStatistics function toggles IP forwarding on or off and sets the default time-to-live (TTL) value for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To set only the default TTL, the caller can also use the  SetIpTTL function. On Windows Vista and later, the SetIpStatistics function can only be called by a user logged on as a member of the Administrators group. If SetIpStatistics is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIpStatistics function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetIpStatistics",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPSTATS",
        "name": "pIpStats",
        "description": "A pointer to a  MIB_IPSTATS structure. The caller should set the dwForwarding and dwDefaultTTL members of this structure to the new values. To keep one of the members at its current value, use MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  SetIpStatisticsEx function toggles IP forwarding on or off and sets the default time-to-live (TTL) value for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "To set only the default TTL, the caller can also use the  SetIpTTL function. The SetIpStatisticsEx function can only be called by a user logged on as a member of the Administrators group. If SetIpStatisticsEx is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetIpStatisticsEx function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetIpStatisticsEx",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_IPSTATS",
        "name": "pIpStats",
        "description": "A pointer to a  MIB_IPSTATS structure. The caller should set the dwForwarding and dwDefaultTTL members of this structure to the new values. To keep one of the members at its current value, use MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "Family",
        "description": "The address family for which forwarding and TTL is to be set.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, and AF_INET6.  ValueMeaning  AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  sets forwarding and TTL options for IPv4 entries.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  sets forwarding and TTL options for IPv6 entries."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  UnenableRouter function decrements the reference count that tracks the number of requests to enable IPv4 forwarding. When this reference count reaches zero,  UnenableRouter turns off IPv4 forwarding on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "The UnenableRouter function is specific to IPv4 forwarding. Each call that a process makes to  UnenableRouter must correspond to a previous call to  EnableRouter by the same process. The system returns an error on extraneous calls to  UnenableRouter. As a result, a given process is not able to decrement the reference count that tracks the number of requests for enabling IPv4 forwarding for another process. Also, if IPv4 forwarding was enabled by a given process, it cannot be disabled by a different process. It is not possible to accurately determine the reference count that tracks the number of requests for enabling IPv4 forwarding since there might be other outstanding EnableRouter requests.         So the value returned for the lpdwEnableCountparmameter is always  a large count equal to ULONG_MAX/2. If the process that calls  EnableRouter terminates without calling  UnenableRouter, the system  decrements the reference count that tracks requests to enable  IPv4 forwarding as though the process had called  UnenableRouter. After calling the  UnenableRouter, use the  CloseHandle call to close the handle to the event object in the  OVERLAPPED structure. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "UnenableRouter",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "OVERLAPPED*",
        "name": "pOverlapped",
        "description": "A pointer to an OVERLAPPED structure. This structure should be the same as the one used in the call to  the EnableRouter function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpdwEnableCount",
        "description": "An optional pointer to a DWORD variable. This variable receives the number of references remaining."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  FreeMibTable function  frees the buffer allocated by the functions that return tables of network interfaces, addresses, and routes (GetIfTable2 and GetAnycastIpAddressTable, for example).",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The FreeMibTable function is defined on Windows Vista and later. The FreeMibTable function is used to free the internal buffers used by various functions to retrieve tables of interfaces, addresses, and routes. When these tables are no longer needed, then FreeMibTable should be called to release the memory used by these tables. ",
    "return_type": "VOID NETIOAPI_API_",
    "category": "IP Helper",
    "name": "FreeMibTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Memory",
        "description": "A pointer to the buffer to free."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertIpv4MaskToLength function converts an IPv4 subnet mask to an IPv4  prefix length.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertIpv4MaskToLength returns NO_ERROR. Any nonzero return value indicates failure.  ",
    "remarks": "The ConvertIpv4MaskToLength function is available on Windows Vista       and later. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertIpv4MaskToLength",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Mask",
        "description": "The IPv4 subnet mask."
      },
      {
        "in_out": "_Out_",
        "type": "PUINT8",
        "name": "MaskLength",
        "description": "A pointer to a UINT8 value to hold the IPv4 prefix length, in bits, when the function returns successfully."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  ConvertLengthToIpv4Mask function converts an IPv4  prefix length to an IPv4 subnet mask.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "On success,  ConvertLengthToIpv4Mask returns NO_ERROR. Any nonzero return value indicates failure and the Mask parameter is set to INADDR_NONE defined in the Ws2def.h header file.  ",
    "remarks": "The ConvertLengthToIpv4Mask function is available on Windows Vista       and later. ",
    "return_type": "NETIO_STATUS",
    "category": "IP Helper",
    "name": "ConvertLengthToIpv4Mask",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaskLength",
        "description": "The IPv4 prefix length, in bits."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "Mask",
        "description": "A pointer to a LONG value to hold the IPv4 subnet mask when the function returns successfully."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The  CreateSortedAddressPairs function  takes a supplied list of potential IP destination addresses, pairs the destination addresses with the host machine's local IP addresses, and sorts the pairs according to which address     pair is best suited for communication between the two peers.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreateSortedAddressPairs function is defined on Windows Vista and later. The CreateSortedAddressPairs function takes a list of source and destination IPv6 addresses, and returns a list of     pairs of addresses in sorted order.  The list is sorted by which address     pair is best suited for communication between the source and destination address. The list of source addresses pointed to by the SourceAddressList is currently reserved for future and must be a NULL pointer. The SourceAddressCount is currently reserved for future and must be zero. The CreateSortedAddressPairs function currently  uses all of the host machine's local addresses for the source address list. The list of destination addresses is pointed to by the DestinationAddressList parameter. The list of destination addresses is an array of SOCKADDR_IN6 structures.  Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node. For more information on the IPv4-mapped IPv6 address format, see Dual-Stack Sockets. The DestinationAddressCount parameter contains the number of destination addresses pointed to by the DestinationAddressList parameter. The CreateSortedAddressPairs function supports a maximum of 500 destination addresses. If the CreateSortedAddressPairs function is successful, the SortedAddressPairList parameter points to an array of SOCKADDR_IN6_PAIR structures that contain the sorted address pairs. When this returned list is no longer required, free the memory used by the list by calling the FreeMibTable function. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "CreateSortedAddressPairs",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "const PSOCKADDR_IN6",
        "name": "SourceAddressList",
        "description": "Must be NULL. Reserved for future use."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SourceAddressCount",
        "description": "Must be 0. Reserved for future use."
      },
      {
        "in_out": "_In_",
        "type": "const PSOCKADDR_IN6",
        "name": "DestinationAddressList",
        "description": "A pointer to an array of SOCKADDR_IN6 structures that contain a list of potential IPv6 destination addresses.         Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DestinationAddressCount",
        "description": "The number of destination addresses pointed to by the DestinationAddressList parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AddressSortOptions",
        "description": "Reserved for future use."
      },
      {
        "in_out": "_Out_",
        "type": "PSOCKADDR_IN6_PAIR*",
        "name": "SortedAddressPairList",
        "description": "A pointer to store an array of SOCKADDR_IN6_PAIR structures that contain a list of pairs of IPv6 addresses         sorted in the preferred order of communication, if the function call is successful."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "SortedAddressPairCount",
        "description": "A pointer to store the number of address pairs pointed to by the SortedAddressPairList parameter, if the function call is successful."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  ParseNetworkString function  parses the input network string and checks whether it     is a legal representation of the specified IP network string type. If the string matches a type and its specification,     the function can optionally return the parsed result.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The ParseNetworkString function parses the input network string passed in the NetworkString parameter and checks whether it     is a legal representation of one of the string types as specified in      the Types argument. If the string matches a type and its specification,     the function succeeds and can optionally return the parsed result     to the caller in the optional AddressInfo, PortNumber, and PrefixLength parameters when these parameters are not NULL pointers. The ParseNetworkString function can parse representations of IPv4 or IPv6 addresses,      services, and networks, as well as named Internet addresses and      services using DNS names. The SOCKADDR_IN,  SOCKADDR_IN6, and  SOCKADDR structures are used in the NET_ADDRESS_INFO structure pointed to by the AddressInfo parameter. The SOCKADDR_IN and SOCKADDR structures are defined in the  Ws2def.h header file which is automatically included by the Winsock2.h header file. The SOCKADDR_IN6 structure is defined in the Ws2ipdef.h header file which is automatically included by the Ws2tcpip.h header file. In order to use the ParseNetworkString function  and the NET_ADDRESS_INFO structure, the Winsock2.h and Ws2tcpip.h header files must be included before the Iphlpapi.h header file. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "ParseNetworkString",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const WCHAR*",
        "name": "NetworkString",
        "description": "A pointer to the NULL-terminated network string to parse."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Types",
        "description": "The type of IP network string to parse. This parameter consists of one of network string types as defined in the Iphlpapi.h          header file.  ValueMeaning  NET_STRING_IPV4_ADDRESS 0x00000001   The NetworkString parameter  points to an IPv4 address using Internet standard dotted-decimal notation.    A network port or prefix must not be present in the network string.  An example network string is the following: 192.168.100.10   NET_STRING_IPV4_SERVICE 0x00000002   The NetworkString parameter  points to an IPv4 service using Internet standard dotted-decimal notation.    A network port is required as part of the network string. A prefix must not be present in the network string.  An example network string is the following: 192.168.100.10:80   NET_STRING_IPV4_NETWORK 0x00000004   The NetworkString parameter  points to an IPv4 network using Internet standard dotted-decimal notation.    A network prefix that uses the Classless Inter-Domain Routing (CIDR) notation is required as part of the network string. A network port must not be present in the network string.  An example network string is the following: 192.168.100/24   NET_STRING_IPV6_ADDRESS 0x00000008   The NetworkString parameter  points to an IPv6 address using Internet standard hexadecimal encoding.    An IPv6 scope ID may be present in the network string. A network port or prefix must not be present in the network string.   An example network string is the following: 21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A%2   NET_STRING_IPV6_ADDRESS_NO_SCOPE 0x00000008   The NetworkString parameter  points to an IPv6 address using Internet standard hexadecimal encoding. An IPv6 scope ID must not be  present in the network string. A network port or prefix must not be present in the network string.   An example network string is the following: 21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A   NET_STRING_IPV6_SERVICE 0x00000020   The NetworkString parameter  points to an IPv6 service using Internet standard hexadecimal encoding.    A network port is required as part of the network string. An IPv6 scope ID may be present in the network string. A prefix must not be present in the network string.  An example network string with a scope ID is the following: [21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A%2]:8080   NET_STRING_IPV6_SERVICE_NO_SCOPE 0x00000040   The NetworkString parameter  points to an IPv6 service using Internet standard hexadecimal encoding.    A network port is required as part of the network string. An IPv6 scope ID must not be present in the network string. A prefix must not be present in the network string.  An example network string is the following: 21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A:8080   NET_STRING_IPV6_NETWORK 0x00000080   The NetworkString parameter  points to an IPv6 network using Internet standard hexadecimal encoding.    A network prefix in CIDR notation is required as part of the network string. A network port or scope ID must not be present in the network string.  An example network string is the following: 21DA:D3::/48   NET_STRING_NAMED_ADDRESS 0x00000100   The NetworkString parameter  points to an Internet address using a Domain Name System (DNS) name.    A network port or prefix must not be present in the network string.  An example network string is the following: www.microsoft.com   NET_STRING_NAMED_SERVICE 0x00000200   The NetworkString parameter  points to an Internet service using a DNS name.    A network port must be present in the network string.  An example network string is the following: www.microsoft.com:80   NET_STRING_IP_ADDRESS 0x00000009   The NetworkString parameter  points to an IPv4 address using Internet standard dotted-decimal notation or an IPv6 address using the Internet standard hexadecimal encoding.    An IPv6 scope ID may be present in the network string. A network port or prefix must not be present in the network string.   This type matches either the NET_STRING_IPV4_ADDRESS or NET_STRING_IPV6_ADDRESS types.   NET_STRING_IP_ADDRESS_NO_SCOPE 0x00000011   The NetworkString parameter  points to an IPv4 address using Internet standard dotted-decimal notation or an IPv6 address using Internet standard hexadecimal encoding.    An IPv6 scope ID must not be present in the network string. A network port or prefix must not be present in the network string.   This type matches either the NET_STRING_IPV4_ADDRESS or NET_STRING_IPV6_ADDRESS_NO_SCOPE types.   NET_STRING_IP_SERVICE 0x00000022   The NetworkString parameter  points to an IPv4 service or IPv6 service.    A network port is required as part of the network string. An IPv6 scope ID may be present in the network string. A prefix must not be present in the network string.  This type matches either the NET_STRING_IPV4_SERVICE or NET_STRING_IPV6_SERVICE types.   NET_STRING_IP_SERVICE_NO_SCOPE 0x00000042   The NetworkString parameter  points to an IPv4 service or IPv6 service.    A network port is required as part of the network string. An IPv6 scope ID must not be present in the network string. A prefix must not be present in the network string.  This type matches either the NET_STRING_IPV4_SERVICE or NET_STRING_IPV6_SERVICE_NO_SCOPE types.   NET_STRING_IP_NETWORK 0x00000084   The NetworkString parameter  points to an IPv4 or IPv6 network.    A network prefix in CIDR notation is required as part of the network string. A network port or scope ID must not be present in the network.  This type matches either the NET_STRING_IPV4_NETWORK or NET_STRING_IPV6_NETWORK types.   NET_STRING_ANY_ADDRESS 0x00000209   The NetworkString parameter  points to an IPv4 address in Internet standard dotted-decimal notation, an IPv6 address in Internet standard hexadecimal encoding, or a DNS name.    An IPv6 scope ID may be present in the network string for an IPv6 address. A network port or prefix must not be present in the network string.   This type matches either the NET_STRING_NAMED_ADDRESS or NET_STRING_IP_ADDRESS types.   NET_STRING_ANY_ADDRESS_NO_SCOPE 0x00000211   The NetworkString parameter  points to an IPv4 address in Internet standard dotted-decimal notation, an IPv6 address in Internet standard hexadecimal encoding, or a DNS name.    An IPv6 scope ID must not be present in the network string for an IPv6 address. A network port or prefix must not be present in the network string.   This type matches either the NET_STRING_NAMED_ADDRESS or NET_STRING_IP_ADDRESS_NO_SCOPE types.   NET_STRING_ANY_SERVICE 0x00000222   The NetworkString parameter  points to an IPv4 service or IPv6 service using IP address notation or a DNS name.    A network port is required as part of the network string. An IPv6 scope ID may be present in the network string. A prefix must not be present in the network string.  This type matches either the NET_STRING_NAMED_SERVICE or NET_STRING_IP_SERVICE types.   NET_STRING_ANY_SERVICE_NO_SCOPE 0x00000242   The NetworkString parameter  points to an IPv4 service or IPv6 service using IP address notation or a DNS name.    A network port is required as part of the network string. An IPv6 scope ID must not be present in the network string. A prefix must not be present in the network string.  This type matches either the NET_STRING_NAMED_SERVICE or NET_STRING_IP_SERVICE_NO_SCOPE types."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PNET_ADDRESS_INFO",
        "name": "AddressInfo",
        "description": "On success, the function returns a pointer to a NET_ADDRESS_INFO structure that contains the parsed IP address information if a NULL pointer was not passed in this parameter."
      },
      {
        "in_out": "_Out_opt_",
        "type": "USHORT*",
        "name": "PortNumber",
        "description": "On success, the function returns a pointer to the parsed network port in host order if a NULL pointer was not passed in this parameter. If a network port was not present in the NetworkString parameter, then a pointer to a value of zero is returned."
      },
      {
        "in_out": "_Out_opt_",
        "type": "BYTE*",
        "name": "PrefixLength",
        "description": "On success, the function returns a pointer to the parsed prefix length if a NULL pointer was not passed in this parameter. If a prefix was not present in the NetworkString parameter, then a pointer to a value of -1 is returned."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetNetworkParams function retrieves network parameters for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetNetworkParams function is used to retrieve  network parameters for the local computer. Network parameters are returned  in a FIXED_INFO \t\tstructure. The  memory for the FIXED_INFO \t\tstructure must be allocated by the application. It is the responsibility of the application to free this memory when it is no longer needed. In the Microsoft Windows Software Development Kit (SDK), the FIXED_INFO_WIN2KSP1 structure is defined.   When compiling an       application if the target platform is Windows 2000 with Service Pack 1 (SP1) and later (NTDDI_VERSION >= NTDDI_WIN2KSP1,       _WIN32_WINNT >= 0x0501, or       WINVER >= 0x0501), the FIXED_INFO_WIN2KSP1 struct is typedefed to the FIXED_INFO structure. When compiling an application if the target       platform is not Windows 2000 with SP1 and later, the       FIXED_INFO structure is undefined. The GetNetworkParams function and the       FIXED_INFO structure are supported on  Windows 98   and later. But to build an application for a target platform earlier than Windows 2000 with Service Pack 1 (SP1), an earlier version of the Platform Software Development Kit (SDK)  must be used. The following example retrieves the network parameters for the local computer and prints information from the returned data. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetNetworkParams",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PFIXED_INFO",
        "name": "pFixedInfo",
        "description": "A pointer to a  buffer that contains a FIXED_INFO structure that receives the network parameters for the local computer, if the function was successful. This buffer must be allocated by the caller prior to calling the GetNetworkParams function."
      },
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "pOutBufLen",
        "description": "A pointer to a ULONG variable that specifies the size of the  FIXED_INFO structure. If this size is insufficient to hold the information,  GetNetworkParams fills in this variable with the required size, and returns an error code of ERROR_BUFFER_OVERFLOW."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CancelMibChangeNotify2 function deregisters for change notifications for IP interface changes, IP address changes, IP route changes, Teredo port changes, and when the unicast IP address table is stable and can be retrieved.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CancelMibChangeNotify2 function is defined on Windows Vista and later. The   CancelMibChangeNotify2 function deregisters for a change notification previously requested for IP interface changes, IP  address changes, IP route changes, or Teredo port changes on  a local computer. These requests are made  by calling NotifyIpInterfaceChange, NotifyUnicastIpAddressChange, NotifyRouteChange2,  or NotifyTeredoPortChange. The   CancelMibChangeNotify2 function also cancels a previous request to be notified when the unicast IP address table is stable on a local computer and can be  retrieved. This request is made by calling the NotifyStableUnicastIpAddressTable function. The NotificationHandle parameter returned to these notification functions is passed to CancelMibChangeNotify2 to deregister for notifications or cancel a pending request to retrieve the stable unicast IP address table. An application cannot make a call to the CancelMibChangeNotify2 function from the context of the thread which is currently executing the notification callback function for the same NotificationHandle parameter. Otherwise, the thread executing that callback will result in deadlock. So the CancelMibChangeNotify2 function must not be called directly as part of the notification callback routine. In a more general situation, a thread that executes the CancelMibChangeNotify2 function cannot own a resource on which the thread that executes a notification callback operation would wait because it would result in a similar deadlock. The CancelMibChangeNotify2 function should be called from a different thread, on which the thread that receives the notification callback doesn't have dependencies on. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "CancelMibChangeNotify2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "NotificationHandle",
        "description": "The handle returned from a notification          registration or retrieval function to indicate which notification to cancel."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  NotifyAddrChange function causes a notification to be sent to the caller whenever a change occurs in the table that maps IPv4 addresses to interfaces.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR if the caller specifies NULL for the Handle and overlapped parameters. If the caller specifies non-NULL parameters, the return value for success is ERROR_IO_PENDING. If the function fails, use  FormatMessage to obtain the message string for the returned error.  ",
    "remarks": "The   NotifyAddrChange function may be called in two ways: If the caller specifies NULL for the Handle and overlapped parameters, the call to  NotifyAddrChange is synchronous and will block until an IP address change occurs. In this case if a change occurs, the NotifyAddrChange function completes to indicate that a change has occurred. If the NotifyAddrChange function is called synchronously, a notification will be sent on the next IPv4 address change until the application terminates. If the caller specifies a handle variable and an  OVERLAPPED structure, then the NotifyAddrChange function call is asynchronous and the caller can use the returned handle with the OVERLAPPED structure to receive asynchronous notification of IPv4 address changes using the GetOverlappedResult function. See the following topics for information about using the handle and  OVERLAPPED structure to receive notifications: The CancelIPChangeNotify function cancels notification of IPv4 address and route changes previously requested with successful calls to the NotifyAddrChange or NotifyRouteChange functions. Once an application has been notified of a change, the application can then call the GetIpAddrTable or GetAdaptersAddresses function to retrieve the table of IPv4 addresses to determine what has changed. If the application is notified and requires notification for the next change, then the NotifyAddrChange function must be called again. If the NotifyAddrChange function is called asynchronously, a notification will be sent on the next IPv4 address change until either the application cancels the notification by calling the CancelIPChangeNotify function or the application terminates. If the application terminates, the system will automatically cancel the registration for the notification. It is still recommended that an application explicitly cancel any notification before it terminates. Any registration for a notification does not persist across a system shut down or reboot. On Windows Vista and later, the  NotifyIpInterfaceChange function  can be used to  register to be notified for changes to IPv4 and IPv6 interfaces on  the local computer. The following example waits for a change to occur in the table that maps IP addresses to interfaces. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "NotifyAddrChange",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Handle",
        "description": "A pointer to a HANDLE variable that receives a file handle for use in a subsequent call to the GetOverlappedResult function.  Warning  Do not close this handle, and do not associate it with a completion port."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "overlapped",
        "description": "A pointer to an  OVERLAPPED structure that  notifies the caller of any changes in the table that maps IP addresses to interfaces."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  NotifyIpInterfaceChange function  registers to be notified for changes to all IP interfaces, IPv4 interfaces, or IPv6 interfaces on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The NotifyIpInterfaceChange function is defined on Windows Vista and later. The Family parameter must be set to either AF_INET, AF_INET6, or AF_UNSPEC. The invocation of the callback function specified in the Callback parameter is serialized. The callback function should be defined as a function of type VOID. The parameters passed to the callback function include the following:   The callback function specified in the Callback parameter must be implemented in the same process as the application calling the NotifyIpInterfaceChange function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the NotifyIpInterfaceChange function to register for change notifications. When the callback function is received when a change occurs and the Row parameter is not NULL, the pointer to the MIB_IPINTERFACE_ROW structure passed in the Row parameter contains incomplete data. The  information returned in the MIB_IPINTERFACE_ROW structure is only enough information that an application can call the GetIpInterfaceEntry function to query complete information on the IP interface that changed. When the callback function is received, an application should allocate a MIB_IPINTERFACE_ROW structure and initialize it with the Family,  InterfaceLuid and InterfaceIndex members in the MIB_IPINTERFACE_ROW structure pointed to by the Row parameter received. A pointer to this newly initialized MIB_IPINTERFACE_ROW structure should be passed to the GetIpInterfaceEntry function to retrieve complete information on the IP interface that was changed. The memory pointed to by the Row parameter used in the callback indications is managed by the operating system.  An application that receives a notification should never attempt to free the memory pointed to by the Row parameter. To deregister for change notifications, call the  CancelMibChangeNotify2 function passing the NotificationHandle parameter returned by  NotifyIpInterfaceChange. An application cannot make a call to the CancelMibChangeNotify2 function from the context of the thread which is currently executing the notification callback function for the same NotificationHandle parameter. Otherwise, the thread executing that callback will result in deadlock. So the CancelMibChangeNotify2 function must not be called directly as part of the notification callback routine. In a more general situation, a thread that executes the CancelMibChangeNotify2 function cannot own a resource on which the thread that executes a notification callback operation would wait because it would result in a similar deadlock. The CancelMibChangeNotify2 function should be called from a different thread, on which the thread that receives the notification callback doesn't have dependencies on. Once the NotifyIpInterfaceChange function is called to register for change notifications, these notifications will continue to be sent until the application deregisters for change notifications or the application terminates. If the application terminates, the system will automatically deregister any registration for change notifications. It is still recommended that an application explicitly deregister for change notifications before it terminates. Any registration for change notifications does not persist across a system shut down or reboot. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "NotifyIpInterfaceChange",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family on which to register for change notifications. Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_UNSPEC 0   The address family is unspecified. When this parameter is specified,  this function registers for both IPv4 and IPv6 change notifications.   AF_INET 2    The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function register for only IPv4 change notifications.   AF_INET6 23    The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function registers for only IPv6 change notifications."
      },
      {
        "in_out": "_In_",
        "type": "PIPINTERFACE_CHANGE_CALLBACK",
        "name": "Callback",
        "description": "A pointer to the function to call when a change occurs. This function will be invoked         when an interface notification is received."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CallerContext",
        "description": "A user context passed to the callback function specified in the Callback parameter when an interface notification is received."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InitialNotification",
        "description": "A value that indicates whether the callback should be invoked         immediately after registration for change notification completes. This initial notification does not indicate a change occurred to an IP interface. The purpose of this parameter to provide confirmation that the callback is registered."
      },
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "NotificationHandle",
        "description": "A pointer used to return a handle that can be later used to         deregister the change notification. On success, a notification handle is returned in this parameter. If an error occurs, NULL is returned."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  NotifyRouteChange function causes a notification to be sent to the caller whenever a change occurs in the IPv4 routing table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR if the caller specifies NULL for the Handle and overlapped parameters. If the caller specifies non-NULL parameters, the return value for success is ERROR_IO_PENDING. If the function fails, use  FormatMessage to obtain the message string for the returned error.  ",
    "remarks": "The   NotifyRouteChange function may be called in two ways: If the caller specifies NULL for the Handle and overlapped parameters, the call to  NotifyRouteChange is synchronous and will block until  an IPv4 routing table change occurs. In this case if a change occurs, the NotifyRouteChange function completes to indicate that a change has occurred. If the NotifyRouteChange function is called synchronously, a notification will be sent on the next IPv4 routing change until the application terminates. If the caller specifies a handle variable and an  OVERLAPPED structure, the caller can use the returned handle with the OVERLAPPED structure to receive asynchronous notification of IPv4 routing table changes. See the following topics for information about using the handle and  OVERLAPPED structure to receive notifications: If the application receives a notification and requires notification for the next change, then the NotifyRouteChange function must be called again. The CancelIPChangeNotify function cancels notification of IP address and route changes previously requested with successful calls to the NotifyAddrChange or NotifyRouteChange functions. Once an application has been notified of a change, the application can then call the GetIpForwardTable or GetIpForwardTable2 function to retrieve the IPv4 routing table to determine what has changed. If the application is notified and requires notification for the next change, then the NotifyRouteChange function must be called again. If the NotifyRouteChange function is called asynchronously, a notification will be sent on the next IPv4 route change until either the application cancels the notification by calling the CancelIPChangeNotify function or the application terminates. If the application terminates, the system will automatically cancel the registration for the notification. It is still recommended that an application explicitly cancel any notification before it terminates. Any registration for a notification does not persist across a system shut down or reboot. On Windows Vista and later, the  NotifyRouteChange2 function  can be used to  register to be notified for changes to the IPv6 routing table  on the local computer. The following example waits for a change to occur in the IP routing table. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "NotifyRouteChange",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Handle",
        "description": "A pointer to a HANDLE variable that receives a handle to use in asynchronous notification."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "overlapped",
        "description": "A pointer to an  OVERLAPPED structure that  notifies the caller of any changes in the routing table."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  NotifyRouteChange2 function  registers to be notified for changes to IP route entries  on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The NotifyRouteChange2 function is defined on Windows Vista and later. The Family parameter must be set to either AF_INET, AF_INET6, or AF_UNSPEC. The invocation of the callback function specified in the Callback parameter is serialized. The callback function should be defined as a function of type VOID. The parameters passed to the callback function include the following:   The callback function specified in the Callback parameter must be implemented in the same process as the application calling the NotifyRouteChange2 function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the NotifyRouteChange2 function to register for change notifications. When the callback function is received when a change occurs and the Row parameter is not NULL, the pointer to the MIB_IPFORWARD_ROW2 structure passed in the Row parameter contains incomplete data. The  information returned in the MIB_IPFORWARD_ROW2 structure is only enough information that an application can call the GetIpForwardEntry2  function to query complete information on the IP route that changed. When the callback function is received, an application should allocate a MIB_IPFORWARD_ROW2 structure and initialize it with the DestinationPrefix,  NextHop,  InterfaceLuid and InterfaceIndex members in the MIB_IPFORWARD_ROW2 structure pointed to by the Row parameter received. A pointer to this newly initialized MIB_IPFORWARD_ROW2 structure should be passed to the GetIpForwardEntry2 function to retrieve complete information on the IP route that was changed. The memory pointed to by the Row parameter used in the callback indications is managed by the operating system.  An application that receives a notification should never attempt to free the memory pointed to by the Row parameter. Once the NotifyRouteChange2 function is called to register for change notifications, these notifications will continue to be sent until the application deregisters for change notifications or the application terminates. If the application terminates, the system will automatically deregister any registration for change notifications. It is still recommended that an application explicitly deregister for change notifications before it terminates. Any registration for change notifications does not persist if the system is shutdown or rebooted. To deregister for change notifications, call the  CancelMibChangeNotify2 function passing the NotificationHandle parameter returned by  NotifyRouteChange2. An application cannot make a call to the CancelMibChangeNotify2 function from the context of the thread which is currently executing the notification callback function for the same NotificationHandle parameter. Otherwise, the thread executing that callback will result in deadlock. So the CancelMibChangeNotify2 function must not be called directly as part of the notification callback routine. In a more general situation, a thread that executes the CancelMibChangeNotify2 function cannot own a resource on which the thread that executes a notification callback operation would wait because it would result in a similar deadlock. The CancelMibChangeNotify2 function should be called from a different thread, on which the thread that receives the notification callback doesn't have dependencies on. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "NotifyRouteChange2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family on which to register for change notifications.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_INET    Register for only IPv4 route  change notifications.   AF_INET6    Register for only IPv6 route  change notifications.   AF_UNSPEC    Register for both IPv4 and IPv6 route change notifications."
      },
      {
        "in_out": "_In_",
        "type": "PIPFORWARD_CHANGE_CALLBACK",
        "name": "Callback",
        "description": "A pointer to the function to call when a change occurs. This function will be invoked         when an IP route notification is received."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CallerContext",
        "description": "A user context passed to the callback function specified in the Callback parameter when an interface notification is received."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InitialNotification",
        "description": "A value that indicates whether the callback should be invoked         immediately after registration for change notification completes. This initial notification does not indicate a change occurred to an IP route entry. The purpose of this parameter to provide confirmation that the callback is registered."
      },
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "NotificationHandle",
        "description": "A pointer used to return a handle that can be later used to         deregister the change notification. On success, a notification handle is returned in this parameter. If an error occurs, NULL is returned."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  NotifyUnicastIpAddressChange function  registers to be notified for changes to all unicast IP interfaces, unicast IPv4 addresses, or unicast IPv6 addresses on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The NotifyUnicastIpAddressChange function is defined on Windows Vista and later. The Family parameter must be set to either AF_INET, AF_INET6, or AF_UNSPEC. The invocation of the callback function specified in the Callback parameter is serialized. The callback function should be defined as a function of type VOID. The parameters passed to the callback function include the following:   The callback function specified in the Callback parameter must be implemented in the same process as the application calling the NotifyUnicastIpAddressChange function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the NotifyUnicastIpAddressChange function to register for change notifications. When the callback function is received when a change occurs and the Row parameter is not NULL, the pointer to the MIB_UNICASTIPADDRESS_ROW structure passed in the Row parameter contains incomplete data. The  information returned in the MIB_UNICASTIPADDRESS_ROW structure is only enough information that an application can call the GetUnicastIpAddressEntry function to query complete information on the IP address that changed. When the callback function is received, an application should allocate a MIB_UNICASTIPADDRESS_ROW structure and initialize it with the Address,  InterfaceLuid and InterfaceIndex members in the MIB_UNICASTIPADDRESS_ROW structure pointed to by the Row parameter received. A pointer to this newly initialized MIB_UNICASTIPADDRESS_ROW structure should be passed to the GetUnicastIpAddressEntry function to retrieve complete information on the unicast IP address that was changed. The memory pointed to by the Row parameter used in the callback indications is managed by the operating system.  An application that receives a notification should never attempt to free the memory pointed to by the Row parameter. Once the NotifyUnicastIpAddressChange function is called to register for change notifications, these notifications will continue to be sent until the application deregisters for change notifications or the application terminates. If the application terminates, the system will automatically deregister any registration for change notifications. It is still recommended that an application explicitly deregister for change notifications before it terminates. Any registration for change notifications does not persist if the system is shutdown or rebooted. To deregister for change notifications, call the  CancelMibChangeNotify2 function passing the NotificationHandle parameter returned by  NotifyUnicastIpAddressChange. An application cannot make a call to the CancelMibChangeNotify2 function from the context of the thread which is currently executing the notification callback function for the same NotificationHandle parameter. Otherwise, the thread executing that callback will result in deadlock. So the CancelMibChangeNotify2 function must not be called directly as part of the notification callback routine. In a more general situation, a thread that executes the CancelMibChangeNotify2 function cannot own a resource on which the thread that executes a notification callback operation would wait because it would result in a similar deadlock. The CancelMibChangeNotify2 function should be called from a different thread, on which the thread that receives the notification callback doesn't have dependencies on. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "NotifyUnicastIpAddressChange",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ADDRESS_FAMILY",
        "name": "Family",
        "description": "The address family on which to register for change notifications.  Possible values for the address family are listed in the Winsock2.h header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET, AF_INET6, and AF_UNSPEC.  ValueMeaning  AF_INET    Register for only unicast IPv4 address change notifications.   AF_INET6    Register for only unicast IPv6 address change notifications.   AF_UNSPEC    Register for both unicast IPv4 and IPv6 address change notifications."
      },
      {
        "in_out": "_In_",
        "type": "PUNICAST_IPADDRESS_CHANGE_CALLBACK",
        "name": "Callback",
        "description": "A pointer to the function to call when a change occurs. This function will be invoked         when a unicast IP address notification is received."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CallerContext",
        "description": "A user context passed to the callback function specified in the Callback parameter when an interface notification is received."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InitialNotification",
        "description": "A value that indicates whether the callback should be invoked         immediately after registration for change notification completes. This initial notification does not indicate a change occurred to a unicast IP address. The purpose of this parameter to provide confirmation that the callback is registered."
      },
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "NotificationHandle",
        "description": "A pointer used to return a handle that can be later used to         deregister the change notification. On success, a notification handle is returned in this parameter. If an error occurs, NULL is returned."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  CreatePersistentTcpPortReservation function creates a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreatePersistentTcpPortReservation function is defined on Windows Vista and later. The CreatePersistentTcpPortReservation function is used to add a persistent reservation for a block of TCP ports. Applications and services which need to reserve ports fall into two categories. The first category includes components which need a particular port as part of their operation. Such components will generally prefer to specify their required port at installation time (in an application manifest, for example). The second category includes components which need any available port or block of ports at runtime.   These two categories correspond to specific and wildcard port reservation requests. Specific reservation requests may be persistent or runtime, while wildcard port reservation requests are only supported at runtime. The CreatePersistentTcpPortReservation function provides the ability for an application or service to reserve a persistent block of TCP ports.  Persistent TCP port reservations are recorded in a persistent store for the TCP module in Windows. A caller obtains a persistent port reservation by specifying how many ports are required and whether a specific range is needed. If the request can be satisfied, the CreatePersistentTcpPortReservation function returns a unique opaque ULONG64 token, which subsequently identifies the reservation. A persistent TCP port reservation may be released by calling the DeletePersistentTcpPortReservation function. Note that the token for a given persistent TCP port reservation may change each time the system is restarted. Windows does not implement inter-component security for persistent reservations obtained using these functions. This means that if a component is granted the ability to obtain any persistent port reservations, that component automatically gains the ability to consume any persistent port reservations granted to any other component on the system. Process-level security is enforced for runtime reservations, but such control cannot be extended to persistent port reservations created using the CreatePersistentTcpPortReservation or  CreatePersistentUdpPortReservation function. Once a persistent TCP port reservation has been obtained, an application can request port assignments from the TCP port reservation by opening a TCP socket, then calling the WSAIoctl function specifying the SIO_ASSOCIATE_PORT_RESERVATION IOCTL and passing the reservation token before issuing a call to the bind function on the socket. The SIO_ACQUIRE_PORT_RESERVATION IOCTL can be used to request a runtime reservation for a block of TCP or UDP ports. For runtime port reservations, the port pool requires that reservations be consumed from the process on whose socket the reservation was granted. Runtime port reservations last only as long as the lifetime of the socket on which the SIO_ACQUIRE_PORT_RESERVATION IOCTL was called.  In contrast, persistent port reservations created using the CreatePersistentTcpPortReservation function may be consumed by any process with the ability to obtain persistent reservations. The CreatePersistentTcpPortReservation function can only be called by a user logged on as a member of the Administrators group. If CreatePersistentTcpPortReservation is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following example creates a persistent TCP port reservation, then creates a socket and allocates a port from the port reservation, and then closes the socket and deletes the TCP port reservation. This example must be run by a user that is a member of the Administrators group. The simplest way to run this example is in an enhanced shell as the built-in Administrator (RunAs administrator). ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "CreatePersistentTcpPortReservation",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "StartPort",
        "description": "The starting TCP port number in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "NumberOfPorts",
        "description": "The number of TCP port numbers to reserve."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "Token",
        "description": "A pointer to a port reservation token that is returned if the function succeeds."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  CreatePersistentUdpPortReservation function creates a persistent UDP port reservation for a consecutive block of UDP ports on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The CreatePersistentUdpPortReservation function is defined on Windows Vista and later. The CreatePersistentUdpPortReservation function is used to add a persistent reservation for a block of UDP ports. Applications and services which need to reserve ports fall into two categories. The first category includes components which need a particular port as part of their operation. Such components will generally prefer to specify their required port at installation time (in an application manifest, for example). The second category includes components which need any available port or block of ports at runtime.   These two categories correspond to specific and wildcard port reservation requests. Specific reservation requests may be persistent or runtime, while wildcard port reservation requests are only supported at runtime. The CreatePersistentUdpPortReservation function provides the ability for an application or service to reserve persistently a block of UDP ports.  Persistent TCP reservations are recorded in a persistent store for the UDP module in Windows. A caller obtains a persistent port reservation by specifying how many ports are required and whether a specific range is needed. If the request can be satisfied, the CreatePersistentUdpPortReservation function returns a unique opaque ULONG64 token, which subsequently identifies the reservation. A persistent UDP port reservation may be released by calling the DeletePersistentUdpPortReservation function. Note that the token for a given persistent UDP port reservation may change each time the system is restarted. Windows does not implement inter-component security for persistent reservations obtained using these functions. This means that if a component is granted the ability to obtain any persistent port reservations, that component automatically gains the ability to consume any persistent port reservations granted to any other component on the system. Process-level security is enforced for runtime reservations, but such control cannot be extended to persistent reservations created using the created using the CreatePersistentTcpPortReservation or  CreatePersistentUdpPortReservation function. Once a persistent UDP port reservation has been obtained, an application can request port assignments from the UDP port reservation by opening a UDP socket, then calling the WSAIoctl function specifying the SIO_ASSOCIATE_PORT_RESERVATION IOCTL and passing the reservation token before issuing a call to the bind function on the socket. The SIO_ACQUIRE_PORT_RESERVATION IOCTL can be used to request a runtime reservation for a block of TCP or UDP ports. For runtime port reservations, the port pool requires that reservations be consumed from the process on whose socket the reservation was granted. Runtime port reservations last only as long as the lifetime of the socket on which the SIO_ACQUIRE_PORT_RESERVATION IOCTL was called.  In contrast, persistent port reservations created using the CreatePersistentUdpPortReservation function may be consumed by any process with the ability to obtain persistent reservations. The CreatePersistentUdpPortReservation function can only be called by a user logged on as a member of the Administrators group. If CreatePersistentUdpPortReservation is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "CreatePersistentUdpPortReservation",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "StartPort",
        "description": "The starting UDP port number in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "NumberOfPorts",
        "description": "The number of UDP port numbers to reserve."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "Token",
        "description": "A pointer to a port reservation token that is returned if the function succeeds."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  DeletePersistentTcpPortReservation function deletes a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The DeletePersistentTcpPortReservation function is defined on Windows Vista and later. The DeletePersistentTcpPortReservation function is used to delete a persistent reservation for a block of TCP ports. The DeletePersistentTcpPortReservation function can only be called by a user logged on as a member of the Administrators group. If DeletePersistentTcpPortReservation is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. The following example deletes a persistent TCP port reservation. This example must be run by a user that is a member of the Administrators group. The simplest way to run this example is in an enhanced shell as the built-in Administrator (RunAs administrator). ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "DeletePersistentTcpPortReservation",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "StartPort",
        "description": "The starting TCP port number in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "NumberOfPorts",
        "description": "The number of TCP port numbers to delete."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  DeletePersistentUdpPortReservation function deletes a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The DeletePersistentUdpPortReservation function is defined on Windows Vista and later. The DeletePersistentUdpPortReservation function is used to delete a persistent reservation for a block of UDP ports. The DeletePersistentUdpPortReservation function can only be called by a user logged on as a member of the Administrators group. If DeletePersistentUdpPortReservation is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "DeletePersistentUdpPortReservation",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "StartPort",
        "description": "The starting UDP port number in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "NumberOfPorts",
        "description": "The number of UDP port numbers to delete."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  LookupPersistentTcpPortReservation function looks up the token for a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The LookupPersistentTcpPortReservation  function is defined on Windows Vista and later. The LookupPersistentTcpPortReservation  function is used to lookup the token for a persistent reservation for a block of TCP ports. A persistent reservation for a block of TCP ports is  created by a call to the CreatePersistentTcpPortReservation function. The StartPort  or NumberOfPorts parameters passed to the LookupPersistentTcpPortReservation  function must match the values used when the persistent reservation for a block of TCP ports was created by  the CreatePersistentTcpPortReservation function. If the LookupPersistentTcpPortReservation function succeeds, the Token parameter returned will point to the token for the persistent port reservation for the block of TCP ports. Note that the token for a given persistent reservation for a block of TCP ports may change each time the system is restarted. An application can request port assignments from the TCP port reservation by opening a TCP socket, then calling the WSAIoctl function specifying the SIO_ASSOCIATE_PORT_RESERVATION IOCTL and passing the reservation token before issuing a call to the bind function on the socket. The following example looks up a persistent TCP port reservation and then creates a socket and allocates a port from the port reservation. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "LookupPersistentTcpPortReservation",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "StartPort",
        "description": "The starting TCP port number in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "NumberOfPorts",
        "description": "The number of TCP port numbers  that were reserved."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "Token",
        "description": "A pointer to a port reservation token that is returned if the function succeeds."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  LookupPersistentUdpPortReservation function looks up the token for a persistent UDP port reservation for a consecutive block of TCP ports on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The LookupPersistentUdpPortReservation  function is defined on Windows Vista and later. The LookupPersistentUdpPortReservation  function is used to lookup the token for a persistent reservation for a block of UDP ports. A persistent reservation for a block of UDP ports is  created by a call to the CreatePersistentUdpPortReservation function. The StartPort  or NumberOfPorts parameters passed to the LookupPersistentUdpPortReservation  function must match the values used when the persistent reservation for a block of TCP ports was created by  the CreatePersistentUdpPortReservation function. If the LookupPersistentUdpPortReservation function succeeds, the Token parameter returned will point to the token for the persistent port reservation for the block of UDP ports. Note that the token for a given persistent reservation for a block of TCP ports may change each time the system is restarted. An application can request port assignments from the UDP port reservation by opening a UDP socket, then calling the WSAIoctl function specifying the SIO_ASSOCIATE_PORT_RESERVATION IOCTL and passing the reservation token before issuing a call to the bind function on the socket. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "LookupPersistentUdpPortReservation",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "StartPort",
        "description": "The starting UDP port number in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "NumberOfPorts",
        "description": "The number of UDP port numbers that were reserved."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG64",
        "name": "Token",
        "description": "A pointer to a port reservation token that is returned if the function succeeds."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  CancelSecurityHealthChangeNotify function  deregisters for change notifications to network security health on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. The specific error code can be returned by a call to GetLastError.  ",
    "remarks": "The CancelSecurityHealthChangeNotify function is only supported on Windows Server 2003 with Service Pack 1 (SP1) and Windows Server 2003 with Service Pack 2 (SP2). The   CancelSecurityHealthChangeNotify function deregisters for an asynchronous change notification previously requested for network security health on  a local computer. A request to register for change notification is made  by calling NotifySecurityHealthChange function with the pHandle and  pOverLapped parameters not NULL. The pOverLapped parameter returned to the NotifySecurityHealthChange function is passed to CancelSecurityHealthChangeNotify in the notifyOverlapped parameter to deregister for change notification. The   CancelSecurityHealthChangeNotify function can only be used when the call to the NotifySecurityHealthChange function was made asynchronously (the pHandle and  pOverLapped parameters passed to NotifySecurityHealthChange were not be NULL). ",
    "return_type": "BOOL",
    "category": "IP Helper",
    "name": "CancelSecurityHealthChangeNotify",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPOVERLAPPED",
        "name": "notifyOverlapped",
        "description": "A pointer to an OVERLAPPED structure returned by the NotifySecurityHealthChange function."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 3,
    "description": "The  NotifySecurityHealthChange function  registers to be notified for a change to network security health on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The NotifySecurityHealthChange function is only supported on Windows Server 2003 with Service Pack 1 (SP1) and Windows Server 2003 with Service Pack 2 (SP2). The   NotifySecurityHealthChange function is used to register for a change notification for network security health on  a local computer. A change to security health will occur when  a TCP SYN attack against the local computer takes place. A TCP SYN attack is one form of a denial of service attempt. The   NotifySecurityHealthChange function may be called in two ways: If the pHandle and  pOverLapped parameters are NULL, then the NotifySecurityHealthChange function call is synchronous and will block until the security health has changed (the value pointed to by the SecurityHealthFlags parameter). If the NotifySecurityHealthChange function is called synchronously, a notification will be sent on the next security health change until the application terminates. If the pHandle and  pOverLapped parameters are not NULL, then the NotifySecurityHealthChange function call is asynchronous and results are returned when the state of security health changes (the value pointed to by the SecurityHealthFlags parameter). In this case, the function registers for a notification. The parameter passed in the pOverLapped parameter must point to a valid OVERLAPPED structure. The caller can use the returned handle pointed to by the pHandle parameter with the OVERLAPPED structure to receive asynchronous notification of a security health changes using the GetOverlappedResult function. See the following topics for information about using the handle and  OVERLAPPED structure to receive notifications: Each call to the NotifySecurityHealthChange function will result in a single notification. So once the NotifySecurityHealthChange function returns, if further notification is required then the function must be called again. When the NotifySecurityHealthChange function call is asynchronous, an application can deregister for security change notification (cancel the pending notification request) by calling the CancelSecurityHealthChangeNotify function with the notifyOverlapped parameter set to the value returned in pOverLapped parameter returned from the NotifySecurityHealthChange function. If the NotifySecurityHealthChange function is called asynchronously, a notification will be sent on the next security health change until either the application cancels the notification by calling the CancelSecurityHealthChangeNotify function or the application terminates. If the application terminates, the system will automatically cancel the registration for the notification. It is still recommended that an application explicitly cancel any notification before it terminates. Any registration for a security health notification does not persist across a system shut down or reboot. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "NotifySecurityHealthChange",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PHANDLE",
        "name": "pHandle",
        "description": "A pointer to a HANDLE variable if the function is to be called asynchronously.  On input when used asynchronously, this parameter should point to a HANDLE variable that receives a file handle for use in a subsequent call to the GetOverlappedResult function. The NotifySecurityHealthChange function will fill in the handle to use when the call is made asynchronously.  On successful output when used asynchronously, this parameter will point to the HANDLE that was used. If the function fails, this parameter will point to an invalid handle. Warning  if the function is successful, do not close this handle and do not associate it with a completion port.   If the pHandle and  pOverLapped parameters are NULL, then the function call is synchronous."
      },
      {
        "in_out": "",
        "type": "LPOVERLAPPED",
        "name": "pOverLapped",
        "description": "A pointer to an overlapped structure to use if the call is to be made asynchronously.  On input when used asynchronously, this parameter should point to an initialized OVERLAPPED structure that  notifies the caller of a change to network security health.  If the pHandle and  pOverLapped parameters are NULL, then the function call is synchronous."
      },
      {
        "in_out": "",
        "type": "PULONG",
        "name": "SecurityHealthFlags",
        "description": "A pointer to a ULONG that contains a set flags that describe a known state of health of TCP/IP with respect to security and denial of service.  On input, the value pointed to by this parameter indicates the known state of network security health.  On successful output for synchronous calls, the value pointed to by this parameter indicates the state of the security health flags on the local computer.   The possible values for this flag are defined in the Iprtrmib.h header file.  ValueMeaning   0   No network security health problems.  To get notification when a TCP SYN attack starts, the NotifySecurityHealthChange function  should be called with the SecurityHealthFlags parameter pointed to a ULONG that contains zero. The call completes when a TCP SYN attack occurs.    MIB_SECURITY_TCP_SYN_ATTACK 0x00000001   A TCP SYN attack is underway.  To get notification when the TCP SYN attack stops, the NotifySecurityHealthChange function  should be called with the SecurityHealthFlags parameter pointed to a ULONG that contains MIB_SECURITY_TCP_SYN_ATTACK. The call completes when a TCP SYN attack ceases."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 1,
    "description": "The  GetTeredoPort function  retrieves the dynamic UDP port number used by the Teredo client on the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetTeredoPort function is defined on Windows Vista and later. The GetTeredoPort function retrieves the current UDP port number used by the Teredo client for the Teredo service port. The Teredo port is dynamic and can change any time the Teredo client is restarted on the local computer. An application can  register to be notified when the Teredo service port changes by calling the NotifyTeredoPortChange function. The Teredo client also uses static UDP port 3544 for listening to multicast traffic sent on multicast IPv4 address 224.0.0.253 as defined in RFC 4380. For more information, see http://www.ietf.org/rfc/rfc4380.txt. The GetTeredoPort function is used primarily by firewall applications in order to configure the appropriate exceptions to allow incoming and outgoing Teredo traffic. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "GetTeredoPort",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "USHORT*",
        "name": "Port",
        "description": "A pointer to the  UDP port number. On successful return, this parameter will be filled with the port number used by the Teredo client."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The  NotifyTeredoPortChange function  registers to be notified for changes to the UDP port number used by the Teredo client for the Teredo service port on  a local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Netioapi.h (include Iphlpapi.h)",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The NotifyTeredoPortChange function is defined on Windows Vista and later. The GetTeredoPort function can be used to retrieve the initial UDP port number used by the Teredo client for the Teredo service port. The Teredo port is dynamic and can change any time the Teredo client is restarted on the local computer. An application can  register to be notified when the Teredo service port changes by calling the NotifyTeredoPortChange function. The invocation of the callback function specified in the Callback parameter is serialized. The callback function should be defined as a function of type VOID. The parameters passed to the callback function include the following:   The callback function specified in the Callback parameter must be implemented in the same process as the application calling the NotifyTeredoPortChange function. If the callback function is in a separate DLL, then the DLL should be loaded before calling the NotifyTeredoPortChange function to register for change notifications. Once the NotifyTeredoPortChange function is called to register for change notifications, these notifications will continue to be sent until the application deregisters for change notifications or the application terminates. If the application terminates, the system will automatically deregister any registration for change notifications. It is still recommended that an application explicitly deregister for change notifications before it terminates. Any registration for change notifications does not persist across a system shut down or reboot. To deregister for change notifications, call the  CancelMibChangeNotify2 function passing the NotificationHandle parameter returned by  NotifyTeredoPortChange. An application cannot make a call to the CancelMibChangeNotify2 function from the context of the thread which is currently executing the notification callback function for the same NotificationHandle parameter. Otherwise, the thread executing that callback will result in deadlock. So the CancelMibChangeNotify2 function must not be called directly as part of the notification callback routine. In a more general situation, a thread that executes the CancelMibChangeNotify2 function cannot own a resource on which the thread that executes a notification callback operation would wait because it would result in a similar deadlock. The CancelMibChangeNotify2 function should be called from a different thread, on which the thread that receives the notification callback doesn't have dependencies on. The Teredo client also uses static UDP port 3544 for listening to multicast traffic sent on multicast IPv4 address 224.0.0.253 as defined in RFC 4380. For more information, see http://www.ietf.org/rfc/rfc4380.txt. The NotifyTeredoPortChange function is used primarily by firewall applications in order to configure the appropriate exceptions to allow incoming and outgoing Teredo traffic. The NotifyStableUnicastIpAddressTable function is used primarily by applications that use the Teredo client. ",
    "return_type": "NETIOAPI_API",
    "category": "IP Helper",
    "name": "NotifyTeredoPortChange",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PTEREDO_PORT_CHANGE_CALLBACK",
        "name": "Callback",
        "description": "A pointer to the function to call when a Teredo client port change occurs. This function will be invoked         when a Teredo port change notification is received."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "CallerContext",
        "description": "A user context passed to the callback function specified in the Callback parameter when a Teredo port change  notification is received."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "InitialNotification",
        "description": "A value that indicates whether the callback should be invoked         immediately after registration for change notification completes. This initial notification does not indicate a change occurred to the Teredo client port. The purpose of this parameter to provide confirmation that the callback is registered."
      },
      {
        "in_out": "_Inout_",
        "type": "HANDLE*",
        "name": "NotificationHandle",
        "description": "A pointer used to return a handle that can be later used to         deregister the change notification. On success, a notification handle is returned in this parameter. If an error occurs, NULL is returned."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The GetExtendedTcpTable function retrieves a table that contains a list of TCP endpoints available to the application.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the call is successful, the value NO_ERROR is returned. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The table type returned by this function depends on the specific combination of the ulAf parameter and the TableClass parameter. When the ulAf parameter is set to AF_INET, the following table indicates the TCP table type to retrieve in the structure pointed to by the pTcpTable parameter for each possible TableClass value.   When the ulAf parameter is set to AF_INET6, the following table indicates the TCP table type to retrieve in the structure pointed to by the pTcpTable parameter for each possible TableClass value.   The GetExtendedTcpTable function called with the ulAf parameter set to AF_INET6 and the TableClass set to TCP_TABLE_BASIC_LISTENER, TCP_TABLE_BASIC_CONNECTIONS, or TCP_TABLE_BASIC_ALL  is not supported and returns ERROR_NOT_SUPPORTED. On the Windows SDK released for Windows Vista    and later, the organization of header files has changed. The various MIB_TCPTABLE  structures are defined in the Tcpmib.h header file, not in the Iprtrmib.h header file. Note that the Tcpmib.h header file is automatically included in Iprtrmib.h, which is automatically included in the Iphlpapi.h header file. The  Tcpmib.h and Iprtrmib.h header files should never be used directly. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetExtendedTcpTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "pTcpTable",
        "description": "A pointer to the table structure that contains the filtered TCP endpoints available to the application. For information about how to determine the type of table returned based on specific input parameter combinations, see the Remarks section later in this document."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "The estimated size of the structure returned in pTcpTable, in bytes. If this value is set too small, ERROR_INSUFFICIENT_BUFFER is returned by this function, and this field will contain the correct size of the structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A value that specifies whether the TCP connection table should be sorted. If this parameter is set to TRUE, the TCP endpoints in the table are sorted in ascending order, starting with the lowest local IP address. If this parameter is set to FALSE, the TCP endpoints in the table appear in the order in which they were retrieved. The following values are compared (as listed) when ordering the TCP endpoints: Local IP address Local scope ID (applicable when the ulAf parameter is set to AF_INET6) Local TCP port Remote IP address Remote scope ID (applicable when the ulAf parameter is set to AF_INET6) Remote TCP port"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulAf",
        "description": "The version of IP used by the TCP endpoints.  ValueMeaning  AF_INET   IPv4 is used.   AF_INET6   IPv6 is used."
      },
      {
        "in_out": "_In_",
        "type": "TCP_TABLE_CLASS",
        "name": "TableClass",
        "description": "The type of the TCP table structure to retrieve.  This parameter can be one of the values from the TCP_TABLE_CLASS enumeration.  On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the TCP_TABLE_CLASS enumeration  is defined in the Iprtrmib.h header file, not in the Iphlpapi.h header file.  The TCP_TABLE_CLASS enumeration value is combined with the value of the ulAf parameter to determine the extended TCP information to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Reserved",
        "description": "Reserved. This value must be zero."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The GetExtendedUdpTable function retrieves a table that contains a list of UDP endpoints available to the application.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the call is successful, the value NO_ERROR is returned. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The table type returned by this function depends on the specific combination of the ulAf parameter and the TableClass parameter. When the ulAf parameter is set to AF_INET, the following table indicates the UDP table type to retrieve in the structure pointed to by the pUdpTable parameter for each possible TableClass value.   When the ulAf parameter is set to AF_INET6, the following table indicates the TCP table type to retrieve in the structure pointed to by the pUdpTable parameter for each possible TableClass value.   The GetExtendedUdpTable function when called with the ulAf parameter set to AF_INET6 and the TableClass set to UDP_TABLE_BASIC is only supported on  Windows Vista and later. On Windows Server 2003 with Service Pack 1 (SP1) and Windows XP with Service Pack 2 (SP2), the GetExtendedUdpTable function called with the ulAf parameter set to AF_INET6 and the TableClass set to UDP_TABLE_BASIC fails and returns ERROR_NOT_SUPPORTED. On the Windows SDK released for Windows Vista    and later, the organization of header files has changed. The various MIB_UDPTABLE  structures are defined in the Udpmib.h header file, not in the Iprtrmib.h header file. Note that the Udpmib.h header file is automatically included in Iprtrmib.h, which is automatically included in the Iphlpapi.h header file. The  Udpmib.h and Iprtrmib.h header files should never be used directly. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetExtendedUdpTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "pUdpTable",
        "description": "A pointer to the table structure that contains the filtered UDP endpoints available to the application.   For information about how to determine the type of table returned based on specific input parameter combinations, see the Remarks section later in this document."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "The estimated size of the structure returned in pUdpTable, in bytes. If this value is set too small, ERROR_INSUFFICIENT_BUFFER is returned by this function, and this field will contain the correct size of the structure."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A value that specifies whether the UDP endpoint table should be sorted. If this parameter is set to TRUE, the UDP endpoints in the table are sorted in ascending order, starting with the lowest local IP address. If this parameter is set to FALSE, the UDP endpoints in the table appear in the order in which they were retrieved. The following values are compared as listed when ordering the UDP endpoints:  Local IP address Local scope ID (applicable when the ulAf parameter is set to AF_INET6) Local UDP port"
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulAf",
        "description": "The version of IP used by the UDP endpoint.  ValueMeaning  AF_INET   IPv4 is used.   AF_INET6   IPv6 is used."
      },
      {
        "in_out": "_In_",
        "type": "UDP_TABLE_CLASS",
        "name": "TableClass",
        "description": "The type of the UDP table structure to retrieve.  This parameter can be one of the values from the UDP_TABLE_CLASS enumeration.  On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the UDP_TABLE_CLASS enumeration  is defined in the Iprtrmib.h header file, not in the Iphlpapi.h header file.  The UDP_TABLE_CLASS enumeration value is combined with the value of the ulAf parameter to determine the extended UDP information to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Reserved",
        "description": "Reserved. This value must be zero."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetOwnerModuleFromTcp6Entry function retrieves data about the module that issued the context bind for a specific IPv6 TCP endpoint in a MIB table row.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function call is successful, the value NO_ERROR is returned. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The Buffer parameter contains not only a structure with pointers to specific data,  for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but the actual data itself; that is the name and path strings. Therefore, when calculating the size of the buffer, ensure that you have enough space for both the structure as well as the data the members of the structure point to. The resolution of TCP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the TCPIP_OWNER_MODULE_BASIC_INFO structure can be a process name (such as \"svchost.exe\"), a service name (such as \"RPC\"), or a component name (such as \"timer.dll\"). For computers running on Windows Vista or later, the pModuleName and pModulePath members of the TCPIP_OWNER_MODULE_BASIC_INFO retrieved by  GetOwnerModuleFromTcpEntry function may point to an empty string for some TCP connections. Applications that start TCP connections located in the Windows system folder (C:\\Windows\\System32, by default) are considered protected. If the GetOwnerModuleFromTcpEntry function is called by a user that is not a member of the Administrators group, the function call will succeed but the pModuleName and pModulePath members will point to memory that contains an empty string for the TCP connections started by protected applications. For computers running on Windows Vista or later, accessing the pModuleName and pModulePath members of the TCPIP_OWNER_MODULE_BASIC_INFO structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected pModuleName and pModulePath members to be allowed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetOwnerModuleFromTcp6Entry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_TCP6ROW_OWNER_MODULE",
        "name": "pTcpEntry",
        "description": "A pointer to a MIB_TCP6ROW_OWNER_MODULE structure that contains the IPv6 TCP endpoint entry used to obtain the owner module."
      },
      {
        "in_out": "_In_",
        "type": "TCPIP_OWNER_MODULE_INFO_CLASS",
        "name": "Class",
        "description": "A TCPIP_OWNER_MODULE_INFO_CLASS enumeration value that indicates the type of data to obtain regarding the owner module. The TCPIP_OWNER_MODULE_INFO_CLASS enumeration is defined in the Iprtrmib.h header file.  This parameter must be set to TCPIP_OWNER_MODULE_INFO_BASIC."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "A pointer to a buffer that contains a TCPIP_OWNER_MODULE_BASIC_INFO structure with the owner module data. The type of data returned in this buffer is indicated by the value of the Class parameter. The following structures are used for the data in Buffer when  Class is set to the corresponding value.  Class enumeration valueBuffer data format TCPIP_OWNER_MODULE_BASIC_INFO TCPIP_OWNER_MODULE_BASIC_INFO"
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "The estimated size of the structure returned in Buffer, in bytes. If this value is set too small, ERROR_INSUFFICIENT_BUFFER is returned by this function, and this field will contain the correct structure size."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetOwnerModuleFromTcpEntry function retrieves data about the module that issued the context bind for a specific IPv4 TCP endpoint in a MIB table row.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function call is successful, the value NO_ERROR is returned. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The Buffer parameter contains not only a structure with pointers to specific data,  for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but the actual data itself; that is the name and path strings. Therefore, when calculating the buffer size, ensure that you have enough space for both the structure as well as the data the members of the structure point to. The resolution of TCP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the TCPIP_OWNER_MODULE_BASIC_INFO structure can be a process name, such as \"svchost.exe\", a service name (such as \"RPC\"), or a component name, such as \"timer.dll\". For computers running on Windows Vista or later, the pModuleName and pModulePath members of the TCPIP_OWNER_MODULE_BASIC_INFO retrieved by  GetOwnerModuleFromTcpEntry function may point to an empty string for some TCP connections. Applications that start TCP connections located in the Windows system folder (C:\\Windows\\System32, by default) are considered protected. If the GetOwnerModuleFromTcpEntry function is called by a user that is not a member of the Administrators group, the function call will succeed but the pModuleName and pModulePath members will point to memory that contains an empty string for the TCP connections started by protected applications. For computers running on Windows Vista or later, accessing the pModuleName and pModulePath members of the TCPIP_OWNER_MODULE_BASIC_INFO structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected pModuleName and pModulePath members to be allowed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetOwnerModuleFromTcpEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_TCPROW_OWNER_MODULE",
        "name": "pTcpEntry",
        "description": "A pointer to a MIB_TCPROW_OWNER_MODULE structure that contains the IPv4 TCP endpoint entry used to obtain the owner module."
      },
      {
        "in_out": "_In_",
        "type": "TCPIP_OWNER_MODULE_INFO_CLASS",
        "name": "Class",
        "description": "A TCPIP_OWNER_MODULE_INFO_CLASS enumeration value that indicates the type of data to obtain regarding the owner module. The TCPIP_OWNER_MODULE_INFO_CLASS enumeration is defined in the Iprtrmib.h header file.  This parameter must be set to TCPIP_OWNER_MODULE_INFO_BASIC."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "A pointer a buffer that contains a TCPIP_OWNER_MODULE_BASIC_INFO structure with the owner module data. The type of data returned in this buffer is indicated by the value of the Class parameter.  The following structures are used for the data in Buffer when  Class is set to the corresponding value.  Class enumeration valueBuffer data format TCPIP_OWNER_MODULE_BASIC_INFO TCPIP_OWNER_MODULE_BASIC_INFO"
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "The estimated size, in  bytes, of the structure returned in Buffer. If this value is set too small, ERROR_INSUFFICIENT_BUFFER is returned by this function, and this field will contain the correct size of the buffer. The size required is the size of the corresponding structure plus an additional number of bytes equal to the length of data pointed to in the structure (for example, the name and path strings)."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetOwnerModuleFromUdp6Entry function retrieves data about the module that issued the context bind for a specific IPv6 UDP endpoint in a MIB table row.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the call is successful, the value NO_ERROR is returned. Otherwise, the following error is returned.  ",
    "remarks": "The Buffer parameter contains not only a structure with pointers to specific data, for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but the actual data itself; that is the name and path strings. Therefore, when calculating the buffer size, ensure that you have enough space for both the structure as well as the data the members of the structure point to. The resolution of UDP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the TCPIP_OWNER_MODULE_BASIC_INFO structure can be a process name, such as \"svchost.exe\", a service name, such as \"RPC\", or a component name, such as \"timer.dll\". For computers running on Windows Vista or later, accessing the pModuleName and pModulePath members of the TCPIP_OWNER_MODULE_BASIC_INFO structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected pModuleName and pModulePath members to be allowed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetOwnerModuleFromUdp6Entry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_UDP6ROW_OWNER_MODULE",
        "name": "pUdpEntry",
        "description": "A pointer to a MIB_UDP6ROW_OWNER_MODULE structure that contains the IPv6 UDP endpoint entry used to obtain the owner module."
      },
      {
        "in_out": "_In_",
        "type": "TCPIP_OWNER_MODULE_INFO_CLASS",
        "name": "Class",
        "description": "TCPIP_OWNER_MODULE_INFO_CLASS enumeration value that indicates the type of data to obtain regarding the owner module."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "The buffer that contains a TCPIP_OWNER_MODULE_BASIC_INFO structure with the owner module data. The type of data returned in this buffer is indicated by the value of the Class parameter. The following structures are used for the data in Buffer when  Class is set to the corresponding value.  Class enumeration valueBuffer data format TCPIP_OWNER_MODULE_BASIC_INFO TCPIP_OWNER_MODULE_BASIC_INFO"
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "The estimated size, in bytes, of the structure returned in Buffer. If this value is set too small, ERROR_INSUFFICIENT_BUFFER is returned by this function, and this field will contain the correct size of the structure."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetOwnerModuleFromUdpEntry function retrieves data about the module that issued the context bind for a specific IPv4 UDP endpoint in a MIB table row.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the call is successful, the value NO_ERROR is returned. Otherwise, the following error is returned.  ",
    "remarks": "The Buffer parameter contains not only a structure with pointers to specific data, for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but also the actual data itself; that is the name and path strings. Therefore, when calculating the buffer size, ensure that you have enough space for both the structure as well as the data the members of the structure point to. The resolution of UDP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the TCPIP_OWNER_MODULE_BASIC_INFO structure can be a process name, such as \"svchost.exe\", a service name, such as \"RPC\", or a component name, such as \"timer.dll\". For computers running on Windows Vista or later, accessing the pModuleName and pModulePath members of the TCPIP_OWNER_MODULE_BASIC_INFO structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected pModuleName and pModulePath members to be allowed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetOwnerModuleFromUdpEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_UDPROW_OWNER_MODULE",
        "name": "pUdpEntry",
        "description": "A pointer to a MIB_UDPROW_OWNER_MODULE structure that contains the IPv4 UDP endpoint entry used to obtain the owner module."
      },
      {
        "in_out": "_In_",
        "type": "TCPIP_OWNER_MODULE_INFO_CLASS",
        "name": "Class",
        "description": "A TCPIP_OWNER_MODULE_INFO_CLASS enumeration value that indicates the type of data to obtain regarding the owner module."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "The buffer that contains a TCPIP_OWNER_MODULE_BASIC_INFO structure with the owner module data. The type of data returned in this buffer is indicated by the value of the Class parameter. The following structures are used for the data in Buffer when  Class is set to the corresponding value.  Class enumeration valueBuffer data format TCPIP_OWNER_MODULE_BASIC_INFO TCPIP_OWNER_MODULE_BASIC_INFO"
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "The estimated size, in bytes, of the structure returned in Buffer. If this value is set too small, ERROR_INSUFFICIENT_BUFFER is returned by this function, and this field will contain the correct structure size."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP2 [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The  GetPerTcp6ConnectionEStats function retrieves extended statistics for an IPv6 TCP connection.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetPerTcp6ConnectionEStats function is defined on Windows Vista and later. The GetPerTcp6ConnectionEStats function is designed to use TCP to diagnose performance    problems in both the network and the application.  If a network based    application is performing poorly, TCP can determine if the bottleneck    is in the sender, the receiver or the network itself.  If the    bottleneck is in the network, TCP can provide specific information    about its nature. The GetPerTcp6ConnectionEStats function retrieves extended statistics for the IPv6 TCP connection passed in the Row parameter. The type of extended statistics that is retrieved is specified in the EstatsType parameter. Extended statistics on this TCP connection must have previously been enabled by calls to the SetPerTcp6ConnectionEStats function for all TCP_ESTATS_TYPE values except when TcpConnectionEstatsSynOpts is passed in the EstatsType parameter. The GetTcp6Table function is used to retrieve the IPv6 TCP connection table on the local computer. This function returns a MIB_TCP6TABLE structure that contain an array of MIB_TCP6ROW entries. The Row parameter passed to the GetPerTcp6ConnectionEStats function must be an entry for an existing IPv6 TCP connection. The only version of TCP connection statistics currently supported is version zero. So the RwVersion, RosVersion, and RodVersion parameters passed to GetPerTcp6ConnectionEStats should be set to 0. For information on extended TCP statistics on an IPv4 connection, see the GetPerTcpConnectionEStats and SetPerTcpConnectionEStats functions. The SetPerTcp6ConnectionEStats function can only be called by a user logged on as a member of the Administrators group. If SetPerTcp6ConnectionEStats is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. An application that uses the GetPerTcp6ConnectionEStats function to retrieve extended statistics for an IPv6 TCP connection must check that the previous call to the SetPerTcp6ConnectionEStats function to enabled extended statistics returned with success. If the SetPerTcp6ConnectionEStats function to enable extended statistics failed, subsequent calls to the GetPerTcp6ConnectionEStats will still return numbers in the returned structures. However the returned numbers are meaningless random data and don't represent extended TCP statistics. This behavior can be observed by running the example below as both an administrator and a normal user. The following example retrieves the TCP extended statistics for an IPv4 and IPv6 TCP connection and prints values from the returned data. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetPerTcp6ConnectionEStats",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PMIB_TCP6ROW",
        "name": "Row",
        "description": "A pointer to a MIB_TCP6ROW structure for an IPv6 TCP connection."
      },
      {
        "in_out": "",
        "type": "TCP_ESTATS_TYPE",
        "name": "EstatsType",
        "description": "The type of extended statistics for TCP requested. This parameter determines the data and format of information that is returned in the Rw, Rod, and Ros parameters if the call is successful. This parameter can be one of the values from the TCP_ESTATS_TYPE enumeration type defined in the Tcpestats.h header file.   ValueMeaning  TcpConnectionEstatsSynOpts   This value requests SYN exchange information for a TCP connection. Only read-only static information is available for this enumeration value. If the Ros parameter was not NULL and the function succeeds, the buffer pointed to by the Ros parameter should contain a TCP_ESTATS_SYN_OPTS_ROS_v0 structure.   TcpConnectionEstatsData   This value requests extended data transfer information for a TCP connection.  Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_DATA_RW_v0 structure.  If extended data transfer information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_DATA_ROD_v0 structure.    TcpConnectionEstatsSndCong   This value requests sender congestion for a TCP connection.  All three types of information (read-only static, read-only dynamic,  and read/write information) are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_SND_CONG_RW_v0 structure.  If the Ros parameter was not NULL and the function succeeds, the buffer pointed to by the Ros parameter should contain a TCP_ESTATS_SND_CONG_ROS_v0 structure. If sender congestion information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_SND_CONG_ROD_v0 structure.    TcpConnectionEstatsPath   This value requests extended path measurement information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_PATH_RW_v0 structure.  If extended path measurement information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_PATH_ROD_v0 structure.    TcpConnectionEstatsSendBuff   This value requests extended output-queuing information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_SEND_BUFF_RW_v0 structure.  If extended output-queuing information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_SEND_BUFF_ROD_v0 structure.    TcpConnectionEstatsRec   This value requests extended local-receiver information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_REC_RW_v0 structure.  If extended local-receiver information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_REC_ROD_v0 structure.    TcpConnectionEstatsObsRec   This value requests extended remote-receiver information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_OBS_REC_RW_v0 structure.  If extended remote-receiver information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_OBS_REC_ROD_v0 structure.    TcpConnectionEstatsBandwidth   This value requests bandwidth estimation statistics for a TCP connection on bandwidth. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_BANDWIDTH_RW_v0 structure.  If bandwidth estimation statistics was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_BANDWIDTH_ROD_v0 structure.    TcpConnectionEstatsFineRtt   This value requests fine-grained round-trip time (RTT) estimation statistics for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_FINE_RTT_RW_v0 structure.  If fine-grained RTT estimation statistics was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_FINE_RTT_ROD_v0 structure."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Rw",
        "description": "A pointer to a buffer to receive the read/write information. This parameter may be a NULL pointer if an application does not want to retrieve read/write information for the TCP connection."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwVersion",
        "description": "The version of the read/write information requested. The current supported value is a version of zero."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwSize",
        "description": "The size, in bytes, of the buffer pointed to by Rw parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Ros",
        "description": "A pointer to a buffer to receive read-only static information. This parameter may be a NULL pointer if an application does not want to retrieve read-only static information for the TCP connection."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RosVersion",
        "description": "The version of the read-only static information requested. The current supported value is a version of zero."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RosSize",
        "description": "The size, in bytes, of the buffer pointed to by the Ros parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Rod",
        "description": "A pointer to a buffer to receive read-only dynamic information. This parameter may be a NULL pointer if an application does not want to retrieve read-only dynamic information  for the TCP connection."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RodVersion",
        "description": "The version of the read-only dynamic information requested. The current supported value is a version of zero.."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RodSize",
        "description": "The size, in bytes, of the buffer pointed to by the Rod parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The  GetPerTcpConnectionEStats function retrieves extended statistics for an IPv4 TCP connection.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetPerTcpConnectionEStats function is defined on Windows Vista and later. The GetPerTcpConnectionEStats function is designed to use TCP to diagnose performance    problems in both the network and the application.  If a network based    application is performing poorly, TCP can determine if the bottleneck    is in the sender, the receiver or the network itself.  If the    bottleneck is in the network, TCP can provide specific information    about its nature. The GetPerTcpConnectionEStats function retrieves extended statistics for the IPv4 TCP connection passed in the Row parameter. The type of extended statistics that is retrieved is specified in the EstatsType parameter. Extended statistics on this TCP connection must have previously been enabled by calls to the SetPerTcpConnectionEStats function for all TCP_ESTATS_TYPE values except when TcpConnectionEstatsSynOpts is passed in the EstatsType parameter. The GetTcpTable function is used to retrieve the IPv4 TCP connection table on the local computer. This function returns a MIB_TCPTABLE structure that contain an array of MIB_TCPROW entries. The Row parameter passed to the GetPerTcpConnectionEStats function must be an entry for an existing IPv4 TCP connection. The only version of TCP connection statistics currently supported is version zero. So the RwVersion, RosVersion, and RodVersion parameters passed to GetPerTcpConnectionEStats should be set to 0. For information on extended TCP statistics on an IPv6 connection, see the GetPerTcp6ConnectionEStats and SetPerTcp6ConnectionEStats functions. The SetPerTcpConnectionEStats function can only be called by a user logged on as a member of the Administrators group. If SetPerTcpConnectionEStats is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. An application that uses the GetPerTcpConnectionEStats function to retrieve extended statistics for an IPv4 TCP connection must check that the previous call to the SetPerTcpConnectionEStats function to enabled extended statistics returned with success. If the SetPerTcpConnectionEStats function to enable extended statistics failed, subsequent calls to the GetPerTcpConnectionEStats will still return numbers in the returned structures. However the returned numbers are meaningless random data and don't represent extended TCP statistics. This behavior can be observed by running the example below as both an administrator and a normal user. The following example retrieves the TCP extended statistics for an IPv4 and IPv6 TCP connection and prints values from the returned data. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetPerTcpConnectionEStats",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PMIB_TCPROW",
        "name": "Row",
        "description": "A pointer to a MIB_TCPROW structure for an IPv4 TCP connection."
      },
      {
        "in_out": "",
        "type": "TCP_ESTATS_TYPE",
        "name": "EstatsType",
        "description": "The type of extended statistics for TCP requested. This parameter determines the data and format of information that is returned in the Rw, Rod, and Ros parameters if the call is successful. This parameter can be one of the values from the TCP_ESTATS_TYPE enumeration type defined in the Tcpestats.h header file.   ValueMeaning  TcpConnectionEstatsSynOpts   This value requests SYN exchange information for a TCP connection. Only read-only static information is available for this enumeration value. If the Ros parameter was not NULL and the function succeeds, the buffer pointed to by the Ros parameter should contain a TCP_ESTATS_SYN_OPTS_ROS_v0 structure.   TcpConnectionEstatsData   This value requests extended data transfer information for a TCP connection.  Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_DATA_RW_v0 structure.  If extended data transfer information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_DATA_ROD_v0 structure.    TcpConnectionEstatsSndCong   This value requests sender congestion for a TCP connection.  All three types of information (read-only static, read-only dynamic,  and read/write information) are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_SND_CONG_RW_v0 structure.  If the Ros parameter was not NULL and the function succeeds, the buffer pointed to by the Ros parameter should contain a TCP_ESTATS_SND_CONG_ROS_v0 structure. If sender congestion information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_SND_CONG_ROD_v0 structure.    TcpConnectionEstatsPath   This value requests extended path measurement information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_PATH_RW_v0 structure.  If extended path measurement information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_PATH_ROD_v0 structure.    TcpConnectionEstatsSendBuff   This value requests extended output-queuing information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_SEND_BUFF_RW_v0 structure.  If extended output-queuing information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_SEND_BUFF_ROD_v0 structure.    TcpConnectionEstatsRec   This value requests extended local-receiver information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_REC_RW_v0 structure.  If extended local-receiver information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_REC_ROD_v0 structure.    TcpConnectionEstatsObsRec   This value requests extended remote-receiver information for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_OBS_REC_RW_v0 structure.  If extended remote-receiver information was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_OBS_REC_ROD_v0 structure.    TcpConnectionEstatsBandwidth   This value requests bandwidth estimation statistics for a TCP connection on bandwidth. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_BANDWIDTH_RW_v0 structure.  If bandwidth estimation statistics was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_BANDWIDTH_ROD_v0 structure.    TcpConnectionEstatsFineRtt   This value requests fine-grained round-trip time (RTT) estimation statistics for a TCP connection. Only read-only dynamic information and read/write information are available for this enumeration value. If the Rw parameter was not NULL and the function succeeds, the buffer pointed to by the Rw parameter should contain a TCP_ESTATS_FINE_RTT_RW_v0 structure.  If fine-grained RTT estimation statistics was enabled  for this TCP connection, the Rod parameter was not NULL, and the function succeeds, the buffer pointed to by the Rod parameter should contain a TCP_ESTATS_FINE_RTT_ROD_v0 structure."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Rw",
        "description": "A pointer to a buffer to receive the read/write information. This parameter may be a NULL pointer if an application does not want to retrieve read/write information for the TCP connection."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwVersion",
        "description": "The version of the read/write information requested. The current supported value is a version of zero."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwSize",
        "description": "The size, in bytes, of the buffer pointed to by Rw parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Ros",
        "description": "A pointer to a buffer to receive read-only static information. This parameter may be a NULL pointer if an application does not want to retrieve read-only static information for the TCP connection."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RosVersion",
        "description": "The version of the read-only static information requested. The current supported value is a version of zero."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RosSize",
        "description": "The size, in bytes, of the buffer pointed to by the Ros parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "Rod",
        "description": "A pointer to a buffer to receive read-only dynamic information. This parameter may be a NULL pointer if an application does not want to retrieve read-only dynamic information  for the TCP connection."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RodVersion",
        "description": "The version of the read-only dynamic information requested. The current supported value is a version of zero."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RodSize",
        "description": "The size, in bytes, of the buffer pointed to by the Rod parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetTcpStatistics function retrieves the TCP statistics for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The  GetTcpStatistics function returns the TCP statistics for IPv4 on the current computer.     On Windows XP and later, the GetTcpStatisticsEx can be used to obtain the TCP statistics for either IPv4 or IPv6. The following example retrieves the TCP statistics for the local computer and prints some values from the returned data. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetTcpStatistics",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_TCPSTATS",
        "name": "pStats",
        "description": "A pointer to a  MIB_TCPSTATS structure that receives the TCP statistics for the local computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetTcpStatisticsEx function retrieves the Transmission Control Protocol (TCP) statistics for the current computer. The  GetTcpStatisticsEx function differs from the  GetTcpStatistics function in that  GetTcpStatisticsEx also supports the Internet Protocol version 6 (IPv6) protocol family.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetTcpStatisticsEx",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_TCPSTATS",
        "name": "pStats",
        "description": "A pointer to a  MIB_TCPSTATS structure that receives the TCP statistics for the local computer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFamily",
        "description": "The protocol family for which to retrieve statistics. This parameter must be one of the following values:     ValueMeaning  AF_INET   Internet Protocol version 4 (IPv4).   AF_INET6   Internet Protocol version 6 (IPv6)."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetTcp6Table function retrieves the TCP connection table for IPv6.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetTcp6Table function is defined on Windows Vista and later. The following example retrieves the TCP connection table for IPv6 and prints the state of each connection. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetTcp6Table",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_TCP6TABLE",
        "name": "TcpTable",
        "description": "A pointer to a buffer that receives the TCP connection table for IPv6 as a  MIB_TCP6TABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "SizePointer",
        "description": "On input, specifies the size in bytes of the buffer pointed to by the TcpTable parameter. On output, if the buffer is not large enough to hold the returned TCP connection table, the function sets this parameter equal to the required buffer size in bytes."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "Order",
        "description": "A Boolean value that specifies whether the TCP connection table should be sorted. If this parameter is TRUE, the table is sorted in ascending order, starting with the lowest local IP address.  If this parameter is FALSE, the table appears in the order in which they were retrieved. The following values are compared (as listed) when ordering the TCP endpoints:   Local IPv6 address Local scope ID Local port Remote IPv6 address Remote scope ID Remote port"
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetTcp6Table2 function retrieves the TCP connection table for IPv6.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetTcp6Table2 function is defined on Windows Vista and later. The GetTcp6Table2 function is an enhanced version of the GetTcp6Table function that also retrieves information on the TCP offload state of the TCP connection. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetTcp6Table2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_TCP6TABLE2",
        "name": "TcpTable",
        "description": "A pointer to a buffer that receives the TCP connection table for IPv6 as a  MIB_TCP6TABLE2 structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "SizePointer",
        "description": "On input, specifies the size of the buffer pointed to by the TcpTable parameter.     On output, if the buffer is not large enough to hold the returned TCP connection table, the function sets this parameter equal to the required buffer size."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "Order",
        "description": "A value that specifies whether the TCP connection table should be sorted. If this parameter is TRUE, the table is sorted in ascending order, starting with the lowest local IP address.  If this parameter is FALSE, the table appears in the order in which they were retrieved. The following values are compared (as listed) when ordering the TCP endpoints:  Local IPv6 address Local scope ID Local port Remote IPv6 address Remote scope ID Remote port"
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetTcpTable function retrieves the IPv4 TCP connection table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "On the Windows SDK released for Windows Vista and later, the return value from the GetTcpTable function is changed to a data type of ULONG which is equivalent to a DWORD. The following example retrieves the TCP connection table for IPv4 and prints the state of each connection. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetTcpTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_TCPTABLE",
        "name": "pTcpTable",
        "description": "A pointer to a buffer that receives the TCP connection table as a  MIB_TCPTABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "On input, specifies the size in  bytes  of the buffer pointed to by the pTcpTable parameter. On output, if the buffer is not large enough to hold the returned connection table, the function sets this parameter equal to the required buffer size in bytes. On the Windows SDK released for Windows Vista and later, the data type for this parameter is changed to a PULONG which is equivalent to a PDWORD."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A Boolean value that specifies whether the TCP connection table should be sorted. If this parameter is TRUE, the table is sorted in the order of:     Local IP address Local port Remote IP address Remote port"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetTcpTable2 function retrieves the IPv4 TCP connection table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetTcpTable2 function is defined on Windows Vista and later. The GetTcpTable2 function is an enhanced version of the GetTcpTable function that also retrieves information on the TCP offload state of the TCP connection. The following example retrieves the TCP connection table for IPv4 and prints the state of each connection. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetTcpTable2",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_TCPTABLE2",
        "name": "TcpTable",
        "description": "A pointer to a buffer that receives the TCP connection table as a  MIB_TCPTABLE2 structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "SizePointer",
        "description": "On input, specifies the size of the buffer pointed to by the TcpTable parameter.     On output, if the buffer is not large enough to hold the returned connection table, the function sets this parameter equal to the required buffer size."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "Order",
        "description": "A value that specifies whether the TCP connection table should be sorted. If this parameter is TRUE, the table is sorted in the order of:      Local IP address Local port Remote IP address Remote port"
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The  SetPerTcp6ConnectionEStats function sets a value in the read/write information for an IPv6 TCP connection. This function is used to enable or disable extended statistics for an IPv6 TCP connection.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetPerTcp6ConnectionEStats function is defined on Windows Vista and later. The SetPerTcp6ConnectionEStats function is used to enable or disable extended statistics for the IPv6 TCP connection passed in the Row parameter. Extended statistics on a TCP connection are disabled by default. The SetPerTcp6ConnectionEStats function is used to set the value of a member in the read/write information for extended statistics for an IPv6 TCP connection. The type and format of the structure to be set is specified by the EstatsType parameter. The Rw parameter contains a pointer to the structure being passed. The member to set in this structure is specified by the Offset parameter. All members in the structure pointed to by Rw parameter must be specified. The only version of TCP connection statistics currently supported is version zero. So the RwVersion parameter passed to SetPerTcp6ConnectionEStats should be set to 0. The structure pointed to by the Rw parameter passed this function depends on the enumeration value passed in the EstatsType parameter. The following table below indicates the structure type that should be passed in the Rw parameter for each possible EstatsType parameter type.   The Offset parameter is currently unused. The possible structures pointed to by the Rw parameter all have a single member except for the TCP_ESTATS_BANDWIDTH_RW_v0 structure.  When the EstatsType parameter is set to TcpConnectionEstatsBandwidth, the TCP_ESTATS_BANDWIDTH_RW_v0 structure pointed to by the Rw parameter must have both structure members set to the preferred values in a single call to the  SetPerTcp6ConnectionEStats function. If the RwSize parameter is set to 0, the SetPerTcp6ConnectionEStats function  returns NO_ERROR and makes no changes tothe extended statistics status. The GetTcp6Table function is used to retrieve the IPv6 TCP connection table on the local computer. This function returns a MIB_TCP6TABLE structure that contain an array of MIB_TCP6ROW entries. The Row parameter passed to the SetPerTcp6ConnectionEStats function must be an entry for an existing IPv6 TCP connection. Once extended statistics are enabled on a TCP connection for IPv6, an application calls the GetPerTcp6ConnectionEStats function to retrieve extended statistics on the TCP connection. The GetPerTcp6ConnectionEStats function is designed to use TCP to diagnose performance    problems in both the network and the application.  If a network based    application is performing poorly, TCP can determine if the bottleneck    is in the sender, the receiver or the network itself.  If the    bottleneck is in the network, TCP can provide specific information    about its nature. For information on extended TCP statistics on an IPv4 connection, see the GetPerTcpConnectionEStats and SetPerTcpConnectionEStats functions. The SetPerTcp6ConnectionEStats function can only be called by a user logged on as a member of the Administrators group. If SetPerTcp6ConnectionEStats is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and Windows Server 2008. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "SetPerTcp6ConnectionEStats",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PMIB_TCP6ROW",
        "name": "Row",
        "description": "A pointer to a MIB_TCP6ROW structure for an IPv6 TCP connection."
      },
      {
        "in_out": "",
        "type": "TCP_ESTATS_TYPE",
        "name": "EstatsType",
        "description": "The type of extended statistics for TCP to set. This parameter determines the data and format of information that is expected in the Rw parameter. This parameter can be one of the values from the TCP_ESTATS_TYPE enumeration type defined in the Tcpestats.h header file.   ValueMeaning  TcpConnectionEstatsData   This value specifies extended data transfer information for a TCP connection.  When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_DATA_RW_v0 structure.   TcpConnectionEstatsSndCong   This value specifies sender congestion for a TCP connection.  When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_SND_CONG_RW_v0 structure.   TcpConnectionEstatsPath   This value specifies extended path measurement information for a TCP connection. When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_PATH_RW_v0 structure.   TcpConnectionEstatsSendBuff   This value specifies extended output-queuing information for a TCP connection. When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_SEND_BUFF_RW_v0 structure.   TcpConnectionEstatsRec   This value specifies extended local-receiver information for a TCP connection. When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_REC_RW_v0 structure.   TcpConnectionEstatsObsRec   This value specifies extended remote-receiver information for a TCP connection. When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_OBS_REC_RW_v0 structure.   TcpConnectionEstatsBandwidth   This value specifies bandwidth estimation statistics for a TCP connection on bandwidth. When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_BANDWIDTH_RW_v0 structure.   TcpConnectionEstatsFineRtt   This value specifies fine-grained round-trip time (RTT) estimation statistics for a TCP connection. When this value is specified, the buffer pointed to by the Rw parameter should point to a TCP_ESTATS_FINE_RTT_RW_v0 structure."
      },
      {
        "in_out": "",
        "type": "PUCHAR",
        "name": "Rw",
        "description": "A pointer to a buffer that contains the read/write information to set. The buffer should contain a value from the TCP_BOOLEAN_OPTIONAL enumeration for each structure member that specifies how each member should be updated."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwVersion",
        "description": "The version of the read/write information to be set. This parameter should be set to zero for Windows Vista, Windows Server 2008, and Windows 7."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwSize",
        "description": "The size, in bytes, of the buffer pointed to by the Rw parameter."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "Offset",
        "description": "The offset, in bytes, to the member in the structure pointed to by the Rw parameter to be set.  This parameter is currently unused and must be set to zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The  SetPerTcpConnectionEStats function  sets a value in the read/write information for an IPv4 TCP connection. This function is used to enable or disable extended statistics for an IPv4 TCP connection.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The SetPerTcpConnectionEStats function is defined on Windows Vista and later. The SetPerTcpConnectionEStats function is used to enable or disable extended statistics on an IPv4 TCP connection passed in the Row parameter. Extended statistics on a TCP connection are disabled by default. The SetPerTcpConnectionEStats function is used to set the value of a member in the read/write information for extended statistics for an IPv4 TCP connection. The type and format of the structure to be set is specified by the EstatsType parameter. The Rw parameter contains a pointer to the structure being passed.  All members in the structure pointed to by Rw parameter must be specified. The only version of TCP connection statistics currently supported is version zero. So the RwVersion parameter passed to SetPerTcpConnectionEStats should be set to 0. The structure pointed to by the Rw parameter passed this function depends on the enumeration value passed in the EstatsType parameter. The following table below indicates the structure type that should be passed in the Rw parameter for each possible EstatsType parameter type.   The Offset parameter is currently unused and must be set to 0. The possible structures pointed to by the Rw parameter all have a single member except for the TCP_ESTATS_BANDWIDTH_RW_v0 structure.  When the EstatsType parameter is set to TcpConnectionEstatsBandwidth, the TCP_ESTATS_BANDWIDTH_RW_v0 structure pointed to by the Rw parameter must have both structure members set  to the preferred values in a single call to the  SetPerTcpConnectionEStats function. If the RwSize parameter is set to 0, the SetPerTcpConnectionEStats function  returns NO_ERROR and makes no changes tothe extended statistics status. The GetTcpTable function is used to retrieve the IPv4 TCP connection table on the local computer. This function returns a MIB_TCPTABLE structure that contain an array of MIB_TCPROW entries. The Row parameter passed to the SetPerTcpConnectionEStats function must be an entry for an existing IPv4 TCP connection. Once extended statistics are enabled on a TCP connection for IPv4, applications call the GetPerTcpConnectionEStats function to retrieve extended statistics on the TCP connection. The GetPerTcpConnectionEStats function is designed to use TCP to diagnose performance    problems in both the network and the application.  If a network based    application is performing poorly, TCP can determine if the bottleneck    is in the sender, the receiver or the network itself.  If the    bottleneck is in the network, TCP can provide specific information    about its nature. For information on extended TCP statistics on an IPv6 connection, see the GetPerTcp6ConnectionEStats and SetPerTcp6ConnectionEStats functions. The SetPerTcpConnectionEStats function can only be called by a user logged on as a member of the Administrators group. If SetPerTcpConnectionEStats is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. This function can also fail because of user account control (UAC) on Windows Vista and Windows Server 2008. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "SetPerTcpConnectionEStats",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PMIB_TCPROW",
        "name": "Row",
        "description": "A pointer to a MIB_TCPROW structure for an IPv4 TCP connection."
      },
      {
        "in_out": "",
        "type": "TCP_ESTATS_TYPE",
        "name": "EstatsType",
        "description": "The type of extended statistics for TCP to set. This parameter determines the data and format of information that is expected in the Rw parameter. This parameter can be one of the values from the TCP_ESTATS_TYPE enumeration type defined in the Tcpestats.h header file."
      },
      {
        "in_out": "",
        "type": "PUCHAR",
        "name": "Rw",
        "description": "A pointer to a buffer that contains the read/write information to set. The buffer should contain a value from the TCP_BOOLEAN_OPTIONAL enumeration for each structure member that specifies how each member should be updated."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwVersion",
        "description": "The version of the read/write information to be set. This parameter should be set to zero for Windows Vista, Windows Server 2008, and Windows 7."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "RwSize",
        "description": "The size, in bytes, of the buffer pointed to by the Rw parameter."
      },
      {
        "in_out": "",
        "type": "ULONG",
        "name": "Offset",
        "description": "The offset, in bytes, to the member in the structure pointed to by the Rw parameter to be set. This parameter is currently unused and must be set to zero."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetTcpEntry function sets the state of a TCP connection.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "The function returns NO_ERROR (zero) if the function is successful. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "Currently, the only state to which a TCP connection can be set is MIB_TCP_STATE_DELETE_TCB. On Windows Vista and later, the SetTcpEntry function can only be called by a user logged on as a member of the Administrators group. If SetTcpEntry is called by a user that is not a member of the Administrators group, the function call will fail and ERROR_ACCESS_DENIED is returned. The SetTcpEntry function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a requestedExecutionLevel set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "SetTcpEntry",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PMIB_TCPROW",
        "name": "pTcpRow",
        "description": "A pointer to a  MIB_TCPROW structure. This structure specifies information to identify the TCP connection to modify. It also specifies the new state for the TCP connection. The caller must specify values for all the members in this structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetUdp6Table function retrieves the IPv6 User Datagram Protocol (UDP) listener table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The GetUdp6Table function is defined on Windows Vista and later. ",
    "return_type": "ULONG",
    "category": "IP Helper",
    "name": "GetUdp6Table",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_UDP6TABLE",
        "name": "Udp6Table",
        "description": "A pointer to a buffer that receives the IPv6 UDP listener table as a  MIB_UDP6TABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "SizePointer",
        "description": "On input, specifies the size in bytes of the buffer pointed to by the Udp6Table parameter.     On output, if the buffer is not large enough to hold the returned listener table, the function sets this parameter equal to the required buffer size in bytes."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "Order",
        "description": "A Boolean value that specifies whether the returned UDP listener table should be sorted. If this parameter is TRUE, the table is sorted in the order of:     Local IPv6 address Local scope ID Local port"
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetUdpStatistics function retrieves the User Datagram Protocol (UDP) statistics for the local computer.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, use  FormatMessage to obtain the message string for the returned error. ",
    "remarks": "Windows Server 2003 and Windows XP:  Use the  GetUdpStatisticsEx function to obtain the UDP statistics for the IPv6 protocol. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetUdpStatistics",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_UDPSTATS",
        "name": "pStats",
        "description": "Pointer to a  MIB_UDPSTATS structure that receives the UDP statistics for the local computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetUdpStatisticsEx function retrieves the User Datagram Protocol (UDP) statistics for the current computer. The  GetUdpStatisticsEx function differs from the  GetUdpStatistics function in that  GetUdpStatisticsEx also supports the Internet Protocol version 6 (IPv6) protocol family.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetUdpStatisticsEx",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_UDPSTATS",
        "name": "pStats",
        "description": "A pointer to a  MIB_UDPSTATS structure that receives the UDP statistics for the local computer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFamily",
        "description": "The protocol family for which to retrieve statistics. This parameter must be one of the following values:     ValueMeaning  AF_INET   Internet Protocol version 4 (IPv4).   AF_INET6   Internet Protocol version 6 (IPv6)."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetUdpTable function retrieves the IPv4 User Datagram Protocol (UDP) listener table.",
    "library": "Iphlpapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "On the Windows SDK released for Windows Vista and later, the return value from the GetUdpTable function is changed to a data type of ULONG which is equivalent to a DWORD. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "GetUdpTable",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PMIB_UDPTABLE",
        "name": "pUdpTable",
        "description": "A pointer to a buffer that receives the IPv4 UDP listener table as a  MIB_UDPTABLE structure."
      },
      {
        "in_out": "_Inout_",
        "type": "PDWORD",
        "name": "pdwSize",
        "description": "On input, specifies the size in bytes of the buffer pointed to by the UdpTable parameter.     On output, if the buffer is not large enough to hold the returned listener table, the function sets this parameter equal to the required buffer size in bytes. On the Windows SDK released for Windows Vista and later, the data type for this parameter is changed to a PULONG which is equivalent to a PDWORD."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "A Boolean value that specifies whether the returned UDP listener table should be sorted. If this parameter is TRUE, the table is sorted in the order of:     Local IP address Local port"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[This function is no longer available for use as of Windows Vista. Instead, use the  GetTcpTable or GetExtendedTcpTable function to retrieve the TCP connection table.]",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, it returns ERROR_SUCCESS. If the function fails, it returns a function from winerror.h. ",
    "remarks": "In the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the function prototype for AllocateAndGetTcpExTableFromStack is still defined in the Iphlpapi.h header file for continued support on Windows Server 2003 and Windows XP. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "AllocateAndGetTcpExTableFromStack",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "ppTcpTable",
        "description": "Pointer to the address of the opaque data that contains the TCP connection table after the function returns."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "If true, the TCP connection entries in the table returned in ppTcpTable are sorted; if false, they are not."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "Handle to the heap from which the memory to store the table will be allocated."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "One or more flags that indicate specific heap allocation control behaviors."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFamily",
        "description": "The family of the TCP addresses in the table.  ValueMeaning  AF_INET   Retrieve IPv4 TCP addresses.   AF_INET6   Retrieve IPv6 TCP addresses."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[This function is no longer available for use as of Windows Vista. Instead, use the GetUdpTable or GetExtendedUdpTable function to retrieve the UDP connection table.]",
    "library": "Iphlpapi.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Iphlpapi.h",
    "return_value": "If the function succeeds, it returns ERROR_SUCCESS. If the function fails, it returns a function from winerror.h. ",
    "remarks": "In the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the function prototype for AllocateAndGetUdpExTableFromStack is still defined in the Iphlpapi.h header file for continued support on Windows Server 2003 and Windows XP. ",
    "return_type": "DWORD",
    "category": "IP Helper",
    "name": "AllocateAndGetUdpExTableFromStack",
    "is_callback": 0,
    "dll": "Iphlpapi.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PVOID*",
        "name": "ppUDPTable",
        "description": "Pointer to the address of the opaque data that contains the UDP connection table after the function returns."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bOrder",
        "description": "If true, the UDP connection entries in the table returned in ppUDPTable are sorted; if false, they are not."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hHeap",
        "description": "Handle to the heap from which the memory to store the table will be allocated."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "One or more flags that indicate specific heap allocation control behaviors."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFamily",
        "description": "The family of the UDP addresses in the table.  ValueMeaning  AF_INET   Retrieve IPv4 UDP addresses.   AF_INET6   Retrieve IPv6 UDP addresses."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]