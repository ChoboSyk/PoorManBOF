[
  {
    "n_arguments": 5,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverAdd",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHACMDRIVERID",
        "name": "phadid",
        "description": "Pointer to the buffer that receives a handle identifying the installed driver. This handle is used to identify the driver in calls to other ACM functions."
      },
      {
        "in_out": "",
        "type": "HINSTANCE",
        "name": "hinstModule",
        "description": "Handle to the instance of the module whose executable or dynamic-link library (DLL) contains the driver entry function."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Driver function address or a notification window handle, depending on the fdwAdd flags."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwPriority",
        "description": "Window message to send for notification broadcasts. This parameter is used only with the ACM_DRIVERADDF_NOTIFYHWND flag. All other flags require this member to be set to zero."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwAdd",
        "description": "Flags for adding ACM drivers. The following values are defined.   Value  Meaning  ACM_DRIVERADDF_FUNCTIONThe lParam parameter is a driver function address conforming to the acmDriverProc prototype. The function may reside in either an executable or DLL file. ACM_DRIVERADDF_GLOBALProvided for compatibility with 16-bit applications. For the Win32 API, ACM drivers added by the acmDriverAdd function can be used only by the application that added the driver. This is true whether or not ACM_DRIVERADDF_GLOBAL is specified. For more information, see Adding Drivers Within an Application. ACM_DRIVERADDF_LOCALThe ACM automatically gives a local driver higher priority than a global driver when searching for a driver to satisfy a function call. For more information, see Adding Drivers Within an Application. ACM_DRIVERADDF_NAMEThe lParam parameter is a registry value name in HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32. The value identifies a DLL that implements an ACM codec. Applications can use this flag if new registry entries are created after the application has already started using the ACM. ACM_DRIVERADDF_NOTIFYHWNDThe lParam parameter is a handle of a notification window that receives messages when changes to global driver priorities and states are made. The window message to receive is defined by the application and must be passed in dwPriority. The wParam and lParam parameters passed with the window message are reserved for future use and should be ignored. ACM_DRIVERADDF_GLOBAL cannot be specified in conjunction with this flag. For more information about driver priorities, see the description for the acmDriverPriority function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverClose",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the open driver instance to be closed."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwClose",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverDetails",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the driver identifier of an installed ACM driver. Disabled drivers can be queried for details."
      },
      {
        "in_out": "",
        "type": "LPACMDRIVERDETAILS",
        "name": "padd",
        "description": "Pointer to an ACMDRIVERDETAILS structure that will receive the driver details. The cbStruct member must be initialized to the size, in bytes, of the structure."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDetails",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The acmDriverEnum function will return MMSYSERR_NOERROR (zero) if no ACM drivers are installed. Moreover, the callback function will not be called. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverEnum",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "ACMDRIVERENUMCB",
        "name": "fnCallback",
        "description": "Procedure instance address of the application-defined callback function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM driver information."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwEnum",
        "description": "Flags for enumerating ACM drivers. The following values are defined.   Value  Meaning  ACM_DRIVERENUMF_DISABLEDDisabled ACM drivers should be included in the enumeration. Drivers can be disabled by the user through the Control Panel or by an application using the acmDriverPriority function. If a driver is disabled, the fdwSupport parameter to the callback function will have the ACMDRIVERDETAILS_SUPPORTF_DISABLED flag set. ACM_DRIVERENUMF_NOLOCALOnly global drivers should be included in the enumeration."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The callback function must return TRUE to continue enumeration or FALSE to stop enumeration. ",
    "remarks": "The acmDriverEnum function will return MMSYSERR_NOERROR (zero) if no ACM drivers are installed. Moreover, the callback function will not be called. The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "BOOL ACMDRIVERENUMCB",
    "category": "Windows Multimedia",
    "name": "acmDriverEnumCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to an ACM driver identifier."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Application-defined value specified in acmDriverEnum."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSupport",
        "description": "Driver-support flags specific to the driver specified by hadid. These flags are identical to the fdwSupport flags of the ACMDRIVERDETAILS structure. This parameter can be a combination of the following values.   Value  Meaning  ACMDRIVERDETAILS_SUPPORTF_ASYNCDriver supports asynchronous conversions. ACMDRIVERDETAILS_SUPPORTF_CODECDriver supports conversion between two different format tags. For example, if a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_CONVERTERDriver supports conversion between two different formats of the same format tag. For example, if a driver supports resampling of WAVE_FORMAT_PCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_DISABLEDDriver has been disabled. An application must specify the ACM_DRIVERENUMF_DISABLED flag with acmDriverEnum to include disabled drivers in the enumeration. ACMDRIVERDETAILS_SUPPORTF_FILTERDriver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverID",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMOBJ",
        "name": "hao",
        "description": "Handle to the open driver instance or stream handle. This is the handle of an ACM object, such as HACMDRIVER or HACMSTREAM."
      },
      {
        "in_out": "",
        "type": "LPHACMDRIVERID",
        "name": "phadid",
        "description": "Pointer to a buffer that receives a handle identifying the installed driver that is associated with hao."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDriverID",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The return value is specific to the user-defined ACM driver message specified by the uMsg parameter. However, possible error values include the following.  ",
    "remarks": "To display a custom About dialog box from an ACM driver, an application must send the ACMDM_DRIVER_ABOUT message to the driver. The lParam1 parameter should be the handle of the owner window for the custom About dialog box, and lParam2 must be set to zero. If the driver does not support a custom About dialog box, MMSYSERR_NOTSUPPORTED will be returned and it is the application's responsibility to display its own dialog box. For example, the Control Panel Sound Mapper option will display a default About dialog box based on the ACMDRIVERDETAILS structure when an ACM driver returns MMSYSERR_NOTSUPPORTED. An application can query a driver for custom About dialog box support without the dialog box being displayed by setting lParam1 to \u00e2\u0080\u00931L. If the driver supports a custom About dialog box, MMSYSERR_NOERROR will be returned. Otherwise, the return value is MMSYSERR_NOTSUPPORTED. User-defined messages must be sent only to an ACM driver that specifically supports the messages. The caller should verify that the ACM driver is the correct driver by retrieving the driver details and checking the wMid, wPid, and vdwDriver members of the ACMDRIVERDETAILS structure. Never send user-defined messages to an unknown ACM driver. ",
    "return_type": "LRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverMessage",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver instance to which the message will be sent."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Message that the ACM driver must process. This message must be in the ACMDM_USER message range (above or equal to ACMDM_USER and less than ACMDM_RESERVED_LOW). The exceptions to this restriction are the ACMDM_DRIVER_ABOUT, DRV_QUERYCONFIGURE, and DRV_CONFIGURE messages."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverOpen",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHACMDRIVER",
        "name": "phad",
        "description": "Pointer to a buffer that receives the new driver instance handle that can be used to communicate with the driver."
      },
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the driver identifier of an installed and enabled ACM driver."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwOpen",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "All driver identifiers can be enabled and disabled, including global, local and notification driver identifiers. If more than one global driver identifier needs to be enabled, disabled or shifted in priority, an application should defer change notification broadcasts by using the ACM_DRIVERPRIORITYF_BEGIN flag. A single change notification will be broadcast when the ACM_DRIVERPRIORITYF_END flag is specified. An application can use the function with the acmMetrics ACM_METRIC_DRIVER_PRIORITY metric index to retrieve the current priority of a global driver. Drivers are always enumerated from highest to lowest priority by the acmDriverEnum function. All enabled driver identifiers will receive change notifications. An application can register a notification message by using the acmDriverAdd function in conjunction with the ACM_DRIVERADDF_NOTIFYHWND flag. Changes to nonglobal driver identifiers will not be broadcast. Priorities are simply used for the search order when an application does not specify a driver. Boosting the priority of a driver will have no effect on the performance of a driver. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverPriority",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the driver identifier of an installed ACM driver. If the ACM_DRIVERPRIORITYF_BEGIN and ACM_DRIVERPRIORITYF_END flags are specified, this parameter must be NULL."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwPriority",
        "description": "New priority for a global ACM driver identifier. ..."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwPriority",
        "description": "Flags for setting priorities of ACM drivers. The following values are defined.   Value  Meaning  ACM_DRIVERPRIORITYF_BEGINChange notification broadcasts should be deferred. An application must reenable notification broadcasts as soon as possible with the ACM_DRIVERPRIORITYF_END flag. Note that hadid must be NULL, dwPriority must be zero, and only the ACM_DRIVERPRIORITYF_BEGIN flag can be set. ACM_DRIVERPRIORITYF_DISABLEACM driver should be disabled if it is currently enabled. Disabling a disabled driver does nothing. ACM_DRIVERPRIORITYF_ENABLEACM driver should be enabled if it is currently disabled. Enabling an enabled driver does nothing. ACM_DRIVERPRIORITYF_ENDCalling task wants to reenable change notification broadcasts. An application must call acmDriverPriority with ACM_DRIVERPRIORITYF_END for each successful call with the ACM_DRIVERPRIORITYF_BEGIN flag. Note that hadid must be NULL, dwPriority must be zero, and only the ACM_DRIVERPRIORITYF_END flag can be set."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "Applications should not call any system-defined functions from inside a callback function, except for PostMessage, timeGetSystemTime, timeGetTime, timeSetEvent, timeKillEvent, midiOutShortMsg, midiOutLongMsg, and OutputDebugStr. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "acmDriverProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwID",
        "description": "Identifier of the installable ACM driver."
      },
      {
        "in_out": "",
        "type": "HDRIVER",
        "name": "hdrvr",
        "description": "Handle to the installable ACM driver. This parameter is a unique handle the ACM assigns to the driver."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "ACM driver message."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmDriverRemove",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the driver identifier to be removed."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwRemove",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFilterChoose",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPACMFILTERCHOOSE",
        "name": "pafltrc",
        "description": "Pointer to an ACMFILTERCHOOSE structure that contains information used to initialize the dialog box. When acmFilterChoose returns, this structure contains information about the user's filter selection. The pwfltr member of this structure must contain a valid pointer to a memory location that will contain the returned filter header structure. The cbwfltr member must be filled in with the size, in bytes, of this memory buffer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "",
    "remarks": "To customize the dialog box selections, a hook function can optionally process the MM_ACM_FILTERCHOOSE message. You should use this function the same way as you use the Common Dialog hook functions for customizing common dialog boxes. ",
    "return_type": "UINT ACMFILTERCHOOSEHOOKPROC",
    "category": "Windows Multimedia",
    "name": "acmFilterChooseHookProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwnd",
        "description": "Window handle for the dialog box."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Window message."
      },
      {
        "in_out": "",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFilterDetails",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio filter details for a filter tag. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver."
      },
      {
        "in_out": "",
        "type": "LPACMFILTERDETAILS",
        "name": "pafd",
        "description": "Pointer to the ACMFILTERDETAILS structure that is to receive the filter details for the given filter tag."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDetails",
        "description": "Flags for getting the details. The following values are defined.   Value  Meaning  ACM_FILTERDETAILSF_FILTERA WAVEFILTER structure pointed to by the pwfltr member of the ACMFILTERDETAILS structure was given and the remaining details should be returned. The dwFilterTag member of the ACMFILTERDETAILS structure must be initialized to the same filter tag pwfltr specifies. This query type can be used to get a string description of an arbitrary filter structure. If an application specifies an ACM driver handle for had, details on the filter will be returned for that driver. If an application specifies NULL for had, the ACM finds the first acceptable driver to return the details. ACM_FILTERDETAILSF_INDEXA filter index for the filter tag was given in the dwFilterIndex member of the ACMFILTERDETAILS structure. The filter details will be returned in the structure defined by pafd. The index ranges from zero to one less than the cStandardFilters member returned in the ACMFILTERTAGDETAILS structure for a filter tag. An application must specify a driver handle for had when retrieving filter details with this flag. For information about what members should be initialized before calling this function, see the ACMFILTERDETAILS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The acmFilterEnum function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will not be called. The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFilterEnum",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio filter details. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver."
      },
      {
        "in_out": "",
        "type": "LPACMFILTERDETAILS",
        "name": "pafd",
        "description": "Pointer to the ACMFILTERDETAILS structure that contains the filter details when it is passed to the function specified by fnCallback. When your application calls acmFilterEnum, the cbStruct, pwfltr, and cbwfltr members of this structure must be initialized. The dwFilterTag member must also be initialized to either WAVE_FILTER_UNKNOWN or a valid filter tag."
      },
      {
        "in_out": "",
        "type": "ACMFILTERENUMCB",
        "name": "fnCallback",
        "description": "Procedure-instance address of the application-defined callback function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "A 32-bit (DWORD), 64-bit (DWORD_PTR) application-defined value that is passed to the callback function along with ACM filter details."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwEnum",
        "description": "Flags for enumerating the filters for a given filter tag. The following values are defined.   Value  Meaning  ACM_FILTERENUMF_DWFILTERTAGThe dwFilterTag member of the WAVEFILTER structure pointed to by the pwfltr member of the ACMFILTERDETAILS structure is valid. The enumerator will enumerate only a filter that conforms to this attribute. The dwFilterTag member of the ACMFILTERDETAILS structure must be equal to the dwFilterTag member of the WAVEFILTER structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The callback function must return TRUE to continue enumeration or FALSE to stop enumeration. ",
    "remarks": "The acmFilterEnum function will return MMSYSERR_NOERROR (zero) if no filters are to be enumerated. Moreover, the callback function will not be called. The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "BOOL ACMFILTERENUMCB",
    "category": "Windows Multimedia",
    "name": "acmFilterEnumCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the ACM driver identifier."
      },
      {
        "in_out": "",
        "type": "LPACMFILTERDETAILS",
        "name": "pafd",
        "description": "Pointer to an ACMFILTERDETAILS structure that contains the enumerated filter details for a filter tag."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Application-defined value specified in acmFilterEnum."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSupport",
        "description": "Driver-support flags specific to the driver identified by hadid for the specified filter. These flags are identical to the fdwSupport flags of the ACMDRIVERDETAILS structure, but they are specific to the filter that is being enumerated. This parameter can be a combination of the following values and identifies which operations the driver supports for the filter tag.   Value  Meaning  ACMDRIVERDETAILS_SUPPORTF_ASYNCDriver supports asynchronous conversions with the specified filter tag. ACMDRIVERDETAILS_SUPPORTF_CODECDriver supports conversion between two different format tags while using the specified filter. For example, if a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified filter, this flag is set. ACMDRIVERDETAILS_SUPPORTF_CONVERTERDriver supports conversion between two different formats of the same format tag while using the specified filter. For example, if a driver supports resampling of WAVE_FORMAT_PCM with the specified filter, this flag is set. ACMDRIVERDETAILS_SUPPORTF_FILTERDriver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_HARDWAREDriver supports hardware input, output, or both with the specified filter through a waveform-audio device. An application should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indices to get the waveform-audio device identifiers associated with the supporting ACM driver."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFilterTagDetails",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio filter tag details. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver. An application must specify a valid HACMDRIVER or HACMDRIVERID identifier when using the ACM_FILTERTAGDETAILSF_INDEX query type. Driver identifiers for disabled drivers are not allowed."
      },
      {
        "in_out": "",
        "type": "LPACMFILTERTAGDETAILS",
        "name": "paftd",
        "description": "Pointer to the ACMFILTERTAGDETAILS structure that is to receive the filter tag details."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "fdwDetails",
        "description": "Flags for getting the details. The following values are defined.   Value  Meaning  ACM_FILTERTAGDETAILSF_FILTERTAGA filter tag was given in the dwFilterTag member of the ACMFILTERTAGDETAILS structure. The filter tag details will be returned in the structure pointed to by paftd. If an application specifies an ACM driver handle for had, details on the filter tag will be returned for that driver. If an application specifies NULL for had, the ACM finds the first acceptable driver to return the details. ACM_FILTERTAGDETAILSF_INDEXA filter tag index was given in the dwFilterTagIndex member of the ACMFILTERTAGDETAILS structure. The filter tag and details will be returned in the structure pointed to by paftd. The index ranges from zero to one less than the cFilterTags member returned in the ACMDRIVERDETAILS structure for an ACM driver. An application must specify a driver handle for had when retrieving filter tag details with this flag. ACM_FILTERTAGDETAILSF_LARGESTSIZEDetails on the filter tag with the largest filter size, in bytes, are to be returned. The dwFilterTag member must either be WAVE_FILTER_UNKNOWN or the filter tag to find the largest size for. If an application specifies an ACM driver handle for had, details on the largest filter tag will be returned for that driver. If an application specifies NULL for had, the ACM finds an acceptable driver with the largest filter tag requested to return the details."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will not be called. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFilterTagEnum",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio filter tag details. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver."
      },
      {
        "in_out": "",
        "type": "LPACMFILTERTAGDETAILS",
        "name": "paftd",
        "description": "Pointer to the ACMFILTERTAGDETAILS structure that contains the filter tag details when it is passed to the fnCallback function. When your application calls acmFilterTagEnum, the cbStruct member of this structure must be initialized."
      },
      {
        "in_out": "",
        "type": "ACMFILTERTAGENUMCB",
        "name": "fnCallback",
        "description": "Procedure instance address of the application-defined callback function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM filter tag details."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwEnum",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The callback function must return TRUE to continue enumeration or FALSE to stop enumeration. ",
    "remarks": "The acmFilterTagEnum function returns MMSYSERR_NOERROR (zero) if no filter tags are to be enumerated. Moreover, the callback function will not be called. The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "BOOL CALLBACK",
    "category": "Windows Multimedia",
    "name": "acmFilterTagEnumCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the ACM driver identifier."
      },
      {
        "in_out": "",
        "type": "LPACMFILTERTAGDETAILS",
        "name": "paftd",
        "description": "Pointer to an ACMFILTERTAGDETAILS structure that contains the enumerated filter tag details."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Application-defined value specified in acmFilterTagEnum."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSupport",
        "description": "Driver-support flags specific to the driver identifier hadid. These flags are identical to the fdwSupport flags of the ACMDRIVERDETAILS structure. This parameter can be a combination of the following values and identifies which operations the driver supports with the filter tag.   Value  Meaning  ACMDRIVERDETAILS_SUPPORTF_ASYNCDriver supports asynchronous conversions with the specified filter tag. ACMDRIVERDETAILS_SUPPORTF_CODECDriver supports conversion between two different format tags while using the specified filter tag. For example, if a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified filter tag, this flag is set. ACMDRIVERDETAILS_SUPPORTF_CONVERTERDriver supports conversion between two different formats of the same format tag while using the specified filter tag. For example, if a driver supports resampling of WAVE_FORMAT_PCM with the specified filter tag, this flag is set. ACMDRIVERDETAILS_SUPPORTF_FILTERDriver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_HARDWAREDriver supports hardware input, output, or both with the specified filter tag through a waveform-audio device. An application should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indices to get the waveform-audio device identifiers associated with the supporting ACM driver."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible return values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFormatChoose",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPACMFORMATCHOOSE",
        "name": "pfmtc",
        "description": "Pointer to an ACMFORMATCHOOSE structure that contains information used to initialize the dialog box. When this function returns, this structure contains information about the user's format selection. The pwfx member of this structure must contain a valid pointer to a memory location that will contain the returned format header structure. Moreover, the cbwfx member must be filled in with the size, in bytes, of this memory buffer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "",
    "remarks": "If the hook function processes one of the WM_CTLCOLOR messages, this function must return a handle of the brush that should be used to paint the control background. A hook function can optionally process the MM_ACM_FORMATCHOOSE message. You should use this function the same way as you use the Common Dialog hook functions for customizing common dialog boxes. ",
    "return_type": "UINT ACMFORMATCHOOSEHOOKPROC",
    "category": "Windows Multimedia",
    "name": "acmFormatChooseHookProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwnd",
        "description": "Window handle for the dialog box."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Window message."
      },
      {
        "in_out": "",
        "type": "WPARAM",
        "name": "wParam",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFormatDetails",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio format details for a format tag. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver."
      },
      {
        "in_out": "",
        "type": "LPACMFORMATDETAILS",
        "name": "pafd",
        "description": "Pointer to an ACMFORMATDETAILS structure to contain the format details for the given format tag."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDetails",
        "description": "Flags for getting the waveform-audio format tag details. The following values are defined.   Value  Meaning  ACM_FORMATDETAILSF_FORMATA WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure was given and the remaining details should be returned. The dwFormatTag member of the ACMFORMATDETAILS structure must be initialized to the same format tag as pwfx specifies. This query type can be used to get a string description of an arbitrary format structure. If an application specifies an ACM driver handle for had, details on the format will be returned for that driver. If an application specifies NULL for had, the ACM finds the first acceptable driver to return the details. ACM_FORMATDETAILSF_INDEXA format index for the format tag was given in the dwFormatIndex member of the ACMFORMATDETAILS structure. The format details will be returned in the structure defined by pafd. The index ranges from zero to one less than the cStandardFormats member returned in the ACMFORMATTAGDETAILS structure for a format tag. An application must specify a driver handle for had when retrieving format details with this flag. For information about which members should be initialized before calling this function, see the ACMFORMATDETAILS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will not be called. The following example shows how to enumerate formats that have the WAVE_FORMAT_MPEGLAYER3 format tag. The next example shows the callback function for the previous example. The callback function is called once for each matching format or until the callback returns FALSE. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFormatEnum",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio format details. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver."
      },
      {
        "in_out": "",
        "type": "LPACMFORMATDETAILS",
        "name": "pafd",
        "description": "Pointer to an ACMFORMATDETAILS structure to contain the format details passed to the fnCallback function. This structure must have the cbStruct, pwfx, and cbwfx members of the ACMFORMATDETAILS structure initialized. The dwFormatTag member must also be initialized to either WAVE_FORMAT_UNKNOWN or a valid format tag. The fdwSupport member of the structure must be initialized to zero. To find the required size of the pwfx buffer, call acmMetrics with the ACM_METRIC_MAX_SIZE_FORMAT flag."
      },
      {
        "in_out": "",
        "type": "ACMFORMATENUMCB",
        "name": "fnCallback",
        "description": "Address of an application-defined callback function. See acmFormatEnumCallback. This parameter cannot be NULL."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM format details."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwEnum",
        "description": "Flags for enumerating the formats for a given format tag. The following values are defined.   Value  Meaning  ACM_FORMATENUMF_CONVERTThe WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid. The enumerator will only enumerate destination formats that can be converted from the given pwfx format.If this flag is used, the wFormatTag member of the WAVEFORMATEX structure cannot be WAVE_FORMAT_UNKNOWN.  ACM_FORMATENUMF_HARDWAREThe enumerator should only enumerate formats that are supported as native input or output formats on one or more of the installed waveform-audio devices. This flag provides a way for an application to choose only formats native to an installed waveform-audio device. This flag must be used with one or both of the ACM_FORMATENUMF_INPUT and ACM_FORMATENUMF_OUTPUT flags. Specifying both ACM_FORMATENUMF_INPUT and ACM_FORMATENUMF_OUTPUT will enumerate only formats that can be opened for input or output. This is true regardless of whether this flag is specified. ACM_FORMATENUMF_INPUTEnumerator should enumerate only formats that are supported for input (recording). ACM_FORMATENUMF_NCHANNELSThe nChannels member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid. The enumerator will enumerate only a format that conforms to this attribute. ACM_FORMATENUMF_NSAMPLESPERSECThe nSamplesPerSec member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid. The enumerator will enumerate only a format that conforms to this attribute. ACM_FORMATENUMF_OUTPUTEnumerator should enumerate only formats that are supported for output (playback). ACM_FORMATENUMF_SUGGESTThe WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid. The enumerator will enumerate all suggested destination formats for the given pwfx format. This mechanism can be used instead of the acmFormatSuggest function to allow an application to choose the best suggested format for conversion. The dwFormatIndex member will always be set to zero on return.If this flag is used, the wFormatTag member of the WAVEFORMATEX structure cannot be WAVE_FORMAT_UNKNOWN.  ACM_FORMATENUMF_WBITSPERSAMPLEThe wBitsPerSample member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid. The enumerator will enumerate only a format that conforms to this attribute. ACM_FORMATENUMF_WFORMATTAGThe wFormatTag member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid. The enumerator will enumerate only a format that conforms to this attribute. The dwFormatTag member of the ACMFORMATDETAILS structure must be equal to the wFormatTag member.The value of wFormatTag cannot be WAVE_FORMAT_UNKNOWN in this case."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The callback function must return TRUE to continue enumeration or FALSE to stop enumeration. ",
    "remarks": "The acmFormatEnum function will return MMSYSERR_NOERROR (zero) if no formats are to be enumerated. Moreover, the callback function will not be called. The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "BOOL CALLBACK",
    "category": "Windows Multimedia",
    "name": "acmFormatEnumCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the ACM driver identifier."
      },
      {
        "in_out": "",
        "type": "LPACMFORMATDETAILS",
        "name": "pafd",
        "description": "Pointer to an ACMFORMATDETAILS structure that contains the enumerated format details for a format tag."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Application-defined value specified in the acmFormatEnum function."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSupport",
        "description": "Driver support flags specific to the driver identified by hadid for the specified format. These flags are identical to the fdwSupport flags of the ACMDRIVERDETAILS structure, but they are specific to the format that is being enumerated. This parameter can be a combination of the following values and indicates which operations the driver supports for the format tag.   Value  Meaning  ACMDRIVERDETAILS_SUPPORTF_ASYNCDriver supports asynchronous conversions with the specified filter tag. ACMDRIVERDETAILS_SUPPORTF_CODECDriver supports conversion between two different format tags for the specified format. For example, if a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified format, this flag is set. ACMDRIVERDETAILS_SUPPORTF_CONVERTERDriver supports conversion between two different formats of the same format tag while using the specified format. For example, if a driver supports resampling of WAVE_FORMAT_PCM to the specified format, this flag is set. ACMDRIVERDETAILS_SUPPORTF_FILTERDriver supports a filter (modification of the data without changing any of the format attributes) with the specified format. For example, if a driver supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_HARDWAREDriver supports hardware input, output, or both of the specified format tags through a waveform-audio device. An application should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform-audio device identifiers associated with the supporting ACM driver."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFormatSuggest",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to an open instance of a driver to query for a suggested destination format. If this parameter is NULL, the ACM attempts to find the best driver to suggest a destination format."
      },
      {
        "in_out": "",
        "type": "LPWAVEFORMATEX",
        "name": "pwfxSrc",
        "description": "Pointer to a WAVEFORMATEX structure that identifies the source format for which a destination format will be suggested by the ACM or specified driver."
      },
      {
        "in_out": "",
        "type": "LPWAVEFORMATEX",
        "name": "pwfxDst",
        "description": "Pointer to a WAVEFORMATEX structure that will receive the suggested destination format for the pwfxSrc format. Depending on the fdwSuggest parameter, some members of the structure pointed to by pwfxDst may require initialization."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "cbwfxDst",
        "description": "Size, in bytes, available for the destination format. The acmMetrics and acmFormatTagDetails functions can be used to determine the maximum size required for any format available for the specified driver (or for all installed ACM drivers)."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSuggest",
        "description": "Flags for matching the desired destination format. The following values are defined.   Value  Meaning  ACM_FORMATSUGGESTF_NCHANNELSThe nChannels member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can suggest a destination format matching nChannels or fail. ACM_FORMATSUGGESTF_NSAMPLESPERSECThe nSamplesPerSec member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can suggest a destination format matching nSamplesPerSec or fail. ACM_FORMATSUGGESTF_WBITSPERSAMPLEThe wBitsPerSample member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can suggest a destination format matching wBitsPerSample or fail. ACM_FORMATSUGGESTF_WFORMATTAGThe wFormatTag member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can suggest a destination format matching wFormatTag or fail."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFormatTagDetails",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio format tag details. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver. An application must specify a valid handle or driver identifier when using the ACM_FORMATTAGDETAILSF_INDEX query type. Driver identifiers for disabled drivers are not allowed."
      },
      {
        "in_out": "",
        "type": "LPACMFORMATTAGDETAILS",
        "name": "paftd",
        "description": "Pointer to the ACMFORMATTAGDETAILS structure that is to receive the format tag details."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDetails",
        "description": "Flags for getting the details. The following values are defined.   Value  Meaning  ACM_FORMATTAGDETAILSF_FORMATTAGA format tag was given in the dwFormatTag member of the ACMFORMATTAGDETAILS structure. The format tag details will be returned in the structure pointed to by paftd. If an application specifies an ACM driver handle for had, details on the format tag will be returned for that driver. If an application specifies NULL for had, the ACM finds the first acceptable driver to return the details. ACM_FORMATTAGDETAILSF_INDEXA format tag index was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS structure. The format tag and details will be returned in the structure defined by paftd. The index ranges from zero to one less than the cFormatTags member returned in the ACMDRIVERDETAILS structure for an ACM driver. An application must specify a driver handle for had when retrieving format tag details with this flag. ACM_FORMATTAGDETAILSF_LARGESTSIZEDetails on the format tag with the largest format size, in bytes, are to be returned. The dwFormatTag member of the ACMFORMATTAGDETAILS structure must either be WAVE_FORMAT_UNKNOWN or the format tag to find the largest size for. If an application specifies an ACM driver handle for had, details on the largest format tag will be returned for that driver. If an application specifies NULL for had, the ACM finds an acceptable driver with the largest format tag requested to return the details."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will not be called. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmFormatTagEnum",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to the ACM driver to query for waveform-audio format tag details. If this parameter is NULL, the ACM uses the details from the first suitable ACM driver."
      },
      {
        "in_out": "",
        "type": "LPACMFORMATTAGDETAILS",
        "name": "paftd",
        "description": "Pointer to the ACMFORMATTAGDETAILS structure that is to receive the format tag details passed to the function specified in fnCallback. This structure must have the cbStruct member of the ACMFORMATTAGDETAILS structure initialized."
      },
      {
        "in_out": "",
        "type": "ACMFORMATTAGENUMCB",
        "name": "fnCallback",
        "description": "Procedure instance address of the application-defined callback function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM format tag details."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwEnum",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The callback function must return TRUE to continue enumeration or FALSE to stop enumeration. ",
    "remarks": "The acmFormatTagEnum function will return MMSYSERR_NOERROR (zero) if no format tags are to be enumerated. Moreover, the callback function will not be called. The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "BOOL ACMFORMATTAGENUMCB",
    "category": "Windows Multimedia",
    "name": "acmFormatTagEnumCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMDRIVERID",
        "name": "hadid",
        "description": "Handle to the ACM driver identifier."
      },
      {
        "in_out": "",
        "type": "LPACMFORMATTAGDETAILS",
        "name": "paftd",
        "description": "Pointer to an ACMFORMATTAGDETAILS structure that contains the enumerated format tag details."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Application-defined value specified in the acmFormatTagEnum function."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSupport",
        "description": "Driver-support flags specific to the format tag. These flags are identical to the fdwSupport flags of the ACMDRIVERDETAILS structure. This parameter can be a combination of the following values and indicates which operations the driver supports with the format tag.   Value  Meaning  ACMDRIVERDETAILS_SUPPORTF_ASYNCDriver supports asynchronous conversions with the specified filter tag. ACMDRIVERDETAILS_SUPPORTF_CODECDriver supports conversion between two different format tags where one of the tags is the specified format tag. For example, if a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_CONVERTERDriver supports conversion between two different formats of the specified format tag. For example, if a driver supports resampling of WAVE_FORMAT_PCM, this flag is set. ACMDRIVERDETAILS_SUPPORTF_FILTERDriver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver supports volume or echo operations on the specified format tag, this flag is set. ACMDRIVERDETAILS_SUPPORTF_HARDWAREDriver supports hardware input, output, or both of the specified format tag through a waveform-audio device. An application should use acmMetrics with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform-audio device identifiers associated with the supporting ACM driver."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "The version number is returned as a hexadecimal number of the form 0xAABBCCCC, where AA is the major version number, BB is the minor version number, and CCCC is the build number. ",
    "remarks": "Win32 applications must verify that the ACM version is at least 0x03320000 (version 3.50) or greater before attempting to use any other ACM functions. The build number (CCCC) is always zero for the retail (non-debug) version of the ACM. To display the ACM version for a user, an application should use the following format (note that the values should be printed as unsigned decimals): ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "acmGetVersion",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmMetrics",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMOBJ",
        "name": "hao",
        "description": "Handle to the ACM object to query for the metric specified in uMetric. For some queries, this parameter can be NULL."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMetric",
        "description": "Metric index to be returned in pMetric.   Value  Meaning  ACM_METRIC_COUNT_CODECSReturned value is the number of global ACM compressor or decompressor drivers in the system. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_CONVERTERSReturned value is the number of global ACM converter drivers in the system. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_DISABLEDReturned value is the total number of global disabled ACM drivers (of all support types) in the system. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum of the ACM_METRIC_COUNT_DRIVERS and ACM_METRIC_COUNT_DISABLED metric indices is the total number of globally installed ACM drivers. ACM_METRIC_COUNT_DRIVERSReturned value is the total number of enabled global ACM drivers (of all support types) in the system. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_FILTERSReturned value is the number of global ACM filter drivers in the system. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_HARDWAREReturned value is the number of global ACM hardware drivers in the system. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_LOCAL_CODECSReturned value is the number of local ACM compressor drivers, ACM decompressor drivers, or both for the calling task. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_LOCAL_CONVERTERSReturned value is the number of local ACM converter drivers for the calling task. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_LOCAL_DISABLEDReturned value is the total number of local disabled ACM drivers, of all support types, for the calling task. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum of the ACM_METRIC_COUNT_LOCAL_DRIVERS and ACM_METRIC_COUNT_LOCAL_DISABLED metric indices is the total number of locally installed ACM drivers. ACM_METRIC_COUNT_LOCAL_DRIVERSReturned value is the total number of enabled local ACM drivers (of all support types) for the calling task. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_COUNT_LOCAL_FILTERSReturned value is the number of local ACM filter drivers for the calling task. The hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_DRIVER_PRIORITYReturned value is the current priority for the specified driver. The hao parameter must be a valid ACM driver identifier of the HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_DRIVER_SUPPORTReturned value is the fdwSupport flags for the specified driver. The hao parameter must be a valid ACM driver identifier of the HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_HARDWARE_WAVE_INPUTReturned value is the waveform-audio input device identifier associated with the specified driver. The hao parameter must be a valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no waveform-audio input device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_HARDWARE_WAVE_OUTPUTReturned value is the waveform-audio output device identifier associated with the specified driver. The hao parameter must be a valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no waveform-audio output device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must point to a buffer of a size equal to a DWORD value. ACM_METRIC_MAX_SIZE_FILTERReturned value is the size of the largest WAVEFILTER structure. If hao is NULL, the return value is the largest WAVEFILTER structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver identifier of the HACMDRIVERID data type, the largest WAVEFILTER structure for that driver is returned. The pMetric parameter must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of the HACMSTREAM data type. ACM_METRIC_MAX_SIZE_FORMATReturned value is the size of the largest WAVEFORMATEX structure. If hao is NULL, the return value is the largest WAVEFORMATEX structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver identifier of the HACMDRIVERID data type, the largest WAVEFORMATEX structure for that driver is returned. The pMetric parameter must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of the HACMSTREAM data type."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "pMetric",
        "description": "Pointer to the buffer to receive the metric details. The exact definition depends on the uMetric index."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamClose",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the open conversion stream to be closed."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwClose",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "You must use the acmStreamPrepareHeader function to prepare the source and destination buffers before they are passed to acmStreamConvert. If an asynchronous conversion request is successfully queued by the ACM or driver and the conversion is later determined to be impossible, the ACMSTREAMHEADER structure is posted back to the application's callback function with the cbDstLengthUsed member set to zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamConvert",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the open conversion stream."
      },
      {
        "in_out": "",
        "type": "LPACMSTREAMHEADER",
        "name": "pash",
        "description": "Pointer to a stream header that describes source and destination buffers for a conversion. This header must have been prepared previously by using the acmStreamPrepareHeader function."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwConvert",
        "description": "Flags for doing the conversion. The following values are defined.   Value  Meaning  ACM_STREAMCONVERTF_BLOCKALIGNOnly integral numbers of blocks will be converted. Converted data will end on block-aligned boundaries. An application should use this flag for all conversions on a stream until there is not enough source data to convert to a block-aligned destination. In this case, the last conversion should be specified without this flag. ACM_STREAMCONVERTF_ENDACM conversion stream should begin returning pending instance data. For example, if a conversion stream holds instance data, such as the end of an echo filter operation, this flag will cause the stream to start returning this remaining data with optional source data. This flag can be specified with the ACM_STREAMCONVERTF_START flag. ACM_STREAMCONVERTF_STARTACM conversion stream should reinitialize its instance data. For example, if a conversion stream holds instance data, such as delta or predictor information, this flag will restore the stream to starting defaults. This flag can be specified with the ACM_STREAMCONVERTF_END flag."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority. ",
    "return_type": "void CALLBACK",
    "category": "Windows Multimedia",
    "name": "acmStreamConvertCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the ACM conversion stream associated with the callback function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "ACM conversion stream message. The following values are defined.   Value  Meaning  MM_ACM_CLOSEACM has successfully closed the conversion stream identified by has. The handle specified by has is no longer valid after receiving this message. MM_ACM_DONEACM has successfully converted the buffer identified by lParam1 (which is a pointer to the ACMSTREAMHEADER structure) for the stream handle identified by has. MM_ACM_OPENACM has successfully opened the conversion stream identified by has."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwInstance",
        "description": "User-instance data given as the dwInstance parameter of the acmStreamOpen function."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns the value returned by the ACM device driver. ",
    "remarks": "",
    "return_type": "MMRESULT ACMAPI",
    "category": "Windows Multimedia",
    "name": "acmStreamMessage",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to an open conversion stream."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If an ACM driver cannot perform real-time conversions and the ACM_STREAMOPENF_NONREALTIME flag is not specified for the fdwOpen parameter, the open operation will fail returning an ACMERR_NOTPOSSIBLE error code. An application can use the ACM_STREAMOPENF_QUERY flag to determine if real-time conversions are supported for input. If an application uses a window to receive callback information, the MM_ACM_OPEN, MM_ACM_CLOSE, and MM_ACM_DONE messages are sent to the window procedure function to indicate the progress of the conversion stream. In this case, the wParam parameter identifies the HACMSTREAM handle. The lParam parameter identifies the ACMSTREAMHEADER structure for MM_ACM_DONE, but it is not used for MM_ACM_OPEN and MM_ACM_CLOSE. If an application uses a function to receive callback information, the MM_ACM_OPEN, MM_ACM_CLOSE, and MM_ACM_DONE messages are sent to the function to indicate the progress of waveform-audio output. The callback function must reside in a dynamic-link library (DLL). If an application uses an event for callback notification, the event is signaled to indicate the progress of the conversion stream. The event will be signaled when a stream is opened, after each buffer is converted, and when the stream is closed. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamOpen",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHACMSTREAM",
        "name": "phas",
        "description": "Pointer to a handle that will receive the new stream handle that can be used to perform conversions. This handle is used to identify the stream in calls to other ACM stream conversion functions. If the ACM_STREAMOPENF_QUERY flag is specified, this parameter should be NULL."
      },
      {
        "in_out": "",
        "type": "HACMDRIVER",
        "name": "had",
        "description": "Handle to an ACM driver. If this handle is specified, it identifies a specific driver to be used for a conversion stream. If this parameter is NULL, all suitable installed ACM drivers are queried until a match is found."
      },
      {
        "in_out": "",
        "type": "LPWAVEFORMATEX",
        "name": "pwfxSrc",
        "description": "Pointer to a WAVEFORMATEX structure that identifies the desired source format for the conversion."
      },
      {
        "in_out": "",
        "type": "LPWAVEFORMATEX",
        "name": "pwfxDst",
        "description": "Pointer to a WAVEFORMATEX structure that identifies the desired destination format for the conversion."
      },
      {
        "in_out": "",
        "type": "LPWAVEFILTER",
        "name": "pwfltr",
        "description": "Pointer to a WAVEFILTER structure that identifies the desired filtering operation to perform on the conversion stream. If no filtering operation is desired, this parameter can be NULL. If a filter is specified, the source (pwfxSrc) and destination (pwfxDst) formats must be the same."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Pointer to a callback function, a handle of a window, or a handle of an event. A callback function will be called only if the conversion stream is opened with the ACM_STREAMOPENF_ASYNC flag. A callback function is notified when the conversion stream is opened or closed and after each buffer is converted. If the conversion stream is opened without the ACM_STREAMOPENF_ASYNC flag, this parameter should be set to zero."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "User-instance data passed to the callback function specified by the dwCallback parameter. This parameter is not used with window and event callbacks. If the conversion stream is opened without the ACM_STREAMOPENF_ASYNC flag, this parameter should be set to zero."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwOpen",
        "description": "Flags for opening the conversion stream. The following values are defined.   Value  Meaning  ACM_STREAMOPENF_ASYNCStream conversion should be performed asynchronously. If this flag is specified, the application can use a callback function to be notified when the conversion stream is opened and closed and after each buffer is converted. In addition to using a callback function, an application can examine the fdwStatus member of the ACMSTREAMHEADER structure for the ACMSTREAMHEADER_STATUSF_DONE flag. ACM_STREAMOPENF_NONREALTIMEACM will not consider time constraints when converting the data. By default, the driver will attempt to convert the data in real time. For some formats, specifying this flag might improve the audio quality or other characteristics. ACM_STREAMOPENF_QUERYACM will be queried to determine whether it supports the given conversion. A conversion stream will not be opened, and no handle will be returned in the phas parameter. CALLBACK_EVENTThe dwCallback parameter is a handle of an event. CALLBACK_FUNCTIONThe dwCallback parameter is a callback procedure address. The function prototype must conform to the acmStreamConvertCallback prototype. CALLBACK_WINDOWThe dwCallback parameter is a window handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Preparing a stream header that has already been prepared has no effect, and the function returns zero. Nevertheless, you should ensure your application does not prepare a stream header multiple times. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamPrepareHeader",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the conversion steam."
      },
      {
        "in_out": "",
        "type": "LPACMSTREAMHEADER",
        "name": "pash",
        "description": "Pointer to an ACMSTREAMHEADER structure that identifies the source and destination buffers to be prepared."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwPrepare",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Resetting an ACM conversion stream is necessary only for asynchronous conversion streams. Resetting a synchronous conversion stream will succeed, but no action will be taken. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamReset",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the conversion stream."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwReset",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "An application can use this function to determine suggested buffer sizes for either source or destination buffers. The buffer sizes returned might be only an estimation of the actual sizes required for conversion. Because actual conversion sizes cannot always be determined without performing the conversion, the sizes returned will usually be overestimated. In the event of an error, the location pointed to by pdwOutputBytes will receive zero. This assumes that the pointer specified by pdwOutputBytes is valid. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamSize",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the conversion stream."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "cbInput",
        "description": "Size, in bytes, of the source or destination buffer. The fdwSize flags specify what the input parameter defines. This parameter must be nonzero."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "pdwOutputBytes",
        "description": "Pointer to a variable that contains the size, in bytes, of the source or destination buffer. The fdwSize flags specify what the output parameter defines. If the acmStreamSize function succeeds, this location will always be filled with a nonzero value."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSize",
        "description": "Flags for the stream size query. The following values are defined:   Value  Meaning  ACM_STREAMSIZEF_DESTINATIONThe cbInput parameter contains the size of the destination buffer. The pdwOutputBytes parameter will receive the recommended source buffer size, in bytes. ACM_STREAMSIZEF_SOURCEThe cbInput parameter contains the size of the source buffer. The pdwOutputBytes parameter will receive the recommended destination buffer size, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Msacm32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Msacm.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Unpreparing a stream header that has already been unprepared is an error. An application must specify the source and destination buffer lengths (cbSrcLength and cbDstLength, respectively) that were used during a call to the corresponding acmStreamPrepareHeader. Failing to reset these member values will cause acmStreamUnprepareHeader to fail with an MMSYSERR_INVALPARAM error. The ACM can recover from some errors. The ACM will return a nonzero error, yet the stream header will be properly unprepared. To determine whether the stream header was actually unprepared, an application can examine the ACMSTREAMHEADER_STATUSF_PREPARED flag. If acmStreamUnprepareHeader returns success, the header will always be unprepared. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "acmStreamUnprepareHeader",
    "is_callback": 0,
    "dll": "Msacm32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HACMSTREAM",
        "name": "has",
        "description": "Handle to the conversion steam."
      },
      {
        "in_out": "",
        "type": "LPACMSTREAMHEADER",
        "name": "pash",
        "description": "Pointer to an ACMSTREAMHEADER structure that identifies the source and destination buffers to be unprepared."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwUnprepare",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The device identifier in uDeviceID varies from zero to one less than the number of devices present. AUX_MAPPER may also be used. Use the auxGetNumDevs function to determine the number of auxiliary output devices present in the system. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "auxGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uDeviceID",
        "description": "Identifier of the auxiliary output device to be queried. Specify a valid device identifier (see the following comments section), or use the following constant:   Value  Meaning  AUX_MAPPERAuxiliary audio mapper. The function returns an error if no auxiliary audio mapper is installed."
      },
      {
        "in_out": "",
        "type": "LPAUXCAPS",
        "name": "lpCaps",
        "description": "Pointer to an AUXCAPS structure to be filled with information about the capabilities of the device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbCaps",
        "description": "Size, in bytes, of the AUXCAPS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of device. A return value of zero means that no devices are present or that an error occurred. ",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "auxGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Not all devices support volume control. To determine whether a device supports volume control, use the AUXCAPS_VOLUME flag to test the dwSupport member of the AUXCAPS structure (filled by the auxGetDevCaps function). To determine whether a device supports volume control on both the left and right channels, use the AUXCAPS_LRVOLUME flag to test the dwSupport member of the AUXCAPS structure (filled by auxGetDevCaps). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "auxGetVolume",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDeviceID",
        "description": "Identifier of the auxiliary output device to be queried."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "lpdwVolume",
        "description": "Pointer to a variable to be filled with the current volume setting. The low-order word of this location contains the left channel volume setting, and the high-order word contains the right channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence. If a device does not support both left and right volume control, the low-order word of the specified location contains the volume level. The full 16-bit setting(s) set with the auxSetVolume function are returned, regardless of whether the device supports the full 16 bits of volume-level control."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the message return value. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "auxOutMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDeviceID",
        "description": "Identifier of the auxiliary output device to receive the message."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Not all devices support volume control. To determine whether the device supports volume control, use the AUXCAPS_VOLUME flag to test the dwSupport member of the AUXCAPS structure (filled by the auxGetDevCaps function). To determine whether the device supports volume control on both the left and right channels, use the AUXCAPS_LRVOLUME flag to test the dwSupport member of the AUXCAPS structure (filled by auxGetDevCaps). Most devices do not support the full 16 bits of volume-level control and will use only the high-order bits of the requested volume setting. For example, for a device that supports 4 bits of volume control, requested volume level values of 0x4000, 0x4FFF, and 0x43BE will produce the same physical volume setting, 0x4000. The auxGetVolume function will return the full 16-bit setting set with auxSetVolume. Volume settings are interpreted logarithmically. This means the perceived volume increase is the same when increasing the volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "auxSetVolume",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDeviceID",
        "description": "Identifier of the auxiliary output device to be queried. Device identifiers are determined implicitly from the number of devices present in the system. Device identifier values range from zero to one less than the number of devices present. Use the auxGetNumDevs function to determine the number of auxiliary devices in the system."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwVolume",
        "description": "Specifies the new volume setting. The low-order word specifies the left-channel volume setting, and the high-order word specifies the right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence. If a device does not support both left and right volume control, the low-order word of dwVolume specifies the volume level, and the high-order word is ignored."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns AVIERR_OK if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function accesses the registry for all filter types that the AVIFile library can use to open, read, or write multimedia files. It does not search the hard disk for filter DLLs and formats. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIBuildFilter",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpszFilter",
        "description": "Pointer to the buffer containing the filter string."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbFilter",
        "description": "Size, in characters, of buffer pointed to by lpszFilter."
      },
      {
        "in_out": "",
        "type": "BOOL",
        "name": "fSaving",
        "description": "Flag that indicates whether the filter should include read or write formats. Specify TRUE to include write formats or FALSE to include read formats."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIClearClipboard",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the updated reference count for the file interface. ",
    "remarks": "The argument pfile is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI_(ULONG)",
    "category": "Windows Multimedia",
    "name": "AVIFileAddRef",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. Unless the file has been opened with write permission, this function returns AVIERR_READONLY. ",
    "remarks": "This function starts a reference count for the new stream. The argument pfile is a pointer to an IAVIFile interface. The argument ppavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileCreateStream",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppavi",
        "description": "Pointer to the new stream interface."
      },
      {
        "in_out": "",
        "type": "AVISTREAMINFO*",
        "name": "psi",
        "description": "Pointer to a structure containing information about the new stream, including the stream type and its sample rate."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The AVISave function uses this function internally. In general, applications should not need to use this function. The argument pfile is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileEndRecord",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "STDAPI_(VOID)",
    "category": "Windows Multimedia",
    "name": "AVIFileExit",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The argument pfile is a pointer to an IAVIFile interface. The argument ppavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileGetStream",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppavi",
        "description": "Pointer to the new stream interface."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of stream to open. Zero indicates any stream can be opened. The following definitions apply to the data commonly found in AVI streams.                     Value                                    Description                  streamtypeAUDIOIndicates an audio stream. streamtypeMIDIIndicates a MIDI stream. streamtypeTEXTIndicates a text stream. streamtypeVIDEOIndicates a video stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam",
        "description": "Count of the stream type. Identifies which occurrence of the specified stream type to access."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The argument pfile is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileInfo",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      },
      {
        "in_out": "",
        "type": "AVIFILEINFO*",
        "name": "pfi",
        "description": "Pointer to the structure used to return file information. Typically, this parameter points to an AVIFILEINFO structure."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lSize",
        "description": "Size, in bytes, of the structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "STDAPI_(VOID)",
    "category": "Windows Multimedia",
    "name": "AVIFileInit",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileOpen",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE*",
        "name": "ppfile",
        "description": "Pointer to a buffer that receives the new IAVIFile interface pointer."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "Null-terminated string containing the name of the file to open."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "mode",
        "description": "Access mode to use when opening the file. ..."
      },
      {
        "in_out": "",
        "type": "CLSID",
        "name": "pclsidHandler",
        "description": "Pointer to a class identifier of the standard or custom handler you want to use. If the value is NULL, the system chooses a handler from the registry based on the file extension or the RIFF type specified in the file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. The return value AVIERR_NODATA indicates that data with the requested chunk identifier does not exist. ",
    "remarks": "The optional header information is custom and does not have a set format. The argument pfile is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileReadData",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "ckid",
        "description": "RIFF chunk identifier (four-character code) of the data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to the buffer used to return the data read."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "lpcbData",
        "description": "Pointer to a location indicating the size of the memory block referenced by lpData. If the data is read successfully, the value is changed to indicate the amount of data read."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the reference count of the file. This return value should be used only for debugging purposes. ",
    "remarks": "The argument pfile is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI_(ULONG)",
    "category": "Windows Multimedia",
    "name": "AVIFileRelease",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. In an application has read-only access to the file, the error code AVIERR_READONLY is returned. ",
    "remarks": "Use the AVIStreamWriteData function to write data that applies to an individual stream. The argument pfile is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIFileWriteData",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pfile",
        "description": "Handle to an open AVI file."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "ckid",
        "description": "RIFF chunk identifier (four-character code) of the data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to the buffer used to write the data."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbData",
        "description": "Size, in bytes, of the memory block referenced by lpData."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "If the clipboard does not contain an AVI file, AVIGetFromClipboard also can copy data with the CF_DIB or CF_WAVE clipboard flags to an AVI file. In this case, the function creates an AVI file with one DIB stream and one waveform-audio stream, and fills each stream with the data from the clipboard. The argument lppf is the address of a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIGetFromClipboard",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE*",
        "name": "lppf",
        "description": "Pointer to the location used to return the handle created for the AVI file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns AVIERR_OK if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Applications can read from or write to the compressed stream. A PAVISTREAM is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIMakeCompressedStream",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppsCompressed",
        "description": "Pointer to a buffer that receives the compressed stream pointer."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "psSource",
        "description": "Pointer to the stream to be compressed."
      },
      {
        "in_out": "",
        "type": "AVICOMPRESSOPTIONS*",
        "name": "lpOptions",
        "description": "Pointer to a structure that identifies the type of compression to use and the options to apply. You can specify video compression by identifying an appropriate handler in the AVICOMPRESSOPTIONS structure. For audio compression, specify the compressed data format."
      },
      {
        "in_out": "",
        "type": "CLSID*",
        "name": "pclsidHandler",
        "description": "Pointer to a class identifier used to create the stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "Use the AVIFileRelease function to close the file. Other functions can use the AVIFile interface created by this function to copy and edit the streams associated with the interface. For example, you can retrieve a specific stream by using AVIFileGetStream with the file interface pointer. The argument pfile is the address of a pointer to an IAVIFile interface. The argument papStreams is the address of a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIMakeFileFromStreams",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE*",
        "name": "ppfile",
        "description": "Pointer to a buffer that receives the new file interface pointer."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nStreams",
        "description": "Count of the number of streams in the array of stream interface pointers referenced by papStreams."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "papStreams",
        "description": "Pointer to an array of stream interface pointers."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "When an application finishes using the editable stream, it must release the stream to free the resources associated with it. The argument ppstream is the address of a pointer to an IAVIStream interface. ",
    "return_type": "SDTAPI",
    "category": "Windows Multimedia",
    "name": "AVIMakeStreamFromClipboard",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "cfFormat",
        "description": "Clipboard flag."
      },
      {
        "in_out": "",
        "type": "HANDLE",
        "name": "hGlobal",
        "description": "Handle to stream data on the clipboard."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppstream",
        "description": "Handle to the created stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "This function also copies data with the CF_DIB, CF_PALETTE, and CF_WAVE clipboard flags onto the clipboard using the first frame of the first video stream of the file as a DIB and using the audio stream as CF_WAVE. The argument pf is a pointer to an IAVIFile interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIPutFileOnClipboard",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVIFILE",
        "name": "pf",
        "description": "Handle to an open AVI file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns AVIERR_OK if successful or an error otherwise. ",
    "remarks": "This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new file. The last two parameters of this function identify a stream to save in the file and define the compression options of that stream. When saving more than one stream in an AVI file, repeat these two stream-specific parameters for each stream in the file. A callback function (referenced by using lpfnCallback) can display status information and let the user cancel the save operation. The callback function uses the following format: The nPercent parameter specifies the percentage of the file saved. The callback function should return AVIERR_OK if the operation should continue and AVIERR_USERABORT if the user wishes to abort the save operation. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "HRESULT",
    "category": "Windows Multimedia",
    "name": "AVISave",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "Null-terminated string containing the name of the file to save."
      },
      {
        "in_out": "",
        "type": "CLSID*",
        "name": "pclsidHandler",
        "description": "Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler. If a handler is not specified, a default is selected from the registry based on the file extension."
      },
      {
        "in_out": "",
        "type": "AVISAVECALLBACK",
        "name": "lpfnCallback",
        "description": "Pointer to a callback function for the save operation."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nStreams",
        "description": "Number of streams saved in the file."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Pointer to an AVI stream. This parameter is paired with lpOptions. The parameter pair can be repeated as a variable number of arguments."
      },
      {
        "in_out": "",
        "type": "LPAVICOMPRESSOPTIONS",
        "name": "lpOptions",
        "description": "Pointer to an application-defined AVICOMPRESSOPTIONS structure containing the compression options for the stream referenced by pavi. This parameter is paired with pavi. The parameter pair can be repeated as a variable number of arguments."
      },
      {
        "in_out": ".",
        "type": ".",
        "name": ".",
        "description": ""
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if the user pressed OK, FALSE for CANCEL, or an error otherwise. ",
    "remarks": "This function presents a standard Compression Options dialog box using hwnd as the parent window handle. When the user is finished selecting the compression options for each stream, the options are returned in the AVICOMPRESSOPTIONS structure in the array referenced by plpOptions. The calling application must pass the interface pointers for the streams in the array referenced by ppavi. An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures. The argument ppavi contains the address of a pointer to an IAVIStream interface. ",
    "return_type": "INT_PTR",
    "category": "Windows Multimedia",
    "name": "AVISaveOptions",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwnd",
        "description": "Handle to the parent window for the Compression Options dialog box."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uiFlags",
        "description": "Flags for displaying the Compression Options dialog box. The following flags are defined.   Value  Meaning  ICMF_CHOOSE_KEYFRAMEDisplays a Key Frame Every dialog box for the video options. This is the same flag used in the ICCompressorChoose function. ICMF_CHOOSE_DATARATEDisplays a Data Rate dialog box for the video options. This is the same flag used in ICCompressorChoose. ICMF_CHOOSE_PREVIEWDisplays a Preview button for the video options. This button previews the compression by using a frame from the stream. This is the same flag used in ICCompressorChoose."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nStreams",
        "description": "Number of streams that have their options set by the dialog box."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppavi",
        "description": "Pointer to an array of stream interface pointers. The nStreams parameter indicates the number of pointers in the array."
      },
      {
        "in_out": "",
        "type": "LPAVICOMPRESSOPTIONS*",
        "name": "plpOptions",
        "description": "Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. These structures hold the compression options set by the dialog box. The nStreams parameter indicates the number of pointers in the array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns AVIERR_OK. ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Windows Multimedia",
    "name": "AVISaveOptionsFree",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "int",
        "name": "nStreams",
        "description": "Count of the AVICOMPRESSOPTIONS structures referenced in plpOptions."
      },
      {
        "in_out": "",
        "type": "LPAVICOMPRESSOPTIONS*",
        "name": "plpOptions",
        "description": "Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. These structures hold the compression options set by the dialog box. The resources allocated by AVISaveOptions for each of these structures will be freed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns AVIERR_OK if successful or an error otherwise. ",
    "remarks": "This function is equivalent to the AVISave function except the streams are passed in an array instead of as a variable number of arguments. This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new file. The last two parameters of this function are arrays that identify the streams to save in the file and define the compression options of those streams. An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures. The argument ppavi contains the address of a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVISaveV",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "Null-terminated string containing the name of the file to save."
      },
      {
        "in_out": "",
        "type": "CLSID*",
        "name": "pclsidHandler",
        "description": "Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler. If a handler is not specified, a default is selected from the registry based on the file extension."
      },
      {
        "in_out": "",
        "type": "AVISAVECALLBACK",
        "name": "lpfnCallback",
        "description": "Pointer to a callback function used to display status information and to let the user cancel the save operation."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nStreams",
        "description": "Number of streams to save."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppavi",
        "description": "Pointer to an array of pointers to the AVISTREAM function structures. The array uses one pointer for each stream."
      },
      {
        "in_out": "",
        "type": "LPAVICOMPRESSOPTIONS*",
        "name": "plpOptions",
        "description": "Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. The array uses one pointer for each stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the current reference count of the stream. This value should be used only for debugging purposes. ",
    "remarks": "The argument pavi contains a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamAddRef",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open AVI stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamBeginStreaming",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Pointer to a stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lStart",
        "description": "Starting frame for streaming."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lEnd",
        "description": "Ending frame for streaming."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lRate",
        "description": "Speed at which the file is read relative to its natural speed. Specify 1000 for the normal speed. Values less than 1000 indicate a slower-than-normal speed; values greater than 1000 indicate a faster-than-normal speed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "You should not need to call this function. Some functions, such as CreateEditableStream and AVIMakeCompressedStream, use it internally. The argument ppavi contains the address of a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamCreate",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppavi",
        "description": "Pointer to a buffer that receives the new stream interface."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam1",
        "description": "Stream-handler specific information."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam2",
        "description": "Stream-handler specific information."
      },
      {
        "in_out": "",
        "type": "CLSID*",
        "name": "pclsidHandler",
        "description": "Pointer to the class identifier used for the stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "Many stream implementations ignore this function. The argument pavi contains a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamEndStreaming",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Pointer to a stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the position of the frame found or -1 if the search is unsuccessful. ",
    "remarks": "The FIND_KEY, FIND_ANY, and FIND_FORMAT flags are mutually exclusive, as are the FIND_NEXT and FIND_PREV flags. The argument pavi contains a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamFindSample",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lPos",
        "description": "Starting frame for the search."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lFlags",
        "description": "Flags that designate the type of frame to locate, the direction in the stream to search, and the type of return information. The following flags are defined.   Value  Meaning  FIND_ANYFinds a nonempty frame. This flag supersedes the SEARCH_ANY flag. FIND_KEYFinds a key frame. This flag supersedes the SEARCH_KEY flag. FIND_FORMATFinds a format change. FIND_NEXTFinds nearest sample, frame, or format change searching forward. The current sample is included in the search. Use this flag with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag. This flag supersedes the SEARCH_FORWARD flag. FIND_PREVFinds nearest sample, frame, or format change searching backward. The current sample is included in the search. Use this flag with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag. This flag supersedes the SEARCH_NEAREST and SEARCH_BACKWARD flags. FIND_FROM_STARTFinds first sample, frame, or format change beginning from the start of the stream. Use this flag with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a pointer to the frame data if successful or NULL otherwise. The frame data is returned as a packed DIB. ",
    "remarks": "The returned frame is valid only until the next call to this function or the AVIStreamGetFrameClose function. ",
    "return_type": "STDAPI_(LPVOID)",
    "category": "Windows Multimedia",
    "name": "AVIStreamGetFrame",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PGETFRAME",
        "name": "pgf",
        "description": "Pointer to the IGetFrame interface."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lPos",
        "description": "Position, in samples, within the stream of the desired frame."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamGetFrameClose",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PGETFRAME",
        "name": "pget",
        "description": "Handle returned from the AVIStreamGetFrameOpen function. After calling this function, the handle is invalid."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a GetFrame object that can be used with the AVIStreamGetFrame function. If the system cannot find a decompressor that can decompress the stream to the given format, or to any RGB format, the function returns NULL. The argument pavi is a pointer to an IAVIStream interface. ",
    "remarks": "",
    "return_type": "STDAPI_(PGETFRAME)",
    "category": "Windows Multimedia",
    "name": "AVIStreamGetFrameOpen",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Pointer to the video stream used as the video source."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiWanted",
        "description": "Pointer to a structure that defines the desired video format. Specify NULL to use a default format. You can also specify AVIGETFRAMEF_BESTDISPLAYFMT to decode the frames to the best format for your display."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. The argument pavi is a pointer to an IAVIStream interface. ",
    "remarks": "",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamInfo",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "AVISTREAMINFO*",
        "name": "psi",
        "description": "Pointer to a structure to contain the stream information."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lSize",
        "description": "Size, in bytes, of the structure used forpsi."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the stream's length, in samples, if successful or -1 otherwise. The argument pavi is a pointer to an IAVIStream interface. ",
    "remarks": "",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamLength",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "This function calls the AVIFileOpen, AVIFileGetStream, and AVIFileRelease functions. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamOpenFromFile",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppavi",
        "description": "Pointer to a buffer that receives the new stream handle."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "Null-terminated string containing the name of the file to open."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of stream to be opened. Zero indicates that any stream can be opened. The following definitions apply to the data commonly found in AVI streams:                     Value                                    Description                  streamtypeAUDIOIndicates an audio stream. streamtypeMIDIIndicates a MIDI stream. streamtypeTEXTIndicates a text stream. streamtypeVIDEOIndicates a video stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam",
        "description": "Stream of the type specified in fccType to access. This parameter is zero-based; use zero to specify the first occurrence."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "mode",
        "description": "Access mode to use when opening the file. This function can open only existing streams, so the OF_CREATE mode flag cannot be used. For more information about the available flags for the mode parameter, see the OpenFile function."
      },
      {
        "in_out": "",
        "type": "CLSID*",
        "name": "pclsidHandler",
        "description": "Pointer to a class identifier of the handler you want to use. If the value is NULL, the system chooses one from the registry based on the file extension or the file RIFF type."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If lpBuffer is NULL, this function does not read any data; it returns information about the size of data that would be read. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamRead",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lStart",
        "description": "First sample to read."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lSamples",
        "description": "Number of samples to read. You can also specify the value AVISTREAMREAD_CONVENIENT to let the stream handler determine the number of samples to read."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to a buffer to contain the data."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbBuffer",
        "description": "Size, in bytes, of the buffer pointed to by lpBuffer."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plBytes",
        "description": "Pointer to a buffer that receives the number of bytes of data written in the buffer referenced by lpBuffer. This value can be NULL."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plSamples",
        "description": "Pointer to a buffer that receives the number of samples written in the buffer referenced by lpBuffer. This value can be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. The return value AVIERR_NODATA indicates the system could not find any data with the specified chunk identifier. ",
    "remarks": "This function retrieves only optional header information from the stream. This information is custom and does not have a set format. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamReadData",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "ckid",
        "description": "Four-character code identifying the data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to the buffer to contain the optional header data."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "lpcbData",
        "description": "Pointer to the location that specifies the buffer size used for lpData. If the read is successful, AVIFile changes this value to indicate the amount of data written into the buffer for lpData."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The AVIStreamReadFormat function reads the stream format data.",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. The argument pavi is a pointer to an IAVIStream interface. ",
    "remarks": "Standard video stream handlers provide format information in a BITMAPINFOHEADER structure. Standard audio stream handlers provide format information in a PCMWAVEFORMAT structure. Other data streams can use other structures that describe the stream data. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamReadFormat",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lPos",
        "description": "Position in the stream used to obtain the format data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpFormat",
        "description": "Pointer to a buffer to contain the format data."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "lpcbFormat",
        "description": "Pointer to a location indicating the size of the memory block referenced by lpFormat. On return, the value is changed to indicate the amount of data read. If lpFormat is NULL, this parameter can be used to obtain the amount of memory needed to return the format."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the current reference count of the stream. This value should be used only for debugging purposes. The argument pavi is a pointer to an IAVIStream interface. ",
    "remarks": "",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamRelease",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the converted time if successful or \u00e2\u0080\u00931 otherwise. ",
    "remarks": "The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamSampleToTime",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lSample",
        "description": "Position information. A sample can correspond to blocks of audio, a video frame, or other format, depending on the stream type."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The handler for writing AVI files does not accept format changes. Besides setting the initial format for a stream, only changes in the palette of a video stream are allowed in an AVI file. The palette change must occur after any frames already written to the AVI file. Other handlers might impose different restrictions. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamSetFormat",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lPos",
        "description": "Position in the stream to receive the format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpFormat",
        "description": "Pointer to a structure containing the new format."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbFormat",
        "description": "Size, in bytes, of the block of memory referenced by lpFormat."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the number if successful or -1 otherwise. ",
    "remarks": "The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamStart",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the converted time if successful or -1 otherwise. ",
    "remarks": "Samples typically correspond to audio samples or video frames. Other stream types might support different formats than these. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI_(LONG)",
    "category": "Windows Multimedia",
    "name": "AVIStreamTimeToSample",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lTime",
        "description": "Time, expressed in milliseconds."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The default AVI file handler supports writing only at the end of a stream. The \"WAVE\" file handler supports writing anywhere. This function overwrites existing data, rather than inserting new data. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamWrite",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lStart",
        "description": "First sample to write."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lSamples",
        "description": "Number of samples to write."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to a buffer containing the data to write."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbBuffer",
        "description": "Size of the buffer referenced by lpBuffer."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag associated with this data. The following flag is defined:  ValueMeaning  AVIIF_KEYFRAME   Indicates this data does not rely on preceding data in the file."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plSampWritten",
        "description": "Pointer to a buffer that receives the number of samples written. This can be set to NULL."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plBytesWritten",
        "description": "Pointer to a buffer that receives the number of bytes written. This can be set to NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. The return value AVIERR_READONLY indicates the file was opened without write access. ",
    "remarks": "Use the AVIStreamWrite function to write the multimedia content of the stream. Use AVIFileWriteData to write data that applies to an entire file. The argument pavi is a pointer to an IAVIStream interface. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "AVIStreamWriteData",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "ckid",
        "description": "Four-character code identifying the data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to a buffer containing the data to write."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbData",
        "description": "Number of bytes of data to write into the stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "When nState is set to CONTROLCALLBACK_PREROLL, this callback function must return TRUE to start capture or FALSE to abort it. When nState is set to CONTROLCALLBACK_CAPTURING, this callback function must return TRUE to continue capture or FALSE to end it. ",
    "remarks": "The first message sent to the callback procedure sets the nState parameter to CONTROLCALLBACK_PREROLL after allocating all buffers and all other capture preparations are complete. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "capControlCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the capture window associated with the callback function."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nState",
        "description": "Current state of the capture operation. The CONTROLCALLBACK_PREROLL value is sent initially to enable prerolling of the video sources and to return control to the capture application at the exact moment recording is to begin. The CONTROLCALLBACK_CAPTURING value is sent once per captured frame to indicate that streaming capture is in progress and to enable the application to end capture."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle of the capture window if successful or NULL otherwise. ",
    "remarks": "",
    "return_type": "HWND VFWAPI",
    "category": "Windows Multimedia",
    "name": "capCreateCaptureWindow",
    "is_callback": 0,
    "dll": "Avicap32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpszWindowName",
        "description": "Null-terminated string containing the name used for the capture window."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwStyle",
        "description": "Window styles used for the capture window. Window styles are described with the CreateWindowEx function."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "x",
        "description": "The x-coordinate of the upper left corner of the capture window."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "y",
        "description": "The y-coordinate of the upper left corner of the capture window."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nWidth",
        "description": "Width of the capture window."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nHeight",
        "description": "Height of the capture window."
      },
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the parent window."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nID",
        "description": "Window identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "",
    "remarks": "A message identifier of zero indicates a new operation is starting and the callback function should clear the current error. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "capErrorCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the capture window associated with the callback function."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nID",
        "description": "Error identification number."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpsz",
        "description": "Pointer to a textual description of the returned error."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "If the information description is longer than its buffer, the description is truncated. The returned string is always null-terminated. If a buffer size is zero, its corresponding description is not copied. ",
    "return_type": "BOOL VFWAPI",
    "category": "Windows Multimedia",
    "name": "capGetDriverDescription",
    "is_callback": 0,
    "dll": "Avicap32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "WORD",
        "name": "wDriverIndex",
        "description": "Index of the capture driver. The index can range from 0 through 9. Plug-and-Play capture drivers are enumerated first, followed by capture drivers listed in the registry, which are then followed by capture drivers listed in SYSTEM.INI."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpszName",
        "description": "Pointer to a buffer containing a null-terminated string corresponding to the capture driver name."
      },
      {
        "in_out": "",
        "type": "INT",
        "name": "cbName",
        "description": "Length, in bytes, of the buffer pointed to by lpszName."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpszVer",
        "description": "Pointer to a buffer containing a null-terminated string corresponding to the description of the capture driver."
      },
      {
        "in_out": "",
        "type": "INT",
        "name": "cbVer",
        "description": "Length, in bytes, of the buffer pointed to by lpszVer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "",
    "remarks": "During capture operations, the first message sent to the callback function is always IDS_CAP_BEGIN and the last is always IDS_CAP_END. A message identifier of zero indicates a new operation is starting and the callback function should clear the current status. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "capStatusCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the capture window associated with the callback function."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "nID",
        "description": "Message identification number."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpsz",
        "description": "Pointer to a textual description of the returned status."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "",
    "remarks": "The capture window calls a video stream callback function when a video buffer is marked done by the capture driver. When capturing to disk, this will precede the disk write operation. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "capVideoStreamCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the capture window associated with the callback function."
      },
      {
        "in_out": "",
        "type": "LPVIDEOHDR",
        "name": "lpVHdr",
        "description": "Pointer to a VIDEOHDR structure containing information about the captured frame."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "",
    "remarks": "The capture window calls a wave stream callback function when an audio buffer is marked done by the waveform-audio driver. When capturing to disk, this will precede the disk write operation. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "capWaveStreamCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the capture window associated with the callback function."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "lpWHdr",
        "description": "Pointer to a WAVEHDR structure containing information about the captured audio data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "",
    "remarks": "The capture window calls the yield callback function at least once for every captured video frame, but the exact rate depends on the frame rate and the overhead of the capture driver and disk. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "capYieldCallback",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle to the capture window associated with the callback function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The stream pointer returned in ppsEditable must be used as the source stream in the other stream editing functions. Internally, this function creates tables to keep track of changes to a stream. The original stream is never changed by the stream editing functions. The stream pointer created by this function can be used in any AVIFile function that accepts stream pointers. You can use this function on the same stream multiple times. A copy of a stream is not affected by changes in another copy. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "CreateEditableStream",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppsEditable",
        "description": "Pointer to a buffer that receives the new stream handle."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "psSource",
        "description": "Handle to the stream supplying data for the new stream. Specify NULL to create an empty editable string that you can copy and paste data into."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Objbase.h",
    "return_value": "Returns a handle of an instance of the file or stream handler. ",
    "remarks": "DllGetClassObject is the only export function your DLL needs. The OLE component object DLL calls this function to obtain an instance of the stream- or file-handler interface. Your file or stream handler should ensure that the system requests the correct class identifier before creating an instance of it. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "DllGetClassObject",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "const",
        "type": "CLSID",
        "name": "&rclsid",
        "description": "Class identifier of the file or stream handler."
      },
      {
        "in_out": "const",
        "type": "IID",
        "name": "&riid",
        "description": "Interface identifier of the file or stream handler."
      },
      {
        "in_out": "",
        "type": "void**",
        "name": "ppv",
        "description": "Pointer to a buffer that receives the object of the interface query. If the interface specified in riid is not supported by the object, S_FALSE is returned and the ppvObj parameter used in the IUnknown interface must be set to NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "This function prepares to draw a DIB specified by lpbi to the DC. The image is stretched to the size specified by dxDest and dyDest. If dxDest and dyDest are set to \u00e2\u0080\u00931, the DIB is drawn to a 1:1 scale without stretching. You can update the flags of a DrawDib DC by reissuing DrawDibBegin, specifying the new flags, and changing at least one of the following settings: dxDest, dyDest, lpbi, dxSrc, or dySrc. If the parameters of DrawDibBegin have not changed, subsequent calls to the function have no effect. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibBegin",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a DC for drawing. This parameter is optional."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDest",
        "description": "Width, in MM_TEXT client units, of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDest",
        "description": "Height, in MM_TEXT client units, of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbi",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the image format. The color table for the DIB follows the image format and the biHeight member must be a positive value."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width, in pixels, of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height, in pixels, of the source rectangle."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Applicable flags for the function. The following values are defined.                Value  Meaning  DDF_ANIMATEAllows palette animation. If this value is present, DrawDib reserves as many entries as possible by setting PC_RESERVED in the palPalEntry array entries of the LOGPALETTE structure, and the palette can be animated by using the DrawDibChangePalette function. If your application uses the DrawDibBegin function with the DrawDibDraw function, set this value with DrawDibBegin rather than DrawDibDraw. DDF_BACKGROUNDPALRealizes the palette used for drawing as a background task, leaving the current palette used for the display unchanged. (This value is mutually exclusive of DDF_SAME_HDC.) DDF_BUFFERCauses DrawDib to try to use an off-screen buffer so DDF_UPDATE can be used. This disables decompression and drawing directly to the screen. If DrawDib is unable to create an off-screen buffer, it will decompress or draw directly to the screen. For more information, see the DDF_UPDATE and DDF_DONTDRAW values described for DrawDibDraw. DDF_DONTDRAWCurrent image is not drawn, but is decompressed. DDF_UPDATE can be used later to draw the image. This flag supersedes the DDF_PREROLL flag. DDF_FULLSCREENNot supported. DDF_HALFTONEAlways dithers the DIB to a standard palette regardless of the palette of the DIB. If your application uses DrawDibBegin with DrawDibDraw, set this value with DrawDibBegin rather than DrawDibDraw. DDF_JUSTDRAWITDraws the image by using GDI. Prohibits DrawDib functions from decompressing, stretching, or dithering the image. This strips DrawDib of capabilities that differentiate it from the StretchDIBits function. DDF_SAME_DRAWUse the current drawing parameters for DrawDibDraw. Use this value only if lpbi, dxDest, dyDest, dxSrc, and dySrc have not changed since using DrawDibDraw or DrawDibBegin. This flag supersedes the DDF_SAME_DIB and DDF_SAME_SIZE flags. DDF_SAME_HDCUse the current DC handle and the palette currently associated with the DC. DDF_UPDATELast buffered bitmap needs to be redrawn. If drawing fails with this value, a buffered image is not available and a new image needs to be specified before the display can be updated."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "This function changes the physical palette only if the current DrawDib palette is realized by calling the DrawDibRealize function. If the color table is not changed, the next call to the DrawDibDraw function that does not specify DDF_SAME_DRAW calls the DrawDibBegin function implicitly. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibChangePalette",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "iStart",
        "description": "Starting palette entry number."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "iLen",
        "description": "Number of palette entries."
      },
      {
        "in_out": "",
        "type": "LPPALETTEENTRY",
        "name": "lppe",
        "description": "Pointer to an array of palette entries."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibClose",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 13,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "DDF_DONTDRAW causes DrawDibDraw to decompress but not display an image. A subsequent call to DrawDibDraw specifying DDF_UPDATE displays the image. If the DrawDib DC does not have an off-screen buffer specified, specifying DDF_DONTDRAW causes the frame to be drawn to the screen immediately. Subsequent calls to DrawDibDraw specifying DDF_UPDATE fail. Although they are set at different times, DDF_UPDATE and DDF_DONTDRAW can be used together to create composite images off-screen. When the off-screen image is complete, you can display the image by calling DrawDibDraw. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibDraw",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the DC."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xDst",
        "description": "The x-coordinate, in MM_TEXT client coordinates, of the upper left corner of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "yDst",
        "description": "The y-coordinate, in MM_TEXT client coordinates, of the upper left corner of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDst",
        "description": "Width, in MM_TEXT client coordinates, of the destination rectangle. ..."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDst",
        "description": "Height, in MM_TEXT client coordinates, of the destination rectangle. ..."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbi",
        "description": "Pointer to the BITMAPINFOHEADER structure containing the image format. The color table for the DIB within BITMAPINFOHEADER follows the format and the biHeight member must be a positive value; DrawDibDraw will not draw inverted DIBs."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBits",
        "description": "Pointer to the buffer that contains the bitmap bits."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xSrc",
        "description": "The x-coordinate, in pixels, of the upper left corner of the source rectangle. The coordinates (0,0) represent the upper left corner of the bitmap."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "ySrc",
        "description": "The y-coordinate, in pixels, of the upper left corner of the source rectangle. The coordinates (0,0) represent the upper left corner of the bitmap."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width, in pixels, of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height, in pixels, of the source rectangle."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Applicable flags for drawing. The following values are defined.                Value  Meaning  DDF_BACKGROUNDPALRealizes the palette used for drawing in the background, leaving the actual palette used for display unchanged. This value is valid only if DDF_SAME_HDC is not set. DDF_DONTDRAWCurrent image is decompressed but not drawn. This flag supersedes the DDF_PREROLL flag. DDF_FULLSCREENNot supported. DDF_HALFTONEAlways dithers the DIB to a standard palette regardless of the palette of the DIB. If your application uses the DrawDibBegin function, set this value in DrawDibBegin rather than in DrawDibDraw. DDF_HURRYUPData does not have to be drawn (that is, it can be dropped) and DDF_UPDATE will not be used to recall this information. DrawDib checks this value only if it is required to build the next frame; otherwise, the value is ignored.This value is usually used to synchronize video and audio. When synchronizing data, applications should send the image with this value in case the driver needs to buffer the frame to decompress subsequent frames.  DDF_NOTKEYFRAMEDIB data is not a key frame. DDF_SAME_HDCUse the current DC handle and the palette currently associated with the DC. DDF_SAME_DRAWUse the current drawing parameters for DrawDibDraw. Use this value only if lpbi, dxDst, dyDst, dxSrc, and dySrc have not changed since using DrawDibDraw or DrawDibBegin. DrawDibDraw typically checks the parameters, and if they have changed, DrawDibBegin prepares the DrawDib DC for drawing. This flag supersedes the DDF_SAME_DIB and DDF_SAME_SIZE flags. DDF_UPDATELast buffered bitmap is to be redrawn. If drawing fails with this value, a buffered image is not available and a new image needs to be specified before the display can be updated."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibEnd",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to the DrawDib DC to free."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the address of the buffer or NULL if no buffer is used. if lpbr is not NULL, it is filled with a copy of the BITMAPINFO structure describing the buffer. ",
    "remarks": "",
    "return_type": "LPVOID",
    "category": "Windows Multimedia",
    "name": "DrawDibGetBuffer",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbi",
        "description": "Pointer to a BITMAPINFO structure. This structure is made up of a BITMAPINFOHEADER structure and a 256-entry table defining the colors used by the bitmap."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwSize",
        "description": "Size, in bytes, of the BITMAPINFO structure pointed to by lpbi"
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to the palette if successful or NULL otherwise. ",
    "remarks": "This function assumes the DrawDib DC contains a valid palette entry, implying that a call to this function must follow calls to the DrawDibDraw or DrawDibBegin functions. You should rarely need to call this function because you can realize the correct palette in response to a window message by using the DrawDibRealize function. ",
    "return_type": "HPALETTE",
    "category": "Windows Multimedia",
    "name": "DrawDibGetPalette",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to a DrawDib DC if successful or NULL otherwise. ",
    "remarks": "When drawing multiple DIBs simultaneously, create a DrawDib DC for each of the images that will be simultaneously on-screen. ",
    "return_type": "HDRAWDIB",
    "category": "Windows Multimedia",
    "name": "DrawDibOpen",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a value that indicates the fastest drawing and stretching capabilities of the display system. This value can be zero if the bitmap format is not supported or one or more of the following values.  ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibProfileDisplay",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbi",
        "description": "Pointer to a BITMAPINFOHEADER structure that contains bitmap information. You can also specify NULL to verify that the profile information is current. If the profile information is not current, DrawDib will rerun the profile tests to obtain a current set of information. When you call DrawDibProfileDisplay with this parameter set to NULL, the return value is meaningless."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the number of entries in the logical palette mapped to different values in the system palette. If an error occurs or no colors were updated, it returns zero. ",
    "remarks": "To select the palette of the DrawDib DC as a background palette, use the DrawDibDraw function and specify the DDF_BACKGROUNDPAL flag. ",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "DrawDibRealize",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the DC containing the palette."
      },
      {
        "in_out": "",
        "type": "BOOL",
        "name": "fBackground",
        "description": "Background palette flag. If this value is nonzero, the palette is a background palette. If this value is zero and the DC is attached to a window, the logical palette becomes the foreground palette when the window has the input focus. (A DC is attached to a window when the window class style is CS_OWNDC or when the DC is obtained by using the GetDC function.)"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibSetPalette",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "Handle to the palette. Specify NULL to use the default palette."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibStart",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "rate",
        "description": "Playback rate, in microseconds per frame."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibStop",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "This function is present only in the debug version of the Microsoft Windows Software Development Kit (SDK) libraries. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "DrawDibTime",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HDRAWDIB",
        "name": "hdd",
        "description": "Handle to a DrawDib DC."
      },
      {
        "in_out": "",
        "type": "LPDRAWDIBTIME",
        "name": "lpddtime",
        "description": "Pointer to a DRAWDIBTIME structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The editable stream that is being cloned must have been created by the CreateEditableStream function or one of the stream editing functions. The new stream can be treated as any other AVI stream. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "EditStreamClone",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an editable stream that will be copied."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppResult",
        "description": "Pointer to a buffer that receives the new stream handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The stream that is copied must be created by the CreateEditableStream function or one of the stream editing functions. The temporary stream can be treated as any other AVI stream. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "EditStreamCopy",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to the stream being copied."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plStart",
        "description": "Starting position within the stream being copied. The starting position is returned."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plLength",
        "description": "Amount of data to copy from the stream referenced by pavi. The length of the copied data is returned."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppResult",
        "description": "Pointer to a buffer that receives the handle created for the new stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The stream being edited must have been created by the CreateEditableStream function or one of the stream editing functions. The temporary stream is an editable stream and can be treated as any other AVI stream. An application must release the temporary stream to free the resources associated with it. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "EditStreamCut",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to the stream being edited."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plStart",
        "description": "Starting position of the data to cut from the stream referenced by pavi."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plLength",
        "description": "Amount of data to cut from the stream referenced by pavi."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM*",
        "name": "ppResult",
        "description": "Pointer to the handle created for the new stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "The stream referenced by pavi must have been created by the CreateEditableStream function or one of the stream editing functions. This function inserts data into the specified stream as a continuous block of data. It opens the specified data stream at the insertion point, pastes the specified stream segment at the insertion point, and appends the stream segment that trails the insertion point to the end of pasted segment. ",
    "return_type": "STDAPI",
    "category": "Windows Multimedia",
    "name": "EditStreamPaste",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an editable stream that will receive the copied stream data."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plPos",
        "description": "Starting position to paste the data within the destination stream (referenced by pavi)."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plLength",
        "description": "Pointer to a buffer that receives the amount of data pasted in the stream."
      },
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pstream",
        "description": "Handle to a stream supplying the data to paste. This stream does not need to be an editable stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lStart",
        "description": "Starting position of the data to copy within the source stream."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lLength",
        "description": "Amount of data to copy from the source stream. If lLength is -1, the entire stream referenced by pstream is pasted in the other stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "You must supply information for the entire AVISTREAMINFO structure, including the members you will not use. You can use the AVIStreamInfo function to initialize the structure and then update selected members with your data. This function does not change the following members: The function changes the following members: ",
    "return_type": "SDTAPI",
    "category": "Windows Multimedia",
    "name": "EditStreamSetInfo",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "AVISTREAMINFO*",
        "name": "lpInfo",
        "description": "Pointer to an AVISTREAMINFO structure containing new information."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cbInfo",
        "description": "Size, in bytes, of the structure pointed to by lpInfo."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "This function updates the szName member of the AVISTREAMINFO structure. ",
    "return_type": "SDTAPI",
    "category": "Windows Multimedia",
    "name": "EditStreamSetName",
    "is_callback": 0,
    "dll": "Avifil32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PAVISTREAM",
        "name": "pavi",
        "description": "Handle to an open stream."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpszName",
        "description": "Null-terminated string containing the description of the stream."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to the selected file. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "GetOpenFileNamePreview",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPOPENFILENAME",
        "name": "lpofn",
        "description": "Pointer to an OPENFILENAME structure used to initialize the dialog box. On return, the structure contains information about the user's file selection."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to the selected file. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "GetSaveFileNamePreview",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPOPENFILENAME",
        "name": "lpofn",
        "description": "Pointer to an OPENFILENAME structure used to initialize the dialog box. On return, the structure contains information about the user's file selection."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "",
    "return_type": "LRESULT",
    "category": "Windows Multimedia",
    "name": "ICClose",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to a compressor or decompressor."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 13,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "You can obtain the required by size of the output buffer by sending the ICM_COMPRESS_GET_SIZE message (or by using the ICCompressGetSize macro). The compressor sets the contents of lpdwFlags to AVIIF_KEYFRAME when it creates a key frame. If your application creates AVI files, it should save the information returned for lpckid and lpdwFlags in the file. Compressors use lpbiPrev and lpPrev to perform temporal compression and require an external buffer to store the format and data of the previous frame. Specify NULL for lpbiPrev and lpPrev when compressing a key frame, when performing fast compression, or if the compressor has its own buffer to store the format and data of the previous image. Specify non-NULL values for these parameters if ICGetInfo returns the VIDCF_TEMPORAL flag, the compressor is performing normal compression, and the frame to compress is not a key frame. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICCompress",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the compressor to use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Compression flag. The following value is defined:             ICCOMPRESS_KEYFRAME   Compressor should make this frame a key frame."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiOutput",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the output format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to an output buffer large enough to contain a compressed frame."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiInput",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the input format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBits",
        "description": "Pointer to the input buffer."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "lpckid",
        "description": "Reserved; do not use."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "lpdwFlags",
        "description": "Pointer to the return flags used in the AVI index. The following value is defined:             AVIIF_KEYFRAME   Current frame is a key frame."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lFrameNum",
        "description": "Frame number."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFrameSize",
        "description": "Requested frame size, in bytes. Specify a nonzero value if the compressor supports a suggested frame size, as indicated by the presence of the VIDCF_CRUNCH flag returned by the ICGetInfo function. If this flag is not set or a data rate for the frame is not specified, specify zero for this parameter. A compressor might have to sacrifice image quality or make some other trade-off to obtain the size goal specified in this parameter."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwQuality",
        "description": "Requested quality value for the frame. Specify a nonzero value if the compressor supports a suggested quality value, as indicated by the presence of the VIDCF_QUALITY flag returned by ICGetInfo. Otherwise, specify zero for this parameter."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiPrev",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the format of the previous frame."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpPrev",
        "description": "Pointer to the uncompressed image of the previous frame. This parameter is not used for fast temporal compression. Specify NULL for this parameter when compressing a key frame, if the compressor does not support temporal compression, or if the compressor does not require an external buffer to store the format and data of the previous image."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if the user chooses a compressor and presses OK. Returns FALSE on error or if the user presses CANCEL. ",
    "remarks": "Before using this function, set the cbSize member of the COMPVARS structure to the size of the structure. Initialize the rest of the structure to zeros unless you want to specify some valid defaults for the dialog box. If specifying defaults, set the dwFlags member to ICMF_COMPVARS_VALID and initialize the other members of the structure. For more information about initializing the structure, see the ICSeqCompressFrameStart function and COMPVARS. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "ICCompressorChoose",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwnd",
        "description": "Handle to a parent window for the dialog box."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uiFlags",
        "description": "Applicable flags. The following values are defined.                     Value                                    Meaning                  ICMF_CHOOSE_ALLCOMPRESSORSAll compressors should appear in the selection list. If this flag is not specified, only the compressors that can handle the input format appear in the selection list. ICMF_CHOOSE_DATARATEDisplays a check box and edit box to enter the data rate for the movie. ICMF_CHOOSE_KEYFRAMEDisplays a check box and edit box to enter the frequency of key frames. ICMF_CHOOSE_PREVIEWDisplays a button to expand the dialog box to include a preview window. The preview window shows how frames of your movie will appear when compressed with the current settings."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "pvIn",
        "description": "Uncompressed data input format. Only compressors that support the specified data input format are included in the compressor list. This parameter is optional."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to an AVI stream interface to use in the preview window. You must specify a video stream. This parameter is optional."
      },
      {
        "in_out": "",
        "type": "PCOMPVARS",
        "name": "pc",
        "description": "Pointer to a COMPVARS structure. The information returned initializes the structure for use with other functions."
      },
      {
        "in_out": "",
        "type": "LPSTR",
        "name": "lpszTitle",
        "description": "Pointer to a null-terminated string containing a title for the dialog box. This parameter is optional."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "This function does not return a value. ",
    "remarks": "Use this function to release the resources in the COMPVARS structure after using the ICCompressorChoose, ICSeqCompressFrameStart, ICSeqCompressFrame, and ICSeqCompressFrameEnd functions. ",
    "return_type": "void",
    "category": "Windows Multimedia",
    "name": "ICCompressorFree",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PCOMPVARS",
        "name": "pc",
        "description": "Pointer to the COMPVARS structure containing the resources to be freed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDecompress",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the decompressor to use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Applicable decompression flags. The following values are defined.                     Value                                    Meaning                  ICDECOMPRESS_HURRYUPTries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but not draw the image. ICDECOMPRESS_NOTKEYFRAMECurrent frame is not a key frame. ICDECOMPRESS_NULLFRAMECurrent frame does not contain data and the decompressed image should be left the same. ICDECOMPRESS_PREROLLCurrent frame precedes the point in the movie where playback starts and, therefore, will not be drawn. ICDECOMPRESS_UPDATEScreen is being updated or refreshed."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiFormat",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to the input data."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbi",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the output format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBits",
        "description": "Pointer to a buffer that is large enough to contain the decompressed data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 14,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "Typically, applications use the ICDECOMPRESS_PREROLL flag to seek to a key frame in a compressed stream. The flag is sent with the key frame and with subsequent frames required to decompress the desired frame. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDecompressEx",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the decompressor."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Decompression flags. The following values are defined.                     Value                                    Meaning                  ICDECOMPRESS_HURRYUPTries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but not draw the image. ICDECOMPRESS_NOTKEYFRAMECurrent frame is not a key frame. ICDECOMPRESS_NULLFRAMECurrent frame does not contain data and the decompressed image should be left the same. ICDECOMPRESS_PREROLLCurrent frame precedes the point in the movie where playback starts and, therefore, will not be drawn. ICDECOMPRESS_UPDATEScreen is being updated or refreshed."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiSrc",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpSrc",
        "description": "Pointer to the input data."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xSrc",
        "description": "The x-coordinate of the source rectangle for the DIB specified by lpbiSrc."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "ySrc",
        "description": "The y-coordinate of the source rectangle for the DIB specified by lpbiSrc."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height of the source rectangle."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiDst",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the output format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpDst",
        "description": "Pointer to a buffer that is large enough to contain the decompressed data."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xDst",
        "description": "The x-coordinate of the destination rectangle for the DIB specified by lpbiDst."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "yDst",
        "description": "The y-coordinate of the destination rectangle for the DIB specified by lpbiDst."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDst",
        "description": "Width of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDst",
        "description": "Height of the destination rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 14,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDecompressExBegin",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the decompressor to use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Decompression flags. The following values are defined.                                  Value                                    Meaning                  ICDECOMPRESS_HURRYUPTries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but not draw the image. ICDECOMPRESS_NOTKEYFRAMECurrent frame is not a key frame. ICDECOMPRESS_NULLFRAMECurrent frame does not contain data and the decompressed image should be left the same. ICDECOMPRESS_PREROLLCurrent frame precedes the point in the movie where playback starts and, therefore, will not be drawn. ICDECOMPRESS_UPDATEScreen is being updated or refreshed."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiSrc",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpSrc",
        "description": "Pointer to the input data."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xSrc",
        "description": "The x-coordinate of the source rectangle for the DIB specified by lpbiSrc."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "ySrc",
        "description": "The y-coordinate of the source rectangle for the DIB specified by lpbiSrc."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height of the source rectangle."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiDst",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the output format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpDst",
        "description": "Pointer to a buffer that is large enough to contain the decompressed data."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xDst",
        "description": "The x-coordinate of the destination rectangle for the DIB specified by lpbiDst."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "yDst",
        "description": "The y-coordinate of the destination rectangle for the DIB specified by lpbiDst."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDst",
        "description": "Width of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDst",
        "description": "Height of the destination rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 14,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDecompressExQuery",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the decompressor to use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved; do not use."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiSrc",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data to decompress."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpSrc",
        "description": "Reserved; must be NULL."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xSrc",
        "description": "The x-coordinate of the source rectangle for the DIB specified by lpbiSrc."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "ySrc",
        "description": "The y-coordinate of the source rectangle for the DIB specified by lpbiSrc."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height of the source rectangle."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiDst",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the output format. If the value of this parameter is NULL, the function determines whether the input format is supported and this parameter is ignored."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpDst",
        "description": "Pointer to a buffer that is large enough to contain the decompressed data."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xDst",
        "description": "The x-coordinate of the destination rectangle for the DIB specified by lpbiDst."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "yDst",
        "description": "The y-coordinate of the destination rectangle for the DIB specified by lpbiDst."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDst",
        "description": "Width of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDst",
        "description": "Height of the destination rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "You can initiate drawing the frames by sending the ICM_DRAW_START message (or by using the ICDrawStart macro). The application should be sure to buffer the required number of frames before drawing is started. Send the KM_GETBUFFERSWANTED message (or use the ICGetBuffersWanted macro) to obtain this value. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDraw",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to an decompressor."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Decompression flags. The following values are defined.                     Value                                    Meaning                  ICDRAW_HURRYUPData is buffered and not drawn to the screen. Use this flag for fastest decompression. ICDRAW_NOTKEYFRAMECurrent frame is not a key frame. ICDRAW_NULLFRAMECurrent frame does not contain any data and the previous frame should be redrawn. ICDRAW_PREROLLCurrent frame of video occurs before playback should start. For example, if playback will begin on frame 10, and frame 0 is the nearest previous key frame, frames 0 through 9 are sent to the driver with the ICDRAW_PREROLL flag set. The driver needs this data to display frame 10 properly. ICDRAW_UPDATEUpdates the screen based on previously received data. Set lpData to NULL when this flag is used."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpFormat",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the input format of the data."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpData",
        "description": "Pointer to the input data."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "cbData",
        "description": "Size of the input data, in bytes."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lTime",
        "description": "Time, in samples, to draw this frame. The units for video data are frames. For a definition of the playback rate, see the dwRate and dwScale members of the ICDRAWBEGIN structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 16,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if the renderer can decompress the data or ICERR_UNSUPPORTED otherwise. ",
    "remarks": "The ICDRAW_HDC and ICDRAW_FULLSCREEN flags are mutually exclusive. If an application sets the ICDRAW_HDC flag in dwFlags, the decompressor uses hwnd, hdc, and the parameters defining the destination rectangle (xDst, yDst, dxDst, and dyDst). Your application should set these parameters to the size of the destination rectangle. Specify destination rectangle values relative to the current window or DC. If an application sets the ICDRAW_FULLSCREEN flag in dwFlags, the hwnd and hdc parameters are not used and should be set to NULL. Also, the destination rectangle is not used and its parameters can be set to zero. The source rectangle is relative to the full video frame. The portion of the video frame specified by the source rectangle is stretched or shrunk to fit the destination rectangle. The dwRate and dwScale parameters specify the decompression rate. The integer value specified for dwRate divided by the integer value specified for dwScale defines the frame rate in frames per second. This value is used by the renderer when it is responsible for timing frames during playback. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDrawBegin",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the decompressor to use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Decompression flags. The following values are defined.                                  Value                                    Meaning                  ICDRAW_ANIMATEApplication can animate the palette. ICDRAW_CONTINUEDrawing is a continuation of the previous frame. ICDRAW_FULLSCREENDraws the decompressed data on the full screen. ICDRAW_HDCDraws the decompressed data to a window or a DC. ICDRAW_MEMORYDCDC is off-screen. ICDRAW_QUERYDetermines if the decompressor can decompress the data. The driver does not decompress the data. ICDRAW_UPDATINGCurrent frame is being updated rather than played."
      },
      {
        "in_out": "",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "Handle to the palette used for drawing."
      },
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwnd",
        "description": "Handle to the window used for drawing."
      },
      {
        "in_out": "",
        "type": "HDC",
        "name": "hdc",
        "description": "DC used for drawing."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xDst",
        "description": "The x-coordinate of the upper right corner of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "yDst",
        "description": "The y-coordinate of the upper right corner of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDst",
        "description": "Width of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDst",
        "description": "Height of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbi",
        "description": "Pointer to a BITMAPINFOHEADER structure containing the format of the input data to be decompressed."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "xSrc",
        "description": "The x-coordinate of the upper right corner of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "ySrc",
        "description": "The y-coordinate of the upper right corner of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height of the source rectangle."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwRate",
        "description": "Frame rate numerator. The frame rate, in frames per second, is obtained by dividing dwRate by dwScale."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwScale",
        "description": "Frame rate denominator. The frame rate, in frames per second, is obtained by dividing dwRate by dwScale."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "Applications can use this function to determine alternative input formats that a drawing handler can decompress and if the drawing handler can stretch data. If the drawing handler cannot stretch data as requested, the application might have to stretch the data. If the drawing handler cannot decompress a format provided by an application, use the ICDecompress, ICDecompressEx, j, ICDecompressExQuery, and ICDecompressOpen functions to obtain alternate formats. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICDrawSuggestFormat",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the driver to use."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiIn",
        "description": "Pointer to a structure containing the format of the compressed data. For bitmaps, this is a BITMAPINFOHEADER structure."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiOut",
        "description": "Pointer to a structure to return the suggested format. The drawing handler can receive and draw data from this format. For bitmaps, this is a BITMAPINFOHEADER structure."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxSrc",
        "description": "Width of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dySrc",
        "description": "Height of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dxDst",
        "description": "Width of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dyDst",
        "description": "Height of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "HIC",
        "name": "hicDecompressor",
        "description": "Decompressor that can use the format of data in lpbiIn."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to a decompressor if successful or zero otherwise. ",
    "remarks": "",
    "return_type": "HIC",
    "category": "Windows Multimedia",
    "name": "ICGetDisplayFormat",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the compressor to use. Specify NULL to have VCM select and open an appropriate compressor."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiIn",
        "description": "Pointer to BITMAPINFOHEADER structure containing the compressed format."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiOut",
        "description": "Pointer to a buffer to return the decompressed format. The buffer should be large enough for a BITMAPINFOHEADER structure and 256 color entries."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "BitDepth",
        "description": "Preferred bit depth, if nonzero."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dx",
        "description": "Width multiplier to stretch the image. If this parameter is zero, that dimension is not stretched."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "dy",
        "description": "Height multiplier to stretch the image. If this parameter is zero, that dimension is not stretched."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the number of bytes copied into the structure or zero if an error occurs. ",
    "remarks": "",
    "return_type": "LRESULT",
    "category": "Windows Multimedia",
    "name": "ICGetInfo",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to a compressor."
      },
      {
        "in_out": "",
        "type": "ICINFO*",
        "name": "lpicinfo",
        "description": "Pointer to the ICINFO structure to return information about the compressor."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "cb",
        "description": "Size, in bytes, of the structure pointed to by lpicinfo."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to a compressed DIB. The image data follows the format header. ",
    "remarks": "To obtain the format information from the BITMAPINFOHEADER structure, use the GlobalLock function to lock the data. Use the GlobalFree function to free the DIB when you are finished. ",
    "return_type": "HANDLE",
    "category": "Windows Multimedia",
    "name": "ICImageCompress",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to a compressor opened with the ICOpen function. Specify NULL to have VCM select an appropriate compressor for the compression format. An application can have the user select the compressor by using the ICCompressorChoose function, which opens the selected compressor and returns a handle of the compressor in this parameter."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uiFlags",
        "description": "Reserved; must be zero."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFO",
        "name": "lpbiIn",
        "description": "Pointer to the BITMAPINFO structure containing the input data format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBits",
        "description": "Pointer to input data bits to compress. The data bits exclude header and format information."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFO",
        "name": "lpbiOut",
        "description": "Pointer to the BITMAPINFO structure containing the compressed output format. Specify NULL to have the compressor use an appropriate format."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lQuality",
        "description": "Quality value used by the compressor. Values range from 0 to 10,000."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plSize",
        "description": "Maximum size desired for the compressed image. The compressor might not be able to compress the data to fit within this size. When the function returns, this parameter points to the size of the compressed image. Image sizes are specified in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to an uncompressed DIB in the CF_DIB format if successful or NULL otherwise. Image data follows the format header. ",
    "remarks": "To obtain the format information from the LPBITMAPINFOHEADER structure, use the GlobalLock function to lock the data. Use the GlobalFree function to free the DIB when you are finished. ",
    "return_type": "HANDLE",
    "category": "Windows Multimedia",
    "name": "ICImageDecompress",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to a decompressor opened with the ICOpen function. Specify NULL to have VCM select an appropriate decompressor for the compressed image."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uiFlags",
        "description": "Reserved; must be zero."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFO",
        "name": "lpbiIn",
        "description": "Compressed input data format."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBits",
        "description": "Pointer to input data bits to compress. The data bits exclude header and format information."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFO",
        "name": "lpbiOut",
        "description": "Decompressed output format. Specify NULL to let decompressor use an appropriate format."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or an error otherwise. ",
    "remarks": "To enumerate the compressors or decompressors, specify an integer for fccHandler. This function returns information for integers between zero and the number of installed compressors or decompressors of the type specified for fccType. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "ICInfo",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of compressor. Specify zero to match all compressor types."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccHandler",
        "description": "Four-character code identifying a specific compressor or a number between zero and the number of installed compressors of the type specified by fccType."
      },
      {
        "in_out": "",
        "type": "ICINFO*",
        "name": "lpicinfo",
        "description": "Pointer to a ICINFO structure to return information about the compressor."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or an error otherwise. ",
    "remarks": "Applications must open an installed compressor or decompressor before using it. If your application installs a function as a compressor or decompressor, it should remove the function with the ICRemove function before it terminates. This prevents other applications from trying to access the function when it is not available. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "ICInstall",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of data used by the compressor or decompressor. Specify \"VIDC\" for a video compressor or decompressor."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccHandler",
        "description": "Four-character code identifying a specific compressor or decompressor."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Pointer to a null-terminated string containing the name of the compressor or decompressor, or the address of a function used for compression or decompression. The contents of this parameter are defined by the flags set for wFlags."
      },
      {
        "in_out": "",
        "type": "LPSTR",
        "name": "szDesc",
        "description": "Reserved; do not use."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Flags defining the contents of lParam. The following values are defined.                     Value                                    Meaning                  ICINSTALL_DRIVERThe lParam parameter contains the address of a null-terminated string that names the compressor to install. ICINSTALL_FUNCTIONThe lParam parameter contains the address of a compressor function. This function should be structured like the DriverProc entry point function used by compressors."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to a compressor or decompressor if successful or zero otherwise. ",
    "remarks": "",
    "return_type": "HIC",
    "category": "Windows Multimedia",
    "name": "ICLocate",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of compressor or decompressor to open. For video streams, the value of this parameter is 'VIDC'."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccHandler",
        "description": "Preferred handler of the specified type. Typically, the handler type is stored in the stream header in an AVI file. Specify NULL if your application can use any handler type or it does not know the handler type to use."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiIn",
        "description": "Pointer to a BITMAPINFOHEADER structure defining the input format. A compressor handle is not returned unless it supports this format."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "lpbiOut",
        "description": "Pointer to a BITMAPINFOHEADER structure defining an optional decompressed format. You can also specify zero to use the default output format associated with the input format. If this parameter is nonzero, a compressor handle is not returned unless it can create this output format."
      },
      {
        "in_out": "",
        "type": "WORD",
        "name": "wFlags",
        "description": "Flags that describe the search criteria for a compressor or decompressor. The following values are defined:             ValueMeaning  ICMODE_COMPRESS   Finds a compressor that can compress an image with a format defined by lpbiIn to the format defined by lpbiOut.   ICMODE_DECOMPRESS                Finds a decompressor that can decompress an image with a format defined by lpbiIn to the format defined by lpbiOut.              ICMODE_DRAW                Finds a decompressor that can decompress an image with a format defined by lpbiIn and draw it directly to hardware.              ICMODE_FASTCOMPRESS                Has the same meaning as ICMODE_COMPRESS except the compressor is used for a real-time operation and emphasizes speed over quality.              ICMODE_FASTDECOMPRESS                Has the same meaning as ICMODE_DECOMPRESS except the decompressor is used for a real-time operation and emphasizes speed over quality."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to a compressor or decompressor if successful or zero otherwise. ",
    "remarks": "",
    "return_type": "HIC",
    "category": "Windows Multimedia",
    "name": "ICOpen",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of compressor or decompressor to open. For video streams, the value of this parameter is \"VIDC\"."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccHandler",
        "description": "Preferred handler of the specified type. Typically, the handler type is stored in the stream header in an AVI file."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMode",
        "description": "Flag defining the use of the compressor or decompressor. The following values are defined.                     Value                                    Meaning                  ICMODE_COMPRESSCompressor will perform normal compression. ICMODE_DECOMPRESSDecompressor will perform normal decompression. ICMODE_DRAWDecompressor will decompress and draw the data directly to hardware. ICMODE_FASTCOMPRESSCompressor will perform fast (real-time) compression. ICMODE_FASTDECOMPRESSDecompressor will perform fast (real-time) decompression. ICMODE_QUERYQueries the compressor or decompressor for information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a handle to a compressor or decompressor if successful or zero otherwise. ",
    "remarks": "",
    "return_type": "HIC",
    "category": "Windows Multimedia",
    "name": "ICOpenFunction",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Type of compressor to open. For video, the value of this parameter is ICTYPE_VIDEO."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccHandler",
        "description": "Preferred handler of the specified type. Typically, this comes from the stream header in an AVI file."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMode",
        "description": "Flag to define the use of the compressor or decompressor. The following values are defined.                     Value                                    Meaning                  ICMODE_COMPRESSCompressor will perform normal compression. ICMODE_DECOMPRESSDecompressor will perform normal decompression. ICMODE_DRAWDecompressor will decompress and draw the data directly to hardware. ICMODE_FASTCOMPRESSCompressor will perform fast (real-time) compression. ICMODE_FASTDECOMPRESSDecompressor will perform fast (real-time) decompression. ICMODE_QUERYQueries the compressor or decompressor for information."
      },
      {
        "in_out": "",
        "type": "FARPROC",
        "name": "lpfnHandler",
        "description": "Pointer to the function used as the compressor or decompressor."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "ICRemove",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccType",
        "description": "Four-character code indicating the type of data used by the compressor or decompressor. Specify \"VIDC\" for a video compressor or decompressor."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fccHandler",
        "description": "Four-character code identifying a specific compressor or a number between zero and the number of installed compressors of the type specified by fccType."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Reserved; do not use."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns a message-specific result. ",
    "remarks": "",
    "return_type": "LRESULT",
    "category": "Windows Multimedia",
    "name": "ICSendMessage",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the compressor to receive the message."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMsg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dw1",
        "description": "Additional message-specific information."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dw2",
        "description": "Additional message-specific information."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the address of the compressed bits if successful or NULL otherwise. ",
    "remarks": "This function uses a COMPVARS structure to provide settings for the specified compressor and intersperses key frames at the rate specified by the ICSeqCompressorFrameStart function. You can specify values for the data rate for the sequence and the key-frame frequency by using the appropriate members of COMPVARS. Use this function instead of the ICCompress function to compress a video sequence. You can allow the user to specify a compressor and initialize a COMPVARS structure by using the ICCompressorChoose function. Or, you can initialize a COMPVARS structure manually. Use the ICSeqCompressFrameStart, ICSeqCompressFrame, and ICSeqCompressFrameEnd functions to compress a sequence of frames to a specified data rate and number of key frames. Use ICSeqCompressFrame once for each frame to be compressed. When finished with compression, use the ICCompressorFree function to release the resources specified by COMPVARS. ",
    "return_type": "LPVOID",
    "category": "Windows Multimedia",
    "name": "ICSeqCompressFrame",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PCOMPVARS",
        "name": "pc",
        "description": "Pointer to a COMPVARS structure initialized with information about the compression."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uiFlags",
        "description": "Reserved; must be zero."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpBits",
        "description": "Pointer to the data bits to compress. (The data bits exclude header or format information.)"
      },
      {
        "in_out": "",
        "type": "BOOL*",
        "name": "pfKey",
        "description": "Returns whether or not the frame was compressed into a key frame."
      },
      {
        "in_out": "",
        "type": "LONG*",
        "name": "plSize",
        "description": "Maximum size desired for the compressed image. The compressor might not be able to compress the data to fit within this size. When the function returns, the parameter points to the size of the compressed image. Images sizes are specified in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "This function does not return a value. ",
    "remarks": "When finished with compression, use the ICCompressorFree function to release the resources specified by COMPVARS. ",
    "return_type": "void",
    "category": "Windows Multimedia",
    "name": "ICSeqCompressFrameEnd",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PCOMPVARS",
        "name": "pc",
        "description": "Pointer to a COMPVARS structure used during sequence compression."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "This function uses a COMPVARS structure to provide settings for the specified compressor and intersperses key frames at the rate specified by the lKey member of COMPVARS. You can specify values for the data rate for the sequence and the key-frame frequency by using the appropriate members of COMPVARS. Use the ICSeqCompressFrameStart, ICSeqCompressFrame, and ICSeqCompressFrameEnd functions to compress a sequence of frames to a specified data rate and number of key frames. When finished with compression, use the ICCompressorFree function to release the resources specified in COMPVARS. COMPVARS needs to be initialized before you use this function. You can initialize the structure manually or you can allow the user to specify a compressor and initialize a COMPVARS structure by using the ICCompressorChoose function. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "ICSeqCompressFrameStart",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "PCOMPVARS",
        "name": "pc",
        "description": "Pointer to a COMPVARS structure initialized with information for compression."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFO",
        "name": "lpbiIn",
        "description": "Format of the data to be compressed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns ICERR_OK if successful or FALSE otherwise. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "ICSetStatusProc",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HIC",
        "name": "hic",
        "description": "Handle to the compressor."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Applicable flags. Set to zero."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam",
        "description": "Constant specified with the status callback address."
      },
      {
        "in_out": "LONG",
        "type": "(CALLBACK* ())",
        "name": "fpfnStatus",
        "description": "Pointer to the status callback function. Specify NULL to indicate no status callbacks should be sent."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns a value that corresponds to the message specified by wMsg. If the I/O procedure does not recognize a message, it should return zero. ",
    "remarks": "The four-character code specified by the fccIOProc member of the MMIOINFO structure associated with a file identifies a file name extension for a custom storage system. When an application calls the mmioOpen function with a file name such as EXAMPLE.XYZ+ABC, the I/O procedure associated with the four-character code \"XYZ\" is called to open the ABC element of the file EXAMPLE.XYZ. The mmioInstallIOProc function maintains a separate list of installed I/O procedures for each Windows application. Therefore, different applications can use the same I/O procedure identifier for different I/O procedures without conflict. If an application calls mmioInstallIOProc more than once to register the same I/O procedure, it must call this function to remove the procedure once for each time it installed the procedure. The mmioInstallIOProc function does not prevent an application from installing two different I/O procedures with the same identifier, or installing an I/O procedure with one of the predefined identifiers (DOS or MEM). The most recently installed procedure takes precedence, and the most recently installed procedure is the first one to be removed. When searching for a specified I/O procedure, local procedures are searched first, then global procedures. ",
    "return_type": "LRESULT CALLBACK",
    "category": "Windows Multimedia",
    "name": "IOProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "LPSTR",
        "name": "lpmmioinfo",
        "description": "Pointer to an MMIOINFO structure containing information about the open file. The I/O procedure must maintain the lDiskOffset member in this structure to indicate the file offset to the next read or write location. The I/O procedure can use the adwInfo member to store state information. The I/O procedure should not modify any other members of the MMIOINFO structure."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMsg",
        "description": "Message indicating the requested I/O operation. Messages that can be received include MMIOM_OPEN, MMIOM_CLOSE, MMIOM_READ, MMIOM_WRITE, and MMIOM_SEEK."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam1",
        "description": "Parameter for the message."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam2",
        "description": "Parameter for the message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Dinput.h",
    "return_value": "Returns JOYERR_NOERROR if successful. Returns JOYERR_PARMS if the parameter is non-zero. ",
    "remarks": "This function causes a window message to be sent to all top-level windows. This message may be defined by applications that need to respond to changes in joystick calibration by using RegisterWindowMessage with the following message ID: ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joyConfigChanged",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Reserved for future use. Must equal zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values:  ",
    "remarks": "Use the joyGetNumDevs function to determine the number of joystick devices supported by the driver. This method fails when passed an invalid value for the cbjc parameter. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joyGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uJoyID",
        "description": "Identifier of the joystick to be queried. Valid values for uJoyID range from -1 to 15. A value of -1 enables retrieval of the szRegKey member of the JOYCAPS structure whether a device is present or not."
      },
      {
        "in_out": "",
        "type": "LPJOYCAPS",
        "name": "pjc",
        "description": "Pointer to a JOYCAPS structure to contain the capabilities of the joystick."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbjc",
        "description": "Size, in bytes, of the JOYCAPS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "The joyGetNumDevs function returns the number of joysticks supported by the current driver or zero if no driver is installed. ",
    "remarks": "Use the joyGetPos function to determine whether a given joystick is physically attached to the system. If the specified joystick is not connected, joyGetPos returns a JOYERR_UNPLUGGED error value. ",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "joyGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values.  ",
    "remarks": "For devices that have four to six axes of movement, a point-of-view control, or more than four buttons, use the joyGetPosEx function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joyGetPos",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uJoyID",
        "description": "Identifier of the joystick to be queried. Valid values for uJoyID range from zero (JOYSTICKID1) to 15."
      },
      {
        "in_out": "",
        "type": "LPJOYINFO",
        "name": "pji",
        "description": "Pointer to a JOYINFO structure that contains the position and button status of the joystick."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values.  ",
    "remarks": "This function provides access to extended devices such as rudder pedals, point-of-view hats, devices with a large number of buttons, and coordinate systems using up to six axes. For joystick devices that use three axes or fewer and have fewer than four buttons, use the joyGetPos function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joyGetPosEx",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uJoyID",
        "description": "Identifier of the joystick to be queried. Valid values for uJoyID range from zero (JOYSTICKID1) to 15."
      },
      {
        "in_out": "",
        "type": "LPJOYINFOEX",
        "name": "pji",
        "description": "Pointer to a JOYINFOEX structure that contains extended position information and button status of the joystick. You must set the dwSize and dwFlags members or joyGetPosEx will fail. The information returned from joyGetPosEx depends on the flags you specify in dwFlags."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values.  ",
    "remarks": "The movement threshold is the distance the joystick must be moved before a joystick position-change message (MM_JOY1MOVE, MM_JOY1ZMOVE, MM_JOY2MOVE, or MM_JOY2ZMOVE) is sent to a window that has captured the device. The threshold is initially zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joyGetThreshold",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uJoyID",
        "description": "Identifier of the joystick. Valid values for uJoyID range from zero (JOYSTICKID1) to 15."
      },
      {
        "in_out": "",
        "type": "LPUINT",
        "name": "puThreshold",
        "description": "Pointer to a variable that contains the movement threshold value."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values.  ",
    "remarks": "This method returns JOYERR_NOERROR when passed a valid joystick identifier that has not been captured. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joyReleaseCapture",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uJoyID",
        "description": "Identifier of the joystick to be released. Valid values for uJoyID range from zero (JOYSTICKID1) to 15."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values.  ",
    "remarks": "If the specified joystick is currently captured, the function returns undefined behavior. Call the joyReleaseCapture function to release the captured joystick, or destroy the window to release the joystick automatically. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joySetCapture",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwnd",
        "description": "Handle to the window to receive the joystick messages."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uJoyID",
        "description": "Identifier of the joystick to be captured. Valid values for uJoyID range from zero (JOYSTICKID1) to 15."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uPeriod",
        "description": "Polling frequency, in milliseconds."
      },
      {
        "in_out": "",
        "type": "BOOL",
        "name": "fChanged",
        "description": "Change position flag. Specify TRUE for this parameter to send messages only when the position changes by a value greater than the joystick movement threshold. Otherwise, messages are sent at the polling frequency specified in uPeriod."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns JOYERR_NOERROR if successful or one of the following error values.  ",
    "remarks": "The movement threshold is the distance the joystick must be moved before a joystick position-change message (MM_JOY1MOVE, MM_JOY1ZMOVE, MM_JOY2MOVE, or MM_JOY2ZMOVE) is sent to a window that has captured the device. The threshold is initially zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "joySetThreshold",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uJoyID",
        "description": "Identifier of the joystick. Valid values for uJoyID range from zero (JOYSTICKID1) to 15."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uThreshold",
        "description": "New movement threshold."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE if unsuccessful. ",
    "remarks": "This function is a simplified version of the mciSendString function. It does not take a buffer for return information, and it displays a message box when errors occur. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "mciExecute",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCSTR",
        "name": "pszCommand",
        "description": "Pointer to a null-terminated string that specifies an MCI command string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the handle of the creator task responsible for opening the device if successful. If the device identifier is invalid, the return value is NULL. ",
    "remarks": "",
    "return_type": "HANDLE",
    "category": "Windows Multimedia",
    "name": "mciGetCreatorTask",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MCIDEVICEID",
        "name": "IDDevice",
        "description": "Device for which the creator task is returned."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the device identifier assigned to the device when it was opened if successful. The identifier is used in the mciSendCommand function. If the device name is not known, if the device is not open, or if there was not enough memory to complete the operation, the return value is zero. ",
    "remarks": "Each file for a compound device has a unique device identifier. The identifier of the \"all\" device is MCI_ALL_DEVICE_ID. ",
    "return_type": "MCIDEVICEID",
    "category": "Windows Multimedia",
    "name": "mciGetDeviceID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpszDevice",
        "description": "Pointer to a null-terminated string that specifies the device name or the alias name by which the device is known."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the device identifier assigned to the device when it was opened if successful. The identifier is used in the mciSendCommand function. If the element ID is not known, if the value of lpstrType is NULL, if the device is not open, or if there was not enough memory to complete the operation, the return value is zero. ",
    "remarks": "Each file for a compound device has a unique device identifier. The identifier of the \"all\" device is MCI_ALL_DEVICE_ID. For UNICODE, this method calls mciGetDeviceIDFromElementIDW, which defines the parameter lpstrType as type LPCWSTR. ",
    "return_type": "MCIDEVICEID",
    "category": "Windows Multimedia",
    "name": "mciGetDeviceIDFromElementID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwElementID",
        "description": "The element identifier."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpstrType",
        "description": "Pointer to a null-terminated string specifying the type name that corresponds to dwElementID."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE if the error code is not known. ",
    "remarks": "Each string that MCI returns, whether data or an error description, can be a maximum of 128 characters. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "mciGetErrorString",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwError",
        "description": "Error code returned by the mciSendCommand or mciSendString function."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpszErrorText",
        "description": "Pointer to a buffer that receives a null-terminated string describing the specified error."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cchErrorText",
        "description": "Length of the buffer, in characters, pointed to by the lpszErrorText parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the address of the current yield callback function if successful or NULL if the device identifier is invalid. ",
    "remarks": "",
    "return_type": "YIELDPROC",
    "category": "Windows Multimedia",
    "name": "mciGetYieldProc",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MCIDEVICEID",
        "name": "IDDevice",
        "description": "MCI device being monitored (the device performing an MCI command)."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "lpdwYieldData",
        "description": "Pointer to a buffer containing yield data to be passed to the callback function. This parameter can be NULL if there is no yield data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. The low-order word of the returned DWORD value contains the error return value. If the error is device-specific, the high-order word of the return value is the driver identifier; otherwise, the high-order word is zero. For a list of possible return values, see MCIERR Return Values. To retrieve a text description of return values, pass the return value to the mciGetErrorString function. ",
    "remarks": "Error values that are returned when a device is being opened are listed with the MCI_OPEN command message. In addition to the MCI_OPEN error return values, this function can return the values listed in MCIERR Return Values. Use MCI_OPEN to obtain the device identifier specified by the IDDevice parameter. ",
    "return_type": "MCIERROR",
    "category": "Windows Multimedia",
    "name": "mciSendCommand",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MCIDEVICEID",
        "name": "IDDevice",
        "description": "Device identifier of the MCI device that is to receive the command message. This parameter is not used with the MCI_OPEN command message."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Command message. For a list, see Multimedia Commands."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "fdwCommand",
        "description": "Flags for the command message."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam",
        "description": "Pointer to a structure that contains parameters for the command message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. The low-order word of the returned DWORD value contains the error return value. If the error is device-specific, the high-order word of the return value is the driver identifier; otherwise, the high-order word is zero. For a list of possible error values, see MCIERR Return Values. To retrieve a text description of return values, pass the return value to the mciGetErrorString function. ",
    "remarks": "",
    "return_type": "MCIERROR",
    "category": "Windows Multimedia",
    "name": "mciSendString",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpszCommand",
        "description": "Pointer to a null-terminated string that specifies an MCI command string. For a list, see Multimedia Command Strings."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpszReturnString",
        "description": "Pointer to a buffer that receives return information. If no return information is needed, this parameter can be NULL."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cchReturn",
        "description": "Size, in characters, of the return buffer specified by the lpszReturnString parameter."
      },
      {
        "in_out": "",
        "type": "HANDLE",
        "name": "hwndCallback",
        "description": "Handle to a callback window if the \"notify\" flag was specified in the command string."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "This function overrides any previous yield procedure for this device. ",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "mciSetYieldProc",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MCIDEVICEID",
        "name": "IDDevice",
        "description": "Identifier of the device to assign a procedure to."
      },
      {
        "in_out": "",
        "type": "YIELDPROC",
        "name": "yp",
        "description": "Pointer to the procedure to call when yielding for the specified device. If this parameter is NULL, the function disables any existing yield procedure."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwYieldData",
        "description": "Data to be sent to the yield procedure when it is called for the specified device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns the handle to an MCI window if successful or zero otherwise. ",
    "remarks": "Default window styles for a child window are WS_CHILD, WS_BORDER, and WS_VISIBLE. MCIWndCreate assumes a child window when a non-NULL handle of a parent window is specified. Default window styles for a parent window are WS_OVERLAPPEDWINDOW and WS_VISIBLE. MCIWndCreate assumes a parent window when a NULL handle of a parent window is specified. Use the window handle returned by this function for the window handle in the MCIWnd macros. If your application uses this function, it does not need to use the MCIWndRegisterClass function. ",
    "return_type": "HWND",
    "category": "Windows Multimedia",
    "name": "MCIWndCreate",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWND",
        "name": "hwndParent",
        "description": "Handle to the parent window."
      },
      {
        "in_out": "",
        "type": "HINSTANCE",
        "name": "hInstance",
        "description": "Handle to the module instance to associate with the MCIWnd window."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwStyle",
        "description": "Flags defining the window style. In addition to specifying the window styles used with the CreateWindowEx function, you can specify the following styles to use with MCIWnd windows.   Value  Meaning  MCIWNDF_NOAUTOSIZEWINDOWWill not change the dimensions of an MCIWnd window when the image size changes. MCIWNDF_NOAUTOSIZEMOVIEWill not change the dimensions of the destination rectangle when an MCIWnd window size changes. MCIWNDF_NOERRORDLGInhibits display of MCI errors to users. MCIWNDF_NOMENUHides the Menu button from view on the toolbar and prohibits users from accessing its pop-up menu. MCIWNDF_NOOPENHides the open and close commands from the MCIWnd menu and prohibits users from accessing these choices in the pop-up menu. MCIWNDF_NOPLAYBARHides the toolbar from view and prohibits users from accessing it. MCIWNDF_NOTIFYANSICauses MCIWnd to use an ANSI string instead of a Unicode string when notifying the parent window of device mode changes. This flag is used in combination with MCIWNDF_NOTIFYMODE. MCIWNDF_NOTIFYMODECauses MCIWnd to notify the parent window with an MCIWNDM_NOTIFYMODE message whenever the device changes operating modes. The lParam parameter of this message identifies the new mode, such as MCI_MODE_STOP. MCIWNDF_NOTIFYPOSCauses MCIWnd to notify the parent window with an MCIWNDM_NOTIFYPOS message whenever a change in the playback or record position within the content occurs. The lParam parameter of this message contains the new position in the content. MCIWNDF_NOTIFYMEDIACauses MCIWnd to notify the parent window with an MCIWNDM_NOTIFYMEDIA message whenever a new device is used or a data file is opened or closed. The lParam parameter of this message contains a pointer to the new file name. MCIWNDF_NOTIFYSIZECauses MCIWnd to notify the parent window when the MCIWnd window size changes. MCIWNDF_NOTIFYERRORCauses MCIWnd to notify the parent window when an MCI error occurs. MCIWNDF_NOTIFYALLCauses all MCIWNDF window notification styles to be used. MCIWNDF_RECORDAdds a Record button to the toolbar and adds a new file command to the menu if the MCI device has recording capability. MCIWNDF_SHOWALLCauses all MCIWNDF_SHOW styles to be used. MCIWNDF_SHOWMODEDisplays the current mode of the MCI device in the window title bar. For a list of device modes, see the MCIWndGetMode macro. MCIWNDF_SHOWNAMEDisplays the name of the open MCI device or data file in the MCIWnd window title bar. MCIWNDF_SHOWPOSDisplays the current position within the content of the MCI device in the window title bar."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "Null-terminated string indicating the name of an MCI device or data file to open."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "Returns zero if successful. ",
    "remarks": "After registering the MCI window class, use the CreateWindow or CreateWindowEx functions to create an MCIWnd window. If your application uses this function, it does not need to use the MCIWndCreate function. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "MCIWndRegisterClass",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HINSTANCE",
        "name": "hInstance",
        "description": "Handle to the device instance."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "After calling this function, the MIDI input device receives event data in an MIM_DATA message whenever a message with the same event data is sent to the output device driver. A thru driver is a special form of MIDI output driver. The system will allow only one MIDI output device to be connected to a MIDI input device, but multiple MIDI output devices can be connected to a MIDI thru device. Whenever the given MIDI input device receives event data in an MIM_DATA message, a message with the same event data is sent to the given output device driver (or through the thru driver to the output drivers). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiConnect",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDI",
        "name": "hMidi",
        "description": "Handle to a MIDI input device or a MIDI thru device. (For thru devices, this handle must have been returned by a call to the midiOutOpen function.)"
      },
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output or thru device."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "pReserved",
        "description": "Reserved; must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following:.  ",
    "remarks": "MIDI input, output, and thru devices can be connected by using the midiConnect function. Thereafter, whenever the MIDI input device receives event data in an MIM_DATA message, a message with the same event data is sent to the output device driver (or through the thru driver to the output drivers). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiDisconnect",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDI",
        "name": "hMidi",
        "description": "Handle to a MIDI input device or a MIDI thru device."
      },
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device to be disconnected."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "pReserved",
        "description": "Reserved; must be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "When the buffer is filled, it is sent back to the application. The buffer must be prepared by using the midiInPrepareHeader function before it is passed to the midiInAddBuffer function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInAddBuffer",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiInHdr",
        "description": "Pointer to a MIDIHDR structure that identifies the buffer."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiInHdr",
        "description": "Size, in bytes, of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If there are input buffers that have been sent by using the midiInAddBuffer function and have not been returned to the application, the close operation will fail. To return all pending buffers through the callback function, use the midiInReset function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device. If the function is successful, the handle is no longer valid after the call to this function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "To determine the number of MIDI input devices present on the system, use the midiInGetNumDevs function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uDeviceID",
        "description": "Identifier of the MIDI input device. The device identifier varies from zero to one less than the number of devices present. This parameter can also be a properly cast device handle."
      },
      {
        "in_out": "",
        "type": "LPMIDIINCAPS",
        "name": "lpMidiInCaps",
        "description": "Pointer to a MIDIINCAPS structure that is filled with information about the capabilities of the device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiInCaps",
        "description": "Size, in bytes, of the MIDIINCAPS structure. Only cbMidiInCaps bytes (or less) of information is copied to the location pointed to by lpMidiInCaps. If cbMidiInCaps is zero, nothing is copied, and the function returns MMSYSERR_NOERROR."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is always null-terminated. If cchText is zero, nothing is copied, and the function returns zero. All error descriptions are less than MAXERRORLENGTH characters long. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInGetErrorText",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MMRESULT",
        "name": "wError",
        "description": "Error code."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpText",
        "description": "Pointer to the buffer to be filled with the textual error description."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cchText",
        "description": "Length, in characters, of the buffer pointed to by lpText."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInGetID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hmi",
        "description": "Handle to the MIDI input device."
      },
      {
        "in_out": "",
        "type": "LPUINT",
        "name": "puDeviceID",
        "description": "Pointer to a variable to be filled with the device identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of MIDI input devices present in the system. A return value of zero means that there are no devices (not that there is no error). ",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "midiInGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the value returned by the audio device driver. ",
    "remarks": "This function is used only for driver-specific messages that are not supported by the MIDI API. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "midiInMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "deviceID",
        "description": "Identifier of the MIDI device that receives the message. You must cast the device ID to the HMIDIIN handle type. If you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "msg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dw1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dw2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following/  ",
    "remarks": "To determine the number of MIDI input devices present in the system, use the midiInGetNumDevs function. The device identifier specified by wDeviceID varies from zero to one less than the number of devices present. If a window or thread is chosen to receive callback information, the following messages are sent to the window procedure or thread to indicate the progress of MIDI input: MM_MIM_OPEN, MM_MIM_CLOSE, MM_MIM_DATA, MM_MIM_LONGDATA, MM_MIM_ERROR, MM_MIM_LONGERROR, and MM_MIM_MOREDATA. If a function is chosen to receive callback information, the following messages are sent to the function to indicate the progress of MIDI input: MIM_OPEN, MIM_CLOSE, MIM_DATA, MIM_LONGDATA, MIM_ERROR, MIM_LONGERROR, and MIM_MOREDATA. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHMIDIIN",
        "name": "lphMidiIn",
        "description": "Pointer to an HMIDIIN handle. This location is filled with a handle identifying the opened MIDI input device. The handle is used to identify the device in calls to other MIDI input functions."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDeviceID",
        "description": "Identifier of the MIDI input device to be opened."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Pointer to a callback function, a thread identifier, or a handle of a window called with information about incoming MIDI messages. For more information on the callback function, see MidiInProc."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallbackInstance",
        "description": "User instance data passed to the callback function. This parameter is not used with window callback functions or threads."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Callback flag for opening the device and, optionally, a status flag that helps regulate rapid data transfers. It can be the following values.   Value  Meaning  CALLBACK_FUNCTIONThe dwCallback parameter is a callback procedure address. CALLBACK_NULLThere is no callback mechanism. This value is the default setting. CALLBACK_THREADThe dwCallback parameter is a thread identifier. CALLBACK_WINDOWThe dwCallback parameter is a window handle. MIDI_IO_STATUSWhen this parameter also specifies CALLBACK_FUNCTION, MIM_MOREDATA messages are sent to the callback function as well as MIM_DATA messages. Or, if this parameter also specifies CALLBACK_WINDOW, MM_MIM_MOREDATA messages are sent to the window as well as MM_MIM_DATA messages. This flag does not affect event or thread callbacks.    Most applications that use a callback mechanism will specify CALLBACK_FUNCTION for this parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before you pass a MIDI data block to a device driver, you must prepare the buffer by passing it to the midiInPrepareHeader function. After the header has been prepared, do not modify the buffer. After the driver is done using the buffer, call the midiInUnprepareHeader function. The application can re-use the same buffer, or allocate multiple buffers and  call midiInPrepareHeader for each buffer. If you re-use the same buffer, it is not necessary to prepare the buffer each time. You can call  midiInPrepareHeader once at the beginning and then call midiInUnprepareHeader once at the end. Preparing a header that has already been prepared has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInPrepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device.           To get the device handle, call midiInOpen."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiInHdr",
        "description": "Pointer to a MIDIHDR structure that identifies the buffer to be prepared.             Before calling the function, set the lpData, dwBufferLength, and dwFlags members of the MIDIHDR structure. The dwFlags member must be set to zero."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiInHdr",
        "description": "Size, in bytes, of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The meaning of the dwParam1 and dwParam2 parameters is specific to the message type. For more information, see the topics for messages, such as MIM_DATA. Applications should not call any multimedia functions from inside the callback function, as doing so can cause a deadlock. Other system functions can safely be called from the callback. ",
    "return_type": "void CALLBACK",
    "category": "Windows Multimedia",
    "name": "MidiInProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMsg",
        "description": "MIDI input message."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Instance data supplied with the midiInOpen function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function returns all pending input buffers to the callback function and sets the MHDR_DONE flag in the dwFlags member of the MIDIHDR structure. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInReset",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following  ",
    "remarks": "This function resets the time stamp to zero; time stamp values for subsequently received messages are relative to the time that this function was called. All messages except system-exclusive messages are sent directly to the client when they are received. System-exclusive messages are placed in the buffers supplied by the midiInAddBuffer function. If there are no buffers in the queue, the system-exclusive data is thrown away without notification to the client and input continues. Buffers are returned to the client when they are full, when a complete system-exclusive message has been received, or when the midiInReset function is used. The dwBytesRecorded member of the MIDIHDR structure will contain the actual length of data received. Calling this function when input is already started has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInStart",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If there are any system-exclusive messages or stream buffers in the queue, the current buffer is marked as done (the dwBytesRecorded member of the MIDIHDR structure will contain the actual length of data), but any empty buffers in the queue remain there and are not marked as done. Calling this function when input is not started has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInStop",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function is complementary to midiInPrepareHeader. You must use this function before freeing the buffer. After passing a buffer to the device driver by using the midiInAddBuffer function, you must wait until the driver is finished with the buffer before using midiInUnprepareHeader. Unpreparing a buffer that has not been prepared has no effect, and the function returns MMSYSERR_NOERROR. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiInUnprepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIIN",
        "name": "hMidiIn",
        "description": "Handle to the MIDI input device."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiInHdr",
        "description": "Pointer to a MIDIHDR structure identifying the buffer to be cleaned up."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiInHdr",
        "description": "Size of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Some synthesizers are not capable of keeping all percussion patches loaded simultaneously. Caching patches ensures that the specified patches are available. Each element of the KEYARRAY array represents one of the 128 key-based percussion patches and has bits set for each of the 16 MIDI channels that use the particular patch. The least-significant bit represents physical channel 0, and the most-significant bit represents physical channel 15. For example, if the patch on key number 60 is used by physical channels 9 and 15, element 60 would be set to 0x8200. This function applies only to internal MIDI synthesizer devices. Not all internal synthesizers support patch caching. To see if a device supports patch caching, use the MIDICAPS_CACHE flag to test the dwSupport member of the MIDIOUTCAPS structure filled by the midiOutGetDevCaps function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutCacheDrumPatches",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the opened MIDI output device. This device should be an internal MIDI synthesizer. This parameter can also be the handle of a MIDI stream, cast to HMIDIOUT."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wPatch",
        "description": "Drum patch number that should be used. This parameter should be set to zero to cache the default drum patch."
      },
      {
        "in_out": "",
        "type": "WORD*",
        "name": "lpKeyArray",
        "description": "Pointer to a KEYARRAY array indicating the key numbers of the specified percussion patches to be cached or uncached."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Options for the cache operation. It can be one of the following flags.   Value  Meaning  MIDI_CACHE_ALLCaches all of the specified patches. If they cannot all be cached, it caches none, clears the KEYARRAY array, and returns MMSYSERR_NOMEM. MIDI_CACHE_BESTFITCaches all of the specified patches. If they cannot all be cached, it caches as many patches as possible, changes the KEYARRAY array to reflect which patches were cached, and returns MMSYSERR_NOMEM. MIDI_CACHE_QUERYChanges the KEYARRAY array to indicate which patches are currently cached. MIDI_UNCACHEUncaches the specified patches and clears the KEYARRAY array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Some synthesizers are not capable of keeping all patches loaded simultaneously and must load data from disk when they receive MIDI program change messages. Caching patches ensures that the specified patches are immediately available. Each element of the PATCHARRAY array represents one of the 128 patches and has bits set for each of the 16 MIDI channels that use the particular patch. The least-significant bit represents physical channel 0, and the most-significant bit represents physical channel 15 (0x0F). For example, if patch 0 is used by physical channels 0 and 8, element 0 would be set to 0x0101. This function applies only to internal MIDI synthesizer devices. Not all internal synthesizers support patch caching. To see if a device supports patch caching, use the MIDICAPS_CACHE flag to test the dwSupport member of the MIDIOUTCAPS structure filled by the midiOutGetDevCaps function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutCachePatches",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the opened MIDI output device. This device must be an internal MIDI synthesizer. This parameter can also be the handle of a MIDI stream, cast to HMIDIOUT."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wBank",
        "description": "Bank of patches that should be used. This parameter should be set to zero to cache the default patch bank."
      },
      {
        "in_out": "",
        "type": "WORD*",
        "name": "lpPatchArray",
        "description": "Pointer to a PATCHARRAY array indicating the patches to be cached or uncached."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Options for the cache operation. It can be one of the following flags.   Value  Meaning  MIDI_CACHE_ALLCaches all of the specified patches. If they cannot all be cached, it caches none, clears the PATCHARRAY array, and returns MMSYSERR_NOMEM. MIDI_CACHE_BESTFITCaches all of the specified patches. If they cannot all be cached, it caches as many patches as possible, changes the PATCHARRAY array to reflect which patches were cached, and returns MMSYSERR_NOMEM. MIDI_CACHE_QUERYChanges the PATCHARRAY array to indicate which patches are currently cached. MIDI_UNCACHEUncaches the specified patches and clears the PATCHARRAY array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If there are output buffers that have been sent by using the midiOutLongMsg function and have not been returned to the application, the close operation will fail. To mark all pending buffers as being done, use the midiOutReset function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device. If the function is successful, the handle is no longer valid after the call to this function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "To determine the number of MIDI output devices present in the system, use the midiOutGetNumDevs function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uDeviceID",
        "description": "Identifier of the MIDI output device. The device identifier specified by this parameter varies from zero to one less than the number of devices present. The MIDI_MAPPER constant is also a valid device identifier. This parameter can also be a properly cast device handle."
      },
      {
        "in_out": "",
        "type": "LPMIDIOUTCAPS",
        "name": "lpMidiOutCaps",
        "description": "Pointer to a MIDIOUTCAPS structure. This structure is filled with information about the capabilities of the device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiOutCaps",
        "description": "Size, in bytes, of the MIDIOUTCAPS structure. Only cbMidiOutCaps bytes (or less) of information is copied to the location pointed to by lpMidiOutCaps. If cbMidiOutCaps is zero, nothing is copied, and the function returns MMSYSERR_NOERROR."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is always null-terminated. If cchText is zero, nothing is copied, and the function returns MMSYSERR_NOERROR. All error descriptions are less than MAXERRORLENGTH characters long. ",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "midiOutGetErrorText",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MMRESULT",
        "name": "mmrError",
        "description": "Error code."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "lpText",
        "description": "Pointer to a buffer to be filled with the textual error description."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cchText",
        "description": "Length, in characters, of the buffer pointed to by lpText."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutGetID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device."
      },
      {
        "in_out": "",
        "type": "LPUINT",
        "name": "puDeviceID",
        "description": "Pointer to a variable to be filled with the device identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of MIDI output devices. A return value of zero means that there are no devices (not that there is no error). ",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "midiOutGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If a device identifier is used, then the result of the midiOutGetVolume call and the information returned in lpdwVolume applies to all instances of the device. If a device handle is used, then the result and information returned applies only to the instance of the device referenced by the device handle. Not all devices support volume control. You can determine whether a device supports volume control by querying the device by using the midiOutGetDevCaps function and specifying the MIDICAPS_VOLUME flag. You can also determine whether the device supports volume control on both the left and right channels by querying the device by using the midiOutGetDevCaps function and specifying the MIDICAPS_LRVOLUME flag. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutGetVolume",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to an open MIDI output device. This parameter can also contain the handle of a MIDI stream, as long as it is cast to HMIDIOUT. This parameter can also be a device identifier."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "lpdwVolume",
        "description": "Pointer to the location to contain the current volume setting. The low-order word of this location contains the left-channel volume setting, and the high-order word contains the right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence. If a device does not support both left and right volume control, the low-order word of the specified location contains the mono volume level. Any value set by using the midiOutSetVolume function is returned, regardless of whether the device supports that value."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before the buffer is passed to midiOutLongMsg, it must be prepared by using the midiOutPrepareHeader function. The MIDI output device driver determines whether the data is sent synchronously or asynchronously. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutLongMsg",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to HMIDIOUT."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiOutHdr",
        "description": "Pointer to a MIDIHDR structure that identifies the MIDI buffer."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiOutHdr",
        "description": "Size, in bytes, of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the value returned by the audio device driver. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "midiOutMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "deviceID",
        "description": "Identifier of the MIDI device that receives the message. You must cast the device ID to the HMIDIOUT handle type. If you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "msg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dw1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dw2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "To determine the number of MIDI output devices present in the system, use the midiOutGetNumDevs function. The device identifier specified by wDeviceID varies from zero to one less than the number of devices present. MIDI_MAPPER can also be used as the device identifier. If a window or thread is chosen to receive callback information, the following messages are sent to the window procedure or thread to indicate the progress of MIDI output: MM_MOM_OPEN, MM_MOM_CLOSE, and MM_MOM_DONE. If a function is chosen to receive callback information, the following messages are sent to the function to indicate the progress of MIDI output: MOM_OPEN, MOM_CLOSE, and MOM_DONE. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHMIDIOUT",
        "name": "lphmo",
        "description": "Pointer to an HMIDIOUT handle. This location is filled with a handle identifying the opened MIDI output device. The handle is used to identify the device in calls to other MIDI output functions."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDeviceID",
        "description": "Identifier of the MIDI output device that is to be opened."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Pointer to a callback function, an event handle, a thread identifier, or a handle of a window or thread called during MIDI playback to process messages related to the progress of the playback. If no callback is desired, specify NULL for this parameter. For more information on the callback function, see MidiOutProc."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallbackInstance",
        "description": "User instance data passed to the callback. This parameter is not used with window callbacks or threads."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Callback flag for opening the device. It can be the following values.   Value  Meaning  CALLBACK_EVENTThe dwCallback parameter is an event handle. This callback mechanism is for output only. CALLBACK_FUNCTIONThe dwCallback parameter is a callback function address. CALLBACK_NULLThere is no callback mechanism. This value is the default setting. CALLBACK_THREADThe dwCallback parameter is a thread identifier. CALLBACK_WINDOWThe dwCallback parameter is a window handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before you pass a MIDI data block to a device driver, you must prepare the buffer by passing it to the midiOutPrepareHeader function. After the header has been prepared, do not modify the buffer. After the driver is done using the buffer, call the midiOutUnprepareHeader function. The application can re-use the same buffer, or allocate multiple buffers and  call midiOutPrepareHeader for each buffer. If you re-use the same buffer, it is not necessary to prepare the buffer each time. You can call  midiOutPrepareHeader once at the beginning and then call midiOutUnprepareHeader once at the end. A stream buffer cannot be larger than 64K. Preparing a header that has already been prepared has no effect, and the function returns MMSYSERR_NOERROR. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutPrepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device. To get the device handle, call midiOutOpen. This parameter can also be the handle of a MIDI stream cast to a HMIDIOUT type."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiOutHdr",
        "description": "Pointer to a MIDIHDR structure that identifies the buffer to be prepared.            Before calling the function, set the lpData, dwBufferLength, and dwFlags members of the MIDIHDR structure. The dwFlags member must be set to zero."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiOutHdr",
        "description": "Size, in bytes, of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Applications should not call any multimedia functions from inside the callback function, as doing so can cause a deadlock. Other system functions can safely be called from the callback. ",
    "return_type": "void CALLBACK",
    "category": "Windows Multimedia",
    "name": "MidiOutProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI device associated with the callback function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMsg",
        "description": "MIDI output message."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Instance data supplied by using the midiOutOpen function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Any pending system-exclusive or stream output buffers are returned to the callback function and the MHDR_DONE flag is set in the dwFlags member of the MIDIHDR structure. Terminating a system-exclusive message without sending an EOX (end-of-exclusive) byte might cause problems for the receiving device. The midiOutReset function does not send an EOX byte when it terminates a system-exclusive message \u00e2\u0080\u0094 applications are responsible for doing this. To turn off all notes, a note-off message for each note in each channel is sent. In addition, the sustain controller is turned off for each channel. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutReset",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to HMIDIOUT."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If a device identifier is used, then the result of the midiOutSetVolume call applies to all instances of the device. If a device handle is used, then the result applies only to the instance of the device referenced by the device handle. Not all devices support volume changes. You can determine whether a device supports it by querying the device using the midiOutGetDevCaps function and the MIDICAPS_VOLUME flag. You can also determine whether the device supports volume control on both the left and right channels by querying the device using the midiOutGetDevCaps function and the MIDICAPS_LRVOLUME flag. Devices that do not support a full 16 bits of volume-level control use the high-order bits of the requested volume setting. For example, a device that supports 4 bits of volume control produces the same volume setting for the following volume-level values: 0x4000, 0x43be, and 0x4fff. The midiOutGetVolume function returns the full 16-bit value, as set by midiOutSetVolume, irrespective of the device's capabilities. Volume settings are interpreted logarithmically. This means that the perceived increase in volume is the same when increasing the volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutSetVolume",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to an open MIDI output device. This parameter can also contain the handle of a MIDI stream, as long as it is cast to HMIDIOUT. This parameter can also be a device identifier."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwVolume",
        "description": "New volume setting. The low-order word contains the left-channel volume setting, and the high-order word contains the right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence. If a device does not support both left and right volume control, the low-order word of dwVolume specifies the mono volume level, and the high-order word is ignored."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following:  ",
    "remarks": "This function is used to send any MIDI message except for system-exclusive or stream messages. This function might not return until the message has been sent to the output device. You can send short messages while streams are playing on the same device (although you cannot use a running status in this case). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutShortMsg",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to HMIDIOUT."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwMsg",
        "description": "MIDI message. The message is packed into a DWORD value with the first byte of the message in the low-order byte. The message is packed into this parameter as follows.                     Word                                    Byte                                    Usage                  HighHigh-orderNot used. Low-orderThe second byte of MIDI data (when needed). LowHigh-orderThe first byte of MIDI data (when needed). Low-orderThe MIDI status.    The two MIDI data bytes are optional, depending on the MIDI status byte. When a series of messages have the same status byte, the status byte can be omitted from messages after the first one in the series, creating a running status. Pack a message for running status as follows:                     Word                                    Byte                                    Usage                  HighHigh-orderNot used. Low-orderNot used. LowHigh-orderThe second byte of MIDI data (when needed). Low-orderThe first byte of MIDI data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function is complementary to the midiOutPrepareHeader function. You must call midiOutUnprepareHeader before freeing the buffer. After passing a buffer to the device driver with the midiOutLongMsg function, you must wait until the device driver is finished with the buffer before calling midiOutUnprepareHeader. Unpreparing a buffer that has not been prepared has no effect, and the function returns MMSYSERR_NOERROR. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiOutUnprepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDIOUT",
        "name": "hmo",
        "description": "Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to HMIDIOUT."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiOutHdr",
        "description": "Pointer to a MIDIHDR structure identifying the buffer to be cleaned up."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiOutHdr",
        "description": "Size, in bytes, of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hStream",
        "description": "Handle to a MIDI stream, as retrieved by using the midiStreamOpen function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHMIDISTRM",
        "name": "lphStream",
        "description": "Pointer to a variable to contain the stream handle when the function returns."
      },
      {
        "in_out": "",
        "type": "LPUINT",
        "name": "puDeviceID",
        "description": "Pointer to a device identifier. The device is opened on behalf of the stream and closed again when the stream is closed."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "cMidi",
        "description": "Reserved; must be 1."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Pointer to a callback function, an event handle, a thread identifier, or a handle of a window or thread called during MIDI playback to process messages related to the progress of the playback. If no callback mechanism is desired, specify NULL for this parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Application-specific instance data that is returned to the application with every callback function."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwOpen",
        "description": "Callback flag for opening the device. One of the following callback flags must be specified.   Value  Meaning  CALLBACK_EVENTThe dwCallback parameter is an event handle. This callback mechanism is for output only. CALLBACK_FUNCTIONThe dwCallback parameter is a callback procedure address. For the callback signature, see MidiOutProc. CALLBACK_NULLThere is no callback mechanism. This is the default setting. CALLBACK_THREADThe dwCallback parameter is a thread identifier. CALLBACK_WINDOWThe dwCallback parameter is a window handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before the buffer is passed to midiStreamOpen, it must be prepared by using the midiOutPrepareHeader function. Because the midiStreamOpen function opens the output device in paused mode, you must call the midiStreamRestart function before you can use midiStreamOut to start the playback. For the current implementation of this function, the buffer must be smaller than 64K. The buffer pointed to by the MIDIHDR structure contains one or more MIDI events, each of which is defined by a MIDIEVENT structure. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamOut",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hMidiStream",
        "description": "Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies the output device."
      },
      {
        "in_out": "",
        "type": "LPMIDIHDR",
        "name": "lpMidiHdr",
        "description": "Pointer to a MIDIHDR structure that identifies the MIDI buffer."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbMidiHdr",
        "description": "Size, in bytes, of the MIDIHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The current playback position is saved when playback is paused. To resume playback from the current position, use the midiStreamRestart function. Calling this function when the output is already paused has no effect, and the function returns MMSYSERR_NOERROR. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamPause",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hms",
        "description": "Handle to a MIDI stream. This handle must have been returned by a call to the MIDIEVENT function. This handle identifies the output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before calling midiStreamPosition, set the wType member of the MMTIME structure to indicate the time format you desire. After calling midiStreamPosition, check the wType member to determine if the desired time format is supported. If the desired format is not supported, wType will specify an alternative format. The position is set to zero when the device is opened or reset. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamPosition",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hms",
        "description": "Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies the output device."
      },
      {
        "in_out": "",
        "type": "LPMMTIME",
        "name": "pmmt",
        "description": "Pointer to an MMTIME structure."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbmmt",
        "description": "Size, in bytes, of the MMTIME structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "These properties are the default properties defined by the system. Driver writers can implement and document their own properties. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamProperty",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hm",
        "description": "Handle to the MIDI device that the property is associated with."
      },
      {
        "in_out": "",
        "type": "LPBYTE",
        "name": "lppropdata",
        "description": "Pointer to the property data."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwProperty",
        "description": "Flags that specify the action to perform and identify the appropriate property of the MIDI data stream. The midiStreamProperty function requires setting two flags in each use. One flag (either MIDIPROP_GET or MIDIPROP_SET) specifies an action, and the other identifies a specific property to examine or edit.   Value  Meaning  MIDIPROP_GETRetrieves the current setting of the given property. MIDIPROP_SETSets the given property. MIDIPROP_TEMPORetrieves the tempo property. The lppropdata parameter points to a MIDIPROPTEMPO structure. The current tempo value can be retrieved at any time. Output devices set the tempo by inserting MEVT_TEMPO events into the MIDI data. MIDIPROP_TIMEDIVSpecifies the time division property. You can get or set this property. The lppropdata parameter points to a MIDIPROPTIMEDIV structure. This property can be set only when the device is stopped."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Calling this function when the output is not paused has no effect, and the function returns MMSYSERR_NOERROR. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamRestart",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hms",
        "description": "Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies the output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "When you call this function, any pending system-exclusive or stream output buffers are returned to the callback mechanism and the MHDR_DONE bit is set in the dwFlags member of the MIDIHDR structure. While the midiOutReset function turns off all notes, midiStreamStop turns off only those notes that have been turned on by a MIDI note-on message. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "midiStreamStop",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIDISTRM",
        "name": "hms",
        "description": "Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies the output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXER",
        "name": "hmx",
        "description": "Handle to the mixer device. This handle must have been returned successfully by the mixerOpen function. If mixerClose is successful, hmx is no longer valid."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "All members of the MIXERCONTROLDETAILS structure must be initialized before calling this function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerGetControlDetails",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXEROBJ",
        "name": "hmxobj",
        "description": "Handle to the mixer device object being queried."
      },
      {
        "in_out": "",
        "type": "LPMIXERCONTROLDETAILS",
        "name": "pmxcd",
        "description": "Pointer to a MIXERCONTROLDETAILS structure, which is filled with state information about the control."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDetails",
        "description": "Flags for retrieving control details. The following values are defined.   Value  Meaning  MIXER_GETCONTROLDETAILSF_LISTTEXTThe paDetails member of the MIXERCONTROLDETAILS structure points to one or more MIXERCONTROLDETAILS_LISTTEXT structures to receive text labels for multiple-item controls. An application must get all list text items for a multiple-item control at once. This flag cannot be used with MIXERCONTROL_CONTROLTYPE_CUSTOM controls. MIXER_GETCONTROLDETAILSF_VALUECurrent values for a control are retrieved. The paDetails member of the MIXERCONTROLDETAILS structure points to one or more details structures appropriate for the control class. MIXER_OBJECTF_AUXThe hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by the auxGetNumDevs function. MIXER_OBJECTF_HMIDIINThe hmxobj parameter is the handle of a MIDI (Musical Instrument Digital Interface) input device. This handle must have been returned by the midiInOpen function. MIXER_OBJECTF_HMIDIOUTThe hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function. MIXER_OBJECTF_HMIXERThe hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional. MIXER_OBJECTF_HWAVEINThe hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function. MIXER_OBJECTF_HWAVEOUTThe hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function. MIXER_OBJECTF_MIDIINThe hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the number of devices returned by the midiInGetNumDevs function. MIXER_OBJECTF_MIDIOUTThe hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the number of devices returned by the midiOutGetNumDevs function. MIXER_OBJECTF_MIXERThe hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices returned by the mixerGetNumDevs function. This flag is optional. MIXER_OBJECTF_WAVEINThe hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of devices returned by the waveInGetNumDevs function. MIXER_OBJECTF_WAVEOUTThe hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of devices returned by the waveOutGetNumDevs function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Use the mixerGetNumDevs function to determine the number of mixer devices present in the system. The device identifier specified by uMxId varies from zero to one less than the number of mixer devices present. Only the number of bytes (or less) of information specified in cbmxcaps is copied to the location pointed to by pmxcaps. If cbmxcaps is zero, nothing is copied, and the function returns successfully. This function also accepts a mixer device handle returned by the mixerOpen function as the uMxId parameter. The application should cast the HMIXER handle to a UINT. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uMxId",
        "description": "Identifier or handle of an open mixer device."
      },
      {
        "in_out": "",
        "type": "LPMIXERCAPS",
        "name": "pmxcaps",
        "description": "Pointer to a MIXERCAPS structure that receives information about the capabilities of the device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbmxcaps",
        "description": "Size, in bytes, of the MIXERCAPS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerGetID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXEROBJ",
        "name": "hmxobj",
        "description": "Handle to the audio mixer object to map to a mixer device identifier."
      },
      {
        "in_out": "UINT",
        "type": "FAR*",
        "name": "puMxId",
        "description": "Pointer to a variable that receives the mixer device identifier. If no mixer device is available for the hmxobj object, the value -1 is placed in this location and the MMSYSERR_NODRIVER error value is returned."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwId",
        "description": "Flags for mapping the mixer object hmxobj. The following values are defined.   Value  Meaning  MIXER_OBJECTF_AUXThe hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by the auxGetNumDevs function. MIXER_OBJECTF_HMIDIINThe hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function. MIXER_OBJECTF_HMIDIOUTThe hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function. MIXER_OBJECTF_HMIXERThe hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional. MIXER_OBJECTF_HWAVEINThe hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function. MIXER_OBJECTF_HWAVEOUTThe hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function. MIXER_OBJECTF_MIDIINThe hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the number of devices returned by the midiInGetNumDevs function. MIXER_OBJECTF_MIDIOUTThe hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the number of devices returned by the midiOutGetNumDevs function. MIXER_OBJECTF_MIXERThe hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices returned by the mixerGetNumDevs function. This flag is optional. MIXER_OBJECTF_WAVEINThe hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of devices returned by the waveInGetNumDevs function. MIXER_OBJECTF_WAVEOUTThe hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of devices returned by the waveOutGetNumDevs function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerGetLineControls",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXEROBJ",
        "name": "hmxobj",
        "description": "Handle to the mixer device object that is being queried."
      },
      {
        "in_out": "",
        "type": "LPMIXERLINECONTROLS",
        "name": "pmxlc",
        "description": "Pointer to a MIXERLINECONTROLS structure. This structure is used to reference one or more MIXERCONTROL structures to be filled with information about the controls associated with an audio line. The cbStruct member of the MIXERLINECONTROLS structure must always be initialized to be the size, in bytes, of the MIXERLINECONTROLS structure."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwControls",
        "description": "Flags for retrieving information about one or more controls associated with an audio line. The following values are defined.   Value  Meaning  MIXER_GETLINECONTROLSF_ALLThe pmxlc parameter references a list of MIXERCONTROL structures that will receive information on all controls associated with the audio line identified by the dwLineID member of the MIXERLINECONTROLS structure. The cControls member must be initialized to the number of controls associated with the line. This number is retrieved from the cControls member of the MIXERLINE structure returned by the mixerGetLineInfo function. The cbmxctrl member must be initialized to the size, in bytes, of a single MIXERCONTROL structure. The pamxctrl member must point to the first MIXERCONTROL structure to be filled. The dwControlID and dwControlType members are ignored for this query. MIXER_GETLINECONTROLSF_ONEBYIDThe pmxlc parameter references a single MIXERCONTROL structure that will receive information on the control identified by the dwControlID member of the MIXERLINECONTROLS structure. The cControls member must be initialized to 1. The cbmxctrl member must be initialized to the size, in bytes, of a single MIXERCONTROL structure. The pamxctrl member must point to a MIXERCONTROL structure to be filled. The dwLineID and dwControlType members are ignored for this query. This query is usually used to refresh a control after receiving a MM_MIXM_CONTROL_CHANGE control change notification message by the user-defined callback (see mixerOpen). MIXER_GETLINECONTROLSF_ONEBYTYPEThe mixerGetLineControls function retrieves information about the first control of a specific class for the audio line that is being queried. The pmxlc parameter references a single MIXERCONTROL structure that will receive information about the specific control. The audio line is identified by the dwLineID member. The control class is specified in the dwControlType member of the MIXERLINECONTROLS structure.The dwControlID member is ignored for this query. This query can be used by an application to get information on a single control associated with a line. For example, you might want your application to use a peak meter only from a waveform-audio output line.  MIXER_OBJECTF_AUXThe hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by the auxGetNumDevs function. MIXER_OBJECTF_HMIDIINThe hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function. MIXER_OBJECTF_HMIDIOUTThe hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function. MIXER_OBJECTF_HMIXERThe hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional. MIXER_OBJECTF_HWAVEINThe hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function. MIXER_OBJECTF_HWAVEOUTThe hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function. MIXER_OBJECTF_MIDIINThe hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the number of devices returned by the midiInGetNumDevs function. MIXER_OBJECTF_MIDIOUTThe hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the number of devices returned by the midiOutGetNumDevs function. MIXER_OBJECTF_MIXERThe hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices returned by the mixerGetNumDevs function. This flag is optional. MIXER_OBJECTF_WAVEINThe hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of devices returned by the waveInGetNumDevs function. MIXER_OBJECTF_WAVEOUTThe hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of devices returned by the waveOutGetNumDevs function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerGetLineInfo",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXEROBJ",
        "name": "hmxobj",
        "description": "Handle to the mixer device object that controls the specific audio line."
      },
      {
        "in_out": "",
        "type": "LPMIXERLINE",
        "name": "pmxl",
        "description": "Pointer to a MIXERLINE structure. This structure is filled with information about the audio line for the mixer device. The cbStruct member must always be initialized to be the size, in bytes, of the MIXERLINE structure."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwInfo",
        "description": "Flags for retrieving information about an audio line. The following values are defined.   Value  Meaning  MIXER_GETLINEINFOF_COMPONENTTYPEThe pmxl parameter will receive information about the first audio line of the type specified in the dwComponentType member of the MIXERLINE structure. This flag is used to retrieve information about an audio line of a specific component type. Remaining structure members except cbStruct require no further initialization. MIXER_GETLINEINFOF_DESTINATIONThe pmxl parameter will receive information about the destination audio line specified by the dwDestination member of the MIXERLINE structure. This index ranges from zero to one less than the value in the cDestinations member of the MIXERCAPS structure. All remaining structure members except cbStruct require no further initialization. MIXER_GETLINEINFOF_LINEIDThe pmxl parameter will receive information about the audio line specified by the dwLineID member of the MIXERLINE structure. This is usually used to retrieve updated information about the state of an audio line. All remaining structure members except cbStruct require no further initialization. MIXER_GETLINEINFOF_SOURCEThe pmxl parameter will receive information about the source audio line specified by the dwDestination and dwSource members of the MIXERLINE structure. The index specified by dwDestination ranges from zero to one less than the value in the cDestinations member of the MIXERCAPS structure. The index specified by dwSource ranges from zero to one less than the value in the cConnections member of the MIXERLINE structure returned for the audio line stored in the dwDestination member. All remaining structure members except cbStruct require no further initialization. MIXER_GETLINEINFOF_TARGETTYPEThe pmxl parameter will receive information about the audio line that is for the dwType member of the Target structure, which is a member of the MIXERLINE structure. This flag is used to retrieve information about an audio line that handles the target type (for example, MIXERLINE_TARGETTYPE_WAVEOUT). The application must initialize the dwType, wMid, wPid, vDriverVersion and szPname members of the MIXERLINE structure before calling mixerGetLineInfo. All of these values can be retrieved from the device capabilities structures for all media devices. Remaining structure members except cbStruct require no further initialization.  Note  In the ANSI version of this function (mixerGetLineInfoA), you cannot use the ANSI string returned from mixerGetLineInfo or waveOutGetDevCaps for the value of the psPname string when calling mixerGetLineInfo with the MIXER_GETLINEINFOF_TARGETTYPE flag. The reason is that an internal conversion to and from Unicode is performed, which might  result in loss of data.     MIXER_OBJECTF_AUXThe hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by the auxGetNumDevs function. MIXER_OBJECTF_HMIDIINThe hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function. MIXER_OBJECTF_HMIDIOUTThe hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function. MIXER_OBJECTF_HMIXERThe hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional. MIXER_OBJECTF_HWAVEINThe hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function. MIXER_OBJECTF_HWAVEOUTThe hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function. MIXER_OBJECTF_MIDIINThe hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the number of devices returned by the midiInGetNumDevs function. MIXER_OBJECTF_MIDIOUTThe hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the number of devices returned by the midiOutGetNumDevs function. MIXER_OBJECTF_MIXERThe hmxobj parameter is a mixer device identifier in the range of zero to one less than the number of devices returned by the mixerGetNumDevs function. This flag is optional. MIXER_OBJECTF_WAVEINThe hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of devices returned by the waveInGetNumDevs function. MIXER_OBJECTF_WAVEOUTThe hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of devices returned by the waveOutGetNumDevs function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of mixer devices or zero if no mixer devices are available. ",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "mixerGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns a value that is specific to the custom mixer driver message. Possible error values include the following.  ",
    "remarks": "User-defined messages must be sent only to a mixer driver that supports the messages. The application should verify that the mixer driver is the driver that supports the message by retrieving the mixer capabilities and checking the wMid, wPid, vDriverVersion, and szPname members of the MIXERCAPS structure. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "mixerMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXER",
        "name": "driverID",
        "description": "Identifier of the mixer that receives the message. You must cast the device ID to the HMIXER handle type. If you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Custom mixer driver message to send to the mixer driver. This message must be above or equal to the MXDM_USER constant."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Parameter associated with the message being sent."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Parameter associated with the message being sent."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Use the mixerGetNumDevs function to determine the number of audio mixer devices present in the system. The device identifier specified by uMxId varies from zero to one less than the number of devices present. If a window is chosen to receive callback information, the MM_MIXM_LINE_CHANGE and MM_MIXM_CONTROL_CHANGE messages are sent to the window procedure function to indicate when an audio line or control state changes. For both messages, the wParam parameter is the handle of the mixer device. The lParam parameter is the line identifier for MM_MIXM_LINE_CHANGE or the control identifier for MM_MIXM_CONTROL_CHANGE that changed state. To query for audio mixer support or a media device, use the mixerGetID function. On 64-bit systems, this function may not work as expected in situations where you pass a 64-bit LPHWAVEOUT pointer in the uMxId parameter, because the uMxId parameter is truncated to 32 bits. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHMIXER",
        "name": "phmx",
        "description": "Pointer to a variable that will receive a handle identifying the opened mixer device. Use this handle to identify the device when calling other audio mixer functions. This parameter cannot be NULL."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMxId",
        "description": "Identifier of the mixer device to open. Use a valid device identifier or any HMIXEROBJ (see the mixerGetID function for a description of mixer object handles). A \"mapper\" for audio mixer devices does not currently exist, so a mixer device identifier of -1 is not valid."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Handle to a window called when the state of an audio line and/or control associated with the device being opened is changed. Specify NULL for this parameter if no callback mechanism is to be used."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "Reserved. Must be zero."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwOpen",
        "description": "Flags for opening the device. The following values are defined.   Value  Meaning  CALLBACK_WINDOWThe dwCallback parameter is assumed to be a window handle (HWND). MIXER_OBJECTF_AUXThe uMxId parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by the auxGetNumDevs function. MIXER_OBJECTF_HMIDIINThe uMxId parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function. MIXER_OBJECTF_HMIDIOUTThe uMxId parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function. MIXER_OBJECTF_HMIXERThe uMxId parameter is a mixer device handle returned by the mixerOpen function. This flag is optional. MIXER_OBJECTF_HWAVEINThe uMxId parameter is a waveform-audio input handle returned by the waveInOpen function. MIXER_OBJECTF_HWAVEOUTThe uMxId parameter is a waveform-audio output handle returned by the waveOutOpen function. MIXER_OBJECTF_MIDIINThe uMxId parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the number of devices returned by the midiInGetNumDevs function. MIXER_OBJECTF_MIDIOUTThe uMxId parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the number of devices returned by the midiOutGetNumDevs function. MIXER_OBJECTF_MIXERThe uMxId parameter is a mixer device identifier in the range of zero to one less than the number of devices returned by the mixerGetNumDevs function. This flag is optional. MIXER_OBJECTF_WAVEINThe uMxId parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of devices returned by the waveInGetNumDevs function. MIXER_OBJECTF_WAVEOUTThe uMxId parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of devices returned by the waveOutGetNumDevs function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "All members of the MIXERCONTROLDETAILS structure must be initialized before calling mixerSetControlDetails. If an application needs to retrieve only the current state of a custom mixer control and not display a dialog box, then mixerGetControlDetails can be used with the MIXER_GETCONTROLDETAILSF_VALUE flag. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mixerSetControlDetails",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMIXEROBJ",
        "name": "hmxobj",
        "description": "Handle to the mixer device object for which properties are being set."
      },
      {
        "in_out": "",
        "type": "LPMIXERCONTROLDETAILS",
        "name": "pmxcd",
        "description": "Pointer to a MIXERCONTROLDETAILS structure. This structure is used to reference control detail structures that contain the desired state for the control."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwDetails",
        "description": "Flags for setting properties for a control. The following values are defined.   Value  Meaning  MIXER_OBJECTF_AUXThe hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by the auxGetNumDevs function. MIXER_OBJECTF_HMIDIINThe hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function. MIXER_OBJECTF_HMIDIOUTThe hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function. MIXER_OBJECTF_HMIXERThe hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional. MIXER_OBJECTF_HWAVEINThe hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function. MIXER_OBJECTF_HWAVEOUTThe hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function. MIXER_OBJECTF_MIDIINThe hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the number of devices returned by the midiInGetNumDevs function. MIXER_OBJECTF_MIDIOUTThe hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the number of devices returned by the midiOutGetNumDevs function. MIXER_OBJECTF_MIXERThe hmxobj parameter is a mixer device identifier in the range of zero to one less than the number of devices returned by the mixerGetNumDevs function. This flag is optional. MIXER_OBJECTF_WAVEINThe hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of devices returned by the waveInGetNumDevs function. MIXER_OBJECTF_WAVEOUTThe hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of devices returned by the waveOutGetNumDevs function. MIXER_SETCONTROLDETAILSF_CUSTOMA custom dialog box for the specified custom mixer control is displayed. The mixer device gathers the required information from the user and returns the data in the specified buffer. The handle for the owning window is specified in the hwndOwner member of the MIXERCONTROLDETAILS structure. (This handle can be set to NULL.) The application can then save the data from the dialog box and use it later to reset the control to the same state by using the MIXER_SETCONTROLDETAILSF_VALUE flag. MIXER_SETCONTROLDETAILSF_VALUEThe current value(s) for a control are set. The paDetails member of the MIXERCONTROLDETAILS structure points to one or more mixer-control details structures of the appropriate class for the control."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "",
    "header": "Mmddk.h (include Mmddk.h)",
    "return_value": "",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "mmGetCurrentTask",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If the file is opened for reading, the I/O buffer is filled from the disk. If the file is opened for writing and the MMIO_DIRTY flag is set in the dwFlags member of the MMIOINFO structure, the buffer is written to disk. The pchNext,pchEndRead, and pchEndWrite members of the MMIOINFO structure are updated to reflect the new state of the I/O buffer. If the specified file is opened for writing or for both reading and writing, the I/O buffer is flushed to disk before the next buffer is read. If the I/O buffer cannot be written to disk because the disk is full, mmioAdvance returns MMIOERR_CANNOTWRITE. If the specified file is open only for writing, the MMIO_WRITE flag must be specified. If you have written to the I/O buffer, you must set the MMIO_DIRTY flag in the dwFlags member of the MMIOINFO structure before calling mmioAdvance. Otherwise, the buffer will not be written to disk. If the end of file is reached, mmioAdvance still returns successfully even though no more data can be read. To check for the end of the file, check if the pchNext and pchEndRead members of the MMIOINFO structure are equal after calling mmioAdvance. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioAdvance",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of a file opened by using the mmioOpen function."
      },
      {
        "in_out": "",
        "type": "LPMMIOINFO",
        "name": "lpmmioinfo",
        "description": "Pointer to the MMIOINFO structure obtained by using the mmioGetInfo function. This structure is used to set the current file information, and then it is updated after the buffer is advanced. This parameter is optional."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Flags for the operation. It can be one of the following.   Value  Meaning  MMIO_READBuffer is filled from the file. MMIO_WRITEBuffer is written to the file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If the chunk was descended into by using mmioDescend, mmioAscend seeks to the location following the end of the chunk (past the extra pad byte, if any). If the chunk was created and descended into by using mmioCreateChunk, or if the MMIO_DIRTY flag is set in the dwFlags member of the MMCKINFO structure referenced by lpck, the current file position is assumed to be the end of the data portion of the chunk. If the chunk size is not the same as the value stored in the cksize member of the MMCKINFO structure when mmioCreateChunk was called, mmioAscend corrects the chunk size in the file before ascending from the chunk. If the chunk size is odd, mmioAscend writes a null pad byte at the end of the chunk. After ascending from the chunk, the current file position is the location following the end of the chunk (past the extra pad byte, if any). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioAscend",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of an open RIFF file."
      },
      {
        "in_out": "",
        "type": "LPMMCKINFO",
        "name": "lpck",
        "description": "Pointer to an application-defined MMCKINFO structure previously filled by the mmioDescend or mmioCreateChunk function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. The error value can originate from the mmioFlush function or from the I/O procedure. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file to close."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Flags for the close operation. The following value is defined.   Value  Meaning  MMIO_FHOPENIf the file was opened by passing a file handle whose type is not HMMIO, using this flag tells the mmioClose function to close the multimedia file handle, but not the standard file handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function cannot insert a chunk into the middle of a file. If an application attempts to create a chunk somewhere other than at the end of a file, mmioCreateChunk overwrites existing information in the file. The MMCKINFO structure pointed to by the lpck parameter should be set up as follows: ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioCreateChunk",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of an open RIFF file."
      },
      {
        "in_out": "",
        "type": "LPMMCKINFO",
        "name": "lpck",
        "description": "Pointer to a buffer that receives a MMCKINFO structure containing information about the chunk to be created."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Flags identifying what type of chunk to create. The following values are defined.   Value  Meaning  MMIO_CREATELIST\"LIST\" chunk. MMIO_CREATERIFF\"RIFF\" chunk."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "A \"RIFF\" chunk consists of a four-byte chunk identifier (type FOURCC), followed by a four-byte chunk size (type DWORD), followed by the data portion of the chunk, followed by a null pad byte if the size of the data portion is odd. If the chunk identifier is \"RIFF\" or \"LIST\", the first four bytes of the data portion of the chunk are a form type or list type (type FOURCC). If you use mmioDescend to search for a chunk, make sure the file position is at the beginning of a chunk before calling the function. The search begins at the current file position and continues to the end of the file. If a parent chunk is specified, the file position should be somewhere within the parent chunk before calling mmioDescend. In this case, the search begins at the current file position and continues to the end of the parent chunk. If mmioDescend is unsuccessful in searching for a chunk, the current file position is undefined. If mmioDescend is successful, the current file position is changed. If the chunk is a \"RIFF\" or \"LIST\" chunk, the new file position will be just after the form type or list type (12 bytes from the beginning of the chunk). For other chunks, the new file position will be the start of the data portion of the chunk (8 bytes from the beginning of the chunk). The mmioDescend function fills the MMCKINFO structure pointed to by the lpck parameter with the following information: ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioDescend",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of an open RIFF file."
      },
      {
        "in_out": "",
        "type": "LPMMCKINFO",
        "name": "lpck",
        "description": "Pointer to a buffer that receives an MMCKINFO structure."
      },
      {
        "in_out": "",
        "type": "LPMMCKINFO",
        "name": "lpckParent",
        "description": "Pointer to an optional application-defined MMCKINFO structure identifying the parent of the chunk being searched for. If this parameter is not NULL, mmioDescend assumes the MMCKINFO structure it refers to was filled when mmioDescend was called to descend into the parent chunk, and mmioDescend searches for a chunk within the parent chunk. Set this parameter to NULL if no parent chunk is being specified."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Search flags. If no flags are specified, mmioDescend descends into the chunk beginning at the current file position. The following values are defined.   Value  Meaning  MMIO_FINDCHUNKSearches for a chunk with the specified chunk identifier. MMIO_FINDLISTSearches for a chunk with the chunk identifier \"LIST\" and with the specified form type. MMIO_FINDRIFFSearches for a chunk with the chunk identifier \"RIFF\" and with the specified form type."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Closing a file with the mmioClose function automatically flushes its buffer. If there is insufficient disk space to write the buffer, mmioFlush fails, even if the preceding calls of the mmioWrite function were successful. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioFlush",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of a file opened by using the mmioOpen function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "fuFlush",
        "description": "Flag determining how the flush is carried out. It can be zero or the following.                     Value                                    Description                  MMIO_EMPTYBUFEmpties the buffer after writing it to the disk."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "To directly access the I/O buffer of a file opened for buffered I/O, use the following members of the MMIOINFO structure filled by mmioGetInfo: After you read or write to the buffer and modify pchNext, do not call any multimedia file I/O functions except mmioAdvance until you call the mmioSetInfo function. Call mmioSetInfo when you are finished directly accessing the buffer. When you reach the end of the buffer specified by the pchEndRead or pchEndWrite member, call mmioAdvance to fill the buffer from the disk or write the buffer to the disk. The mmioAdvance function updates the pchNext, pchEndRead, and pchEndWrite members in the MMIOINFO structure for the file. Before calling mmioAdvance or mmioSetInfo to flush a buffer to disk, set the MMIO_DIRTY flag in the dwFlags member of the MMIOINFO structure for the file. Otherwise, the buffer will not be written to disk. Do not decrement pchNext or modify any members in the MMIOINFO structure other than pchNext and dwFlags. Do not set any flags in dwFlags except MMIO_DIRTY. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioGetInfo",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file."
      },
      {
        "in_out": "",
        "type": "LPMMIOINFO",
        "name": "lpmmioinfo",
        "description": "Pointer to a buffer that receives an MMIOINFO structure that mmioGetInfo fills with information about the file."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the address of the I/O procedure installed, removed, or located. Returns NULL if there is an error. ",
    "remarks": "",
    "return_type": "LPMMIOPROC",
    "category": "Windows Multimedia",
    "name": "mmioInstallIOProc",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "FOURCC",
        "name": "fccIOProc",
        "description": "Four-character code identifying the I/O procedure to install, remove, or locate. All characters in this code should be uppercase."
      },
      {
        "in_out": "",
        "type": "LPMMIOPROC",
        "name": "pIOProc",
        "description": "Pointer to the I/O procedure to install. To remove or locate an I/O procedure, set this parameter to NULL. For more information about the I/O procedure, see MMIOProc."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flag indicating whether the I/O procedure is being installed, removed, or located. The following values are defined.   Value  Meaning  MMIO_FINDPROCSearches for the specified I/O procedure. MMIO_GLOBALPROCThis flag is a modifier to the MMIO_INSTALLPROC flag and indicates the I/O procedure should be installed for global use. This flag is ignored if MMIO_FINDPROC or MMIO_REMOVEPROC is specified. MMIO_INSTALLPROCInstalls the specified I/O procedure. MMIO_REMOVEPROCRemoves the specified I/O procedure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns a handle of the opened file. If the file cannot be opened, the return value is NULL. If lpmmioinfo is not NULL, the wErrorRet member of the MMIOINFO structure will contain one of the following error values.  ",
    "remarks": "If lpmmioinfo points to an MMIOINFO structure, initialize the members of the structure as follows. All unused members must be set to zero, including reserved members. You must call mmioClose to close a file opened by using mmioOpen. Open files are not automatically closed when an application exits. ",
    "return_type": "HMMIO",
    "category": "Windows Multimedia",
    "name": "mmioOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "szFilename",
        "description": "Pointer to a buffer that contains the name of the file. If no I/O procedure is specified to open the file, the file name determines how the file is opened, as follows:  If the file name does not contain a plus sign (+), it is assumed to be the name of a standard file (that is, a file whose type is not HMMIO). If the file name is of the form EXAMPLE.EXT+ABC, the extension EXT is assumed to identify an installed I/O procedure which is called to perform I/O on the file. For more information, see mmioInstallIOProc. If the file name is NULL and no I/O procedure is given, the adwInfo member of the MMIOINFO structure is assumed to be the standard (non-HMMIO) file handle of a currently open file.  The file name should not be longer than 128 characters, including the terminating NULL character. When opening a memory file, set szFilename to NULL."
      },
      {
        "in_out": "",
        "type": "LPMMIOINFO",
        "name": "lpmmioinfo",
        "description": "Pointer to an MMIOINFO structure containing extra parameters used by mmioOpen. Unless you are opening a memory file, specifying the size of a buffer for buffered I/O, or specifying an uninstalled I/O procedure to open a file, this parameter should be NULL. If this parameter is not NULL, all unused members of the MMIOINFO structure it references must be set to zero, including the reserved members."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwOpenFlags",
        "description": "Flags for the open operation. ..."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "The return value depends on the message specified by uMsg. If the I/O procedure does not recognize a message, it should return zero. ",
    "remarks": "The four-character code specified by the fccMMIOProc member in the MMIOINFO structure associated with a file identifies a file name extension for a custom storage system. When an application calls mmioOpen with a file name such as \"one.xyz+two\", the I/O procedure associated with the four-character code \"XYZ\" is called to open the \"two\" element of the file \"one.xyz\". The mmioInstallIOProc function maintains a separate list of installed I/O procedures for each Windows-based application. Therefore, different applications can use the same I/O procedure identifier for different I/O procedures without conflict. However, installing an I/O procedure globally enables any process to use the procedure. If an application calls mmioInstallIOProc more than once to register the same I/O procedure, then it must call mmioInstallIOProc to remove the procedure once for each time it installed the procedure. mmioInstallIOProc will not prevent an application from installing two different I/O procedures with the same identifier, or installing an I/O procedure with one of the predefined identifiers (\"DOS \", \"MEM \"). The most recently installed procedure takes precedence, and the most recently installed procedure is the first one to be removed. When searching for a specified I/O procedure, local procedures are searched first, then global procedures. ",
    "return_type": "LRESULT",
    "category": "Windows Multimedia",
    "name": "MMIOProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "LPSTR",
        "name": "lpmmioinfo",
        "description": "Points to an MMIOINFO structure containing information about the open file. The I/O procedure must maintain the lDiskOffset member in this structure to indicate the file offset to the next read or write location. The I/O procedure can use the adwInfo[] member to store state information. The I/O procedure should not modify any other members of the MMIOINFO structure."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Specifies a message indicating the requested I/O operation. Messages that can be received include MMIOM_OPEN, MMIOM_CLOSE, MMIOM_READ, MMIOM_SEEK, MMIOM_WRITE, and MMIOM_WRITEFLUSH."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam1",
        "description": "Specifies an application-defined parameter for the message."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lParam2",
        "description": "Specifies an application-defined parameter for the message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of bytes actually read. If the end of the file has been reached and no more bytes can be read, the return value is 0. If there is an error reading from the file, the return value is \u00e2\u0080\u00931. ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Windows Multimedia",
    "name": "mmioRead",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file to be read."
      },
      {
        "in_out": "",
        "type": "HPSTR",
        "name": "pch",
        "description": "Pointer to a buffer to contain the data read from the file."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cch",
        "description": "Number of bytes to read from the file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if the file was renamed. Otherwise, returns an error code returned from mmioRename or from the I/O procedure. ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioRename",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szFilename",
        "description": "Pointer to a string containing the file name of the file to rename."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "szNewFilename",
        "description": "Pointer to a string containing the new file name."
      },
      {
        "in_out": "const",
        "type": "LPMMIOINFO",
        "name": "lpmmioinfo",
        "description": "Pointer to an MMIOINFO structure containing extra parameters used by mmioRename. If this parameter is not NULL, all unused members of the MMIOINFO structure it references must be set to zero, including the reserved members."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwRenameFlags",
        "description": "Flags for the rename operation. This parameter should be set to zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the new file position, in bytes, relative to the beginning of the file. If there is an error, the return value is \u00e2\u0080\u0093 1. ",
    "remarks": "Seeking to an invalid location in the file, such as past the end of the file, might not cause mmioSeek to return an error, but it might cause subsequent I/O operations on the file to fail. To locate the end of a file, call mmioSeek with lOffset set to zero and iOrigin set to SEEK_END. ",
    "return_type": "LONG",
    "category": "Windows Multimedia",
    "name": "mmioSeek",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file to seek in."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "lOffset",
        "description": "Offset to change the file position."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "iOrigin",
        "description": "Flags indicating how the offset specified by lOffset is interpreted. The following values are defined:  NameDescription  SEEK_CUR   Seeks to lOffset bytes from the current file position.   SEEK_END   Seeks to lOffset bytes from the end of the file.   SEEK_SET   Seeks to lOffset bytes from the beginning of the file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns a value that corresponds to the message. If the I/O procedure does not recognize the message, the return value should be zero. ",
    "remarks": "Use this function to send custom user-defined messages. Do not use it to send the MMIOM_OPEN, MMIOM_CLOSE, MMIOM_READ, MMIOM_WRITE, MMIOM_WRITEFLUSH, or MMIOM_SEEK messages. Define custom messages to be greater than or equal to the MMIOM_USER constant. ",
    "return_type": "LRESULT",
    "category": "Windows Multimedia",
    "name": "mmioSendMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle for a file opened by using the mmioOpen function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wMsg",
        "description": "Message to send to the I/O procedure."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam1",
        "description": "Parameter for the message."
      },
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam2",
        "description": "Parameter for the message."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. If an error occurs, the file handle remains valid. The following values are defined.  ",
    "remarks": "To enable buffering using an internal buffer, set pchBuffer to NULL and cchBuffer to the desired buffer size. To supply your own buffer, set pchBuffer to point to the buffer, and set cchBuffer to the size of the buffer. To disable buffered I/O, set pchBuffer to NULL and cchBuffer to zero. If buffered I/O is already enabled using an internal buffer, you can reallocate the buffer to a different size by setting pchBuffer to NULL and cchBuffer to the new buffer size. The contents of the buffer can be changed after resizing. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioSetBuffer",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file."
      },
      {
        "in_out": "",
        "type": "LPSTR",
        "name": "pchBuffer",
        "description": "Pointer to an application-defined buffer to use for buffered I/O. If this parameter is NULL, mmioSetBuffer allocates an internal buffer for buffered I/O."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cchBuffer",
        "description": "Size, in characters, of the application-defined buffer, or the size of the buffer for mmioSetBuffer to allocate."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if successful or an error otherwise. ",
    "remarks": "If you have written to the file I/O buffer, set the MMIO_DIRTY flag in the dwFlags member of the MMIOINFO structure before calling mmioSetInfo to terminate direct buffer access. Otherwise, the buffer will not get flushed to disk. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "mmioSetInfo",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file."
      },
      {
        "in_out": "",
        "type": "LPMMIOINFO",
        "name": "lpmmioinfo",
        "description": "Pointer to an MMIOINFO structure filled with information by the mmioGetInfo function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Reserved; must be zero."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the four-character code created from the given string. ",
    "remarks": "This function copies the string to a four-character code and pads it with space characters or truncates it if necessary. It does not check whether the code it returns is valid. ",
    "return_type": "FOURCC",
    "category": "Windows Multimedia",
    "name": "mmioStringToFOURCC",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "sz",
        "description": "Pointer to a null-terminated string to convert to a four-character code."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "wFlags",
        "description": "Flags for the conversion. The following value is defined:   Value  Meaning  MMIO_TOUPPERConverts all characters to uppercase."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of bytes actually written. If there is an error writing to the file, the return value is -1. ",
    "remarks": "The current file position is incremented by the number of bytes written. ",
    "return_type": "LONG",
    "category": "Windows Multimedia",
    "name": "mmioWrite",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HMMIO",
        "name": "hmmio",
        "description": "File handle of the file."
      },
      {
        "in_out": "char",
        "type": "_huge*",
        "name": "pch",
        "description": "Pointer to the buffer to be written to the file."
      },
      {
        "in_out": "",
        "type": "LONG",
        "name": "cch",
        "description": "Number of bytes to write to the file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "",
    "remarks": "The original purpose of this function was to test whether the Windows Multimedia Extensions software was present on computers with Windows 3.1 installed. ",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "mmsystemGetVersion",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "",
    "min_server": "",
    "header": "Mmddk.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Windows Multimedia",
    "name": "mmTaskBlock",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "h",
        "description": "Reserved."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "",
    "min_server": "",
    "header": "Mmddk.h",
    "return_value": "",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "mmTaskCreate",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPTASKCALLBACK",
        "name": "lpfn",
        "description": "Reserved."
      },
      {
        "in_out": "HANDLE",
        "type": "FAR*",
        "name": "lph",
        "description": "Reserved."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInst",
        "description": "Reserved."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "",
    "min_server": "",
    "header": "Mmddk.h",
    "return_value": "",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "mmTaskSignal",
    "is_callback": 0,
    "dll": "Mmtasksignal.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "DWORD",
        "name": "h",
        "description": "Reserved."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "",
    "min_server": "",
    "header": "Mmddk.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "void",
    "category": "Windows Multimedia",
    "name": "mmTaskYield",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": ""
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns zero if processing should continue or a nonzero value if it should end. ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Windows Multimedia",
    "name": "MyStatusProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Constant specified with the status callback address."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "Message",
        "description": "Status flag. It can be one of the following values.   Value  Meaning  ICSTATUS_ENDA lengthy operation is finishing. ICSTATUS_STARTA lengthy operation is starting. ICSTATUS_STATUSOperation is proceeding, and is lParam percent done. ICSTATUS_YIELDA lengthy operation is proceeding. This value has the same meaning as ICSTATUS_STATUS but does not indicate a value for percentage done."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "The sound specified by pszSound must fit into available physical memory and be playable by an installed waveform-audio device driver. PlaySound searches the following directories for sound files: the current directory; the Windows directory; the Windows system directory; directories listed in the PATH environment variable; and the list of directories mapped in a network. If the function cannot find the specified sound and the SND_NODEFAULT flag is not specified, PlaySound uses the default system event sound instead. If the function can find neither the system default entry nor the default sound, it makes no sound and returns FALSE. If the SND_ALIAS_ID flag is specified in fdwSound, the pszSound parameter must be one of the following values.  The SND_ASYNC flag causes PlaySound to return immediately without waiting for the sound to finish playing. If you combine the SND_MEMORY and SND_ASYNC flags, the memory buffer that contains the sound must remain valid until the sound has completed playing. The following example plays a sound file: The following example plays a sound-file resource: The following example plays a system-event sound: The following example is equivalent to the previous example, but uses an identifier for the system event: The following example plays the sound for an application-specific alias in the registry: The following example stops playback of a sound that is playing asynchronously: ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "PlaySound",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "pszSound",
        "description": "A string that specifies the sound to play. The maximum length, including the null terminator, is 256 characters. If this parameter is NULL, any currently playing waveform sound is stopped. To stop a non-waveform sound, specify SND_PURGE in the fdwSound parameter. Three flags in fdwSound (SND_ALIAS, SND_FILENAME, and SND_RESOURCE) determine whether the name is interpreted as an alias for a system event, a file name, or a resource identifier. If none of these flags are specified, PlaySound searches the registry or the WIN.INI file for an association with the specified sound name. If an association is found, the sound event is played. If no association is found in the registry, the name is interpreted as a file name."
      },
      {
        "in_out": "",
        "type": "HMODULE",
        "name": "hmod",
        "description": "Handle to the executable file that contains the resource to be loaded. This parameter must be NULL unless SND_RESOURCE is specified in fdwSound."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwSound",
        "description": "Flags for playing the sound. The following values are defined.   Value  Meaning  SND_APPLICATIONThe pszSound parameter is an application-specific alias in the registry. You can combine this flag with the SND_ALIAS or SND_ALIAS_ID flag to specify an application-defined sound alias. SND_ALIASThe pszSound parameter is a system-event alias in the registry or the WIN.INI file. Do not use with either SND_FILENAME or SND_RESOURCE. SND_ALIAS_IDThe pszSound parameter is a predefined identifier for a system-event alias. See Remarks. SND_ASYNCThe sound is played asynchronously and PlaySound returns immediately after beginning the sound. To terminate an asynchronously played waveform sound, call PlaySound with pszSound set to NULL. SND_FILENAMEThe pszSound parameter is a file name. If the file cannot be found, the function plays the default sound unless the SND_NODEFAULT flag is set. SND_LOOPThe sound plays repeatedly until PlaySound is called again with the pszSound parameter set to NULL. If this flag is set, you must also set the SND_ASYNC flag. SND_MEMORYThe pszSound parameter points to a sound loaded in memory.For more information, see Playing WAVE Resources.  SND_NODEFAULTNo default sound event is used. If the sound cannot be found, PlaySound returns silently without playing the default sound. SND_NOSTOP The specified sound event will yield to another sound event that is already playing in the same process. If a sound cannot be played because the resource needed to generate that sound is busy playing another sound, the function immediately returns FALSE without playing the requested sound. If this flag is not specified, PlaySound attempts to stop any sound that is currently playing in the same process. Sounds played in other processes are not affected.  SND_NOWAIT Not supported. Note  Previous versions of the documentation implied incorrectly that this flag is supported. The function ignores this flag.    SND_PURGENot supported. SND_RESOURCEThe pszSound parameter is a resource identifier; hmod must identify the instance that contains the resource.For more information, see Playing WAVE Resources.  SND_SENTRY Note  Requires Windows Vista or later.   If this flag is set, the function triggers a SoundSentry event when the sound is played. SoundSentry is an accessibility feature that causes the computer to display a visual cue when a sound is played. If the user did not enable SoundSentry, the visual cue is not displayed.  SND_SYNCThe sound is played synchronously, and PlaySound returns after the sound event completes. This is the default behavior. SND_SYSTEM Note  Requires Windows Vista or later.   If this flag is set, the sound is assigned to the audio session for system notification sounds. The system volume-control program (SndVol) displays a volume slider that controls system notification sounds. Setting this flag puts the sound under the control of that volume slider If this flag is not set, the sound is assigned to the default audio session for the application's process. For more information, see the documentation for the Core Audio APIs."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Opens the specified sound event.",
    "library": "Winmmbse.lib",
    "min_server": "Windows Server 2012 R2 [desktop apps only]",
    "header": "Mmiscapi.h",
    "return_value": "If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "",
    "return_type": "HRESULT",
    "category": "Windows Multimedia",
    "name": "sndOpenSound",
    "is_callback": 0,
    "dll": "Winmmbse.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCWSTR",
        "name": "EventName",
        "description": "The name of the sound event."
      },
      {
        "in_out": "",
        "type": "LPCWSTR",
        "name": "AppName",
        "description": "The application associated with the sound event."
      },
      {
        "in_out": "",
        "type": "INT32",
        "name": "Flags",
        "description": "Flags for playing the sound. The following values are defined."
      },
      {
        "in_out": "",
        "type": "PHANDLE",
        "name": "FileHandle",
        "description": "Receives the handle to the sound."
      }
    ],
    "min_client": "Windows 8.1 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns TRUE if successful or FALSE otherwise. ",
    "remarks": "If the specified sound cannot be found, sndPlaySound plays the system default sound. If there is no system default entry in the registry or WIN.INI file, or if the default sound cannot be found, the function makes no sound and returns FALSE. The specified sound must fit in available physical memory and be playable by an installed waveform-audio device driver. If sndPlaySound does not find the sound in the current directory, the function searches for it using the standard directory-search order. ",
    "return_type": "BOOL",
    "category": "Windows Multimedia",
    "name": "sndPlaySound",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "lpszSound",
        "description": "A string that specifies the sound to play. This parameter can be either an entry in the registry or in WIN.INI that identifies a system sound, or it can be the name of a waveform-audio file. (If the function does not find the entry, the parameter is treated as a file name.) If this parameter is NULL, any currently playing sound is stopped."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "fuSound",
        "description": "Flags for playing the sound. The following values are defined.   Value  Meaning  SND_ASYNCThe sound is played asynchronously and the function returns immediately after beginning the sound. To terminate an asynchronously played sound, call sndPlaySound with lpszSound set to NULL. SND_LOOPThe sound plays repeatedly until sndPlaySound is called again with the lpszSound parameter set to NULL. You must also specify the SND_ASYNC flag to loop sounds. SND_MEMORYThe parameter specified by lpszSound points to an image of a waveform sound in memory. The data passed must be trusted by the application. SND_NODEFAULTIf the sound cannot be found, the function returns silently without playing the default sound. SND_NOSTOPIf a sound is currently playing in the same process, the function immediately returns FALSE, without playing the requested sound. SND_SENTRY Note  Requires Windows Vista or later.   If this flag is set, the function triggers a SoundSentry event when the sound is played. For more information, see PlaySound. SND_SYNCThe sound is played synchronously and the function does not return until the sound ends. SND_SYSTEM Note  Requires Windows Vista or later.   If this flag is set, the sound is assigned to the audio session for system notification sounds. For more information, see PlaySound."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "",
    "library": "Vfw32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Vfw.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The size of the destination buffer must be large enough to accommodate any alignment bytes at the end of each pixel row. This function does nothing if biSrc and biDst have different values for biBitCount or if the value for biSrc.  biBitCount does not equal 8, 16, or 24. This function performs no dithering or other smoothing. Pixel values are merely dropped or duplicated on a line-by-line, column-by-column basis. This function does not do any special processing based on pixel encoding except for calculating the number of bits per pixel. In particular this function will not generate correct results when pixels are encoded in groups of more than 1 pixel, as in the case of a YUV format where U and V are decimated and so are not represented equally in each pixel. Before including Vfw.h, you must add the following line to your code: ",
    "return_type": "VOID FAR PASCAL",
    "category": "Windows Multimedia",
    "name": "StretchDIB",
    "is_callback": 0,
    "dll": "Msvfw32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "biDst",
        "description": "Pointer to a BITMAPINFOHEADER structure that describes the destination bitmap."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpvDst",
        "description": "Pointer to the memory buffer that will receive the copied pixel bits."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "DstX",
        "description": "X coordinate of the destination rectangle's origin."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "DstY",
        "description": "Y coordinate of the destination rectangle's origin."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "DstXE",
        "description": "Width, in pixels, of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "DstYE",
        "description": "Height, in pixels, of the destination rectangle."
      },
      {
        "in_out": "",
        "type": "LPBITMAPINFOHEADER",
        "name": "biSrc",
        "description": "Pointer to a BITMAPINFOHEADER structure that describes the source bitmap."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "lpvSrc",
        "description": "Pointer to the source bitmap data."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "SrcX",
        "description": "X coordinate of the source rectangle's origin."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "SrcY",
        "description": "Y coordinate of the source rectangle's origin."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "SrcXE",
        "description": "Width, in pixels, of the source rectangle."
      },
      {
        "in_out": "",
        "type": "int",
        "name": "SrcYE",
        "description": "Height, in pixels, of the source rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns TIMERR_NOERROR if successful or TIMERR_NOCANDO if the resolution specified in uPeriod is out of range. ",
    "remarks": "Call this function immediately before using timer services, and call the timeEndPeriod function immediately after you are finished using the timer services. You must match each call to timeBeginPeriod with a call to timeEndPeriod, specifying the same minimum resolution in both calls. An application can make multiple timeBeginPeriod calls as long as each call is matched with a call to timeEndPeriod. This function affects a global Windows setting. Windows uses the lowest value (that is, highest resolution) requested by any process. Setting a higher resolution can improve the accuracy of time-out intervals in wait functions. However, it can also reduce overall system performance, because the thread scheduler switches tasks more often. High resolutions can also prevent the CPU power management system from entering power-saving modes. Setting a higher resolution does not improve the accuracy of the high-resolution performance counter. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "timeBeginPeriod",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uPeriod",
        "description": "Minimum timer resolution, in milliseconds, for the application or device driver. A lower value specifies a higher (more accurate) resolution."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns TIMERR_NOERROR if successful or TIMERR_NOCANDO if the resolution specified in uPeriod is out of range. ",
    "remarks": "Call this function immediately after you are finished using timer services. You must match each call to timeBeginPeriod with a call to timeEndPeriod, specifying the same minimum resolution in both calls. An application can make multiple timeBeginPeriod calls as long as each call is matched with a call to timeEndPeriod. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "timeEndPeriod",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uPeriod",
        "description": "Minimum timer resolution specified in the previous call to the timeBeginPeriod function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The timeGetDevCaps function queries the timer device to determine its resolution.",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error code otherwise. Possible error codes include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "timeGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPTIMECAPS",
        "name": "ptc",
        "description": "A pointer to a TIMECAPS structure. This structure is filled with information about the resolution of the timer device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbtc",
        "description": "The size, in bytes, of the TIMECAPS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "If successful, returns TIMERR_NOERROR. Otherwise, returns an error code. ",
    "remarks": "The system time is returned in the ms member of the MMTIME structure. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "timeGetSystemTime",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPMMTIME",
        "name": "pmmt",
        "description": "Pointer to an MMTIME structure."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbmmt",
        "description": "Size, in bytes, of the MMTIME structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns the system time, in milliseconds. ",
    "remarks": "The only difference between this function and the timeGetSystemTime function is that timeGetSystemTime uses the MMTIME structure to return the system time. The timeGetTime function has less overhead than timeGetSystemTime. Note that the value returned by the timeGetTime function is a DWORD value. The return value wraps around to 0 every 2^32 milliseconds, which is about 49.71 days. This can cause problems in code that directly uses the timeGetTime return value in computations, particularly where the value is used to control code execution. You should always use the difference between two timeGetTime return values in computations. The default precision of the timeGetTime function can be five milliseconds or more, depending on the machine. You can use the timeBeginPeriod and timeEndPeriod functions to increase the precision of timeGetTime. If you do so, the minimum difference between successive values returned by timeGetTime can be as large as the minimum period value set using timeBeginPeriod and timeEndPeriod. Use the QueryPerformanceCounter and QueryPerformanceFrequency functions to measure short time intervals at a high resolution. ",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "timeGetTime",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns TIMERR_NOERROR if successful or MMSYSERR_INVALPARAM if the specified timer event does not exist. ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "timeKillEvent",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uTimerID",
        "description": "Identifier of the timer event to cancel. This identifier was returned by the timeSetEvent function when the timer event was set up."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Applications should not call any system-defined functions from inside a callback function, except for PostMessage, timeGetSystemTime, timeGetTime, timeSetEvent, timeKillEvent, midiOutShortMsg, midiOutLongMsg, and OutputDebugString. ",
    "return_type": "void CALLBACK",
    "category": "Windows Multimedia",
    "name": "TimeProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uID",
        "description": "Identifier of the timer event. This identifier was returned by the timeSetEvent function when the timer event was set up."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Reserved; do not use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwUser",
        "description": "User instance data supplied to the dwUser parameter of timeSetEvent."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dw1",
        "description": "Reserved; do not use."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dw2",
        "description": "Reserved; do not use."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "TimeAPI.h (include Windows.h);  Mmsystem.h on Windows Server 2008 R2, Windows 7, Windows 7, Windows Server 2008 and Windows Vista (include Windows.h)",
    "return_value": "Returns an identifier for the timer event if successful or an error otherwise. This function returns NULL if it fails and the timer event was not created. (This identifier is also passed to the callback function.) ",
    "remarks": "Each call to timeSetEvent for periodic timer events requires a corresponding call to the timeKillEvent function. Creating an event with the TIME_KILL_SYNCHRONOUS and the TIME_CALLBACK_FUNCTION flag prevents the event from occurring after the timeKillEvent function is called. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "timeSetEvent",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDelay",
        "description": "Event delay, in milliseconds. If this value is not in the range of the minimum and maximum event delays supported by the timer, the function returns an error."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uResolution",
        "description": "Resolution of the timer event, in milliseconds. The resolution increases with smaller values; a resolution of 0 indicates periodic events should occur with the greatest possible accuracy. To reduce system overhead, however, you should use the maximum value appropriate for your application."
      },
      {
        "in_out": "",
        "type": "LPTIMECALLBACK",
        "name": "lpTimeProc",
        "description": "Pointer to a callback function that is called once upon expiration of a single event or periodically upon expiration of periodic events.  If fuEvent specifies the TIME_CALLBACK_EVENT_SET or TIME_CALLBACK_EVENT_PULSE flag, then the lpTimeProc parameter is interpreted as a handle to an event object. The event will be set or pulsed upon completion of a single event or periodically upon completion of periodic events.  For any other value of fuEvent, the lpTimeProc parameter is a pointer to a callback function of type LPTIMECALLBACK."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwUser",
        "description": "User-supplied callback data."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "fuEvent",
        "description": "Timer event type. This parameter may include one of the following values.   Value  Meaning  TIME_ONESHOTEvent occurs once, after uDelay milliseconds. TIME_PERIODICEvent occurs every uDelay milliseconds.    The fuEvent parameter may also include one of the following values.   Value  Meaning  TIME_CALLBACK_FUNCTIONWhen the timer expires, Windows calls the function pointed to by the lpTimeProc parameter. This is the default. TIME_CALLBACK_EVENT_SETWhen the timer expires, Windows calls the SetEvent function to set the event pointed to by the lpTimeProc parameter. The dwUser parameter is ignored. TIME_CALLBACK_EVENT_PULSEWhen the timer expires, Windows calls the PulseEvent function to pulse the event pointed to by the lpTimeProc parameter. The dwUser parameter is ignored. TIME_KILL_SYNCHRONOUSPassing this flag prevents an event from occurring after the timeKillEvent function is called."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "When the buffer is filled, the WHDR_DONE bit is set in the dwFlags member of the WAVEHDR structure. The buffer must be prepared with the waveInPrepareHeader function before it is passed to this function. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInAddBuffer",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "pwh",
        "description": "Pointer to a WAVEHDR structure that identifies the buffer."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwh",
        "description": "Size, in bytes, of the WAVEHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If there are input buffers that have been sent with the waveInAddBuffer function and that haven't been returned to the application, the close operation will fail. Call the waveInReset function to mark all pending buffers as done. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device. If the function succeeds, the handle is no longer valid after this call."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Use this function to determine the number of waveform-audio input devices present in the system. If the value specified by the uDeviceID parameter is a device identifier, it can vary from zero to one less than the number of devices present. The WAVE_MAPPER constant can also be used as a device identifier. Only cbwic bytes (or less) of information is copied to the location pointed to by pwic. If cbwic is zero, nothing is copied and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uDeviceID",
        "description": "Identifier of the waveform-audio output device. It can be either a device identifier or a handle of an open waveform-audio input device."
      },
      {
        "in_out": "",
        "type": "LPWAVEINCAPS",
        "name": "pwic",
        "description": "Pointer to a WAVEINCAPS structure to be filled with information about the capabilities of the device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwic",
        "description": "Size, in bytes, of the WAVEINCAPS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is always null-terminated. If cchText is zero, nothing is copied and the function returns zero. All error descriptions are less than MAXERRORLENGTH characters long. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInGetErrorText",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MMRESULT",
        "name": "mmrError",
        "description": "Error number."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "pszText",
        "description": "Pointer to the buffer to be filled with the textual error description."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cchText",
        "description": "Size, in characters, of the buffer pointed to by pszText."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInGetID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      },
      {
        "in_out": "",
        "type": "LPUINT",
        "name": "puDeviceID",
        "description": "Pointer to a variable to be filled with the device identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of devices. A return value of zero means that no devices are present or that an error occurred. ",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "waveInGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[waveInGetPosition is no longer supported for use as of Windows Vista. Instead, use IAudioClock::GetPosition.]",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before calling this function, set the wType member of the MMTIME structure to indicate the time format you want. After calling this function, check wType to determine whether the desired time format is supported. If the format is not supported, the member will specify an alternative format. The position is set to zero when the device is opened or reset. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInGetPosition",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      },
      {
        "in_out": "",
        "type": "LPMMTIME",
        "name": "pmmt",
        "description": "Pointer to an MMTIME structure."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbmmt",
        "description": "Size, in bytes, of the MMTIME structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the value returned from the driver. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "waveInMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "deviceID",
        "description": "Identifier of the waveform device that receives the message. You must cast the device ID to the HWAVEIN handle type. If you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The waveInOpen function opens the given waveform-audio input device for recording.",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Use the waveInGetNumDevs function to determine the number of waveform-audio input devices present on the system. The device identifier specified by uDeviceID varies from zero to one less than the number of devices present. The WAVE_MAPPER constant can also be used as a device identifier. If you choose to have a window or thread receive callback information, the following messages are sent to the window procedure or thread to indicate the progress of waveform-audio input: MM_WIM_OPEN, MM_WIM_CLOSE, and MM_WIM_DATA. If you choose to have a function receive callback information, the following messages are sent to the function to indicate the progress of waveform-audio input: WIM_OPEN, WIM_CLOSE, and WIM_DATA. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHWAVEIN",
        "name": "phwi",
        "description": "Pointer to a buffer that receives a handle identifying the open waveform-audio input device. Use this handle to identify the device when calling other waveform-audio input functions. This parameter can be NULL if WAVE_FORMAT_QUERY is specified for fdwOpen."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uDeviceID",
        "description": "Identifier of the waveform-audio input device to open. It can be either a device identifier or a handle of an open waveform-audio input device. You can use the following flag instead of a device identifier.   Value  Meaning  WAVE_MAPPERThe function selects a waveform-audio input device capable of recording in the specified format."
      },
      {
        "in_out": "",
        "type": "LPCWAVEFORMATEX",
        "name": "pwfx",
        "description": "Pointer to a WAVEFORMATEX structure that identifies the desired format for recording waveform-audio data. You can free this structure immediately after waveInOpen returns."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Pointer to a fixed callback function, an event handle, a handle to a window, or the identifier of a thread to be called during waveform-audio recording to process messages related to the progress of recording. If no callback function is required, this value can be zero. For more information on the callback function, see waveInProc."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallbackInstance",
        "description": "User-instance data passed to the callback mechanism. This parameter is not used with the window callback mechanism."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwOpen",
        "description": "Flags for opening the device. The following values are defined.                Value  Meaning  CALLBACK_EVENTThe dwCallback parameter is an event handle. CALLBACK_FUNCTIONThe dwCallback parameter is a callback procedure address. CALLBACK_NULLNo callback mechanism. This is the default setting. CALLBACK_THREADThe dwCallback parameter is a thread identifier. CALLBACK_WINDOWThe dwCallback parameter is a window handle. WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE If this flag is specified and the  uDeviceID parameter is WAVE_MAPPER, the function opens the default communication device.  This flag applies only when uDeviceID equals WAVE_MAPPER. Note  Requires Windows 7    WAVE_FORMAT_DIRECTIf this flag is specified, the ACM driver does not perform conversions on the audio data. WAVE_FORMAT_QUERYThe function queries the device to determine whether it supports the given format, but it does not open the device. WAVE_MAPPEDThe uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The lpData, dwBufferLength, and dwFlags members of the WAVEHDR structure must be set before calling this function (dwFlags must be zero). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInPrepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "pwh",
        "description": "Pointer to a WAVEHDR structure that identifies the buffer to be prepared."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwh",
        "description": "Size, in bytes, of the WAVEHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "Applications should not call any system-defined functions from inside a callback function, except for EnterCriticalSection, LeaveCriticalSection, midiOutLongMsg, midiOutShortMsg, OutputDebugString, PostMessage, PostThreadMessage, SetEvent, timeGetSystemTime, timeGetTime, timeKillEvent, and timeSetEvent. Calling other wave functions will cause deadlock. ",
    "return_type": "void CALLBACK",
    "category": "Windows Multimedia",
    "name": "waveInProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio device associated with the callback function."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Waveform-audio input message. It can be one of the following messages.   Value  Meaning   WIM_CLOSE Sent when the device is closed using the waveInClose function.  WIM_DATA Sent when the device driver is finished with a data block sent using the waveInAddBuffer function.  WIM_OPEN Sent when the device is opened using the waveInOpen function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "User instance data specified with waveInOpen."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInReset",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Buffers are returned to the application when full or when the waveInReset function is called (the dwBytesRecorded member in the header will contain the length of data). If there are no buffers in the queue, the data is thrown away without notifying the application, and input continues. Calling this function when input is already started has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInStart",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If there are any buffers in the queue, the current buffer will be marked as done (the dwBytesRecorded member in the header will contain the length of data), but any empty buffers in the queue will remain there. Calling this function when input is not started has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInStop",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function complements the waveInPrepareHeader function. You must call this function before freeing the buffer. After passing a buffer to the device driver with the waveInAddBuffer function, you must wait until the driver is finished with the buffer before calling waveInUnprepareHeader. Unpreparing a buffer that has not been prepared has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveInUnprepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEIN",
        "name": "hwi",
        "description": "Handle to the waveform-audio input device."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "pwh",
        "description": "Pointer to a WAVEHDR structure identifying the buffer to be cleaned up."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwh",
        "description": "Size, in bytes, of the WAVEHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The blocks making up the loop are played to the end before the loop is terminated. Calling this function when nothing is playing or looping has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutBreakLoop",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "The close operation fails if the device is still playing a waveform-audio buffer that was previously sent by calling waveOutWrite. Before calling waveOutClose, the application must wait for all buffers to finish playing or call the waveOutReset function to terminate playback. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutClose",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device. If the function succeeds, the handle is no longer valid after this call."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Use the waveOutGetNumDevs function to determine the number of waveform-audio output devices present in the system. If the value specified by the uDeviceID parameter is a device identifier, it can vary from zero to one less than the number of devices present. The WAVE_MAPPER constant can also be used as a device identifier. Only cbwoc bytes (or less) of information is copied to the location pointed to by pwoc. If cbwoc is zero, nothing is copied and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetDevCaps",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uDeviceID",
        "description": "Identifier of the waveform-audio output device. It can be either a device identifier or a handle of an open waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPWAVEOUTCAPS",
        "name": "pwoc",
        "description": "Pointer to a WAVEOUTCAPS structure to be filled with information about the capabilities of the device."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwoc",
        "description": "Size, in bytes, of the WAVEOUTCAPS structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is always null-terminated. If cchText is zero, nothing is copied and the function returns zero. All error descriptions are less than MAXERRORLENGTH characters long. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetErrorText",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "MMRESULT",
        "name": "mmrError",
        "description": "Error number."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "pszText",
        "description": "Pointer to a buffer to be filled with the textual error description."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cchText",
        "description": "Size, in characters, of the buffer pointed to by pszText."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetID",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPUINT",
        "name": "puDeviceID",
        "description": "Pointer to a variable to be filled with the device identifier."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the number of devices. A return value of zero means that no devices are present or that an error occurred. ",
    "remarks": "",
    "return_type": "UINT",
    "category": "Windows Multimedia",
    "name": "waveOutGetNumDevs",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Changing the pitch does not change the playback rate, sample rate, or playback time. Not all devices support pitch changes. To determine whether the device supports pitch control, use the WAVECAPS_PITCH flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetPitch",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "pdwPitch",
        "description": "Pointer to a variable to be filled with the current pitch multiplier setting. The pitch multiplier indicates the current change in pitch from the original authored setting. The pitch multiplier must be a positive value. The pitch multiplier is specified as a fixed-point value. The high-order word of the variable contains the signed integer part of the number, and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and 0x4000 represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no pitch change), and a value of 0x000F8000 specifies a multiplier of 15.5."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Changing the playback rate does not change the sample rate but does change the playback time. Not all devices support playback rate changes. To determine whether a device supports playback rate changes, use the WAVECAPS_PLAYBACKRATE flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetPlaybackRate",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "pdwRate",
        "description": "Pointer to a variable to be filled with the current playback rate. The playback rate setting is a multiplier indicating the current change in playback rate from the original authored setting. The playback rate multiplier must be a positive value. The rate is specified as a fixed-point value. The high-order word of the variable contains the signed integer part of the number, and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and 0x4000 represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no playback rate change), and a value of 0x000F8000 specifies a multiplier of 15.5."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Before calling this function, set the wType member of the MMTIME structure to indicate the time format you want. After calling this function, check wType to determine whether the time format is supported. If the format is not supported, wType will specify an alternative format. The position is set to zero when the device is opened or reset. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetPosition",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPMMTIME",
        "name": "pmmt",
        "description": "Pointer to an MMTIME structure."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbmmt",
        "description": "Size, in bytes, of the MMTIME structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If a device identifier is used, then the result of the waveOutGetVolume call and the information returned in pdwVolume applies to all instances of the device. If a device handle is used, then the result and information returned applies only to the instance of the device referenced by the device handle. Not all devices support volume changes. To determine whether the device supports volume control, use the WAVECAPS_VOLUME flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). To determine whether the device supports left- and right-channel volume control, use the WAVECAPS_LRVOLUME flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by waveOutGetDevCaps). Volume settings are interpreted logarithmically. This means the perceived increase in volume is the same when increasing the volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutGetVolume",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to an open waveform-audio output device. This parameter can also be a device identifier."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "pdwVolume",
        "description": "Pointer to a variable to be filled with the current volume setting. The low-order word of this location contains the left-channel volume setting, and the high-order word contains the right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence. If a device does not support both left and right volume control, the low-order word of the specified location contains the mono volume level. The full 16-bit setting(s) set with the waveOutSetVolume function is returned, regardless of whether the device supports the full 16 bits of volume-level control."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns the value returned from the driver. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Windows Multimedia",
    "name": "waveOutMessage",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "deviceID",
        "description": "Identifier of the waveform device that receives the message. You must cast the device ID to the HWAVEOUT handle type. If you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Message to send."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Use the waveOutGetNumDevs function to determine the number of waveform-audio output devices present in the system. If the value specified by the uDeviceID parameter is a device identifier, it can vary from zero to one less than the number of devices present. The WAVE_MAPPER constant can also be used as a device identifier. The structure pointed to by pwfx can be extended to include type-specific information for certain data formats. For example, for PCM data, an extra UINT is added to specify the number of bits per sample. Use the PCMWAVEFORMAT structure in this case. For all other waveform-audio formats, use the WAVEFORMATEX structure to specify the length of the additional data. If you choose to have a window or thread receive callback information, the following messages are sent to the window procedure function to indicate the progress of waveform-audio output: MM_WOM_OPEN, MM_WOM_CLOSE, and MM_WOM_DONE. The dwCallback and fdwOpen parameters specify how the application is notified about  the progress of waveform-audio output. If fdwOpen contains the CALLBACK_FUNCTION flag, dwCallback is a pointer to a callback function. For the function signature, see waveOutProc. The uMsg parameter of the callback indicates the progress of the audio output: If fdwOpen contains the CALLBACK_WINDOW flag, dwCallback is a handle to a window.The window receives the following messages, indicating the progress: If fdwOpen contains the CALLBACK_THREAD flag, dwCallback is a thread identifier. The thread receives the messages listed previously for CALLBACK_WINDOW. If fdwOpen contains the CALLBACK_EVENT flag, dwCallback is a handle to an event. The event is signaled whenever the state of the waveform buffer changes. The application can use WaitForSingleObject or WaitForMultipleObjects to wait for the event. When the event is signaled, you can get the current state of the waveform buffer by checking the dwFlags member of the WAVEHDR structure. (See waveOutPrepareHeader.) If fdwOpen contains the CALLBACK_NULL flag, dwCallback must be NULL. In that case, no callback mechanism is used. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutOpen",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPHWAVEOUT",
        "name": "phwo",
        "description": "Pointer to a buffer that receives a handle identifying the open waveform-audio output device. Use the handle to identify the device when calling other waveform-audio output functions. This parameter might be NULL if the WAVE_FORMAT_QUERY flag is specified for fdwOpen."
      },
      {
        "in_out": "",
        "type": "UINT_PTR",
        "name": "uDeviceID",
        "description": "Identifier of the waveform-audio output device to open. It can be either a device identifier or a handle of an open waveform-audio input device. You can also use the following flag instead of a device identifier:   Value  Meaning  WAVE_MAPPERThe function selects a waveform-audio output device capable of playing the given format."
      },
      {
        "in_out": "",
        "type": "LPWAVEFORMATEX",
        "name": "pwfx",
        "description": "Pointer to a WAVEFORMATEX structure that identifies the format of the waveform-audio data to be sent to the device. You can free this structure immediately after passing it to waveOutOpen."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallback",
        "description": "Specifies the callback mechanism. The value must be one of the following:  A pointer to a callback function. For the function signature, see waveOutProc. A handle to a window. A thread identifier. A handle to an event. The value NULL.  The fdwOpen parameter specifies how the dwCallback parameter is interpreted. For more information, see Remarks."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwCallbackInstance",
        "description": "User-instance data passed to the callback mechanism. This parameter is not used with the window callback mechanism."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "fdwOpen",
        "description": "Flags for opening the device. The following values are defined.   Value  Meaning  CALLBACK_EVENTThe dwCallback parameter is an event handle. CALLBACK_FUNCTIONThe dwCallback parameter is a callback procedure address. CALLBACK_NULLNo callback mechanism. This is the default setting. CALLBACK_THREADThe dwCallback parameter is a thread identifier. CALLBACK_WINDOWThe dwCallback parameter is a window handle. WAVE_ALLOWSYNCIf this flag is specified, a synchronous waveform-audio device can be opened. If this flag is not specified while opening a synchronous driver, the device will fail to open. WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE If this flag is specified and the  uDeviceID parameter is WAVE_MAPPER, the function opens the default communication device.  This flag applies only when uDeviceID equals WAVE_MAPPER. Note  Requires Windows 7    WAVE_FORMAT_DIRECTIf this flag is specified, the ACM driver does not perform conversions on the audio data. WAVE_FORMAT_QUERYIf this flag is specified, waveOutOpen queries the device to determine if it supports the given format, but the device is not actually opened. WAVE_MAPPEDIf this flag is specified, the uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Calling this function when the output is already paused has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutPause",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Set the lpData, dwBufferLength, and dwFlags members of the WAVEHDR structure before calling this function. Set the dwFlags member to zero. The dwFlags, dwBufferLength, and dwLoops members of the WAVEHDR structure can change between calls to this function and the waveOutWrite function. If you change the size specified by dwBufferLength before the call to waveOutWrite, the new value must be less than the prepared value. If the method succeeds, the WHDR_PREPARED flag is set in the dwFlags member of the WAVEHDR structure. Preparing a header that has already been prepared has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutPrepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "pwh",
        "description": "Pointer to a WAVEHDR structure that identifies the data block to be prepared."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwh",
        "description": "Size, in bytes, of the WAVEHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "The meaning of the two message parameters, dwParam1 and dwParam2, depends on the message specified in uMsg. The documentation for each message describes the message parameters. Applications should not call any system-defined functions from inside a callback function, except for EnterCriticalSection, LeaveCriticalSection, midiOutLongMsg, midiOutShortMsg, OutputDebugString, PostMessage, PostThreadMessage, SetEvent, timeGetSystemTime, timeGetTime, timeKillEvent, and timeSetEvent. Calling other wave functions will cause deadlock. ",
    "return_type": "void CALLBACK",
    "category": "Windows Multimedia",
    "name": "waveOutProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio device associated with the callback."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "uMsg",
        "description": "Waveform-audio output message. It can be one of the following values.                Value  Meaning   WOM_CLOSE Sent when the device is closed using the waveOutClose function.  WOM_DONE Sent when the device driver is finished with a data block sent using the waveOutWrite function.  WOM_OPEN Sent when the device is opened using the waveOutOpen function."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwInstance",
        "description": "User-instance data specified with waveOutOpen."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam1",
        "description": "Message parameter."
      },
      {
        "in_out": "",
        "type": "DWORD_PTR",
        "name": "dwParam2",
        "description": "Message parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "After this function returns, the application can send new playback buffers to the device by calling waveOutWrite, or close the device by calling waveOutClose. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutReset",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Calling this function when the output is not paused has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutRestart",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Changing the pitch does not change the playback rate or the sample rate, nor does it change the playback time. Not all devices support pitch changes. To determine whether the device supports pitch control, use the WAVECAPS_PITCH flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutSetPitch",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwPitch",
        "description": "New pitch multiplier setting. This setting indicates the current change in pitch from the original authored setting. The pitch multiplier must be a positive value. The pitch multiplier is specified as a fixed-point value. The high-order word contains the signed integer part of the number, and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and 0x4000 represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no pitch change), and a value of 0x000F8000 specifies a multiplier of 15.5."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "Changing the playback rate does not change the sample rate but does change the playback time. Not all devices support playback rate changes. To determine whether a device supports playback rate changes, use the WAVECAPS_PLAYBACKRATE flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutSetPlaybackRate",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwRate",
        "description": "New playback rate setting. This setting is a multiplier indicating the current change in playback rate from the original authored setting. The playback rate multiplier must be a positive value. The rate is specified as a fixed-point value. The high-order word contains the signed integer part of the number, and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and 0x4000 represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no playback rate change), and a value of 0x000F8000 specifies a multiplier of 15.5."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "If a device identifier is used, then the result of the waveOutSetVolume call applies to all instances of the device. If a device handle is used, then the result applies only to the instance of the device referenced by the device handle. Not all devices support volume changes. To determine whether the device supports volume control, use the WAVECAPS_VOLUME flag to test the dwSupport member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). To determine whether the device supports volume control on both the left and right channels, use the WAVECAPS_LRVOLUME flag. Most devices do not support the full 16 bits of volume-level control and will not use the least-significant bits of the requested volume setting. For example, if a device supports 4 bits of volume control, the values 0x4000, 0x4FFF, and 0x43BE will all be truncated to 0x4000. The waveOutGetVolume function returns the full 16-bit setting set with waveOutSetVolume. Volume settings are interpreted logarithmically. This means the perceived increase in volume is the same when increasing the volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutSetVolume",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to an open waveform-audio output device. This parameter can also be a device identifier."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwVolume",
        "description": "New volume setting. The low-order word contains the left-channel volume setting, and the high-order word contains the right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence. If a device does not support both left and right volume control, the low-order word of dwVolume specifies the volume level, and the high-order word is ignored."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "This function complements waveOutPrepareHeader. You must call this function before freeing the buffer. After passing a buffer to the device driver with the waveOutWrite function, you must wait until the driver is finished with the buffer before calling waveOutUnprepareHeader. Unpreparing a buffer that has not been prepared has no effect, and the function returns zero. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutUnprepareHeader",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "pwh",
        "description": "Pointer to a WAVEHDR structure identifying the data block to be cleaned up."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwh",
        "description": "Size, in bytes, of the WAVEHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "",
    "library": "Winmm.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mmsystem.h (include Windows.h)",
    "return_value": "Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.  ",
    "remarks": "When the buffer is finished, the WHDR_DONE bit is set in the dwFlags member of the WAVEHDR structure. The buffer must be prepared with the waveOutPrepareHeader function before it is passed to waveOutWrite. Unless the device is paused by calling the waveOutPause function, playback begins when the first data block is sent to the device. ",
    "return_type": "MMRESULT",
    "category": "Windows Multimedia",
    "name": "waveOutWrite",
    "is_callback": 0,
    "dll": "Winmm.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "HWAVEOUT",
        "name": "hwo",
        "description": "Handle to the waveform-audio output device."
      },
      {
        "in_out": "",
        "type": "LPWAVEHDR",
        "name": "pwh",
        "description": "Pointer to a WAVEHDR structure containing information about the data block."
      },
      {
        "in_out": "",
        "type": "UINT",
        "name": "cbwh",
        "description": "Size, in bytes, of the WAVEHDR structure."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]